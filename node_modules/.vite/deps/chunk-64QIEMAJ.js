import {
  require_jsx_runtime
} from "./chunk-Q5B56BVT.js";
import {
  require_react_dom
} from "./chunk-3M4ZFO5U.js";
import {
  require_react
} from "./chunk-YJYY6GXC.js";
import {
  __export,
  __toESM
} from "./chunk-G3PMV62Z.js";

// node_modules/@chakra-ui/react/dist/esm/styled-system/color-mix.js
var colorMix = (value, token) => {
  var _a8;
  if (!value || typeof value !== "string") {
    return { invalid: true, value };
  }
  const [rawColor, rawOpacity] = value.split("/");
  if (!rawColor || !rawOpacity || rawColor === "currentBg") {
    return { invalid: true, value: rawColor };
  }
  const colorToken = token(`colors.${rawColor}`);
  const opacityToken = (_a8 = token.raw(`opacity.${rawOpacity}`)) == null ? void 0 : _a8.value;
  if (!opacityToken && isNaN(Number(rawOpacity))) {
    return { invalid: true, value: rawColor };
  }
  const percent = opacityToken ? Number(opacityToken) * 100 + "%" : `${rawOpacity}%`;
  const color = colorToken ?? rawColor;
  return {
    invalid: false,
    color,
    value: `color-mix(in srgb, ${color} ${percent}, transparent)`
  };
};
var createColorMixTransform = (prop) => (value, args) => {
  const mix = args.utils.colorMix(value);
  if (mix.invalid) return { [prop]: value };
  const cssVar2 = "--mix-" + prop;
  return {
    [cssVar2]: mix.value,
    [prop]: `var(${cssVar2}, ${mix.color})`
  };
};

// node_modules/@chakra-ui/react/dist/esm/utils/clone.js
function clone(obj) {
  if (obj === null || typeof obj !== "object") return obj;
  if (Array.isArray(obj)) return obj.map((prop) => clone(prop));
  const _clone = Object.create(Object.getPrototypeOf(obj));
  for (const key of Object.keys(obj)) {
    _clone[key] = clone(obj[key]);
  }
  return _clone;
}

// node_modules/@chakra-ui/react/dist/esm/utils/is.js
var isObject = (v) => v != null && typeof v === "object" && !Array.isArray(v);
var isCssVar = (v) => /^var\(--.+\)$/.test(v);
var isString = (v) => typeof v === "string";
var isFunction = (v) => typeof v === "function";

// node_modules/@chakra-ui/react/dist/esm/utils/merge.js
function merge(target, source) {
  if (source == null) return target;
  for (const key of Object.keys(source)) {
    if (source[key] === void 0 || key === "__proto__") continue;
    if (!isObject(target[key]) && isObject(source[key])) {
      Object.assign(target, { [key]: source[key] });
    } else if (target[key] && isObject(source[key])) {
      merge(target[key], source[key]);
    } else if (Array.isArray(source[key]) && Array.isArray(target[key])) {
      let i = 0;
      for (; i < source[key].length; i++) {
        if (isObject(target[key][i]) && isObject(source[key][i])) {
          merge(target[key][i], source[key][i]);
        } else {
          target[key][i] = source[key][i];
        }
      }
    } else {
      Object.assign(target, { [key]: source[key] });
    }
  }
  return target;
}
function mergeWith(target, ...sources) {
  for (const source of sources) {
    merge(target, source);
  }
  return target;
}

// node_modules/@chakra-ui/react/dist/esm/styled-system/config.js
var defineConditions = (v) => v;
var defineRecipe = (v) => v;
var defineSlotRecipe = (v) => v;
var defineKeyframes = (v) => v;
var defineGlobalStyles = (v) => v;
var defineStyle = (v) => v;
var defineTextStyles = (v) => v;
var defineAnimationStyles = (v) => v;
var defineLayerStyles = (v) => v;
function createProxy() {
  const identity = (v) => v;
  return new Proxy(identity, {
    get() {
      return identity;
    }
  });
}
var defineTokens = createProxy();
var defineSemanticTokens = createProxy();
var defineConfig = (v) => v;
var mergeConfigs = (...configs) => {
  return mergeWith({}, ...configs.map(clone));
};

// node_modules/@chakra-ui/react/dist/esm/styled-system/css-var.js
var escRegex = /[^a-zA-Z0-9_\u0081-\uffff-]/g;
function esc(string) {
  return `${string}`.replace(escRegex, (s) => `\\${s}`);
}
var dashCaseRegex = /[A-Z]/g;
function dashCase(string) {
  return string.replace(dashCaseRegex, (match4) => `-${match4.toLowerCase()}`);
}
function cssVar(name, options = {}) {
  const { fallback: fallback4 = "", prefix = "" } = options;
  const variable = dashCase(["-", prefix, esc(name)].filter(Boolean).join("-"));
  return {
    var: variable,
    ref: `var(${variable}${fallback4 ? `, ${fallback4}` : ""})`
  };
}

// node_modules/@chakra-ui/react/dist/esm/preset-base.js
var isCssVar2 = (v) => /^var\(--.+\)$/.test(v);
var wrap = (str, v) => v != null ? `${str}(${v})` : v;
var deg = (v) => {
  if (isCssVar2(v) || v == null) return v;
  const unitless = typeof v === "string" && !v.endsWith("deg");
  return typeof v === "number" || unitless ? `${v}deg` : v;
};
var createFocusRing = (selector) => {
  return {
    values: ["outside", "inside", "mixed", "none"],
    transform(value, { token }) {
      const focusRingColor = token("colors.colorPalette.focusRing");
      const styles = {
        inside: {
          "--focus-ring-color": focusRingColor,
          [selector]: {
            outlineOffset: "0px",
            outlineWidth: "var(--focus-ring-width, 1px)",
            outlineColor: "var(--focus-ring-color)",
            outlineStyle: "var(--focus-ring-style, solid)",
            borderColor: "var(--focus-ring-color)"
          }
        },
        outside: {
          "--focus-ring-color": focusRingColor,
          [selector]: {
            outlineWidth: "var(--focus-ring-width, 2px)",
            outlineOffset: "var(--focus-ring-offset, 2px)",
            outlineStyle: "var(--focus-ring-style, solid)",
            outlineColor: "var(--focus-ring-color)"
          }
        },
        mixed: {
          "--focus-ring-color": focusRingColor,
          [selector]: {
            outlineWidth: "var(--focus-ring-width, 3px)",
            outlineStyle: "var(--focus-ring-style, solid)",
            outlineColor: "color-mix(in srgb, var(--focus-ring-color), transparent 60%)",
            borderColor: "var(--focus-ring-color)"
          }
        },
        none: {
          "--focus-ring-color": focusRingColor,
          [selector]: {
            outline: "none"
          }
        }
      };
      return styles[value] ?? {};
    }
  };
};
var divideColor = createColorMixTransform("borderColor");
var createTransition = (value) => {
  return {
    transition: value,
    transitionTimingFunction: "cubic-bezier(0.4, 0, 0.2, 1)",
    transitionDuration: "150ms"
  };
};
var defaultConditions = defineConditions({
  hover: [
    "@media (hover: hover)",
    "&:is(:hover, [data-hover]):not(:disabled, [data-disabled])"
  ],
  active: "&:is(:active, [data-active]):not(:disabled, [data-disabled], [data-state=open])",
  focus: "&:is(:focus, [data-focus])",
  focusWithin: "&:is(:focus-within, [data-focus-within])",
  focusVisible: "&:is(:focus-visible, [data-focus-visible])",
  disabled: "&:is(:disabled, [disabled], [data-disabled], [aria-disabled=true])",
  visited: "&:visited",
  target: "&:target",
  readOnly: "&:is([data-readonly], [aria-readonly=true], [readonly])",
  readWrite: "&:read-write",
  empty: "&:is(:empty, [data-empty])",
  checked: "&:is(:checked, [data-checked], [aria-checked=true], [data-state=checked])",
  enabled: "&:enabled",
  expanded: "&:is([aria-expanded=true], [data-expanded], [data-state=expanded])",
  highlighted: "&[data-highlighted]",
  complete: "&[data-complete]",
  incomplete: "&[data-incomplete]",
  dragging: "&[data-dragging]",
  before: "&::before",
  after: "&::after",
  firstLetter: "&::first-letter",
  firstLine: "&::first-line",
  marker: "&::marker",
  selection: "&::selection",
  file: "&::file-selector-button",
  backdrop: "&::backdrop",
  first: "&:first-of-type",
  last: "&:last-of-type",
  notFirst: "&:not(:first-of-type)",
  notLast: "&:not(:last-of-type)",
  only: "&:only-child",
  even: "&:nth-of-type(even)",
  odd: "&:nth-of-type(odd)",
  peerFocus: ".peer:is(:focus, [data-focus]) ~ &",
  peerHover: ".peer:is(:hover, [data-hover]):not(:disabled, [data-disabled]) ~ &",
  peerActive: ".peer:is(:active, [data-active]):not(:disabled, [data-disabled]) ~ &",
  peerFocusWithin: ".peer:focus-within ~ &",
  peerFocusVisible: ".peer:is(:focus-visible, [data-focus-visible]) ~ &",
  peerDisabled: ".peer:is(:disabled, [disabled], [data-disabled]) ~ &",
  peerChecked: ".peer:is(:checked, [data-checked], [aria-checked=true], [data-state=checked]) ~ &",
  peerInvalid: ".peer:is(:invalid, [data-invalid], [aria-invalid=true]) ~ &",
  peerExpanded: ".peer:is([aria-expanded=true], [data-expanded], [data-state=expanded]) ~ &",
  peerPlaceholderShown: ".peer:placeholder-shown ~ &",
  groupFocus: ".group:is(:focus, [data-focus]) &",
  groupHover: ".group:is(:hover, [data-hover]):not(:disabled, [data-disabled]) &",
  groupActive: ".group:is(:active, [data-active]):not(:disabled, [data-disabled]) &",
  groupFocusWithin: ".group:focus-within &",
  groupFocusVisible: ".group:is(:focus-visible, [data-focus-visible]) &",
  groupDisabled: ".group:is(:disabled, [disabled], [data-disabled]) &",
  groupChecked: ".group:is(:checked, [data-checked], [aria-checked=true], [data-state=checked]) &",
  groupExpanded: ".group:is([aria-expanded=true], [data-expanded], [data-state=expanded]) &",
  groupInvalid: ".group:invalid &",
  indeterminate: "&:is(:indeterminate, [data-indeterminate], [aria-checked=mixed], [data-state=indeterminate])",
  required: "&:is([data-required], [aria-required=true])",
  valid: "&:is([data-valid], [data-state=valid])",
  invalid: "&:is([data-invalid], [aria-invalid=true], [data-state=invalid])",
  autofill: "&:autofill",
  inRange: "&:is(:in-range, [data-in-range])",
  outOfRange: "&:is(:out-of-range, [data-outside-range])",
  placeholder: "&::placeholder, &[data-placeholder]",
  placeholderShown: "&:is(:placeholder-shown, [data-placeholder-shown])",
  pressed: "&:is([aria-pressed=true], [data-pressed])",
  selected: "&:is([aria-selected=true], [data-selected])",
  grabbed: "&:is([aria-grabbed=true], [data-grabbed])",
  underValue: "&[data-state=under-value]",
  overValue: "&[data-state=over-value]",
  atValue: "&[data-state=at-value]",
  default: "&:default",
  optional: "&:optional",
  open: "&:is([open], [data-open], [data-state=open])",
  closed: "&:is([closed], [data-closed], [data-state=closed])",
  fullscreen: "&is(:fullscreen, [data-fullscreen])",
  loading: "&:is([data-loading], [aria-busy=true])",
  hidden: "&:is([hidden], [data-hidden])",
  current: "&[data-current]",
  currentPage: "&[aria-current=page]",
  currentStep: "&[aria-current=step]",
  today: "&[data-today]",
  unavailable: "&[data-unavailable]",
  rangeStart: "&[data-range-start]",
  rangeEnd: "&[data-range-end]",
  now: "&[data-now]",
  topmost: "&[data-topmost]",
  motionReduce: "@media (prefers-reduced-motion: reduce)",
  motionSafe: "@media (prefers-reduced-motion: no-preference)",
  print: "@media print",
  landscape: "@media (orientation: landscape)",
  portrait: "@media (orientation: portrait)",
  dark: ".dark &, .dark .chakra-theme:not(.light) &",
  light: ":root &, .light &",
  osDark: "@media (prefers-color-scheme: dark)",
  osLight: "@media (prefers-color-scheme: light)",
  highContrast: "@media (forced-colors: active)",
  lessContrast: "@media (prefers-contrast: less)",
  moreContrast: "@media (prefers-contrast: more)",
  ltr: "[dir=ltr] &",
  rtl: "[dir=rtl] &",
  scrollbar: "&::-webkit-scrollbar",
  scrollbarThumb: "&::-webkit-scrollbar-thumb",
  scrollbarTrack: "&::-webkit-scrollbar-track",
  horizontal: "&[data-orientation=horizontal]",
  vertical: "&[data-orientation=vertical]",
  icon: "& :where(svg)",
  starting: "@starting-style"
});
var currentBgVar = cssVar("bg-currentcolor");
var isCurrentBgVar = (value) => value === currentBgVar.ref || value === "currentBg";
var colorValues = (theme) => ({
  ...theme("colors"),
  currentBg: currentBgVar
});
var defaultBaseConfig = defineConfig({
  conditions: defaultConditions,
  utilities: {
    // background
    background: {
      values: colorValues,
      shorthand: ["bg"],
      transform(value, args) {
        if (isCurrentBgVar(args.raw)) return { background: currentBgVar.ref };
        const styleObj = createColorMixTransform("background")(value, args);
        return { ...styleObj, [currentBgVar.var]: styleObj == null ? void 0 : styleObj.background };
      }
    },
    backgroundColor: {
      values: colorValues,
      shorthand: ["bgColor"],
      transform(value, args) {
        if (isCurrentBgVar(args.raw))
          return { backgroundColor: currentBgVar.ref };
        const styleObj = createColorMixTransform("backgroundColor")(value, args);
        return {
          ...styleObj,
          [currentBgVar.var]: styleObj == null ? void 0 : styleObj.backgroundColor
        };
      }
    },
    backgroundSize: { shorthand: ["bgSize"] },
    backgroundPosition: { shorthand: ["bgPos"] },
    backgroundRepeat: { shorthand: ["bgRepeat"] },
    backgroundAttachment: { shorthand: ["bgAttachment"] },
    backgroundClip: {
      shorthand: ["bgClip"],
      values: ["text"],
      transform(value) {
        return value === "text" ? { color: "transparent", backgroundClip: "text" } : { backgroundClip: value };
      }
    },
    backgroundGradient: {
      shorthand: ["bgGradient"],
      values(theme) {
        return {
          ...theme("gradients"),
          "to-t": "linear-gradient(to top, var(--gradient))",
          "to-tr": "linear-gradient(to top right, var(--gradient))",
          "to-r": "linear-gradient(to right, var(--gradient))",
          "to-br": "linear-gradient(to bottom right, var(--gradient))",
          "to-b": "linear-gradient(to bottom, var(--gradient))",
          "to-bl": "linear-gradient(to bottom left, var(--gradient))",
          "to-l": "linear-gradient(to left, var(--gradient))",
          "to-tl": "linear-gradient(to top left, var(--gradient))"
        };
      },
      transform(value) {
        return {
          "--gradient-stops": "var(--gradient-from), var(--gradient-to)",
          "--gradient": "var(--gradient-via-stops, var(--gradient-stops))",
          backgroundImage: value
        };
      }
    },
    gradientFrom: {
      values: colorValues,
      transform: createColorMixTransform("--gradient-from")
    },
    gradientTo: {
      values: colorValues,
      transform: createColorMixTransform("--gradient-to")
    },
    gradientVia: {
      values: colorValues,
      transform(value, args) {
        const styles = createColorMixTransform("--gradient-via")(value, args);
        return {
          ...styles,
          "--gradient-via-stops": "var(--gradient-from), var(--gradient-via), var(--gradient-to)"
        };
      }
    },
    backgroundImage: {
      values(theme) {
        return { ...theme("gradients"), ...theme("assets") };
      },
      shorthand: ["bgImg", "bgImage"]
    },
    // border
    border: { values: "borders" },
    borderTop: { values: "borders" },
    borderLeft: { values: "borders" },
    borderBlockStart: { values: "borders" },
    borderRight: { values: "borders" },
    borderInlineEnd: { values: "borders" },
    borderBottom: { values: "borders" },
    borderBlockEnd: { values: "borders" },
    borderInlineStart: { values: "borders", shorthand: ["borderStart"] },
    borderInline: { values: "borders", shorthand: ["borderX"] },
    borderBlock: { values: "borders", shorthand: ["borderY"] },
    // border colors
    borderColor: {
      values: colorValues,
      transform: createColorMixTransform("borderColor")
    },
    borderTopColor: {
      values: colorValues,
      transform: createColorMixTransform("borderTopColor")
    },
    borderBlockStartColor: {
      values: colorValues,
      transform: createColorMixTransform("borderBlockStartColor")
    },
    borderBottomColor: {
      values: colorValues,
      transform: createColorMixTransform("borderBottomColor")
    },
    borderBlockEndColor: {
      values: colorValues,
      transform: createColorMixTransform("borderBlockEndColor")
    },
    borderLeftColor: {
      values: colorValues,
      transform: createColorMixTransform("borderLeftColor")
    },
    borderInlineStartColor: {
      values: colorValues,
      shorthand: ["borderStartColor"],
      transform: createColorMixTransform("borderInlineStartColor")
    },
    borderRightColor: {
      values: colorValues,
      transform: createColorMixTransform("borderRightColor")
    },
    borderInlineEndColor: {
      values: colorValues,
      shorthand: ["borderEndColor"],
      transform: createColorMixTransform("borderInlineEndColor")
    },
    // border styles
    borderStyle: { values: "borderStyles" },
    borderTopStyle: { values: "borderStyles" },
    borderBlockStartStyle: { values: "borderStyles" },
    borderBottomStyle: { values: "borderStyles" },
    borderBlockEndStyle: {
      values: "borderStyles"
    },
    borderInlineStartStyle: {
      values: "borderStyles",
      shorthand: ["borderStartStyle"]
    },
    borderInlineEndStyle: {
      values: "borderStyles",
      shorthand: ["borderEndStyle"]
    },
    borderLeftStyle: { values: "borderStyles" },
    borderRightStyle: { values: "borderStyles" },
    // border radius
    borderRadius: { values: "radii", shorthand: ["rounded"] },
    borderTopLeftRadius: { values: "radii", shorthand: ["roundedTopLeft"] },
    borderStartStartRadius: {
      values: "radii",
      shorthand: ["roundedStartStart", "borderTopStartRadius"]
    },
    borderEndStartRadius: {
      values: "radii",
      shorthand: ["roundedEndStart", "borderBottomStartRadius"]
    },
    borderTopRightRadius: {
      values: "radii",
      shorthand: ["roundedTopRight"]
    },
    borderStartEndRadius: {
      values: "radii",
      shorthand: ["roundedStartEnd", "borderTopEndRadius"]
    },
    borderEndEndRadius: {
      values: "radii",
      shorthand: ["roundedEndEnd", "borderBottomEndRadius"]
    },
    borderBottomLeftRadius: {
      values: "radii",
      shorthand: ["roundedBottomLeft"]
    },
    borderBottomRightRadius: {
      values: "radii",
      shorthand: ["roundedBottomRight"]
    },
    borderInlineStartRadius: {
      values: "radii",
      property: "borderRadius",
      shorthand: ["roundedStart", "borderStartRadius"],
      transform: (value) => ({
        borderStartStartRadius: value,
        borderEndStartRadius: value
      })
    },
    borderInlineEndRadius: {
      values: "radii",
      property: "borderRadius",
      shorthand: ["roundedEnd", "borderEndRadius"],
      transform: (value) => ({
        borderStartEndRadius: value,
        borderEndEndRadius: value
      })
    },
    borderTopRadius: {
      values: "radii",
      property: "borderRadius",
      shorthand: ["roundedTop"],
      transform: (value) => ({
        borderTopLeftRadius: value,
        borderTopRightRadius: value
      })
    },
    borderBottomRadius: {
      values: "radii",
      property: "borderRadius",
      shorthand: ["roundedBottom"],
      transform: (value) => ({
        borderBottomLeftRadius: value,
        borderBottomRightRadius: value
      })
    },
    borderLeftRadius: {
      values: "radii",
      property: "borderRadius",
      shorthand: ["roundedLeft"],
      transform: (value) => ({
        borderTopLeftRadius: value,
        borderBottomLeftRadius: value
      })
    },
    borderRightRadius: {
      values: "radii",
      property: "borderRadius",
      shorthand: ["roundedRight"],
      transform: (value) => ({
        borderTopRightRadius: value,
        borderBottomRightRadius: value
      })
    },
    borderWidth: { values: "borderWidths" },
    borderBlockStartWidth: { values: "borderWidths" },
    borderTopWidth: { values: "borderWidths" },
    borderBottomWidth: { values: "borderWidths" },
    borderBlockEndWidth: { values: "borderWidths" },
    borderRightWidth: { values: "borderWidths" },
    borderInlineWidth: {
      values: "borderWidths",
      shorthand: ["borderXWidth"]
    },
    borderInlineStartWidth: {
      values: "borderWidths",
      shorthand: ["borderStartWidth"]
    },
    borderInlineEndWidth: {
      values: "borderWidths",
      shorthand: ["borderEndWidth"]
    },
    borderLeftWidth: { values: "borderWidths" },
    borderBlockWidth: {
      values: "borderWidths",
      shorthand: ["borderYWidth"]
    },
    // colors
    color: {
      values: colorValues,
      transform: createColorMixTransform("color")
    },
    fill: {
      values: colorValues,
      transform: createColorMixTransform("fill")
    },
    stroke: {
      values: colorValues,
      transform: createColorMixTransform("stroke")
    },
    accentColor: {
      values: colorValues,
      transform: createColorMixTransform("accentColor")
    },
    // divide
    divideX: {
      values: { type: "string" },
      transform(value) {
        return {
          "& > :not(style, [hidden]) ~ :not(style, [hidden])": {
            borderInlineStartWidth: value,
            borderInlineEndWidth: "0px"
          }
        };
      }
    },
    divideY: {
      values: { type: "string" },
      transform(value) {
        return {
          "& > :not(style, [hidden]) ~ :not(style, [hidden])": {
            borderTopWidth: value,
            borderBottomWidth: "0px"
          }
        };
      }
    },
    divideColor: {
      values: colorValues,
      transform(value, args) {
        return {
          "& > :not(style, [hidden]) ~ :not(style, [hidden])": divideColor(
            value,
            args
          )
        };
      }
    },
    divideStyle: {
      property: "borderStyle",
      transform(value) {
        return {
          "& > :not(style, [hidden]) ~ :not(style, [hidden])": {
            borderStyle: value
          }
        };
      }
    },
    // effects
    boxShadow: { values: "shadows", shorthand: ["shadow"] },
    boxShadowColor: {
      values: colorValues,
      transform: createColorMixTransform("--shadow-color"),
      shorthand: ["shadowColor"]
    },
    mixBlendMode: { shorthand: ["blendMode"] },
    backgroundBlendMode: { shorthand: ["bgBlendMode"] },
    opacity: { values: "opacity" },
    // filters
    filter: {
      transform(v) {
        if (v !== "auto") {
          return { filter: v };
        }
        return {
          filter: `var(--blur) var(--brightness) var(--contrast) var(--grayscale) var(--hue-rotate) var(--invert) var(--saturate) var(--sepia) var(--drop-shadow)`
        };
      }
    },
    blur: {
      values: "blurs",
      transform: (v) => ({ "--blur": wrap("blur", v) })
    },
    brightness: {
      transform: (v) => ({ "--brightness": wrap("brightness", v) })
    },
    contrast: {
      transform: (v) => ({ "--contrast": wrap("contrast", v) })
    },
    grayscale: {
      transform: (v) => ({ "--grayscale": wrap("grayscale", v) })
    },
    hueRotate: {
      transform: (v) => ({ "--hue-rotate": wrap("hue-rotate", deg(v)) })
    },
    invert: { transform: (v) => ({ "--invert": wrap("invert", v) }) },
    saturate: {
      transform: (v) => ({ "--saturate": wrap("saturate", v) })
    },
    sepia: { transform: (v) => ({ "--sepia": wrap("sepia", v) }) },
    dropShadow: {
      transform: (v) => ({ "--drop-shadow": wrap("drop-shadow", v) })
    },
    // backdrop filters
    backdropFilter: {
      transform(v) {
        if (v !== "auto") {
          return { backdropFilter: v };
        }
        return {
          backdropFilter: `var(--backdrop-blur) var(--backdrop-brightness) var(--backdrop-contrast) var(--backdrop-grayscale) var(--backdrop-hue-rotate) var(--backdrop-invert) var(--backdrop-opacity) var(--backdrop-saturate) var(--backdrop-sepia)`
        };
      }
    },
    backdropBlur: {
      values: "blurs",
      transform: (v) => ({ "--backdrop-blur": wrap("blur", v) })
    },
    backdropBrightness: {
      transform: (v) => ({
        "--backdrop-brightness": wrap("brightness", v)
      })
    },
    backdropContrast: {
      transform: (v) => ({ "--backdrop-contrast": wrap("contrast", v) })
    },
    backdropGrayscale: {
      transform: (v) => ({
        "--backdrop-grayscale": wrap("grayscale", v)
      })
    },
    backdropHueRotate: {
      transform: (v) => ({
        "--backdrop-hue-rotate": wrap("hue-rotate", deg(v))
      })
    },
    backdropInvert: {
      transform: (v) => ({ "--backdrop-invert": wrap("invert", v) })
    },
    backdropOpacity: {
      transform: (v) => ({ "--backdrop-opacity": wrap("opacity", v) })
    },
    backdropSaturate: {
      transform: (v) => ({ "--backdrop-saturate": wrap("saturate", v) })
    },
    backdropSepia: {
      transform: (v) => ({ "--backdrop-sepia": wrap("sepia", v) })
    },
    // flexbox
    flexBasis: { values: "sizes" },
    gap: { values: "spacing" },
    rowGap: { values: "spacing", shorthand: ["gapY"] },
    columnGap: { values: "spacing", shorthand: ["gapX"] },
    flexDirection: { shorthand: ["flexDir"] },
    // grid
    gridGap: { values: "spacing" },
    gridColumnGap: { values: "spacing" },
    gridRowGap: { values: "spacing" },
    // interactivity
    outlineColor: {
      values: colorValues,
      transform: createColorMixTransform("outlineColor")
    },
    focusRing: createFocusRing("&:is(:focus, [data-focus])"),
    focusVisibleRing: createFocusRing(
      "&:is(:focus-visible, [data-focus-visible])"
    ),
    focusRingColor: {
      values: colorValues,
      transform: createColorMixTransform("--focus-ring-color")
    },
    focusRingOffset: {
      values: "spacing",
      transform: (v) => ({ "--focus-ring-offset": v })
    },
    focusRingWidth: {
      values: "borderWidths",
      property: "outlineWidth",
      transform: (v) => ({ "--focus-ring-width": v })
    },
    focusRingStyle: {
      values: "borderStyles",
      property: "outlineStyle",
      transform: (v) => ({ "--focus-ring-style": v })
    },
    // layout
    aspectRatio: { values: "aspectRatios" },
    width: { values: "sizes", shorthand: ["w"] },
    inlineSize: { values: "sizes" },
    height: { values: "sizes", shorthand: ["h"] },
    blockSize: { values: "sizes" },
    boxSize: {
      values: "sizes",
      property: "width",
      transform: (v) => ({ width: v, height: v })
    },
    minWidth: { values: "sizes", shorthand: ["minW"] },
    minInlineSize: { values: "sizes" },
    minHeight: { values: "sizes", shorthand: ["minH"] },
    minBlockSize: { values: "sizes" },
    maxWidth: { values: "sizes", shorthand: ["maxW"] },
    maxInlineSize: { values: "sizes" },
    maxHeight: { values: "sizes", shorthand: ["maxH"] },
    maxBlockSize: { values: "sizes" },
    hideFrom: {
      values: "breakpoints",
      //@ts-ignore
      transform: (value, { raw, token }) => {
        const bp = token.raw(`breakpoints.${raw}`);
        const media = bp ? `@breakpoint ${raw}` : `@media screen and (min-width: ${value})`;
        return {
          [media]: { display: "none" }
        };
      }
    },
    hideBelow: {
      values: "breakpoints",
      //@ts-ignore
      transform(value, { raw, token }) {
        const bp = token.raw(`breakpoints.${raw}`);
        const media = bp ? `@breakpoint ${raw}Down` : `@media screen and (max-width: ${value})`;
        return {
          [media]: {
            display: "none"
          }
        };
      }
    },
    // scroll
    overscrollBehavior: { shorthand: ["overscroll"] },
    overscrollBehaviorX: { shorthand: ["overscrollX"] },
    overscrollBehaviorY: { shorthand: ["overscrollY"] },
    scrollbar: {
      values: ["visible", "hidden"],
      transform(v) {
        switch (v) {
          case "visible":
            return {
              msOverflowStyle: "auto",
              scrollbarWidth: "auto",
              "&::-webkit-scrollbar": { display: "block" }
            };
          case "hidden":
            return {
              msOverflowStyle: "none",
              scrollbarWidth: "none",
              "&::-webkit-scrollbar": { display: "none" }
            };
          default:
            return {};
        }
      }
    },
    scrollbarColor: {
      values: colorValues,
      transform: createColorMixTransform("scrollbarColor")
    },
    scrollbarGutter: { values: "spacing" },
    scrollbarWidth: { values: "sizes" },
    // scroll margin
    scrollMargin: { values: "spacing" },
    scrollMarginTop: { values: "spacing" },
    scrollMarginBottom: { values: "spacing" },
    scrollMarginLeft: { values: "spacing" },
    scrollMarginRight: { values: "spacing" },
    scrollMarginX: {
      values: "spacing",
      transform: (v) => ({ scrollMarginLeft: v, scrollMarginRight: v })
    },
    scrollMarginY: {
      values: "spacing",
      transform: (v) => ({ scrollMarginTop: v, scrollMarginBottom: v })
    },
    // scroll padding
    scrollPadding: { values: "spacing" },
    scrollPaddingTop: { values: "spacing" },
    scrollPaddingBottom: { values: "spacing" },
    scrollPaddingLeft: { values: "spacing" },
    scrollPaddingRight: { values: "spacing" },
    scrollPaddingInline: { values: "spacing", shorthand: ["scrollPaddingX"] },
    scrollPaddingBlock: { values: "spacing", shorthand: ["scrollPaddingY"] },
    // scroll snap
    scrollSnapType: {
      values: {
        none: "none",
        x: "x var(--scroll-snap-strictness)",
        y: "y var(--scroll-snap-strictness)",
        both: "both var(--scroll-snap-strictness)"
      }
    },
    scrollSnapStrictness: {
      values: ["mandatory", "proximity"],
      transform: (v) => ({ "--scroll-snap-strictness": v })
    },
    scrollSnapMargin: { values: "spacing" },
    scrollSnapMarginTop: { values: "spacing" },
    scrollSnapMarginBottom: { values: "spacing" },
    scrollSnapMarginLeft: { values: "spacing" },
    scrollSnapMarginRight: { values: "spacing" },
    // list
    listStylePosition: { shorthand: ["listStylePos"] },
    listStyleImage: { values: "assets", shorthand: ["listStyleImg"] },
    // position
    position: { shorthand: ["pos"] },
    zIndex: { values: "zIndex" },
    inset: { values: "spacing" },
    insetInline: { values: "spacing", shorthand: ["insetX"] },
    insetBlock: { values: "spacing", shorthand: ["insetY"] },
    top: { values: "spacing" },
    insetBlockStart: { values: "spacing" },
    bottom: { values: "spacing" },
    insetBlockEnd: { values: "spacing" },
    left: { values: "spacing" },
    right: { values: "spacing" },
    insetInlineStart: {
      values: "spacing",
      shorthand: ["insetStart"]
    },
    insetInlineEnd: {
      values: "spacing",
      shorthand: ["insetEnd"]
    },
    // shadow / ring
    ring: {
      transform(value) {
        return {
          "--ring-offset-shadow": `var(--ring-inset) 0 0 0 var(--ring-offset-width) var(--ring-offset-color)`,
          "--ring-shadow": `var(--ring-inset) 0 0 0 calc(var(--ring-width) + var(--ring-offset-width)) var(--ring-color)`,
          "--ring-width": value,
          boxShadow: "var(--ring-offset-shadow), var(--ring-shadow), var(--shadow, 0 0 #0000)"
        };
      }
    },
    ringColor: {
      values: colorValues,
      transform: createColorMixTransform("--ring-color")
    },
    ringOffset: {
      transform: (value) => ({ "--ring-offset-width": value })
    },
    ringOffsetColor: {
      values: colorValues,
      transform: createColorMixTransform("--ring-offset-color")
    },
    ringInset: {
      transform: (v) => ({ "--ring-inset": v })
    },
    // margin
    margin: { values: "spacing", shorthand: ["m"] },
    marginTop: { values: "spacing", shorthand: ["mt"] },
    marginBlockStart: { values: "spacing", shorthand: ["mt"] },
    marginRight: { values: "spacing", shorthand: ["mr"] },
    marginBottom: { values: "spacing", shorthand: ["mb"] },
    marginBlockEnd: { values: "spacing" },
    marginLeft: { values: "spacing", shorthand: ["ml"] },
    marginInlineStart: { values: "spacing", shorthand: ["ms", "marginStart"] },
    marginInlineEnd: { values: "spacing", shorthand: ["me", "marginEnd"] },
    marginInline: { values: "spacing", shorthand: ["mx", "marginX"] },
    marginBlock: { values: "spacing", shorthand: ["my", "marginY"] },
    // padding
    padding: { values: "spacing", shorthand: ["p"] },
    paddingTop: { values: "spacing", shorthand: ["pt"] },
    paddingRight: { values: "spacing", shorthand: ["pr"] },
    paddingBottom: { values: "spacing", shorthand: ["pb"] },
    paddingBlockStart: { values: "spacing" },
    paddingBlockEnd: { values: "spacing" },
    paddingLeft: { values: "spacing", shorthand: ["pl"] },
    paddingInlineStart: {
      values: "spacing",
      shorthand: ["ps", "paddingStart"]
    },
    paddingInlineEnd: { values: "spacing", shorthand: ["pe", "paddingEnd"] },
    paddingInline: { values: "spacing", shorthand: ["px", "paddingX"] },
    paddingBlock: { values: "spacing", shorthand: ["py", "paddingY"] },
    // text decoration
    textDecoration: { shorthand: ["textDecor"] },
    textDecorationColor: {
      values: colorValues,
      transform: createColorMixTransform("textDecorationColor")
    },
    textShadow: { values: "shadows" },
    // transform
    transform: {
      transform: (value) => {
        let v = value;
        if (value === "auto") {
          v = `translateX(var(--translate-x, 0)) translateY(var(--translate-y, 0)) rotate(var(--rotate, 0)) scaleX(var(--scale-x, 1)) scaleY(var(--scale-y, 1)) skewX(var(--skew-x, 0)) skewY(var(--skew-y, 0))`;
        }
        if (value === "auto-gpu") {
          v = `translate3d(var(--translate-x, 0), var(--translate-y, 0), 0) rotate(var(--rotate, 0)) scaleX(var(--scale-x, 1)) scaleY(var(--scale-y, 1)) skewX(var(--skew-x, 0)) skewY(var(--skew-y, 0))`;
        }
        return { transform: v };
      }
    },
    skewX: { transform: (v) => ({ "--skew-x": deg(v) }) },
    skewY: { transform: (v) => ({ "--skew-y": deg(v) }) },
    scaleX: { transform: (v) => ({ "--scale-x": v }) },
    scaleY: { transform: (v) => ({ "--scale-y": v }) },
    scale: {
      transform(value) {
        if (value !== "auto") return { scale: value };
        return {
          scale: `var(--scale-x, 1) var(--scale-y, 1)`
        };
      }
    },
    spaceXReverse: {
      values: { type: "boolean" },
      transform(value) {
        return {
          "& > :not(style, [hidden]) ~ :not(style, [hidden])": {
            "--space-x-reverse": value ? "1" : void 0
          }
        };
      }
    },
    spaceX: {
      property: "marginInlineStart",
      values: "spacing",
      transform: (v) => ({
        "& > :not(style, [hidden]) ~ :not(style, [hidden])": {
          "--space-x-reverse": "0",
          marginInlineStart: `calc(${v} * calc(1 - var(--space-x-reverse)))`,
          marginInlineEnd: `calc(${v} * var(--space-x-reverse))`
        }
      })
    },
    spaceYReverse: {
      values: { type: "boolean" },
      transform(value) {
        return {
          "& > :not(style, [hidden]) ~ :not(style, [hidden])": {
            "--space-y-reverse": value ? "1" : void 0
          }
        };
      }
    },
    spaceY: {
      property: "marginTop",
      values: "spacing",
      transform: (v) => ({
        "& > :not(style, [hidden]) ~ :not(style, [hidden])": {
          "--space-y-reverse": "0",
          marginTop: `calc(${v} * calc(1 - var(--space-y-reverse)))`,
          marginBottom: `calc(${v} * var(--space-y-reverse))`
        }
      })
    },
    rotate: {
      transform(value) {
        if (value !== "auto") return { rotate: deg(value) };
        return {
          rotate: `var(--rotate-x, 0) var(--rotate-y, 0) var(--rotate-z, 0)`
        };
      }
    },
    rotateX: {
      transform(value) {
        return { "--rotate-x": deg(value) };
      }
    },
    rotateY: {
      transform(value) {
        return { "--rotate-y": deg(value) };
      }
    },
    // transform / translate
    translate: {
      transform(value) {
        if (value !== "auto") return { translate: value };
        return {
          translate: `var(--translate-x) var(--translate-y)`
        };
      }
    },
    translateX: {
      values: "spacing",
      transform: (v) => ({ "--translate-x": v })
    },
    translateY: {
      values: "spacing",
      transform: (v) => ({ "--translate-y": v })
    },
    // transition
    transition: {
      values: [
        "all",
        "common",
        "colors",
        "opacity",
        "position",
        "backgrounds",
        "size",
        "shadow",
        "transform"
      ],
      transform(value) {
        switch (value) {
          case "all":
            return createTransition("all");
          case "position":
            return createTransition(
              "left, right, top, bottom, inset-inline, inset-block"
            );
          case "colors":
            return createTransition(
              "color, background-color, border-color, text-decoration-color, fill, stroke"
            );
          case "opacity":
            return createTransition("opacity");
          case "shadow":
            return createTransition("box-shadow");
          case "transform":
            return createTransition("transform");
          case "size":
            return createTransition("width, height");
          case "backgrounds":
            return createTransition(
              "background, background-color, background-image, background-position"
            );
          case "common":
            return createTransition(
              "color, background-color, border-color, text-decoration-color, fill, stroke, opacity, box-shadow, transform, filter, backdrop-filter"
            );
          default:
            return { transition: value };
        }
      }
    },
    transitionDuration: { values: "durations" },
    transitionProperty: {
      values: {
        common: "background-color, border-color, color, fill, stroke, opacity, box-shadow, translate, transform",
        colors: "background-color, border-color, color, fill, stroke",
        size: "width, height",
        position: "left, right, top, bottom, inset-inline, inset-block",
        background: "background, background-color, background-image, background-position"
      }
    },
    transitionTimingFunction: { values: "easings" },
    // animation
    animation: { values: "animations" },
    animationDuration: { values: "durations" },
    animationDelay: { values: "durations" },
    animationTimingFunction: { values: "easings" },
    // typography
    fontFamily: { values: "fonts" },
    fontSize: { values: "fontSizes" },
    fontWeight: { values: "fontWeights" },
    lineHeight: { values: "lineHeights" },
    letterSpacing: { values: "letterSpacings" },
    textIndent: { values: "spacing" },
    truncate: {
      values: { type: "boolean" },
      transform(value) {
        if (value === true) {
          return {
            overflow: "hidden",
            textOverflow: "ellipsis",
            whiteSpace: "nowrap"
          };
        }
        return {};
      }
    },
    lineClamp: {
      transform(value) {
        if (value === "none") {
          return {
            WebkitLineClamp: "unset"
          };
        }
        return {
          overflow: "hidden",
          display: "-webkit-box",
          WebkitLineClamp: value,
          WebkitBoxOrient: "vertical",
          textWrap: "wrap"
        };
      }
    },
    // helpers
    srOnly: {
      values: { type: "boolean" },
      transform(value) {
        return srMapping[value] || {};
      }
    },
    debug: {
      values: { type: "boolean" },
      transform(value) {
        if (!value) return {};
        return {
          outline: "1px solid blue !important",
          "& > *": {
            outline: "1px solid red !important"
          }
        };
      }
    },
    caretColor: {
      values: colorValues,
      transform: createColorMixTransform("caretColor")
    },
    cursor: { values: "cursor" }
  }
});
var srMapping = {
  true: {
    position: "absolute",
    width: "1px",
    height: "1px",
    padding: "0",
    margin: "-1px",
    overflow: "hidden",
    clip: "rect(0, 0, 0, 0)",
    whiteSpace: "nowrap",
    borderWidth: "0"
  },
  false: {
    position: "static",
    width: "auto",
    height: "auto",
    padding: "0",
    margin: "0",
    overflow: "visible",
    clip: "auto",
    whiteSpace: "normal"
  }
};

// node_modules/@pandacss/is-valid-prop/dist/index.mjs
var userGeneratedStr = "";
var userGenerated = userGeneratedStr.split(",");
var cssPropertiesStr = "WebkitAppearance,WebkitBorderBefore,WebkitBorderBeforeColor,WebkitBorderBeforeStyle,WebkitBorderBeforeWidth,WebkitBoxReflect,WebkitLineClamp,WebkitMask,WebkitMaskAttachment,WebkitMaskClip,WebkitMaskComposite,WebkitMaskImage,WebkitMaskOrigin,WebkitMaskPosition,WebkitMaskPositionX,WebkitMaskPositionY,WebkitMaskRepeat,WebkitMaskRepeatX,WebkitMaskRepeatY,WebkitMaskSize,WebkitOverflowScrolling,WebkitTapHighlightColor,WebkitTextFillColor,WebkitTextStroke,WebkitTextStrokeColor,WebkitTextStrokeWidth,WebkitTouchCallout,WebkitUserModify,accentColor,alignContent,alignItems,alignSelf,alignTracks,all,animation,animationComposition,animationDelay,animationDirection,animationDuration,animationFillMode,animationIterationCount,animationName,animationPlayState,animationRange,animationRangeEnd,animationRangeStart,animationTimingFunction,animationTimeline,appearance,aspectRatio,azimuth,backdropFilter,backfaceVisibility,background,backgroundAttachment,backgroundBlendMode,backgroundClip,backgroundColor,backgroundImage,backgroundOrigin,backgroundPosition,backgroundPositionX,backgroundPositionY,backgroundRepeat,backgroundSize,blockSize,border,borderBlock,borderBlockColor,borderBlockStyle,borderBlockWidth,borderBlockEnd,borderBlockEndColor,borderBlockEndStyle,borderBlockEndWidth,borderBlockStart,borderBlockStartColor,borderBlockStartStyle,borderBlockStartWidth,borderBottom,borderBottomColor,borderBottomLeftRadius,borderBottomRightRadius,borderBottomStyle,borderBottomWidth,borderCollapse,borderColor,borderEndEndRadius,borderEndStartRadius,borderImage,borderImageOutset,borderImageRepeat,borderImageSlice,borderImageSource,borderImageWidth,borderInline,borderInlineEnd,borderInlineColor,borderInlineStyle,borderInlineWidth,borderInlineEndColor,borderInlineEndStyle,borderInlineEndWidth,borderInlineStart,borderInlineStartColor,borderInlineStartStyle,borderInlineStartWidth,borderLeft,borderLeftColor,borderLeftStyle,borderLeftWidth,borderRadius,borderRight,borderRightColor,borderRightStyle,borderRightWidth,borderSpacing,borderStartEndRadius,borderStartStartRadius,borderStyle,borderTop,borderTopColor,borderTopLeftRadius,borderTopRightRadius,borderTopStyle,borderTopWidth,borderWidth,bottom,boxAlign,boxDecorationBreak,boxDirection,boxFlex,boxFlexGroup,boxLines,boxOrdinalGroup,boxOrient,boxPack,boxShadow,boxSizing,breakAfter,breakBefore,breakInside,captionSide,caret,caretColor,caretShape,clear,clip,clipPath,color,colorScheme,columnCount,columnFill,columnGap,columnRule,columnRuleColor,columnRuleStyle,columnRuleWidth,columnSpan,columnWidth,columns,contain,containIntrinsicSize,containIntrinsicBlockSize,containIntrinsicHeight,containIntrinsicInlineSize,containIntrinsicWidth,container,containerName,containerType,content,contentVisibility,counterIncrement,counterReset,counterSet,cursor,direction,display,emptyCells,filter,flex,flexBasis,flexDirection,flexFlow,flexGrow,flexShrink,flexWrap,float,font,fontFamily,fontFeatureSettings,fontKerning,fontLanguageOverride,fontOpticalSizing,fontPalette,fontVariationSettings,fontSize,fontSizeAdjust,fontSmooth,fontStretch,fontStyle,fontSynthesis,fontSynthesisPosition,fontSynthesisSmallCaps,fontSynthesisStyle,fontSynthesisWeight,fontVariant,fontVariantAlternates,fontVariantCaps,fontVariantEastAsian,fontVariantEmoji,fontVariantLigatures,fontVariantNumeric,fontVariantPosition,fontWeight,forcedColorAdjust,gap,grid,gridArea,gridAutoColumns,gridAutoFlow,gridAutoRows,gridColumn,gridColumnEnd,gridColumnGap,gridColumnStart,gridGap,gridRow,gridRowEnd,gridRowGap,gridRowStart,gridTemplate,gridTemplateAreas,gridTemplateColumns,gridTemplateRows,hangingPunctuation,height,hyphenateCharacter,hyphenateLimitChars,hyphens,imageOrientation,imageRendering,imageResolution,imeMode,initialLetter,initialLetterAlign,inlineSize,inputSecurity,inset,insetBlock,insetBlockEnd,insetBlockStart,insetInline,insetInlineEnd,insetInlineStart,isolation,justifyContent,justifyItems,justifySelf,justifyTracks,left,letterSpacing,lineBreak,lineClamp,lineHeight,lineHeightStep,listStyle,listStyleImage,listStylePosition,listStyleType,margin,marginBlock,marginBlockEnd,marginBlockStart,marginBottom,marginInline,marginInlineEnd,marginInlineStart,marginLeft,marginRight,marginTop,marginTrim,mask,maskBorder,maskBorderMode,maskBorderOutset,maskBorderRepeat,maskBorderSlice,maskBorderSource,maskBorderWidth,maskClip,maskComposite,maskImage,maskMode,maskOrigin,maskPosition,maskRepeat,maskSize,maskType,masonryAutoFlow,mathDepth,mathShift,mathStyle,maxBlockSize,maxHeight,maxInlineSize,maxLines,maxWidth,minBlockSize,minHeight,minInlineSize,minWidth,mixBlendMode,objectFit,objectPosition,offset,offsetAnchor,offsetDistance,offsetPath,offsetPosition,offsetRotate,opacity,order,orphans,outline,outlineColor,outlineOffset,outlineStyle,outlineWidth,overflow,overflowAnchor,overflowBlock,overflowClipBox,overflowClipMargin,overflowInline,overflowWrap,overflowX,overflowY,overlay,overscrollBehavior,overscrollBehaviorBlock,overscrollBehaviorInline,overscrollBehaviorX,overscrollBehaviorY,padding,paddingBlock,paddingBlockEnd,paddingBlockStart,paddingBottom,paddingInline,paddingInlineEnd,paddingInlineStart,paddingLeft,paddingRight,paddingTop,page,pageBreakAfter,pageBreakBefore,pageBreakInside,paintOrder,perspective,perspectiveOrigin,placeContent,placeItems,placeSelf,pointerEvents,position,printColorAdjust,quotes,resize,right,rotate,rowGap,rubyAlign,rubyMerge,rubyPosition,scale,scrollbarColor,scrollbarGutter,scrollbarWidth,scrollBehavior,scrollMargin,scrollMarginBlock,scrollMarginBlockStart,scrollMarginBlockEnd,scrollMarginBottom,scrollMarginInline,scrollMarginInlineStart,scrollMarginInlineEnd,scrollMarginLeft,scrollMarginRight,scrollMarginTop,scrollPadding,scrollPaddingBlock,scrollPaddingBlockStart,scrollPaddingBlockEnd,scrollPaddingBottom,scrollPaddingInline,scrollPaddingInlineStart,scrollPaddingInlineEnd,scrollPaddingLeft,scrollPaddingRight,scrollPaddingTop,scrollSnapAlign,scrollSnapCoordinate,scrollSnapDestination,scrollSnapPointsX,scrollSnapPointsY,scrollSnapStop,scrollSnapType,scrollSnapTypeX,scrollSnapTypeY,scrollTimeline,scrollTimelineAxis,scrollTimelineName,shapeImageThreshold,shapeMargin,shapeOutside,tabSize,tableLayout,textAlign,textAlignLast,textCombineUpright,textDecoration,textDecorationColor,textDecorationLine,textDecorationSkip,textDecorationSkipInk,textDecorationStyle,textDecorationThickness,textEmphasis,textEmphasisColor,textEmphasisPosition,textEmphasisStyle,textIndent,textJustify,textOrientation,textOverflow,textRendering,textShadow,textSizeAdjust,textTransform,textUnderlineOffset,textUnderlinePosition,textWrap,timelineScope,top,touchAction,transform,transformBox,transformOrigin,transformStyle,transition,transitionBehavior,transitionDelay,transitionDuration,transitionProperty,transitionTimingFunction,translate,unicodeBidi,userSelect,verticalAlign,viewTimeline,viewTimelineAxis,viewTimelineInset,viewTimelineName,viewTransitionName,visibility,whiteSpace,whiteSpaceCollapse,widows,width,willChange,wordBreak,wordSpacing,wordWrap,writingMode,zIndex,zoom,alignmentBaseline,baselineShift,clipRule,colorInterpolation,colorRendering,dominantBaseline,fill,fillOpacity,fillRule,floodColor,floodOpacity,glyphOrientationVertical,lightingColor,marker,markerEnd,markerMid,markerStart,shapeRendering,stopColor,stopOpacity,stroke,strokeDasharray,strokeDashoffset,strokeLinecap,strokeLinejoin,strokeMiterlimit,strokeOpacity,strokeWidth,textAnchor,vectorEffect";
var allCssProperties = cssPropertiesStr.split(",").concat(userGenerated);
var properties = new Map(allCssProperties.map((prop) => [prop, true]));
function memo(fn) {
  const cache = /* @__PURE__ */ Object.create(null);
  return (arg) => {
    if (cache[arg] === void 0)
      cache[arg] = fn(arg);
    return cache[arg];
  };
}
var cssPropertySelectorRegex = /&|@/;
var isCssProperty = memo((prop) => {
  return properties.has(prop) || prop.startsWith("--") || cssPropertySelectorRegex.test(prop);
});

// node_modules/@chakra-ui/react/dist/esm/utils/compact.js
function compact(object) {
  const clone3 = Object.assign({}, object);
  for (let key in clone3) {
    if (clone3[key] === void 0) delete clone3[key];
  }
  return clone3;
}

// node_modules/@chakra-ui/react/dist/esm/utils/walk-object.js
var isNotNullish = (element) => element != null;
function walkObject(target, predicate, options = {}) {
  const { stop, getKey } = options;
  function inner(value, path = []) {
    if (isObject(value) || Array.isArray(value)) {
      const result = {};
      for (const [prop, child] of Object.entries(value)) {
        const key = (getKey == null ? void 0 : getKey(prop, child)) ?? prop;
        const childPath = [...path, key];
        if (stop == null ? void 0 : stop(value, childPath)) {
          return predicate(value, path);
        }
        const next2 = inner(child, childPath);
        if (isNotNullish(next2)) {
          result[key] = next2;
        }
      }
      return result;
    }
    return predicate(value, path);
  }
  return inner(target);
}
function mapObject(obj, fn) {
  if (Array.isArray(obj)) return obj.map((value) => fn(value));
  if (!isObject(obj)) {
    if (obj !== null && obj !== void 0) return fn(obj);
    else return obj;
  }
  return walkObject(obj, (value) => fn(value));
}

// node_modules/@chakra-ui/react/dist/esm/utils/flatten.js
function flatten(values, stop) {
  const result = {};
  walkObject(
    values,
    (token, paths) => {
      if (token) {
        result[paths.join(".")] = token.value;
      }
    },
    { stop }
  );
  return result;
}

// node_modules/@chakra-ui/react/dist/esm/utils/memo.js
var memo2 = (fn, getKey) => {
  const cache = /* @__PURE__ */ Object.create(null);
  function get(...args) {
    const key = (getKey == null ? void 0 : getKey(...args)) ?? args.join("|");
    if (cache[key] === void 0) cache[key] = fn(...args);
    return cache[key];
  }
  return get;
};

// node_modules/@chakra-ui/react/dist/esm/utils/split-props.js
var splitProps = (props21, keys) => {
  const descriptors = Object.getOwnPropertyDescriptors(props21);
  const dKeys = Object.keys(descriptors);
  const split = (k) => {
    const clone3 = {};
    for (let i = 0; i < k.length; i++) {
      const key = k[i];
      if (descriptors[key]) {
        Object.defineProperty(clone3, key, descriptors[key]);
        delete descriptors[key];
      }
    }
    return clone3;
  };
  const fn = (key) => split(Array.isArray(key) ? key : dKeys.filter(key));
  return [keys].map(fn).concat(split(dKeys));
};

// node_modules/@chakra-ui/react/dist/esm/styled-system/unit-conversion.js
var BASE_FONT_SIZE = 16;
var UNIT_PX = "px";
var UNIT_EM = "em";
var UNIT_REM = "rem";
function getUnit(value = "") {
  const DIGIT_REGEX = new RegExp(String.raw`-?\d+(?:\.\d+|\d*)`);
  const UNIT_REGEX = new RegExp(`${UNIT_PX}|${UNIT_EM}|${UNIT_REM}`);
  const unit = value.match(
    new RegExp(`${DIGIT_REGEX.source}(${UNIT_REGEX.source})`)
  );
  return unit == null ? void 0 : unit[1];
}
function toPx(value = "") {
  if (typeof value === "number") {
    return `${value}px`;
  }
  const unit = getUnit(value);
  if (!unit) return value;
  if (unit === UNIT_PX) {
    return value;
  }
  if (unit === UNIT_EM || unit === UNIT_REM) {
    return `${parseFloat(value) * BASE_FONT_SIZE}${UNIT_PX}`;
  }
}
function toRem(value = "") {
  const unit = getUnit(value);
  if (!unit) return value;
  if (unit === UNIT_REM) {
    return value;
  }
  if (unit === UNIT_EM) {
    return `${parseFloat(value)}${UNIT_REM}`;
  }
  if (unit === UNIT_PX) {
    return `${parseFloat(value) / BASE_FONT_SIZE}${UNIT_REM}`;
  }
}

// node_modules/@chakra-ui/react/dist/esm/styled-system/breakpoints.js
var capitalize = (str) => str.charAt(0).toUpperCase() + str.slice(1);
function createBreakpoints(breakpoints2) {
  const sorted = sort(breakpoints2);
  const values = Object.fromEntries(sorted);
  function get(name) {
    return values[name];
  }
  function only(name) {
    return build(get(name));
  }
  function getRanges() {
    const breakpoints22 = Object.keys(values);
    const permuations = getPermutations(breakpoints22);
    const results = breakpoints22.flatMap((name) => {
      const value = get(name);
      const down2 = [
        `${name}Down`,
        build({ max: adjust(value.min) })
      ];
      const up2 = [name, build({ min: value.min })];
      const _only = [`${name}Only`, only(name)];
      return [up2, _only, down2];
    }).filter(([, value]) => value !== "").concat(
      permuations.map(([min4, max4]) => {
        const minValue = get(min4);
        const maxValue2 = get(max4);
        return [
          `${min4}To${capitalize(max4)}`,
          build({ min: minValue.min, max: adjust(maxValue2.min) })
        ];
      })
    );
    return Object.fromEntries(results);
  }
  function toConditions() {
    const ranges = getRanges();
    return Object.fromEntries(Object.entries(ranges));
  }
  const conditions = toConditions();
  const getCondition = (key) => {
    return conditions[key];
  };
  function keys() {
    return ["base", ...Object.keys(values)];
  }
  function up(name) {
    return build({ min: get(name).min });
  }
  function down(name) {
    return build({ max: adjust(get(name).min) });
  }
  return {
    values: Object.values(values),
    only,
    keys,
    conditions,
    getCondition,
    up,
    down
  };
}
function adjust(value) {
  const computedMax = parseFloat(toPx(value) ?? "") - 0.04;
  return toRem(`${computedMax}px`);
}
function sort(breakpoints2) {
  const entries = Object.entries(breakpoints2).sort(([, minA], [, minB]) => {
    return parseInt(minA, 10) < parseInt(minB, 10) ? -1 : 1;
  });
  return entries.map(([name, min4], index, entries2) => {
    var _a8;
    let max4 = null;
    if (index <= entries2.length - 1) {
      max4 = (_a8 = entries2[index + 1]) == null ? void 0 : _a8[1];
    }
    if (max4 != null) {
      max4 = adjust(max4);
    }
    return [name, { name, min: toRem(min4), max: max4 }];
  });
}
function getPermutations(values) {
  const result = [];
  values.forEach((current, index) => {
    let idx = index;
    idx++;
    let next2 = values[idx];
    while (next2) {
      result.push([current, next2]);
      idx++;
      next2 = values[idx];
    }
  });
  return result;
}
function build({ min: min4, max: max4 }) {
  if (min4 == null && max4 == null) return "";
  return [
    "@media screen",
    min4 && `(min-width: ${min4})`,
    max4 && `(max-width: ${max4})`
  ].filter(Boolean).join(" and ");
}

// node_modules/@chakra-ui/react/dist/esm/styled-system/conditions.js
var mapEntries = (obj, fn) => {
  return Object.fromEntries(
    Object.entries(obj).map(([key, value]) => fn(key, value))
  );
};
var createConditions = (options) => {
  const { breakpoints: breakpoints2, conditions: conds = {} } = options;
  const conditions = mapEntries(conds, (key, value) => [`_${key}`, value]);
  const values = Object.assign({}, conditions, breakpoints2.conditions);
  function keys() {
    return Object.keys(values);
  }
  function has2(key) {
    return keys().includes(key) || /^@|&|&$/.test(key) || key.startsWith("_");
  }
  function sort2(paths) {
    return paths.filter((v) => v !== "base").sort((a, b) => {
      const aa = has2(a);
      const bb = has2(b);
      if (aa && !bb) return 1;
      if (!aa && bb) return -1;
      return 0;
    });
  }
  function expandAtRule(key) {
    if (!key.startsWith("@breakpoint")) return key;
    return breakpoints2.getCondition(key.replace("@breakpoint ", ""));
  }
  function resolve(key) {
    return Reflect.get(values, key) || key;
  }
  return {
    keys,
    sort: sort2,
    has: has2,
    resolve,
    breakpoints: breakpoints2.keys(),
    expandAtRule
  };
};

// node_modules/@chakra-ui/react/dist/esm/styled-system/sort-at-params.js
var createMediaQueryRegex = (dimension) => ({
  minMax: new RegExp(
    `(!?\\(\\s*min(-device-)?-${dimension})(.|
)+\\(\\s*max(-device)?-${dimension}`,
    "i"
  ),
  min: new RegExp(`\\(\\s*min(-device)?-${dimension}`, "i"),
  maxMin: new RegExp(
    `(!?\\(\\s*max(-device)?-${dimension})(.|
)+\\(\\s*min(-device)?-${dimension}`,
    "i"
  ),
  max: new RegExp(`\\(\\s*max(-device)?-${dimension}`, "i")
});
var widthRegex = createMediaQueryRegex("width");
var heightRegex = createMediaQueryRegex("height");
var createQueryTester = (regexSet) => ({
  isMin: _testQuery(regexSet.minMax, regexSet.maxMin, regexSet.min),
  isMax: _testQuery(regexSet.maxMin, regexSet.minMax, regexSet.max)
});
var { isMin: isMinWidth, isMax: isMaxWidth } = createQueryTester(widthRegex);
var { isMin: isMinHeight, isMax: isMaxHeight } = createQueryTester(heightRegex);
var isPrint = /print/i;
var isPrintOnly = /^print$/i;
var isLength = /(-?\d*\.?\d+)(ch|em|ex|px|rem)/;
var lengthExec = /(\d)/;
var maxValue = Number.MAX_VALUE;
var multipliers = { ch: 8.8984375, em: 16, rem: 16, ex: 8.296875, px: 1 };
function getQueryLength(query2) {
  const length = isLength.exec(query2) || (isMinWidth(query2) || isMinHeight(query2) ? lengthExec.exec(query2) : null);
  if (!length) return maxValue;
  if (length[0] === "0") return 0;
  const number = parseFloat(length[1]);
  const unit = length[2];
  return number * (multipliers[unit] || 1);
}
function _testQuery(doubleTestTrue, doubleTestFalse, singleTest) {
  return (query2) => doubleTestTrue.test(query2) || !doubleTestFalse.test(query2) && singleTest.test(query2);
}
function _testIsPrint(a, b) {
  const isPrintA = isPrint.test(a), isPrintOnlyA = isPrintOnly.test(a);
  const isPrintB = isPrint.test(b), isPrintOnlyB = isPrintOnly.test(b);
  if (isPrintA && isPrintB) {
    if (!isPrintOnlyA && isPrintOnlyB) return 1;
    if (isPrintOnlyA && !isPrintOnlyB) return -1;
    return a.localeCompare(b);
  }
  return isPrintA ? 1 : isPrintB ? -1 : null;
}
var sortAtParams = memo2((a, b) => {
  const testIsPrint = _testIsPrint(a, b);
  if (testIsPrint !== null) return testIsPrint;
  const minA = isMinWidth(a) || isMinHeight(a), maxA = isMaxWidth(a) || isMaxHeight(a);
  const minB = isMinWidth(b) || isMinHeight(b), maxB = isMaxWidth(b) || isMaxHeight(b);
  if (minA && maxB) return -1;
  if (maxA && minB) return 1;
  const lengthA = getQueryLength(a), lengthB = getQueryLength(b);
  if (lengthA === maxValue && lengthB === maxValue) return a.localeCompare(b);
  if (lengthA === maxValue) return 1;
  if (lengthB === maxValue) return -1;
  if (lengthA !== lengthB) {
    return lengthA > lengthB ? maxA ? -1 : 1 : maxA ? 1 : -1;
  }
  return a.localeCompare(b);
});

// node_modules/@chakra-ui/react/dist/esm/styled-system/sort-at-rules.js
function sortQueries(queries) {
  return queries.sort(([a], [b]) => sortAtParams(a, b));
}
function sortAtRules(obj) {
  const mediaQueries = [];
  const containerQueries = [];
  const rest = {};
  for (const [key, value] of Object.entries(obj)) {
    if (key.startsWith("@media")) {
      mediaQueries.push([key, value]);
    } else if (key.startsWith("@container")) {
      containerQueries.push([key, value]);
    } else if (isObject(value)) {
      rest[key] = sortAtRules(value);
    } else {
      rest[key] = value;
    }
  }
  const sortedMediaQueries = sortQueries(mediaQueries);
  const sortedContainerQueries = sortQueries(containerQueries);
  return {
    ...rest,
    ...Object.fromEntries(sortedMediaQueries),
    ...Object.fromEntries(sortedContainerQueries)
  };
}

// node_modules/@chakra-ui/react/dist/esm/styled-system/css.js
var importantRegex = /\s*!(important)?/i;
var isImportant = (v) => isString(v) ? importantRegex.test(v) : false;
var withoutImportant = (v) => isString(v) ? v.replace(importantRegex, "").trim() : v;
function createCssFn(context) {
  const { transform, conditions, normalize: normalize2 } = context;
  const mergeFn = mergeCss(context);
  return function cssFn(...styleArgs) {
    const styles = mergeFn(...styleArgs);
    const normalized = normalize2(styles);
    const result = /* @__PURE__ */ Object.create(null);
    walkObject(normalized, (value, paths) => {
      const important = isImportant(value);
      if (value == null) return;
      const [prop, ...selectors] = conditions.sort(paths).map(conditions.resolve);
      if (important) {
        value = withoutImportant(value);
      }
      let transformed = transform(prop, value) ?? /* @__PURE__ */ Object.create(null);
      transformed = walkObject(
        transformed,
        (v) => isString(v) && important ? `${v} !important` : v,
        { getKey: (prop2) => conditions.expandAtRule(prop2) }
      );
      mergeByPath(result, selectors.flat(), transformed);
    });
    return sortAtRules(result);
  };
}
function mergeByPath(target, paths, value) {
  let acc = target;
  for (const path of paths) {
    if (!path) continue;
    if (!acc[path]) acc[path] = /* @__PURE__ */ Object.create(null);
    acc = acc[path];
  }
  mergeWith(acc, value);
}
function compactFn(...styles) {
  return styles.filter(
    (style) => isObject(style) && Object.keys(compact(style)).length > 0
  );
}
function mergeCss(ctx) {
  function resolve(styles) {
    const comp = compactFn(...styles);
    if (comp.length === 1) return comp;
    return comp.map((style) => ctx.normalize(style));
  }
  return function mergeFn(...styles) {
    return mergeWith({}, ...resolve(styles));
  };
}

// node_modules/@chakra-ui/react/dist/esm/utils/cx.js
var cx = (...classNames) => classNames.filter(Boolean).map((r) => r.trim()).join(" ");

// node_modules/@chakra-ui/react/dist/esm/utils/omit.js
function omit(object, keysToOmit = []) {
  const clone3 = Object.assign({}, object);
  for (const key of keysToOmit) {
    if (key in clone3) {
      delete clone3[key];
    }
  }
  return clone3;
}

// node_modules/@chakra-ui/react/dist/esm/utils/uniq.js
var uniq = (...items) => {
  const _items = items.filter(Boolean);
  return Array.from(new Set(_items));
};

// node_modules/@chakra-ui/react/dist/esm/styled-system/cva.js
var defaults = (conf) => ({
  base: {},
  variants: {},
  defaultVariants: {},
  compoundVariants: [],
  ...conf
});
function createRecipeFn(options) {
  const { css: css2, conditions, normalize: normalize2, layers } = options;
  function cva(config = {}) {
    const { base, variants: variants3, defaultVariants: defaultVariants3, compoundVariants } = defaults(config);
    const getVariantCss = createCssFn({
      conditions,
      normalize: normalize2,
      transform(prop, value) {
        var _a8;
        return (_a8 = variants3[prop]) == null ? void 0 : _a8[value];
      }
    });
    const resolve = (props21 = {}) => {
      const variantSelections = normalize2({
        ...defaultVariants3,
        ...compact(props21)
      });
      let variantCss = { ...base };
      mergeWith(variantCss, getVariantCss(variantSelections));
      const compoundVariantCss = getCompoundVariantCss(
        compoundVariants,
        variantSelections
      );
      return layers.wrap("recipes", css2(variantCss, compoundVariantCss));
    };
    const variantKeys = Object.keys(variants3);
    const splitVariantProps = (props21) => {
      const restProps = omit(props21, ["recipe"]);
      const [recipeProps, localProps] = splitProps(restProps, variantKeys);
      if (!variantKeys.includes("colorPalette")) {
        recipeProps.colorPalette = props21.colorPalette || defaultVariants3.colorPalette;
      }
      if (variantKeys.includes("orientation")) {
        localProps.orientation = props21.orientation;
      }
      return [recipeProps, localProps];
    };
    const variantMap = Object.fromEntries(
      Object.entries(variants3).map(([key, value]) => [
        key,
        Object.keys(value)
      ])
    );
    const cvaFn = (props21) => css2(resolve(props21));
    return Object.assign(cvaFn, {
      className: config.className,
      __cva__: true,
      variantMap,
      variantKeys,
      raw: resolve,
      config,
      splitVariantProps,
      merge(other) {
        return cva(mergeCva(options)(this, other));
      }
    });
  }
  function getCompoundVariantCss(cvs, vm) {
    let result = {};
    cvs.forEach((cv) => {
      const isMatching = Object.entries(cv).every(([key, value]) => {
        if (key === "css") return true;
        const values = Array.isArray(value) ? value : [value];
        return values.some((value2) => vm[key] === value2);
      });
      if (isMatching) {
        result = css2(result, cv.css);
      }
    });
    return result;
  }
  return cva;
}
function mergeCva(opts) {
  const { css: css2 } = opts;
  return function mergeCva2(cvaA, cvaB) {
    const override = defaults(cvaB.config);
    const variantKeys = uniq(cvaA.variantKeys, Object.keys(cvaB.variants));
    const base = css2(cvaA.base, override.base);
    const variants3 = Object.fromEntries(
      variantKeys.map((key) => [
        key,
        css2(cvaA.config.variants[key], override.variants[key])
      ])
    );
    const defaultVariants3 = mergeWith(
      cvaA.config.defaultVariants,
      override.defaultVariants
    );
    const compoundVariants = [
      ...cvaA.compoundVariants,
      ...override.compoundVariants
    ];
    const className = cx(cvaA.className, cvaB.className);
    return {
      className,
      base,
      variants: variants3,
      defaultVariants: defaultVariants3,
      compoundVariants
    };
  };
}

// node_modules/@chakra-ui/react/dist/esm/styled-system/layers.js
var defaultLayers = {
  reset: "reset",
  base: "base",
  tokens: "tokens",
  recipes: "recipes"
};
var layerOrder = {
  reset: 0,
  base: 1,
  tokens: 2,
  recipes: 3
};
function createLayers(config) {
  const layers = config.layers ?? defaultLayers;
  const values = Object.values(layers);
  const names = values.sort((a, b) => layerOrder[a] - layerOrder[b]);
  return {
    names,
    atRule: `@layer ${names.join(", ")};`,
    wrap(layer, styles) {
      if (config.disableLayers) return styles;
      const params = layers[layer];
      return { [`@layer ${params}`]: styles };
    }
  };
}

// node_modules/@chakra-ui/react/dist/esm/styled-system/normalize.js
function createNormalizeFn(context) {
  const { utility, normalize: normalize2 } = context;
  const { hasShorthand, resolveShorthand } = utility;
  return function(styles) {
    return walkObject(styles, normalize2, {
      stop: (value) => Array.isArray(value),
      getKey: hasShorthand ? resolveShorthand : void 0
    });
  };
}

// node_modules/@chakra-ui/react/dist/esm/styled-system/preflight.js
function createPreflight(options) {
  const { preflight } = options;
  if (!preflight) return {};
  const { scope = "", level = "parent" } = isObject(preflight) ? preflight : {};
  let selector = "";
  if (scope && level === "parent") {
    selector = `${scope} `;
  } else if (scope && level === "element") {
    selector = `&${scope}`;
  }
  const scoped = {
    "*": {
      margin: "0px",
      padding: "0px",
      font: "inherit",
      wordWrap: "break-word",
      WebkitTapHighlightColor: "transparent"
    },
    "*, *::before, *::after, *::backdrop": {
      boxSizing: "border-box",
      borderWidth: "0px",
      borderStyle: "solid",
      borderColor: "var(--global-color-border, currentColor)"
    },
    hr: {
      height: "0px",
      color: "inherit",
      borderTopWidth: "1px"
    },
    body: {
      minHeight: "100dvh",
      position: "relative"
    },
    img: {
      borderStyle: "none"
    },
    "img, svg, video, canvas, audio, iframe, embed, object": {
      display: "block",
      verticalAlign: "middle"
    },
    iframe: { border: "none" },
    "img, video": { maxWidth: "100%", height: "auto" },
    "p, h1, h2, h3, h4, h5, h6": { overflowWrap: "break-word" },
    "ol, ul": { listStyle: "none" },
    "code, kbd, pre, samp": { fontSize: "1em" },
    "button, [type='button'], [type='reset'], [type='submit']": {
      WebkitAppearance: "button",
      backgroundColor: "transparent",
      backgroundImage: "none"
    },
    "button, input, optgroup, select, textarea": { color: "inherit" },
    "button, select": { textTransform: "none" },
    table: {
      textIndent: "0px",
      borderColor: "inherit",
      borderCollapse: "collapse"
    },
    "*::placeholder": {
      opacity: "unset",
      color: "#9ca3af",
      userSelect: "none"
    },
    textarea: {
      resize: "vertical"
    },
    summary: {
      display: "list-item"
    },
    small: {
      fontSize: "80%"
    },
    "sub, sup": {
      fontSize: "75%",
      lineHeight: 0,
      position: "relative",
      verticalAlign: "baseline"
    },
    sub: {
      bottom: "-0.25em"
    },
    sup: {
      top: "-0.5em"
    },
    dialog: {
      padding: "0px"
    },
    a: {
      color: "inherit",
      textDecoration: "inherit"
    },
    "abbr:where([title])": {
      textDecoration: "underline dotted"
    },
    "b, strong": {
      fontWeight: "bolder"
    },
    "code, kbd, samp, pre": {
      fontSize: "1em",
      "--font-mono-fallback": "ui-monospace, SFMono-Regular, Menlo, Monaco, Consolas, 'Liberation Mono', 'Courier New'",
      fontFamily: "var(--global-font-mono, var(--font-mono-fallback))"
    },
    'input[type="text"], input[type="email"], input[type="search"], input[type="password"]': {
      WebkitAppearance: "none",
      MozAppearance: "none"
    },
    "input[type='search']": {
      WebkitAppearance: "textfield",
      outlineOffset: "-2px"
    },
    "::-webkit-search-decoration, ::-webkit-search-cancel-button": {
      WebkitAppearance: "none"
    },
    "::-webkit-file-upload-button": {
      WebkitAppearance: "button",
      font: "inherit"
    },
    'input[type="number"]::-webkit-inner-spin-button, input[type="number"]::-webkit-outer-spin-button': {
      height: "auto"
    },
    "input[type='number']": {
      MozAppearance: "textfield"
    },
    ":-moz-ui-invalid": {
      boxShadow: "none"
    },
    ":-moz-focusring": {
      outline: "auto"
    },
    "[hidden]:where(:not([hidden='until-found']))": {
      display: "none !important"
    }
  };
  const preflightCss = {
    [scope || "html"]: {
      lineHeight: 1.5,
      "--font-fallback": "ui-sans-serif, system-ui, -apple-system, BlinkMacSystemFont, 'Segoe UI', Roboto, 'Helvetica Neue', Arial, 'Noto Sans', sans-serif, 'Apple Color Emoji', 'Segoe UI Emoji', 'Segoe UI Symbol', 'Noto Color Emoji'",
      WebkitTextSizeAdjust: "100%",
      WebkitFontSmoothing: "antialiased",
      MozOsxFontSmoothing: "grayscale",
      textRendering: "optimizeLegibility",
      touchAction: "manipulation",
      MozTabSize: "4",
      tabSize: "4",
      fontFamily: "var(--global-font-body, var(--font-fallback))"
    }
  };
  if (level === "element") {
    const modified = Object.entries(scoped).reduce((acc, [k, v]) => {
      acc[k] = { [selector]: v };
      return acc;
    }, {});
    Object.assign(preflightCss, modified);
  } else if (selector) {
    preflightCss[selector] = scoped;
  } else {
    Object.assign(preflightCss, scoped);
  }
  return preflightCss;
}

// node_modules/@chakra-ui/react/dist/esm/styled-system/serialize.js
function createSerializeFn(options) {
  const { conditions, isValidProperty } = options;
  return function serialize2(styles) {
    return walkObject(styles, (value) => value, {
      getKey: (prop, value) => {
        if (!isObject(value)) return prop;
        if (!conditions.has(prop) && !isValidProperty(prop)) {
          return parseSelectors(prop).map((s) => "&" + s).join(", ");
        }
        return prop;
      }
    });
  };
}
function parseSelectors(selector) {
  const result = [];
  let parenCount = 0;
  let currentSelector = "";
  let inEscape = false;
  for (let i = 0; i < selector.length; i++) {
    const char = selector[i];
    if (char === "\\" && !inEscape) {
      inEscape = true;
      currentSelector += char;
      continue;
    }
    if (inEscape) {
      inEscape = false;
      currentSelector += char;
      continue;
    }
    if (char === "(") {
      parenCount++;
    } else if (char === ")") {
      parenCount--;
    }
    if (char === "," && parenCount === 0) {
      result.push(currentSelector.trim());
      currentSelector = "";
    } else {
      currentSelector += char;
    }
  }
  if (currentSelector) {
    result.push(currentSelector.trim());
  }
  return result;
}

// node_modules/@chakra-ui/react/dist/esm/styled-system/sva.js
var getSlotRecipes = (config = {}) => {
  const init = (slot) => {
    var _a8;
    return {
      base: ((_a8 = config.base) == null ? void 0 : _a8[slot]) ?? {},
      variants: {},
      defaultVariants: config.defaultVariants ?? {},
      compoundVariants: config.compoundVariants ? getSlotCompoundVariant(config.compoundVariants, slot) : []
    };
  };
  const slots = config.slots ?? [];
  const entries = slots.map((slot) => [slot, init(slot)]);
  for (const [variantsKey, variantsSpec] of Object.entries(
    config.variants ?? {}
  )) {
    for (const [variantKey, variantSpec] of Object.entries(
      variantsSpec
    )) {
      entries.forEach(([slot, slotRecipe]) => {
        var _a8;
        (_a8 = slotRecipe.variants)[variantsKey] ?? (_a8[variantsKey] = {});
        slotRecipe.variants[variantsKey][variantKey] = variantSpec[slot] ?? {};
      });
    }
  }
  return Object.fromEntries(entries);
};
var getSlotCompoundVariant = (compoundVariants, slotName) => compoundVariants.filter((compoundVariant) => compoundVariant.css[slotName]).map((compoundVariant) => ({
  ...compoundVariant,
  css: compoundVariant.css[slotName]
}));
function createSlotRecipeFn(options) {
  const { cva } = options;
  return function sva(config = {}) {
    const slots = Object.entries(getSlotRecipes(config)).map(
      ([slot, slotCva]) => [slot, cva(slotCva)]
    );
    function svaFn(props21) {
      const result = slots.map(([slot, cvaFn]) => [slot, cvaFn(props21)]);
      return Object.fromEntries(result);
    }
    const variants3 = config.variants ?? {};
    const variantKeys = Object.keys(variants3);
    function splitVariantProps(props21) {
      var _a8;
      const restProps = omit(props21, ["recipe"]);
      const [recipeProps, localProps] = splitProps(restProps, variantKeys);
      if (!variantKeys.includes("colorPalette")) {
        recipeProps.colorPalette = props21.colorPalette || ((_a8 = config.defaultVariants) == null ? void 0 : _a8.colorPalette);
      }
      if (variantKeys.includes("orientation")) {
        localProps.orientation = props21.orientation;
      }
      return [recipeProps, localProps];
    }
    const variantMap = Object.fromEntries(
      Object.entries(variants3).map(([key, value]) => [key, Object.keys(value)])
    );
    let classNameMap = {};
    if (config.className) {
      classNameMap = Object.fromEntries(
        config.slots.map((slot) => [
          slot,
          `${config.className}__${slot}`
        ])
      );
    }
    return Object.assign(svaFn, {
      variantMap,
      variantKeys,
      splitVariantProps,
      classNameMap
    });
  };
}

// node_modules/@chakra-ui/react/dist/esm/utils/create-props.js
var createProps = () => (props21) => Array.from(new Set(props21));

// node_modules/@chakra-ui/react/dist/esm/styled-system/esc.js
var rcssescape = /([\0-\x1f\x7f]|^-?\d)|^-$|^-|[^\x80-\uFFFF\w-]/g;
var fcssescape = function(ch, asCodePoint) {
  if (!asCodePoint) return "\\" + ch;
  if (ch === "\0") return "�";
  if (ch === "-" && ch.length === 1) return "\\-";
  return ch.slice(0, -1) + "\\" + ch.charCodeAt(ch.length - 1).toString(16);
};
var esc2 = (sel) => {
  return (sel + "").replace(rcssescape, fcssescape);
};

// node_modules/@chakra-ui/react/dist/esm/styled-system/expand-reference.js
var expandTokenReferences = (str, resolve) => {
  let expanded = "";
  let index = 0;
  let state2 = "char";
  let tokenPath = "";
  let fallback4 = "";
  const currentStates = [];
  while (index < str.length) {
    const char = str[index];
    if (char === "{") {
      const endIndex = str.indexOf("}", index);
      if (endIndex === -1) {
        break;
      }
      const path = str.slice(index + 1, endIndex);
      const resolved = resolve(path);
      expanded += resolved ?? path;
      index = endIndex + 1;
      continue;
    }
    if (state2 === "token") {
      if (char === ",") {
        if (str[index] === "") {
          index++;
        }
        state2 = "fallback";
        currentStates.push(state2);
        const resolved = resolve(tokenPath);
        if (resolved == null ? void 0 : resolved.endsWith(")")) {
          expanded += resolved.slice(0, -1);
        }
        tokenPath = "";
        fallback4 = "";
        continue;
      }
    }
    if (state2 === "fallback") {
      const nextFallback = fallback4 + char;
      if (nextFallback === ", var(") {
        const innerEndIndex = cssVarParser(str.slice(index + 1));
        const endIndex = innerEndIndex + index + 1;
        const cssVar2 = str.slice(index + 1, endIndex);
        if (endIndex === -1) {
          break;
        }
        expanded += ", var(" + cssVar2 + ")";
        index = endIndex + 1;
        state2 = currentStates.pop() ?? state2;
        fallback4 = "";
        continue;
      }
    }
    if (state2 === "token" || state2 === "fallback") {
      index++;
      if (char === ")") {
        state2 = currentStates.pop() ?? state2 ?? "char";
        fallback4 += char;
        const resolved = tokenPath ? resolve(tokenPath) ?? esc2(tokenPath) : tokenPath;
        if (fallback4) {
          fallback4 = fallback4.slice(1).trim();
          if (!fallback4.startsWith("token(") && fallback4.endsWith(")")) {
            fallback4 = fallback4.slice(0, -1);
          }
          if (fallback4.includes("token(")) {
            const parsed = expandTokenReferences(fallback4, resolve);
            if (parsed) {
              fallback4 = parsed.slice(0, -1);
            }
          } else if (fallback4) {
            const resolvedFallback = resolve(fallback4);
            if (resolvedFallback) {
              fallback4 = resolvedFallback;
            }
          }
        }
        const lastChar = expanded.at(-1);
        if (fallback4) {
          if (lastChar == null ? void 0 : lastChar.trim()) {
            expanded += resolved.slice(0, -1) + (", " + fallback4 + ")");
          } else {
            expanded += fallback4;
          }
        } else {
          expanded += resolved || ")";
        }
        tokenPath = "";
        fallback4 = "";
        state2 = "char";
        continue;
      }
      if (state2 === "token") {
        tokenPath += char;
      }
      if (state2 === "fallback") {
        fallback4 += char;
      }
      continue;
    }
    const tokenIndex = str.indexOf("token(", index);
    if (tokenIndex !== -1) {
      const innerTokenIndex = tokenIndex + "token(".length;
      expanded += str.slice(index, tokenIndex);
      index = innerTokenIndex;
      state2 = "token";
      currentStates.push(state2);
      continue;
    }
    expanded += char;
    index++;
  }
  return expanded;
};
var cssVarParser = (str) => {
  let index = 0;
  const openedParenthesises = ["("];
  while (index < str.length) {
    const char = str[index];
    if (char === "(") {
      openedParenthesises.push(char);
    } else if (char === ")") {
      openedParenthesises.pop();
      if (openedParenthesises.length === 0) {
        return index;
      }
    }
    index++;
  }
  return index;
};

// node_modules/@chakra-ui/react/dist/esm/styled-system/map-to-json.js
function mapToJson(map2) {
  const obj = {};
  map2.forEach((value, key) => {
    if (value instanceof Map) {
      obj[key] = Object.fromEntries(value);
    } else {
      obj[key] = value;
    }
  });
  return obj;
}

// node_modules/@chakra-ui/react/dist/esm/styled-system/references.js
var REFERENCE_REGEX = /({([^}]*)})/g;
var CURLY_REGEX = /[{}]/g;
var TOKEN_PATH_REGEX = /\w+\.\w+/;
var getReferences = (value) => {
  if (!isString(value)) return [];
  const matches = value.match(REFERENCE_REGEX);
  if (!matches) return [];
  return matches.map((match4) => match4.replace(CURLY_REGEX, "")).map((value2) => value2.trim());
};
var hasReference = (value) => REFERENCE_REGEX.test(value);
function expandReferences(token) {
  var _a8, _b7, _c6;
  if (!((_a8 = token.extensions) == null ? void 0 : _a8.references)) {
    return ((_c6 = (_b7 = token.extensions) == null ? void 0 : _b7.cssVar) == null ? void 0 : _c6.ref) ?? token.value;
  }
  const references = token.extensions.references ?? {};
  token.value = Object.keys(references).reduce((valueStr, key) => {
    const referenceToken = references[key];
    if (referenceToken.extensions.conditions) {
      return valueStr;
    }
    const value = expandReferences(referenceToken);
    return valueStr.replace(`{${key}}`, value);
  }, token.value);
  delete token.extensions.references;
  return token.value;
}

// node_modules/@chakra-ui/react/dist/esm/styled-system/calc.js
function resolveReference(operand) {
  if (isObject(operand) && operand.reference) {
    return operand.reference;
  }
  return String(operand);
}
var toExpression = (operator, ...operands) => operands.map(resolveReference).join(` ${operator} `).replace(/calc/g, "");
var add = (...operands) => `calc(${toExpression("+", ...operands)})`;
var subtract = (...operands) => `calc(${toExpression("-", ...operands)})`;
var multiply = (...operands) => `calc(${toExpression("*", ...operands)})`;
var divide = (...operands) => `calc(${toExpression("/", ...operands)})`;
var negate = (x) => {
  const value = resolveReference(x);
  if (value != null && !Number.isNaN(parseFloat(value))) {
    return String(value).startsWith("-") ? String(value).slice(1) : `-${value}`;
  }
  return multiply(value, -1);
};
var calc = Object.assign(
  (x) => ({
    add: (...operands) => calc(add(x, ...operands)),
    subtract: (...operands) => calc(subtract(x, ...operands)),
    multiply: (...operands) => calc(multiply(x, ...operands)),
    divide: (...operands) => calc(divide(x, ...operands)),
    negate: () => calc(negate(x)),
    toString: () => x.toString()
  }),
  {
    add,
    subtract,
    multiply,
    divide,
    negate
  }
);

// node_modules/@chakra-ui/react/dist/esm/styled-system/token-middleware.js
var addNegativeTokens = {
  enforce: "pre",
  transform(dictionary) {
    const { prefix, allTokens, formatCssVar, formatTokenName, registerToken } = dictionary;
    const tokens = allTokens.filter(
      ({ extensions }) => extensions.category === "spacing"
    );
    tokens.forEach((token) => {
      const originalPath = token.path.slice();
      const originalVar = formatCssVar(originalPath, prefix);
      if (isString(token.value) && token.value === "0rem") {
        return;
      }
      const nextToken = structuredClone(token);
      Object.assign(nextToken.extensions, {
        negative: true,
        prop: `-${token.extensions.prop}`,
        originalPath
      });
      nextToken.value = calc.negate(originalVar.ref);
      const lastPath = nextToken.path[nextToken.path.length - 1];
      if (lastPath != null) {
        nextToken.path[nextToken.path.length - 1] = `-${lastPath}`;
      }
      if (nextToken.path) {
        nextToken.name = formatTokenName(nextToken.path);
      }
      registerToken(nextToken);
    });
  }
};
var units = /* @__PURE__ */ new Set([
  "spacing",
  "sizes",
  "borderWidths",
  "fontSizes",
  "radii"
]);
var addPixelUnit = {
  enforce: "post",
  transform(dictionary) {
    const tokens = dictionary.allTokens.filter((token) => {
      return units.has(token.extensions.category) && !token.extensions.negative;
    });
    tokens.forEach((token) => {
      Object.assign(token.extensions, {
        pixelValue: toPx(token.value)
      });
    });
  }
};
var addVirtualPalette = {
  enforce: "post",
  transform(dictionary) {
    const { allTokens, registerToken, formatTokenName } = dictionary;
    const tokens = allTokens.filter(
      ({ extensions }) => extensions.category === "colors"
    );
    const keys = /* @__PURE__ */ new Map();
    const colorPalettes = /* @__PURE__ */ new Map();
    tokens.forEach((token) => {
      const { colorPalette } = token.extensions;
      if (!colorPalette) return;
      colorPalette.keys.forEach((keyPath) => {
        keys.set(formatTokenName(keyPath), keyPath);
      });
      colorPalette.roots.forEach((colorPaletteRoot) => {
        var _a8;
        const name = formatTokenName(colorPaletteRoot);
        const colorPaletteList = colorPalettes.get(name) || [];
        colorPaletteList.push(token);
        colorPalettes.set(name, colorPaletteList);
        if (token.extensions.default && colorPaletteRoot.length === 1) {
          const keyPath = (_a8 = colorPalette.keys[0]) == null ? void 0 : _a8.filter(Boolean);
          if (!keyPath.length) return;
          const path = colorPaletteRoot.concat(keyPath);
          keys.set(formatTokenName(path), []);
        }
      });
    });
    keys.forEach((segments) => {
      const path = ["colors", "colorPalette", ...segments].filter(Boolean);
      const name = formatTokenName(path);
      const prop = formatTokenName(path.slice(1));
      const token = {
        name,
        value: name,
        originalValue: name,
        path,
        extensions: {
          condition: "base",
          originalPath: path,
          category: "colors",
          prop,
          virtual: true
        }
      };
      registerToken(token, "pre");
    });
  }
};
var removeEmptyTokens = {
  enforce: "post",
  transform(dictionary) {
    dictionary.allTokens = dictionary.allTokens.filter(
      (token) => token.value !== ""
    );
  }
};
var tokenMiddlewares = [
  addNegativeTokens,
  addVirtualPalette,
  addPixelUnit,
  removeEmptyTokens
];

// node_modules/@chakra-ui/react/dist/esm/styled-system/token-transforms.js
var addCssVariables = {
  type: "extensions",
  enforce: "pre",
  name: "tokens/css-var",
  transform(token, dictionary) {
    const { prefix, formatCssVar } = dictionary;
    const { negative, originalPath } = token.extensions;
    const path = negative ? originalPath : token.path;
    return {
      cssVar: formatCssVar(path.filter(Boolean), prefix)
    };
  }
};
var addConditionalCssVariables = {
  enforce: "post",
  type: "value",
  name: "tokens/conditionals",
  transform(token, dictionary) {
    const { prefix, formatCssVar } = dictionary;
    const refs = getReferences(token.value);
    if (!refs.length) return token.value;
    refs.forEach((ref2) => {
      const variable = formatCssVar(ref2.split("."), prefix);
      token.value = token.value.replace(`{${variable.ref}}`, variable);
    });
    return token.value;
  }
};
var addColorPalette = {
  type: "extensions",
  enforce: "pre",
  name: "tokens/colors/colorPalette",
  match(token) {
    return token.extensions.category === "colors" && !token.extensions.virtual;
  },
  transform(token, dict) {
    let path = token.path.slice();
    path.pop();
    path.shift();
    if (path.length === 0) {
      const newPath = [...token.path];
      newPath.shift();
      path = newPath;
    }
    if (path.length === 0) {
      return {};
    }
    const roots = path.reduce((acc, _, i, arr) => {
      const next2 = arr.slice(0, i + 1);
      acc.push(next2);
      return acc;
    }, []);
    const root = path[0];
    const value = dict.formatTokenName(path);
    const keys = token.path.slice(token.path.indexOf(root) + 1).reduce((acc, _, i, arr) => {
      acc.push(arr.slice(i));
      return acc;
    }, []);
    if (keys.length === 0) {
      keys.push([""]);
    }
    return {
      colorPalette: { value, roots, keys }
    };
  }
};
var tokenTransforms = [
  addCssVariables,
  addConditionalCssVariables,
  addColorPalette
];

// node_modules/@chakra-ui/react/dist/esm/styled-system/token-dictionary.js
var isToken = (value) => {
  return isObject(value) && Object.prototype.hasOwnProperty.call(value, "value");
};
function expandBreakpoints(breakpoints2) {
  if (!breakpoints2) return { breakpoints: {}, sizes: {} };
  return {
    breakpoints: mapObject(breakpoints2, (value) => ({ value })),
    sizes: Object.fromEntries(
      Object.entries(breakpoints2).map(([key, value]) => [
        `breakpoint-${key}`,
        { value }
      ])
    )
  };
}
function createTokenDictionary(options) {
  const {
    prefix = "",
    tokens = {},
    semanticTokens = {},
    breakpoints: breakpoints2 = {}
  } = options;
  const formatTokenName = (path) => path.join(".");
  const formatCssVar = (path, prefix2) => cssVar(path.join("-"), { prefix: prefix2 });
  const allTokens = [];
  const tokenNameMap = /* @__PURE__ */ new Map();
  const conditionMap = /* @__PURE__ */ new Map();
  const cssVarMap = /* @__PURE__ */ new Map();
  const colorPaletteMap = /* @__PURE__ */ new Map();
  const flatMap2 = /* @__PURE__ */ new Map();
  const byCategory = /* @__PURE__ */ new Map();
  const categoryMap = /* @__PURE__ */ new Map();
  const transforms = /* @__PURE__ */ new Map();
  const middlewares = [];
  function registerToken(token, phase) {
    allTokens.push(token);
    tokenNameMap.set(token.name, token);
    if (phase) {
      transforms.forEach((fn) => {
        if (fn.enforce === phase) transformToken(fn, token);
      });
    }
  }
  const breakpointTokens = expandBreakpoints(breakpoints2);
  const computedTokens = compact({
    ...tokens,
    breakpoints: breakpointTokens.breakpoints,
    sizes: {
      ...tokens.sizes,
      ...breakpointTokens.sizes
    }
  });
  function registerTokens() {
    walkObject(
      computedTokens,
      (entry, path) => {
        const isDefault = path.includes("DEFAULT");
        path = filterDefault(path);
        const category = path[0];
        const name = formatTokenName(path);
        const t = isString(entry) ? { value: entry } : entry;
        const token = {
          value: t.value,
          originalValue: t.value,
          name,
          path,
          extensions: {
            condition: "base",
            originalPath: path,
            category,
            prop: formatTokenName(path.slice(1))
          }
        };
        if (isDefault) {
          token.extensions.default = true;
        }
        registerToken(token);
      },
      { stop: isToken }
    );
    walkObject(
      semanticTokens,
      (entry, path) => {
        const isDefault = path.includes("DEFAULT");
        path = filterBaseCondition(filterDefault(path));
        const category = path[0];
        const name = formatTokenName(path);
        const t = isString(entry.value) ? { value: { base: entry.value } } : entry;
        const token = {
          value: t.value.base || "",
          originalValue: t.value.base || "",
          name,
          path,
          extensions: {
            originalPath: path,
            category,
            conditions: t.value,
            condition: "base",
            prop: formatTokenName(path.slice(1))
          }
        };
        if (isDefault) {
          token.extensions.default = true;
        }
        registerToken(token);
      },
      { stop: isToken }
    );
  }
  function getByName(name) {
    return tokenNameMap.get(name);
  }
  function buildConditionMap(token) {
    const { condition } = token.extensions;
    if (!condition) return;
    if (!conditionMap.has(condition)) {
      conditionMap.set(condition, /* @__PURE__ */ new Set());
    }
    conditionMap.get(condition).add(token);
  }
  function buildCategoryMap(token) {
    const { category, prop } = token.extensions;
    if (!category) return;
    if (!categoryMap.has(category)) {
      categoryMap.set(category, /* @__PURE__ */ new Map());
    }
    categoryMap.get(category).set(prop, token);
  }
  function buildCssVars(token) {
    const { condition, negative, virtual, cssVar: cssVar2 } = token.extensions;
    if (negative || virtual || !condition || !cssVar2) return;
    if (!cssVarMap.has(condition)) {
      cssVarMap.set(condition, /* @__PURE__ */ new Map());
    }
    cssVarMap.get(condition).set(cssVar2.var, token.value);
  }
  function buildFlatMap(token) {
    const { category, prop, cssVar: cssVar2, negative } = token.extensions;
    if (!category) return;
    if (!byCategory.has(category)) {
      byCategory.set(category, /* @__PURE__ */ new Map());
    }
    const value = negative ? token.extensions.conditions ? token.originalValue : token.value : cssVar2.ref;
    byCategory.get(category).set(prop, value);
    flatMap2.set([category, prop].join("."), value);
  }
  function buildColorPalette(token) {
    const { colorPalette, virtual, default: isDefault } = token.extensions;
    if (!colorPalette || virtual) return;
    colorPalette.roots.forEach((root) => {
      var _a8;
      const name = formatTokenName(root);
      if (!colorPaletteMap.has(name)) {
        colorPaletteMap.set(name, /* @__PURE__ */ new Map());
      }
      const virtualPath = replaceRootWithColorPalette(
        [...token.path],
        [...root]
      );
      const virtualName = formatTokenName(virtualPath);
      const virtualToken = getByName(virtualName);
      if (!virtualToken || !virtualToken.extensions.cssVar) return;
      const { var: virtualVar } = virtualToken.extensions.cssVar;
      colorPaletteMap.get(name).set(virtualVar, token.extensions.cssVar.ref);
      if (isDefault && root.length === 1) {
        const colorPaletteName = formatTokenName(["colors", "colorPalette"]);
        const colorPaletteToken = getByName(colorPaletteName);
        if (!colorPaletteToken) return;
        const name2 = formatTokenName(token.path);
        const virtualToken2 = getByName(name2);
        if (!virtualToken2) return;
        const keyPath = (_a8 = colorPalette.keys[0]) == null ? void 0 : _a8.filter(Boolean);
        if (!keyPath.length) return;
        const computedName = formatTokenName(root.concat(keyPath));
        if (!colorPaletteMap.has(computedName)) {
          colorPaletteMap.set(computedName, /* @__PURE__ */ new Map());
        }
        colorPaletteMap.get(computedName).set(
          colorPaletteToken.extensions.cssVar.var,
          virtualToken2.extensions.cssVar.ref
        );
      }
    });
  }
  let byCategoryJson = {};
  function setupViews() {
    allTokens.forEach((token) => {
      buildConditionMap(token);
      buildCategoryMap(token);
      buildCssVars(token);
      buildFlatMap(token);
      buildColorPalette(token);
    });
    byCategoryJson = mapToJson(byCategory);
  }
  const colorMix2 = (value, tokenFn) => {
    var _a8;
    if (!value || typeof value !== "string") return { invalid: true, value };
    const [colorPath, rawOpacity] = value.split("/");
    if (!colorPath || !rawOpacity) {
      return { invalid: true, value: colorPath };
    }
    const colorToken = tokenFn(colorPath);
    const opacityToken = (_a8 = getByName(`opacity.${rawOpacity}`)) == null ? void 0 : _a8.value;
    if (!opacityToken && isNaN(Number(rawOpacity))) {
      return { invalid: true, value: colorPath };
    }
    const percent = opacityToken ? Number(opacityToken) * 100 + "%" : `${rawOpacity}%`;
    const color = colorToken ?? colorPath;
    return {
      invalid: false,
      color,
      value: `color-mix(in srgb, ${color} ${percent}, transparent)`
    };
  };
  const getVar = memo2((value, fallback4) => {
    return flatMap2.get(value) ?? fallback4;
  });
  const getCategoryValues = memo2((category) => {
    return byCategoryJson[category] || null;
  });
  const expandReferenceInValue = memo2((value) => {
    return expandTokenReferences(value, (path) => {
      if (!path) return;
      if (path.includes("/")) {
        const mix = colorMix2(path, (v) => getVar(v));
        if (mix.invalid) {
          throw new Error("Invalid color mix at " + path + ": " + mix.value);
        }
        return mix.value;
      }
      const resolved = getVar(path);
      if (resolved) return resolved;
      return TOKEN_PATH_REGEX.test(path) ? esc2(path) : path;
    });
  });
  const dictionary = {
    prefix,
    allTokens,
    tokenMap: tokenNameMap,
    registerToken,
    getByName,
    formatTokenName,
    formatCssVar,
    flatMap: flatMap2,
    cssVarMap,
    categoryMap,
    colorPaletteMap,
    getVar,
    getCategoryValues,
    expandReferenceInValue
  };
  function registerTransform(...fns) {
    fns.forEach((fn) => {
      transforms.set(fn.name, fn);
    });
  }
  function registerMiddleware(...fns) {
    middlewares.push(...fns);
  }
  function transformToken(transform, token) {
    if (token.extensions.references) return;
    if (isFunction(transform.match) && !transform.match(token)) return;
    const fn = (v) => transform.transform(v, dictionary);
    const transformed = fn(token);
    switch (true) {
      case transform.type === "extensions":
        Object.assign(token.extensions, transformed);
        break;
      case transform.type === "value":
        token.value = transformed;
        break;
      default:
        token[transform.type] = transformed;
        break;
    }
  }
  function applyMiddlewares(enforce) {
    middlewares.forEach((middleware) => {
      if (middleware.enforce === enforce) {
        middleware.transform(dictionary);
      }
    });
  }
  function applyTransforms(enforce) {
    transforms.forEach((transform) => {
      if (transform.enforce === enforce) {
        allTokens.forEach((token) => {
          transformToken(transform, token);
        });
      }
    });
  }
  function addConditionalTokens() {
    allTokens.forEach((token) => {
      const tokens2 = getConditionalTokens(token);
      if (!tokens2 || tokens2.length === 0) return;
      tokens2.forEach((token2) => {
        registerToken(token2);
      });
    });
  }
  function getTokenReferences(value) {
    const refs = getReferences(value);
    return refs.map((ref2) => getByName(ref2)).filter(Boolean);
  }
  function addReferences() {
    allTokens.forEach((token) => {
      if (!hasReference(token.value)) return;
      const references = getTokenReferences(token.value);
      token.extensions.references = references.reduce((acc, ref2) => {
        acc[ref2.name] = ref2;
        return acc;
      }, {});
    });
  }
  function expandTokenReferences$1() {
    allTokens.forEach((token) => {
      expandReferences(token);
    });
  }
  function build2() {
    applyMiddlewares("pre");
    applyTransforms("pre");
    addConditionalTokens();
    addReferences();
    expandTokenReferences$1();
    applyMiddlewares("post");
    applyTransforms("post");
    setupViews();
  }
  registerTokens();
  registerTransform(...tokenTransforms);
  registerMiddleware(...tokenMiddlewares);
  build2();
  return dictionary;
}
function filterDefault(path) {
  if (path[0] === "DEFAULT") return path;
  return path.filter((item) => item !== "DEFAULT");
}
function filterBaseCondition(path) {
  return path.filter((item) => item !== "base");
}
function getConditionalTokens(token) {
  if (!token.extensions.conditions) return;
  const { conditions } = token.extensions;
  const tokens = [];
  walkObject(conditions, (value, path) => {
    const nextPath = filterBaseCondition(path);
    if (!nextPath.length) return;
    const nextToken = structuredClone(token);
    nextToken.value = value;
    nextToken.extensions.condition = nextPath.join(":");
    tokens.push(nextToken);
  });
  return tokens;
}
function replaceRootWithColorPalette(path, roots) {
  const startIndex = path.findIndex(
    (_, index) => roots.every(
      (rootElement, rootIndex) => path[index + rootIndex] === rootElement
    )
  );
  if (startIndex === -1) {
    return path;
  }
  path.splice(startIndex, roots.length);
  path.splice(startIndex, 0, "colorPalette");
  return path;
}
var tokenCategories = createProps()([
  "aspectRatios",
  "zIndex",
  "opacity",
  "colors",
  "fonts",
  "fontSizes",
  "fontWeights",
  "lineHeights",
  "letterSpacings",
  "sizes",
  "shadows",
  "spacing",
  "radii",
  "cursor",
  "borders",
  "borderWidths",
  "borderStyles",
  "durations",
  "easings",
  "animations",
  "blurs",
  "gradients",
  "breakpoints",
  "assets"
]);

// node_modules/@chakra-ui/react/dist/esm/styled-system/utility.js
function normalize(config) {
  return config;
}
function normalizeConfig(config) {
  return Object.fromEntries(
    Object.entries(config).map(([property, propertyConfig]) => {
      return [property, normalize(propertyConfig)];
    })
  );
}
function createUtility(options) {
  const configs = normalizeConfig(options.config);
  const tokens = options.tokens;
  const shorthands = /* @__PURE__ */ new Map();
  const propValues = /* @__PURE__ */ new Map();
  function register(property, config) {
    configs[property] = normalize(config);
    assignProperty(property, config);
  }
  const assignProperty = (property, config) => {
    const values = getPropertyValues(config);
    if (!values) return;
    propValues.set(property, values);
    assignPropertyType(property, config);
  };
  const assignProperties = () => {
    for (const [prop, config] of Object.entries(configs)) {
      if (!config) continue;
      assignProperty(prop, config);
    }
  };
  const assignShorthands = () => {
    for (const [property, config] of Object.entries(configs)) {
      const { shorthand } = config ?? {};
      if (!shorthand) continue;
      const values = Array.isArray(shorthand) ? shorthand : [shorthand];
      values.forEach((name) => shorthands.set(name, property));
    }
  };
  const assignColorPaletteProperty = () => {
    const values = mapToJson(tokens.colorPaletteMap);
    register("colorPalette", {
      values: Object.keys(values),
      transform: memo2((value) => values[value])
    });
  };
  const propTypes = /* @__PURE__ */ new Map();
  const assignPropertyType = (property, config) => {
    if (!config) return;
    const values = getPropertyValues(config, (key) => `type:Tokens["${key}"]`);
    if (typeof values === "object" && values.type) {
      propTypes.set(property, /* @__PURE__ */ new Set([`type:${values.type}`]));
      return;
    }
    if (values) {
      const keys2 = new Set(Object.keys(values));
      propTypes.set(property, keys2);
    }
    const set19 = propTypes.get(property) ?? /* @__PURE__ */ new Set();
    if (config.property) {
      propTypes.set(property, set19.add(`CssProperties["${config.property}"]`));
    }
  };
  const assignPropertyTypes = () => {
    for (const [property, propertyConfig] of Object.entries(configs)) {
      if (!propertyConfig) continue;
      assignPropertyType(property, propertyConfig);
    }
  };
  const addPropertyType = (property, type) => {
    const set19 = propTypes.get(property) ?? /* @__PURE__ */ new Set();
    propTypes.set(property, /* @__PURE__ */ new Set([...set19, ...type]));
  };
  const getTypes = () => {
    const map2 = /* @__PURE__ */ new Map();
    for (const [prop, values] of propTypes.entries()) {
      if (values.size === 0) {
        map2.set(prop, ["string"]);
        continue;
      }
      const typeValues = Array.from(values).map((key) => {
        if (key.startsWith("CssProperties")) return key;
        if (key.startsWith("type:")) return key.replace("type:", "");
        return JSON.stringify(key);
      });
      map2.set(prop, typeValues);
    }
    return map2;
  };
  const getPropertyValues = (config, resolveFn) => {
    const { values } = config;
    const fn = (key) => {
      const value = resolveFn == null ? void 0 : resolveFn(key);
      return value ? { [value]: value } : void 0;
    };
    if (isString(values)) {
      return (fn == null ? void 0 : fn(values)) ?? tokens.getCategoryValues(values) ?? {};
    }
    if (Array.isArray(values)) {
      return values.reduce((result, value) => {
        result[value] = value;
        return result;
      }, {});
    }
    if (isFunction(values)) {
      return values(resolveFn ? fn : tokens.getCategoryValues);
    }
    return values;
  };
  const defaultTransform = (prop, value) => {
    return {
      [prop]: prop.startsWith("--") ? tokens.getVar(value, value) : value
    };
  };
  const tokenFn = Object.assign(tokens.getVar, {
    raw: (path) => tokens.getByName(path)
  });
  const transform = (prop, raw) => {
    var _a8;
    const key = resolveShorthand(prop);
    if (isString(raw) && !raw.includes("_EMO_")) {
      raw = tokens.expandReferenceInValue(raw);
    }
    const config = configs[key];
    if (!config) {
      return defaultTransform(key, raw);
    }
    const value = (_a8 = propValues.get(key)) == null ? void 0 : _a8[raw];
    if (!config.transform) {
      return defaultTransform(prop, value ?? raw);
    }
    const _colorMix = (value2) => colorMix(value2, tokenFn);
    return config.transform(value ?? raw, {
      raw,
      token: tokenFn,
      utils: { colorMix: _colorMix }
    });
  };
  function build2() {
    assignShorthands();
    assignColorPaletteProperty();
    assignProperties();
    assignPropertyTypes();
  }
  build2();
  const hasShorthand = shorthands.size > 0;
  const resolveShorthand = (prop) => {
    return shorthands.get(prop) ?? prop;
  };
  const keys = () => {
    return [...Array.from(shorthands.keys()), ...Object.keys(configs)];
  };
  const instance = {
    keys,
    hasShorthand,
    transform,
    shorthands,
    resolveShorthand,
    register,
    getTypes,
    addPropertyType
  };
  return instance;
}

// node_modules/@chakra-ui/react/dist/esm/styled-system/system.js
function createSystem(...configs) {
  const config = mergeConfigs(...configs);
  const {
    theme = {},
    utilities = {},
    globalCss: globalCss2 = {},
    cssVarsRoot = ":where(:root, :host)",
    cssVarsPrefix = "chakra",
    preflight
  } = config;
  const layers = createLayers(config);
  const tokens = createTokenDictionary({
    breakpoints: theme.breakpoints,
    tokens: theme.tokens,
    semanticTokens: theme.semanticTokens,
    prefix: cssVarsPrefix
  });
  const breakpoints2 = createBreakpoints(theme.breakpoints ?? {});
  const conditions = createConditions({
    conditions: config.conditions ?? {},
    breakpoints: breakpoints2
  });
  const utility = createUtility({
    config: utilities,
    tokens
  });
  function assignComposition() {
    const { textStyles: textStyles2, layerStyles: layerStyles2, animationStyles: animationStyles2 } = theme;
    const compositions = compact({
      textStyle: textStyles2,
      layerStyle: layerStyles2,
      animationStyle: animationStyles2
    });
    for (const [key, values] of Object.entries(compositions)) {
      const flatValues = flatten(
        values ?? {},
        (v) => isObject(v) && "value" in v
      );
      utility.register(key, {
        values: Object.keys(flatValues),
        transform(value) {
          return css2(flatValues[value]);
        }
      });
    }
  }
  assignComposition();
  utility.addPropertyType("animationName", Object.keys(theme.keyframes ?? {}));
  const properties2 = /* @__PURE__ */ new Set(["css", ...utility.keys(), ...conditions.keys()]);
  const isValidProperty = memo2(
    (prop) => properties2.has(prop) || isCssProperty(prop)
  );
  const normalizeValue2 = (value) => {
    if (Array.isArray(value)) {
      return value.reduce((acc, current, index) => {
        const key = conditions.breakpoints[index];
        if (current != null) acc[key] = current;
        return acc;
      }, {});
    }
    return value;
  };
  const normalizeFn = createNormalizeFn({
    utility,
    normalize: normalizeValue2
  });
  const serialize2 = createSerializeFn({
    conditions,
    isValidProperty
  });
  const css2 = createCssFn({
    transform: utility.transform,
    conditions,
    normalize: normalizeFn
  });
  const cva = createRecipeFn({
    css: css2,
    conditions,
    normalize: normalizeFn,
    layers
  });
  const sva = createSlotRecipeFn({ cva });
  function getTokenCss() {
    const result = {};
    for (const [key, values] of tokens.cssVarMap.entries()) {
      const varsObj = Object.fromEntries(values);
      if (Object.keys(varsObj).length === 0) continue;
      const selector = key === "base" ? cssVarsRoot : conditions.resolve(key);
      const cssObject = css2(serialize2({ [selector]: varsObj }));
      mergeWith(result, cssObject);
    }
    return layers.wrap("tokens", result);
  }
  function getGlobalCss() {
    const keyframes2 = Object.fromEntries(
      Object.entries(theme.keyframes ?? {}).map(([key, value]) => [
        `@keyframes ${key}`,
        value
      ])
    );
    const result = Object.assign({}, keyframes2, css2(serialize2(globalCss2)));
    return layers.wrap("base", result);
  }
  function splitCssProps(props21) {
    return splitProps(props21, isValidProperty);
  }
  function getPreflightCss() {
    const result = createPreflight({ preflight });
    return layers.wrap("reset", result);
  }
  const tokenMap = getTokenMap(tokens);
  const tokenFn = (path, fallback4) => {
    var _a8;
    return ((_a8 = tokenMap.get(path)) == null ? void 0 : _a8.value) || fallback4;
  };
  tokenFn.var = (path, fallback4) => {
    var _a8;
    return ((_a8 = tokenMap.get(path)) == null ? void 0 : _a8.variable) || fallback4;
  };
  function getRecipe(key, fallback4) {
    var _a8;
    return ((_a8 = theme.recipes) == null ? void 0 : _a8[key]) ?? fallback4;
  }
  function getSlotRecipe(key, fallback4) {
    var _a8;
    return ((_a8 = theme.slotRecipes) == null ? void 0 : _a8[key]) ?? fallback4;
  }
  function isRecipe(key) {
    return Object.hasOwnProperty.call(theme.recipes ?? {}, key);
  }
  function isSlotRecipe(key) {
    return Object.hasOwnProperty.call(theme.slotRecipes ?? {}, key);
  }
  function hasRecipe(key) {
    return isRecipe(key) || isSlotRecipe(key);
  }
  const _global = [getPreflightCss(), getGlobalCss(), getTokenCss()];
  return {
    $$chakra: true,
    _config: config,
    _global,
    breakpoints: breakpoints2,
    tokens,
    conditions,
    utility,
    token: tokenFn,
    properties: properties2,
    layers,
    isValidProperty,
    splitCssProps,
    normalizeValue: normalizeValue2,
    getTokenCss,
    getGlobalCss,
    getPreflightCss,
    css: css2,
    cva,
    sva,
    getRecipe,
    getSlotRecipe,
    hasRecipe,
    isRecipe,
    isSlotRecipe
  };
}
function getTokenMap(tokens) {
  const map2 = /* @__PURE__ */ new Map();
  tokens.allTokens.forEach((token) => {
    const { cssVar: cssVar2, virtual, conditions } = token.extensions;
    const value = !!conditions || virtual ? cssVar2.ref : token.value;
    map2.set(token.name, { value, variable: cssVar2.ref });
  });
  return map2;
}
var isValidSystem = (mod2) => {
  return isObject(mod2) && !!Reflect.get(mod2, "$$chakra");
};

// node_modules/@chakra-ui/react/dist/esm/theme/breakpoints.js
var breakpoints = {
  sm: "480px",
  md: "768px",
  lg: "1024px",
  xl: "1280px",
  "2xl": "1536px"
};

// node_modules/@chakra-ui/react/dist/esm/theme/global-css.js
var empty = "var(--chakra-empty,/*!*/ /*!*/)";
var globalCss = defineGlobalStyles({
  "*": {
    fontFeatureSettings: '"cv11"',
    "--ring-inset": empty,
    "--ring-offset-width": "0px",
    "--ring-offset-color": "#fff",
    "--ring-color": "rgba(66, 153, 225, 0.6)",
    "--ring-offset-shadow": "0 0 #0000",
    "--ring-shadow": "0 0 #0000",
    ...Object.fromEntries(
      [
        "brightness",
        "contrast",
        "grayscale",
        "hue-rotate",
        "invert",
        "saturate",
        "sepia",
        "drop-shadow"
      ].map((prop) => [`--${prop}`, empty])
    ),
    ...Object.fromEntries(
      [
        "blur",
        "brightness",
        "contrast",
        "grayscale",
        "hue-rotate",
        "invert",
        "opacity",
        "saturate",
        "sepia"
      ].map((prop) => [`--backdrop-${prop}`, empty])
    ),
    "--global-font-mono": "fonts.mono",
    "--global-font-body": "fonts.body",
    "--global-color-border": "colors.border"
  },
  html: {
    color: "fg",
    bg: "bg",
    lineHeight: "1.5",
    colorPalette: "gray"
  },
  "*::placeholder": {
    color: "fg.muted/80"
  },
  "*::selection": {
    bg: "colorPalette.muted/80"
  }
});

// node_modules/@chakra-ui/react/dist/esm/theme/layer-styles.js
var layerStyles = defineLayerStyles({
  // fill: some background color + color combination
  "fill.muted": {
    value: {
      background: "colorPalette.muted",
      color: "colorPalette.fg"
    }
  },
  "fill.subtle": {
    value: {
      background: "colorPalette.subtle",
      color: "colorPalette.fg"
    }
  },
  "fill.surface": {
    value: {
      background: "colorPalette.subtle",
      color: "colorPalette.fg",
      boxShadow: "0 0 0px 1px var(--shadow-color)",
      boxShadowColor: "colorPalette.muted"
    }
  },
  "fill.solid": {
    value: {
      background: "colorPalette.solid",
      color: "colorPalette.contrast"
    }
  },
  // outline: some border color + color combination
  "outline.subtle": {
    value: {
      color: "colorPalette.fg",
      boxShadow: "inset 0 0 0px 1px var(--shadow-color)",
      boxShadowColor: "colorPalette.subtle"
    }
  },
  "outline.solid": {
    value: {
      borderWidth: "1px",
      borderColor: "colorPalette.solid",
      color: "colorPalette.fg"
    }
  },
  // indicator: floating border color or left/bottom border
  "indicator.bottom": {
    value: {
      position: "relative",
      "--indicator-color-fallback": "colors.colorPalette.solid",
      _before: {
        content: `""`,
        position: "absolute",
        bottom: "var(--indicator-offset-y, 0)",
        insetInline: "var(--indicator-offset-x, 0)",
        height: "var(--indicator-thickness, 2px)",
        background: "var(--indicator-color, var(--indicator-color-fallback))"
      }
    }
  },
  "indicator.top": {
    value: {
      position: "relative",
      "--indicator-color-fallback": "colors.colorPalette.solid",
      _before: {
        content: `""`,
        position: "absolute",
        top: "var(--indicator-offset-y, 0)",
        insetInline: "var(--indicator-offset-x, 0)",
        height: "var(--indicator-thickness, 2px)",
        background: "var(--indicator-color, var(--indicator-color-fallback))"
      }
    }
  },
  "indicator.start": {
    value: {
      position: "relative",
      "--indicator-color-fallback": "colors.colorPalette.solid",
      _before: {
        content: `""`,
        position: "absolute",
        insetInlineStart: "var(--indicator-offset-x, 0)",
        insetBlock: "var(--indicator-offset-y, 0)",
        width: "var(--indicator-thickness, 2px)",
        background: "var(--indicator-color, var(--indicator-color-fallback))"
      }
    }
  },
  "indicator.end": {
    value: {
      position: "relative",
      "--indicator-color-fallback": "colors.colorPalette.solid",
      _before: {
        content: `""`,
        position: "absolute",
        insetInlineEnd: "var(--indicator-offset-x, 0)",
        insetBlock: "var(--indicator-offset-y, 0)",
        width: "var(--indicator-thickness, 2px)",
        background: "var(--indicator-color, var(--indicator-color-fallback))"
      }
    }
  },
  disabled: {
    value: {
      opacity: "0.5",
      cursor: "not-allowed"
    }
  },
  none: {
    value: {}
  }
});

// node_modules/@chakra-ui/react/dist/esm/theme/motion-styles.js
var animationStyles = defineAnimationStyles({
  "slide-fade-in": {
    value: {
      transformOrigin: "var(--transform-origin)",
      "&[data-placement^=top]": {
        animationName: "slide-from-bottom, fade-in"
      },
      "&[data-placement^=bottom]": {
        animationName: "slide-from-top, fade-in"
      },
      "&[data-placement^=left]": {
        animationName: "slide-from-right, fade-in"
      },
      "&[data-placement^=right]": {
        animationName: "slide-from-left, fade-in"
      }
    }
  },
  "slide-fade-out": {
    value: {
      transformOrigin: "var(--transform-origin)",
      "&[data-placement^=top]": {
        animationName: "slide-to-bottom, fade-out"
      },
      "&[data-placement^=bottom]": {
        animationName: "slide-to-top, fade-out"
      },
      "&[data-placement^=left]": {
        animationName: "slide-to-right, fade-out"
      },
      "&[data-placement^=right]": {
        animationName: "slide-to-left, fade-out"
      }
    }
  },
  "scale-fade-in": {
    value: {
      transformOrigin: "var(--transform-origin)",
      animationName: "scale-in, fade-in"
    }
  },
  "scale-fade-out": {
    value: {
      transformOrigin: "var(--transform-origin)",
      animationName: "scale-out, fade-out"
    }
  }
});

// node_modules/@chakra-ui/react/dist/esm/theme/recipes/badge.js
var badgeRecipe = defineRecipe({
  className: "chakra-badge",
  base: {
    display: "inline-flex",
    alignItems: "center",
    borderRadius: "l2",
    gap: "1",
    fontWeight: "medium",
    fontVariantNumeric: "tabular-nums",
    whiteSpace: "nowrap",
    userSelect: "none"
  },
  variants: {
    variant: {
      solid: {
        bg: "colorPalette.solid",
        color: "colorPalette.contrast"
      },
      subtle: {
        bg: "colorPalette.subtle",
        color: "colorPalette.fg"
      },
      outline: {
        color: "colorPalette.fg",
        shadow: "inset 0 0 0px 1px var(--shadow-color)",
        shadowColor: "colorPalette.muted"
      },
      surface: {
        bg: "colorPalette.subtle",
        color: "colorPalette.fg",
        shadow: "inset 0 0 0px 1px var(--shadow-color)",
        shadowColor: "colorPalette.muted"
      },
      plain: {
        color: "colorPalette.fg"
      }
    },
    size: {
      xs: {
        textStyle: "2xs",
        px: "1",
        minH: "4"
      },
      sm: {
        textStyle: "xs",
        px: "1.5",
        minH: "5"
      },
      md: {
        textStyle: "sm",
        px: "2",
        minH: "6"
      },
      lg: {
        textStyle: "sm",
        px: "2.5",
        minH: "7"
      }
    }
  },
  defaultVariants: {
    variant: "subtle",
    size: "sm"
  }
});

// node_modules/@chakra-ui/react/dist/esm/theme/recipes/button.js
var buttonRecipe = defineRecipe({
  className: "chakra-button",
  base: {
    display: "inline-flex",
    appearance: "none",
    alignItems: "center",
    justifyContent: "center",
    userSelect: "none",
    position: "relative",
    borderRadius: "l2",
    whiteSpace: "nowrap",
    verticalAlign: "middle",
    borderWidth: "1px",
    borderColor: "transparent",
    cursor: "button",
    flexShrink: "0",
    outline: "0",
    lineHeight: "1.2",
    isolation: "isolate",
    fontWeight: "medium",
    transitionProperty: "common",
    transitionDuration: "moderate",
    focusVisibleRing: "outside",
    _disabled: {
      layerStyle: "disabled"
    },
    _icon: {
      flexShrink: "0"
    }
  },
  variants: {
    size: {
      "2xs": {
        h: "6",
        minW: "6",
        textStyle: "xs",
        px: "2",
        gap: "1",
        _icon: {
          width: "3.5",
          height: "3.5"
        }
      },
      xs: {
        h: "8",
        minW: "8",
        textStyle: "xs",
        px: "2.5",
        gap: "1",
        _icon: {
          width: "4",
          height: "4"
        }
      },
      sm: {
        h: "9",
        minW: "9",
        px: "3.5",
        textStyle: "sm",
        gap: "2",
        _icon: {
          width: "4",
          height: "4"
        }
      },
      md: {
        h: "10",
        minW: "10",
        textStyle: "sm",
        px: "4",
        gap: "2",
        _icon: {
          width: "5",
          height: "5"
        }
      },
      lg: {
        h: "11",
        minW: "11",
        textStyle: "md",
        px: "5",
        gap: "3",
        _icon: {
          width: "5",
          height: "5"
        }
      },
      xl: {
        h: "12",
        minW: "12",
        textStyle: "md",
        px: "5",
        gap: "2.5",
        _icon: {
          width: "5",
          height: "5"
        }
      },
      "2xl": {
        h: "16",
        minW: "16",
        textStyle: "lg",
        px: "7",
        gap: "3",
        _icon: {
          width: "6",
          height: "6"
        }
      }
    },
    variant: {
      solid: {
        bg: "colorPalette.solid",
        color: "colorPalette.contrast",
        _hover: {
          bg: "colorPalette.solid/90"
        },
        _expanded: {
          bg: "colorPalette.solid/90"
        }
      },
      subtle: {
        bg: "colorPalette.subtle",
        color: "colorPalette.fg",
        _hover: {
          bg: "colorPalette.muted"
        },
        _expanded: {
          bg: "colorPalette.muted"
        }
      },
      surface: {
        bg: "colorPalette.subtle",
        color: "colorPalette.fg",
        shadow: "0 0 0px 1px var(--shadow-color)",
        shadowColor: "colorPalette.muted",
        _hover: {
          bg: "colorPalette.muted"
        },
        _expanded: {
          bg: "colorPalette.muted"
        }
      },
      outline: {
        borderWidth: "1px",
        borderColor: "colorPalette.muted",
        color: "colorPalette.fg",
        _hover: {
          bg: "colorPalette.subtle"
        },
        _expanded: {
          bg: "colorPalette.subtle"
        }
      },
      ghost: {
        color: "colorPalette.fg",
        _hover: {
          bg: "colorPalette.subtle"
        },
        _expanded: {
          bg: "colorPalette.subtle"
        }
      },
      plain: {
        color: "colorPalette.fg"
      }
    }
  },
  defaultVariants: {
    size: "md",
    variant: "solid"
  }
});

// node_modules/@chakra-ui/react/dist/esm/theme/recipes/checkmark.js
var checkmarkRecipe = defineRecipe({
  className: "chakra-checkmark",
  base: {
    display: "inline-flex",
    alignItems: "center",
    justifyContent: "center",
    flexShrink: "0",
    color: "white",
    borderWidth: "1px",
    borderColor: "transparent",
    borderRadius: "l1",
    focusVisibleRing: "outside",
    _icon: {
      boxSize: "full"
    },
    _invalid: {
      colorPalette: "red",
      borderColor: "border.error"
    },
    _disabled: {
      opacity: "0.5"
    }
  },
  variants: {
    size: {
      xs: {
        boxSize: "3"
      },
      sm: {
        boxSize: "4"
      },
      md: {
        boxSize: "5",
        p: "0.5"
      },
      lg: {
        boxSize: "6",
        p: "0.5"
      }
    },
    variant: {
      solid: {
        borderColor: "border",
        "&:is([data-state=checked], [data-state=indeterminate])": {
          bg: "colorPalette.solid",
          color: "colorPalette.contrast",
          borderColor: "colorPalette.solid"
        }
      },
      outline: {
        borderColor: "border",
        "&:is([data-state=checked], [data-state=indeterminate])": {
          color: "colorPalette.fg",
          borderColor: "colorPalette.solid"
        }
      },
      subtle: {
        bg: "colorPalette.muted",
        borderColor: "colorPalette.muted",
        "&:is([data-state=checked], [data-state=indeterminate])": {
          color: "colorPalette.fg"
        }
      },
      plain: {
        "&:is([data-state=checked], [data-state=indeterminate])": {
          color: "colorPalette.fg"
        }
      },
      inverted: {
        borderColor: "border",
        color: "colorPalette.fg",
        "&:is([data-state=checked], [data-state=indeterminate])": {
          borderColor: "colorPalette.solid"
        }
      }
    }
  },
  defaultVariants: {
    variant: "solid",
    size: "md"
  }
});

// node_modules/@chakra-ui/react/dist/esm/theme/recipes/code.js
var { variants, defaultVariants } = badgeRecipe;
var codeRecipe = defineRecipe({
  className: "chakra-code",
  base: {
    fontFamily: "mono",
    alignItems: "center",
    display: "inline-flex",
    borderRadius: "l2"
  },
  variants,
  defaultVariants
});

// node_modules/@chakra-ui/react/dist/esm/theme/recipes/color-swatch.js
var colorSwatchRecipe = defineRecipe({
  className: "color-swatch",
  base: {
    boxSize: "var(--swatch-size)",
    shadow: "inset 0 0 0 1px rgba(0, 0, 0, 0.1)",
    "--checker-size": "8px",
    "--checker-bg": "colors.bg",
    "--checker-fg": "colors.bg.emphasized",
    background: "linear-gradient(var(--color), var(--color)), repeating-conic-gradient(var(--checker-fg) 0%, var(--checker-fg) 25%, var(--checker-bg) 0%, var(--checker-bg) 50%) 0% 50% / var(--checker-size) var(--checker-size) !important",
    display: "inline-flex",
    alignItems: "center",
    justifyContent: "center",
    flexShrink: "0"
  },
  variants: {
    size: {
      "2xs": { "--swatch-size": "sizes.3.5" },
      xs: { "--swatch-size": "sizes.4" },
      sm: { "--swatch-size": "sizes.4.5" },
      md: { "--swatch-size": "sizes.5" },
      lg: { "--swatch-size": "sizes.6" },
      xl: { "--swatch-size": "sizes.7" },
      "2xl": { "--swatch-size": "sizes.8" },
      inherit: { "--swatch-size": "inherit" },
      full: { "--swatch-size": "100%" }
    },
    shape: {
      square: { borderRadius: "none" },
      circle: { borderRadius: "full" },
      rounded: { borderRadius: "l1" }
    }
  },
  defaultVariants: {
    size: "md",
    shape: "rounded"
  }
});

// node_modules/@chakra-ui/react/dist/esm/theme/recipes/container.js
var containerRecipe = defineRecipe({
  className: "chakra-container",
  base: {
    position: "relative",
    maxWidth: "8xl",
    w: "100%",
    mx: "auto",
    px: { base: "4", md: "6", lg: "8" }
  },
  variants: {
    centerContent: {
      true: {
        display: "flex",
        flexDirection: "column",
        alignItems: "center"
      }
    },
    fluid: {
      true: {
        maxWidth: "full"
      }
    }
  }
});

// node_modules/@chakra-ui/react/dist/esm/theme/recipes/heading.js
var headingRecipe = defineRecipe({
  className: "chakra-heading",
  base: {
    fontFamily: "heading",
    fontWeight: "semibold"
  },
  variants: {
    size: {
      xs: { textStyle: "xs" },
      sm: { textStyle: "sm" },
      md: { textStyle: "md" },
      lg: { textStyle: "lg" },
      xl: { textStyle: "xl" },
      "2xl": { textStyle: "2xl" },
      "3xl": { textStyle: "3xl" },
      "4xl": { textStyle: "4xl" },
      "5xl": { textStyle: "5xl" },
      "6xl": { textStyle: "6xl" },
      "7xl": { textStyle: "7xl" }
    }
  },
  defaultVariants: {
    size: "xl"
  }
});

// node_modules/@chakra-ui/react/dist/esm/theme/recipes/icon.js
var iconRecipe = defineRecipe({
  className: "chakra-icon",
  base: {
    display: "inline-block",
    lineHeight: "1em",
    flexShrink: "0",
    color: "currentcolor",
    verticalAlign: "middle"
  },
  variants: {
    size: {
      inherit: {},
      xs: { boxSize: "3" },
      sm: { boxSize: "4" },
      md: { boxSize: "5" },
      lg: { boxSize: "6" },
      xl: { boxSize: "7" },
      "2xl": { boxSize: "8" }
    }
  },
  defaultVariants: {
    size: "inherit"
  }
});

// node_modules/@chakra-ui/react/dist/esm/theme/recipes/input.js
var inputRecipe = defineRecipe({
  className: "chakra-input",
  base: {
    width: "100%",
    minWidth: "0",
    outline: "0",
    position: "relative",
    appearance: "none",
    textAlign: "start",
    borderRadius: "l2",
    _disabled: {
      layerStyle: "disabled"
    },
    height: "var(--input-height)",
    minW: "var(--input-height)",
    "--focus-color": "colors.colorPalette.focusRing",
    "--error-color": "colors.border.error",
    _invalid: {
      focusRingColor: "var(--error-color)",
      borderColor: "var(--error-color)"
    }
  },
  variants: {
    size: {
      "2xs": {
        textStyle: "xs",
        px: "2",
        "--input-height": "sizes.7"
      },
      xs: {
        textStyle: "xs",
        px: "2",
        "--input-height": "sizes.8"
      },
      sm: {
        textStyle: "sm",
        px: "2.5",
        "--input-height": "sizes.9"
      },
      md: {
        textStyle: "sm",
        px: "3",
        "--input-height": "sizes.10"
      },
      lg: {
        textStyle: "md",
        px: "4",
        "--input-height": "sizes.11"
      },
      xl: {
        textStyle: "md",
        px: "4.5",
        "--input-height": "sizes.12"
      },
      "2xl": {
        textStyle: "lg",
        px: "5",
        "--input-height": "sizes.16"
      }
    },
    variant: {
      outline: {
        bg: "transparent",
        borderWidth: "1px",
        borderColor: "border",
        focusVisibleRing: "inside"
      },
      subtle: {
        borderWidth: "1px",
        borderColor: "transparent",
        bg: "bg.muted",
        focusVisibleRing: "inside"
      },
      flushed: {
        bg: "transparent",
        borderBottomWidth: "1px",
        borderBottomColor: "border",
        borderRadius: "0",
        px: "0",
        _focusVisible: {
          borderColor: "var(--focus-color)",
          boxShadow: "0px 1px 0px 0px var(--focus-color)"
        }
      }
    }
  },
  defaultVariants: {
    size: "md",
    variant: "outline"
  }
});

// node_modules/@chakra-ui/react/dist/esm/theme/recipes/input-addon.js
var inputAddonRecipe = defineRecipe({
  className: "chakra-input-addon",
  base: {
    flex: "0 0 auto",
    width: "auto",
    display: "flex",
    alignItems: "center",
    whiteSpace: "nowrap",
    alignSelf: "stretch",
    borderRadius: "l2"
  },
  variants: {
    size: inputRecipe.variants.size,
    variant: {
      outline: {
        borderWidth: "1px",
        borderColor: "border",
        bg: "bg.muted"
      },
      subtle: {
        borderWidth: "1px",
        borderColor: "transparent",
        bg: "bg.emphasized"
      },
      flushed: {
        borderBottom: "1px solid",
        borderColor: "inherit",
        borderRadius: "0",
        px: "0",
        bg: "transparent"
      }
    }
  },
  defaultVariants: {
    size: "md",
    variant: "outline"
  }
});

// node_modules/@chakra-ui/react/dist/esm/theme/recipes/kbd.js
var kbdRecipe = defineRecipe({
  className: "chakra-kbd",
  base: {
    display: "inline-flex",
    alignItems: "center",
    fontWeight: "medium",
    fontFamily: "mono",
    flexShrink: "0",
    whiteSpace: "nowrap",
    wordSpacing: "-0.5em",
    userSelect: "none",
    px: "1",
    borderRadius: "l2"
  },
  variants: {
    variant: {
      raised: {
        bg: "colorPalette.subtle",
        color: "colorPalette.fg",
        borderWidth: "1px",
        borderBottomWidth: "2px",
        borderColor: "colorPalette.muted"
      },
      outline: {
        borderWidth: "1px",
        color: "colorPalette.fg"
      },
      subtle: {
        bg: "colorPalette.muted",
        color: "colorPalette.fg"
      },
      plain: {
        color: "colorPalette.fg"
      }
    },
    size: {
      sm: {
        textStyle: "xs",
        height: "4.5"
      },
      md: {
        textStyle: "sm",
        height: "5"
      },
      lg: {
        textStyle: "md",
        height: "6"
      }
    }
  },
  defaultVariants: {
    size: "md",
    variant: "raised"
  }
});

// node_modules/@chakra-ui/react/dist/esm/theme/recipes/link.js
var linkRecipe = defineRecipe({
  className: "chakra-link",
  base: {
    display: "inline-flex",
    alignItems: "center",
    outline: "none",
    gap: "1.5",
    cursor: "pointer",
    borderRadius: "l1",
    focusRing: "outside"
  },
  variants: {
    variant: {
      underline: {
        color: "colorPalette.fg",
        textDecoration: "underline",
        textUnderlineOffset: "3px",
        textDecorationColor: "currentColor/20"
      },
      plain: {
        color: "colorPalette.fg",
        _hover: {
          textDecoration: "underline",
          textUnderlineOffset: "3px",
          textDecorationColor: "currentColor/20"
        }
      }
    }
  },
  defaultVariants: {
    variant: "plain"
  }
});

// node_modules/@chakra-ui/react/dist/esm/theme/recipes/mark.js
var markRecipe = defineRecipe({
  className: "chakra-mark",
  base: {
    bg: "transparent",
    color: "inherit",
    whiteSpace: "nowrap"
  },
  variants: {
    variant: {
      subtle: {
        bg: "colorPalette.subtle",
        color: "inherit"
      },
      solid: {
        bg: "colorPalette.solid",
        color: "colorPalette.contrast"
      },
      text: {
        fontWeight: "medium"
      },
      plain: {}
    }
  }
});

// node_modules/@chakra-ui/react/dist/esm/theme/recipes/radiomark.js
var radiomarkRecipe = defineRecipe({
  className: "chakra-radiomark",
  base: {
    display: "inline-flex",
    alignItems: "center",
    justifyContent: "center",
    flexShrink: 0,
    verticalAlign: "top",
    color: "white",
    borderWidth: "1px",
    borderColor: "transparent",
    borderRadius: "full",
    cursor: "radio",
    _focusVisible: {
      outline: "2px solid",
      outlineColor: "colorPalette.focusRing",
      outlineOffset: "2px"
    },
    _invalid: {
      colorPalette: "red",
      borderColor: "red.500"
    },
    _disabled: {
      opacity: "0.5",
      cursor: "disabled"
    },
    "& .dot": {
      height: "100%",
      width: "100%",
      borderRadius: "full",
      bg: "currentColor",
      scale: "0.4"
    }
  },
  variants: {
    variant: {
      solid: {
        borderWidth: "1px",
        borderColor: "border",
        _checked: {
          bg: "colorPalette.solid",
          color: "colorPalette.contrast",
          borderColor: "colorPalette.solid"
        }
      },
      subtle: {
        borderWidth: "1px",
        bg: "colorPalette.muted",
        borderColor: "colorPalette.muted",
        color: "transparent",
        _checked: {
          color: "colorPalette.fg"
        }
      },
      outline: {
        borderWidth: "1px",
        borderColor: "inherit",
        _checked: {
          color: "colorPalette.fg",
          borderColor: "colorPalette.solid"
        },
        "& .dot": {
          scale: "0.6"
        }
      },
      inverted: {
        bg: "bg",
        borderWidth: "1px",
        borderColor: "inherit",
        _checked: {
          color: "colorPalette.solid",
          borderColor: "currentcolor"
        }
      }
    },
    size: {
      xs: {
        boxSize: "3"
      },
      sm: {
        boxSize: "4"
      },
      md: {
        boxSize: "5"
      },
      lg: {
        boxSize: "6"
      }
    }
  },
  defaultVariants: {
    variant: "solid",
    size: "md"
  }
});

// node_modules/@chakra-ui/react/dist/esm/theme/recipes/separator.js
var separatorRecipe = defineRecipe({
  className: "chakra-separator",
  base: {
    display: "block",
    borderColor: "border"
  },
  variants: {
    variant: {
      solid: {
        borderStyle: "solid"
      },
      dashed: {
        borderStyle: "dashed"
      },
      dotted: {
        borderStyle: "dotted"
      }
    },
    orientation: {
      vertical: {
        borderInlineStartWidth: "var(--separator-thickness)"
      },
      horizontal: {
        borderTopWidth: "var(--separator-thickness)"
      }
    },
    size: {
      xs: {
        "--separator-thickness": "0.5px"
      },
      sm: {
        "--separator-thickness": "1px"
      },
      md: {
        "--separator-thickness": "2px"
      },
      lg: {
        "--separator-thickness": "3px"
      }
    }
  },
  defaultVariants: {
    size: "sm",
    variant: "solid",
    orientation: "horizontal"
  }
});

// node_modules/@chakra-ui/react/dist/esm/theme/recipes/skeleton.js
var skeletonRecipe = defineRecipe({
  className: "chakra-skeleton",
  base: {},
  variants: {
    loading: {
      true: {
        borderRadius: "l2",
        boxShadow: "none",
        backgroundClip: "padding-box",
        cursor: "default",
        color: "transparent",
        pointerEvents: "none",
        userSelect: "none",
        flexShrink: "0",
        "&::before, &::after, *": {
          visibility: "hidden"
        }
      },
      false: {
        background: "unset",
        animation: "fade-in var(--fade-duration, 0.1s) ease-out !important"
      }
    },
    variant: {
      pulse: {
        background: "bg.emphasized",
        animation: "pulse",
        animationDuration: "var(--duration, 1.2s)"
      },
      shine: {
        "--animate-from": "200%",
        "--animate-to": "-200%",
        "--start-color": "colors.bg.muted",
        "--end-color": "colors.bg.emphasized",
        backgroundImage: "linear-gradient(270deg,var(--start-color),var(--end-color),var(--end-color),var(--start-color))",
        backgroundSize: "400% 100%",
        animation: "bg-position var(--duration, 5s) ease-in-out infinite"
      },
      none: {
        animation: "none"
      }
    }
  },
  defaultVariants: {
    variant: "pulse",
    loading: true
  }
});

// node_modules/@chakra-ui/react/dist/esm/theme/recipes/skip-nav-link.js
var skipNavLinkRecipe = defineRecipe({
  className: "chakra-skip-nav",
  base: {
    display: "inline-flex",
    bg: "bg.panel",
    padding: "2.5",
    borderRadius: "l2",
    fontWeight: "semibold",
    focusVisibleRing: "outside",
    textStyle: "sm",
    // visually hidden
    userSelect: "none",
    border: "0",
    height: "1px",
    width: "1px",
    margin: "-1px",
    outline: "0",
    overflow: "hidden",
    position: "absolute",
    clip: "rect(0 0 0 0)",
    _focusVisible: {
      clip: "auto",
      width: "auto",
      height: "auto",
      position: "fixed",
      top: "6",
      insetStart: "6"
    }
  }
});

// node_modules/@chakra-ui/react/dist/esm/theme/recipes/spinner.js
var spinnerRecipe = defineRecipe({
  className: "chakra-spinner",
  base: {
    display: "inline-block",
    borderColor: "currentColor",
    borderStyle: "solid",
    borderWidth: "2px",
    borderRadius: "full",
    width: "var(--spinner-size)",
    height: "var(--spinner-size)",
    animation: "spin",
    animationDuration: "slowest",
    "--spinner-track-color": "transparent",
    borderBottomColor: "var(--spinner-track-color)",
    borderInlineStartColor: "var(--spinner-track-color)"
  },
  variants: {
    size: {
      inherit: { "--spinner-size": "1em" },
      xs: { "--spinner-size": "sizes.3" },
      sm: { "--spinner-size": "sizes.4" },
      md: { "--spinner-size": "sizes.5" },
      lg: { "--spinner-size": "sizes.8" },
      xl: { "--spinner-size": "sizes.10" }
    }
  },
  defaultVariants: {
    size: "md"
  }
});

// node_modules/@chakra-ui/react/dist/esm/theme/recipes/textarea.js
var textareaRecipe = defineRecipe({
  className: "chakra-textarea",
  base: {
    width: "100%",
    minWidth: "0",
    outline: "0",
    position: "relative",
    appearance: "none",
    textAlign: "start",
    borderRadius: "l2",
    _disabled: {
      layerStyle: "disabled"
    },
    "--focus-color": "colors.colorPalette.focusRing",
    "--error-color": "colors.border.error",
    _invalid: {
      focusRingColor: "var(--error-color)",
      borderColor: "var(--error-color)"
    }
  },
  variants: {
    size: {
      xs: {
        textStyle: "xs",
        px: "2",
        py: "1.5",
        scrollPaddingBottom: "1.5"
      },
      sm: {
        textStyle: "sm",
        px: "2.5",
        py: "2",
        scrollPaddingBottom: "2"
      },
      md: {
        textStyle: "sm",
        px: "3",
        py: "2",
        scrollPaddingBottom: "2"
      },
      lg: {
        textStyle: "md",
        px: "4",
        py: "3",
        scrollPaddingBottom: "3"
      },
      xl: {
        textStyle: "md",
        px: "4.5",
        py: "3.5",
        scrollPaddingBottom: "3.5"
      }
    },
    variant: {
      outline: {
        bg: "transparent",
        borderWidth: "1px",
        borderColor: "border",
        focusVisibleRing: "inside"
      },
      subtle: {
        borderWidth: "1px",
        borderColor: "transparent",
        bg: "bg.muted",
        focusVisibleRing: "inside"
      },
      flushed: {
        bg: "transparent",
        borderBottomWidth: "1px",
        borderBottomColor: "border",
        borderRadius: "0",
        px: "0",
        _focusVisible: {
          borderColor: "var(--focus-color)",
          boxShadow: "0px 1px 0px 0px var(--focus-color)"
        }
      }
    }
  },
  defaultVariants: {
    size: "md",
    variant: "outline"
  }
});

// node_modules/@chakra-ui/react/dist/esm/theme/recipes.js
var recipes = {
  badge: badgeRecipe,
  button: buttonRecipe,
  code: codeRecipe,
  container: containerRecipe,
  heading: headingRecipe,
  input: inputRecipe,
  inputAddon: inputAddonRecipe,
  kbd: kbdRecipe,
  link: linkRecipe,
  mark: markRecipe,
  separator: separatorRecipe,
  skeleton: skeletonRecipe,
  skipNavLink: skipNavLinkRecipe,
  spinner: spinnerRecipe,
  textarea: textareaRecipe,
  icon: iconRecipe,
  checkmark: checkmarkRecipe,
  radiomark: radiomarkRecipe,
  colorSwatch: colorSwatchRecipe
};

// node_modules/@chakra-ui/react/dist/esm/theme/semantic-tokens/colors.js
var semanticColors = defineSemanticTokens.colors({
  bg: {
    DEFAULT: {
      value: { _light: "{colors.white}", _dark: "{colors.black}" }
    },
    subtle: {
      value: { _light: "{colors.gray.50}", _dark: "{colors.gray.950}" }
    },
    muted: {
      value: { _light: "{colors.gray.100}", _dark: "{colors.gray.900}" }
    },
    emphasized: {
      value: { _light: "{colors.gray.200}", _dark: "{colors.gray.800}" }
    },
    inverted: {
      value: { _light: "{colors.black}", _dark: "{colors.white}" }
    },
    panel: {
      value: { _light: "{colors.white}", _dark: "{colors.gray.950}" }
    },
    error: {
      value: { _light: "{colors.red.50}", _dark: "{colors.red.950}" }
    },
    warning: {
      value: { _light: "{colors.orange.50}", _dark: "{colors.orange.950}" }
    },
    success: {
      value: { _light: "{colors.green.50}", _dark: "{colors.green.950}" }
    },
    info: {
      value: { _light: "{colors.blue.50}", _dark: "{colors.blue.950}" }
    }
  },
  fg: {
    DEFAULT: {
      value: { _light: "{colors.black}", _dark: "{colors.gray.50}" }
    },
    muted: {
      value: { _light: "{colors.gray.600}", _dark: "{colors.gray.400}" }
    },
    subtle: {
      value: { _light: "{colors.gray.400}", _dark: "{colors.gray.500}" }
    },
    inverted: {
      value: { _light: "{colors.gray.50}", _dark: "{colors.black}" }
    },
    error: {
      value: { _light: "{colors.red.500}", _dark: "{colors.red.400}" }
    },
    warning: {
      value: { _light: "{colors.orange.600}", _dark: "{colors.orange.300}" }
    },
    success: {
      value: { _light: "{colors.green.600}", _dark: "{colors.green.300}" }
    },
    info: {
      value: { _light: "{colors.blue.600}", _dark: "{colors.blue.300}" }
    }
  },
  border: {
    DEFAULT: {
      value: { _light: "{colors.gray.200}", _dark: "{colors.gray.800}" }
    },
    muted: {
      value: { _light: "{colors.gray.100}", _dark: "{colors.gray.900}" }
    },
    subtle: {
      value: { _light: "{colors.gray.50}", _dark: "{colors.gray.950}" }
    },
    emphasized: {
      value: { _light: "{colors.gray.300}", _dark: "{colors.gray.700}" }
    },
    inverted: {
      value: { _light: "{colors.gray.800}", _dark: "{colors.gray.200}" }
    },
    error: {
      value: { _light: "{colors.red.500}", _dark: "{colors.red.400}" }
    },
    warning: {
      value: { _light: "{colors.orange.500}", _dark: "{colors.orange.400}" }
    },
    success: {
      value: { _light: "{colors.green.500}", _dark: "{colors.green.400}" }
    },
    info: {
      value: { _light: "{colors.blue.500}", _dark: "{colors.blue.400}" }
    }
  },
  gray: {
    contrast: {
      value: { _light: "{colors.white}", _dark: "{colors.black}" }
    },
    fg: {
      value: { _light: "{colors.gray.800}", _dark: "{colors.gray.200}" }
    },
    subtle: {
      value: { _light: "{colors.gray.100}", _dark: "{colors.gray.900}" }
    },
    muted: {
      value: { _light: "{colors.gray.200}", _dark: "{colors.gray.800}" }
    },
    emphasized: {
      value: { _light: "{colors.gray.300}", _dark: "{colors.gray.700}" }
    },
    solid: {
      value: { _light: "{colors.gray.900}", _dark: "{colors.white}" }
    },
    focusRing: {
      value: { _light: "{colors.gray.800}", _dark: "{colors.gray.200}" }
    }
  },
  red: {
    contrast: {
      value: { _light: "white", _dark: "white" }
    },
    fg: {
      value: { _light: "{colors.red.700}", _dark: "{colors.red.300}" }
    },
    subtle: {
      value: { _light: "{colors.red.100}", _dark: "{colors.red.900}" }
    },
    muted: {
      value: { _light: "{colors.red.200}", _dark: "{colors.red.800}" }
    },
    emphasized: {
      value: { _light: "{colors.red.300}", _dark: "{colors.red.700}" }
    },
    solid: {
      value: { _light: "{colors.red.600}", _dark: "{colors.red.600}" }
    },
    focusRing: {
      value: { _light: "{colors.red.600}", _dark: "{colors.red.600}" }
    }
  },
  orange: {
    contrast: {
      value: { _light: "white", _dark: "black" }
    },
    fg: {
      value: { _light: "{colors.orange.700}", _dark: "{colors.orange.300}" }
    },
    subtle: {
      value: { _light: "{colors.orange.100}", _dark: "{colors.orange.900}" }
    },
    muted: {
      value: { _light: "{colors.orange.200}", _dark: "{colors.orange.800}" }
    },
    emphasized: {
      value: { _light: "{colors.orange.300}", _dark: "{colors.orange.700}" }
    },
    solid: {
      value: { _light: "{colors.orange.600}", _dark: "{colors.orange.500}" }
    },
    focusRing: {
      value: { _light: "{colors.orange.600}", _dark: "{colors.orange.500}" }
    }
  },
  green: {
    contrast: {
      value: { _light: "white", _dark: "white" }
    },
    fg: {
      value: { _light: "{colors.green.700}", _dark: "{colors.green.300}" }
    },
    subtle: {
      value: { _light: "{colors.green.100}", _dark: "{colors.green.900}" }
    },
    muted: {
      value: { _light: "{colors.green.200}", _dark: "{colors.green.800}" }
    },
    emphasized: {
      value: { _light: "{colors.green.300}", _dark: "{colors.green.700}" }
    },
    solid: {
      value: { _light: "{colors.green.600}", _dark: "{colors.green.600}" }
    },
    focusRing: {
      value: { _light: "{colors.green.600}", _dark: "{colors.green.600}" }
    }
  },
  blue: {
    contrast: {
      value: { _light: "white", _dark: "white" }
    },
    fg: {
      value: { _light: "{colors.blue.700}", _dark: "{colors.blue.300}" }
    },
    subtle: {
      value: { _light: "{colors.blue.100}", _dark: "{colors.blue.900}" }
    },
    muted: {
      value: { _light: "{colors.blue.200}", _dark: "{colors.blue.800}" }
    },
    emphasized: {
      value: { _light: "{colors.blue.300}", _dark: "{colors.blue.700}" }
    },
    solid: {
      value: { _light: "{colors.blue.600}", _dark: "{colors.blue.600}" }
    },
    focusRing: {
      value: { _light: "{colors.blue.600}", _dark: "{colors.blue.600}" }
    }
  },
  yellow: {
    contrast: {
      value: { _light: "black", _dark: "black" }
    },
    fg: {
      value: { _light: "{colors.yellow.800}", _dark: "{colors.yellow.300}" }
    },
    subtle: {
      value: { _light: "{colors.yellow.100}", _dark: "{colors.yellow.900}" }
    },
    muted: {
      value: { _light: "{colors.yellow.200}", _dark: "{colors.yellow.800}" }
    },
    emphasized: {
      value: { _light: "{colors.yellow.300}", _dark: "{colors.yellow.700}" }
    },
    solid: {
      value: { _light: "{colors.yellow.300}", _dark: "{colors.yellow.300}" }
    },
    focusRing: {
      value: { _light: "{colors.yellow.300}", _dark: "{colors.yellow.300}" }
    }
  },
  teal: {
    contrast: {
      value: { _light: "white", _dark: "white" }
    },
    fg: {
      value: { _light: "{colors.teal.700}", _dark: "{colors.teal.300}" }
    },
    subtle: {
      value: { _light: "{colors.teal.100}", _dark: "{colors.teal.900}" }
    },
    muted: {
      value: { _light: "{colors.teal.200}", _dark: "{colors.teal.800}" }
    },
    emphasized: {
      value: { _light: "{colors.teal.300}", _dark: "{colors.teal.700}" }
    },
    solid: {
      value: { _light: "{colors.teal.600}", _dark: "{colors.teal.600}" }
    },
    focusRing: {
      value: { _light: "{colors.teal.600}", _dark: "{colors.teal.600}" }
    }
  },
  purple: {
    contrast: {
      value: { _light: "white", _dark: "white" }
    },
    fg: {
      value: { _light: "{colors.purple.700}", _dark: "{colors.purple.300}" }
    },
    subtle: {
      value: { _light: "{colors.purple.100}", _dark: "{colors.purple.900}" }
    },
    muted: {
      value: { _light: "{colors.purple.200}", _dark: "{colors.purple.800}" }
    },
    emphasized: {
      value: { _light: "{colors.purple.300}", _dark: "{colors.purple.700}" }
    },
    solid: {
      value: { _light: "{colors.purple.600}", _dark: "{colors.purple.600}" }
    },
    focusRing: {
      value: { _light: "{colors.purple.600}", _dark: "{colors.purple.600}" }
    }
  },
  pink: {
    contrast: {
      value: { _light: "white", _dark: "white" }
    },
    fg: {
      value: { _light: "{colors.pink.700}", _dark: "{colors.pink.300}" }
    },
    subtle: {
      value: { _light: "{colors.pink.100}", _dark: "{colors.pink.900}" }
    },
    muted: {
      value: { _light: "{colors.pink.200}", _dark: "{colors.pink.800}" }
    },
    emphasized: {
      value: { _light: "{colors.pink.300}", _dark: "{colors.pink.700}" }
    },
    solid: {
      value: { _light: "{colors.pink.600}", _dark: "{colors.pink.600}" }
    },
    focusRing: {
      value: { _light: "{colors.pink.600}", _dark: "{colors.pink.600}" }
    }
  },
  cyan: {
    contrast: {
      value: { _light: "white", _dark: "white" }
    },
    fg: {
      value: { _light: "{colors.cyan.700}", _dark: "{colors.cyan.300}" }
    },
    subtle: {
      value: { _light: "{colors.cyan.100}", _dark: "{colors.cyan.900}" }
    },
    muted: {
      value: { _light: "{colors.cyan.200}", _dark: "{colors.cyan.800}" }
    },
    emphasized: {
      value: { _light: "{colors.cyan.300}", _dark: "{colors.cyan.700}" }
    },
    solid: {
      value: { _light: "{colors.cyan.600}", _dark: "{colors.cyan.600}" }
    },
    focusRing: {
      value: { _light: "{colors.cyan.600}", _dark: "{colors.cyan.600}" }
    }
  }
});

// node_modules/@chakra-ui/react/dist/esm/theme/semantic-tokens/radii.js
var semanticRadii = defineSemanticTokens.radii({
  l1: { value: "{radii.xs}" },
  l2: { value: "{radii.sm}" },
  l3: { value: "{radii.md}" }
});

// node_modules/@chakra-ui/react/dist/esm/theme/semantic-tokens/shadows.js
var semanticShadows = defineSemanticTokens.shadows({
  xs: {
    value: {
      _light: "0px 1px 2px {colors.gray.900/10}, 0px 0px 1px {colors.gray.900/20}",
      _dark: "0px 1px 1px {black/64}, 0px 0px 1px inset {colors.gray.300/20}"
    }
  },
  sm: {
    value: {
      _light: "0px 2px 4px {colors.gray.900/10}, 0px 0px 1px {colors.gray.900/30}",
      _dark: "0px 2px 4px {black/64}, 0px 0px 1px inset {colors.gray.300/30}"
    }
  },
  md: {
    value: {
      _light: "0px 4px 8px {colors.gray.900/10}, 0px 0px 1px {colors.gray.900/30}",
      _dark: "0px 4px 8px {black/64}, 0px 0px 1px inset {colors.gray.300/30}"
    }
  },
  lg: {
    value: {
      _light: "0px 8px 16px {colors.gray.900/10}, 0px 0px 1px {colors.gray.900/30}",
      _dark: "0px 8px 16px {black/64}, 0px 0px 1px inset {colors.gray.300/30}"
    }
  },
  xl: {
    value: {
      _light: "0px 16px 24px {colors.gray.900/10}, 0px 0px 1px {colors.gray.900/30}",
      _dark: "0px 16px 24px {black/64}, 0px 0px 1px inset {colors.gray.300/30}"
    }
  },
  "2xl": {
    value: {
      _light: "0px 24px 40px {colors.gray.900/16}, 0px 0px 1px {colors.gray.900/30}",
      _dark: "0px 24px 40px {black/64}, 0px 0px 1px inset {colors.gray.300/30}"
    }
  },
  inner: {
    value: {
      _light: "inset 0 2px 4px 0 {black/5}",
      _dark: "inset 0 2px 4px 0 black"
    }
  },
  inset: {
    value: {
      _light: "inset 0 0 0 1px {black/5}",
      _dark: "inset 0 0 0 1px {colors.gray.300/5}"
    }
  }
});

// node_modules/@ark-ui/react/dist/utils/create-context.js
var import_react = __toESM(require_react(), 1);
function getErrorMessage(hook, provider) {
  return `${hook} returned \`undefined\`. Seems you forgot to wrap component within ${provider}`;
}
function createContext(options = {}) {
  const {
    name,
    strict = true,
    hookName = "useContext",
    providerName = "Provider",
    errorMessage,
    defaultValue
  } = options;
  const Context = (0, import_react.createContext)(defaultValue);
  Context.displayName = name;
  function useContext$1() {
    var _a8;
    const context = (0, import_react.useContext)(Context);
    if (!context && strict) {
      const error = new Error(errorMessage ?? getErrorMessage(hookName, providerName));
      error.name = "ContextError";
      (_a8 = Error.captureStackTrace) == null ? void 0 : _a8.call(Error, error, useContext$1);
      throw error;
    }
    return context;
  }
  return [Context.Provider, useContext$1, Context];
}

// node_modules/@ark-ui/react/dist/components/accordion/use-accordion-context.js
var [AccordionProvider, useAccordionContext] = createContext({
  name: "AccordionContext",
  hookName: "useAccordionContext",
  providerName: "<AccordionProvider />"
});

// node_modules/@ark-ui/react/dist/components/accordion/accordion-context.js
var AccordionContext = (props21) => props21.children(useAccordionContext());

// node_modules/@ark-ui/react/dist/components/accordion/accordion-item.js
var import_jsx_runtime3 = __toESM(require_jsx_runtime(), 1);

// node_modules/@zag-js/anatomy/dist/index.mjs
var createAnatomy = (name, parts26 = []) => ({
  parts: (...values) => {
    if (isEmpty(parts26)) {
      return createAnatomy(name, values);
    }
    throw new Error("createAnatomy().parts(...) should only be called once. Did you mean to use .extendWith(...) ?");
  },
  extendWith: (...values) => createAnatomy(name, [...parts26, ...values]),
  rename: (newName) => createAnatomy(newName, parts26),
  keys: () => parts26,
  build: () => [...new Set(parts26)].reduce(
    (prev2, part) => Object.assign(prev2, {
      [part]: {
        selector: [
          `&[data-scope="${toKebabCase(name)}"][data-part="${toKebabCase(part)}"]`,
          `& [data-scope="${toKebabCase(name)}"][data-part="${toKebabCase(part)}"]`
        ].join(", "),
        attrs: { "data-scope": toKebabCase(name), "data-part": toKebabCase(part) }
      }
    }),
    {}
  )
});
var toKebabCase = (value) => value.replace(/([A-Z])([A-Z])/g, "$1-$2").replace(/([a-z])([A-Z])/g, "$1-$2").replace(/[\s_]+/g, "-").toLowerCase();
var isEmpty = (v) => v.length === 0;

// node_modules/@zag-js/dom-query/dist/index.mjs
var clamp = (value) => Math.max(0, Math.min(1, value));
var wrap2 = (v, idx) => {
  return v.map((_, index) => v[(Math.max(idx, 0) + index) % v.length]);
};
var pipe = (...fns) => (arg) => fns.reduce((acc, fn) => fn(acc), arg);
var noop = () => void 0;
var isObject2 = (v) => typeof v === "object" && v !== null;
var MAX_Z_INDEX = 2147483647;
var dataAttr = (guard) => guard ? "" : void 0;
var ariaAttr = (guard) => guard ? "true" : void 0;
var ELEMENT_NODE = 1;
var DOCUMENT_NODE = 9;
var DOCUMENT_FRAGMENT_NODE = 11;
var isHTMLElement = (el) => isObject2(el) && el.nodeType === ELEMENT_NODE && typeof el.nodeName === "string";
var isDocument = (el) => isObject2(el) && el.nodeType === DOCUMENT_NODE;
var isWindow = (el) => isObject2(el) && el === el.window;
var getNodeName = (node) => {
  if (isHTMLElement(node)) return node.localName || "";
  return "#document";
};
function isRootElement(node) {
  return ["html", "body", "#document"].includes(getNodeName(node));
}
var isNode = (el) => isObject2(el) && el.nodeType !== void 0;
var isShadowRoot = (el) => isNode(el) && el.nodeType === DOCUMENT_FRAGMENT_NODE && "host" in el;
var isInputElement = (el) => isHTMLElement(el) && el.localName === "input";
var isAnchorElement = (el) => !!(el == null ? void 0 : el.matches("a[href]"));
var isElementVisible = (el) => {
  if (!isHTMLElement(el)) return false;
  return el.offsetWidth > 0 || el.offsetHeight > 0 || el.getClientRects().length > 0;
};
var TEXTAREA_SELECT_REGEX = /(textarea|select)/;
function isEditableElement(el) {
  if (el == null || !isHTMLElement(el)) return false;
  try {
    return isInputElement(el) && el.selectionStart != null || TEXTAREA_SELECT_REGEX.test(el.localName) || el.isContentEditable || el.getAttribute("contenteditable") === "true" || el.getAttribute("contenteditable") === "";
  } catch {
    return false;
  }
}
function contains(parent, child) {
  var _a8;
  if (!parent || !child) return false;
  if (!isHTMLElement(parent) || !isHTMLElement(child)) return false;
  const rootNode = (_a8 = child.getRootNode) == null ? void 0 : _a8.call(child);
  if (parent === child) return true;
  if (parent.contains(child)) return true;
  if (rootNode && isShadowRoot(rootNode)) {
    let next2 = child;
    while (next2) {
      if (parent === next2) return true;
      next2 = next2.parentNode || next2.host;
    }
  }
  return false;
}
function getDocument(el) {
  if (isDocument(el)) return el;
  if (isWindow(el)) return el.document;
  return (el == null ? void 0 : el.ownerDocument) ?? document;
}
function getDocumentElement(el) {
  return getDocument(el).documentElement;
}
function getWindow(el) {
  var _a8;
  if (isShadowRoot(el)) return getWindow(el.host);
  if (isDocument(el)) return el.defaultView ?? window;
  if (isHTMLElement(el)) return ((_a8 = el.ownerDocument) == null ? void 0 : _a8.defaultView) ?? window;
  return window;
}
function getActiveElement(rootNode) {
  let activeElement = rootNode.activeElement;
  while (activeElement == null ? void 0 : activeElement.shadowRoot) {
    const el = activeElement.shadowRoot.activeElement;
    if (el === activeElement) break;
    else activeElement = el;
  }
  return activeElement;
}
function getParentNode(node) {
  if (getNodeName(node) === "html") return node;
  const result = node.assignedSlot || node.parentNode || isShadowRoot(node) && node.host || getDocumentElement(node);
  return isShadowRoot(result) ? result.host : result;
}
var styleCache = /* @__PURE__ */ new WeakMap();
function getComputedStyle(el) {
  if (!styleCache.has(el)) {
    styleCache.set(el, getWindow(el).getComputedStyle(el));
  }
  return styleCache.get(el);
}
function getDataUrl(svg, opts) {
  const { type, quality = 0.92, background } = opts;
  if (!svg) throw new Error("[zag-js > getDataUrl]: Could not find the svg element");
  const win = getWindow(svg);
  const doc = win.document;
  const svgBounds = svg.getBoundingClientRect();
  const svgClone = svg.cloneNode(true);
  if (!svgClone.hasAttribute("viewBox")) {
    svgClone.setAttribute("viewBox", `0 0 ${svgBounds.width} ${svgBounds.height}`);
  }
  const serializer = new win.XMLSerializer();
  const source = '<?xml version="1.0" standalone="no"?>\r\n' + serializer.serializeToString(svgClone);
  const svgString = "data:image/svg+xml;charset=utf-8," + encodeURIComponent(source);
  if (type === "image/svg+xml") {
    return Promise.resolve(svgString).then((str) => {
      svgClone.remove();
      return str;
    });
  }
  const dpr = win.devicePixelRatio || 1;
  const canvas = doc.createElement("canvas");
  const image = new win.Image();
  image.src = svgString;
  canvas.width = svgBounds.width * dpr;
  canvas.height = svgBounds.height * dpr;
  const context = canvas.getContext("2d");
  if (type === "image/jpeg" || background) {
    context.fillStyle = background || "white";
    context.fillRect(0, 0, canvas.width, canvas.height);
  }
  return new Promise((resolve) => {
    image.onload = () => {
      context == null ? void 0 : context.drawImage(image, 0, 0, canvas.width, canvas.height);
      resolve(canvas.toDataURL(type, quality));
      svgClone.remove();
    };
  });
}
var isDom = () => typeof document !== "undefined";
function getPlatform() {
  const agent = navigator.userAgentData;
  return (agent == null ? void 0 : agent.platform) ?? navigator.platform;
}
function getUserAgent() {
  const ua2 = navigator.userAgentData;
  if (ua2 && Array.isArray(ua2.brands)) {
    return ua2.brands.map(({ brand, version }) => `${brand}/${version}`).join(" ");
  }
  return navigator.userAgent;
}
var pt = (v) => isDom() && v.test(getPlatform());
var ua = (v) => isDom() && v.test(getUserAgent());
var vn = (v) => isDom() && v.test(navigator.vendor);
var isMac = () => pt(/^Mac/);
var isSafari = () => isApple() && vn(/apple/i);
var isFirefox = () => ua(/firefox\//i);
var isApple = () => pt(/mac|iphone|ipad|ipod/i);
var isIos = () => pt(/iP(hone|ad|od)|iOS/);
function getBeforeInputValue(event) {
  const { selectionStart, selectionEnd, value } = event.currentTarget;
  return value.slice(0, selectionStart) + event.data + value.slice(selectionEnd);
}
function getComposedPath(event) {
  var _a8, _b7, _c6;
  return ((_a8 = event.composedPath) == null ? void 0 : _a8.call(event)) ?? ((_c6 = (_b7 = event.nativeEvent) == null ? void 0 : _b7.composedPath) == null ? void 0 : _c6.call(_b7));
}
function getEventTarget(event) {
  const composedPath = getComposedPath(event);
  return (composedPath == null ? void 0 : composedPath[0]) ?? event.target;
}
var isSelfTarget = (event) => {
  return contains(event.currentTarget, getEventTarget(event));
};
function isOpeningInNewTab(event) {
  const element = event.currentTarget;
  if (!element) return false;
  const isAppleDevice = isApple();
  if (isAppleDevice && !event.metaKey) return false;
  if (!isAppleDevice && !event.ctrlKey) return false;
  const localName = element.localName;
  if (localName === "a") return true;
  if (localName === "button" && element.type === "submit") return true;
  if (localName === "input" && element.type === "submit") return true;
  return false;
}
function isDownloadingEvent(event) {
  const element = event.currentTarget;
  if (!element) return false;
  const localName = element.localName;
  if (!event.altKey) return false;
  if (localName === "a") return true;
  if (localName === "button" && element.type === "submit") return true;
  if (localName === "input" && element.type === "submit") return true;
  return false;
}
function isComposingEvent(event) {
  return getNativeEvent(event).isComposing;
}
function isPrintableKey(e) {
  return e.key.length === 1 && !e.ctrlKey && !e.metaKey;
}
var isLeftClick = (e) => e.button === 0;
var isContextMenuEvent = (e) => {
  return e.button === 2 || isMac() && e.ctrlKey && e.button === 0;
};
var isModifierKey = (e) => e.ctrlKey || e.altKey || e.metaKey;
var isTouchEvent = (event) => "touches" in event && event.touches.length > 0;
var keyMap = {
  Up: "ArrowUp",
  Down: "ArrowDown",
  Esc: "Escape",
  " ": "Space",
  ",": "Comma",
  Left: "ArrowLeft",
  Right: "ArrowRight"
};
var rtlKeyMap = {
  ArrowLeft: "ArrowRight",
  ArrowRight: "ArrowLeft"
};
function getEventKey(event, options = {}) {
  const { dir = "ltr", orientation = "horizontal" } = options;
  let key = event.key;
  key = keyMap[key] ?? key;
  const isRtl = dir === "rtl" && orientation === "horizontal";
  if (isRtl && key in rtlKeyMap) key = rtlKeyMap[key];
  return key;
}
function getNativeEvent(event) {
  return event.nativeEvent ?? event;
}
var pageKeys = /* @__PURE__ */ new Set(["PageUp", "PageDown"]);
var arrowKeys = /* @__PURE__ */ new Set(["ArrowUp", "ArrowDown", "ArrowLeft", "ArrowRight"]);
function getEventStep(event) {
  if (event.ctrlKey || event.metaKey) {
    return 0.1;
  } else {
    const isPageKey = pageKeys.has(event.key);
    const isSkipKey = isPageKey || event.shiftKey && arrowKeys.has(event.key);
    return isSkipKey ? 10 : 1;
  }
}
function getEventPoint(event, type = "client") {
  const point = isTouchEvent(event) ? event.touches[0] || event.changedTouches[0] : event;
  return { x: point[`${type}X`], y: point[`${type}Y`] };
}
var addDomEvent = (target, eventName, handler, options) => {
  const node = typeof target === "function" ? target() : target;
  node == null ? void 0 : node.addEventListener(eventName, handler, options);
  return () => {
    node == null ? void 0 : node.removeEventListener(eventName, handler, options);
  };
};
function getDescriptor(el, options) {
  const { type = "HTMLInputElement", property = "value" } = options;
  const proto = getWindow(el)[type].prototype;
  return Object.getOwnPropertyDescriptor(proto, property) ?? {};
}
function getElementType(el) {
  if (el.localName === "input") return "HTMLInputElement";
  if (el.localName === "textarea") return "HTMLTextAreaElement";
  if (el.localName === "select") return "HTMLSelectElement";
}
function setElementValue(el, value, property = "value") {
  var _a8;
  const type = getElementType(el);
  if (type) {
    const descriptor = getDescriptor(el, { type, property });
    (_a8 = descriptor.set) == null ? void 0 : _a8.call(el, value);
  }
  el.setAttribute(property, value);
}
function setElementChecked(el, checked) {
  var _a8;
  const descriptor = getDescriptor(el, { type: "HTMLInputElement", property: "checked" });
  (_a8 = descriptor.set) == null ? void 0 : _a8.call(el, checked);
  if (checked) el.setAttribute("checked", "");
  else el.removeAttribute("checked");
}
function dispatchInputValueEvent(el, options) {
  const { value, bubbles = true } = options;
  if (!el) return;
  const win = getWindow(el);
  if (!(el instanceof win.HTMLInputElement)) return;
  setElementValue(el, `${value}`);
  el.dispatchEvent(new win.Event("input", { bubbles }));
}
function dispatchInputCheckedEvent(el, options) {
  const { checked, bubbles = true } = options;
  if (!el) return;
  const win = getWindow(el);
  if (!(el instanceof win.HTMLInputElement)) return;
  setElementChecked(el, checked);
  el.dispatchEvent(new win.Event("click", { bubbles }));
}
function getClosestForm(el) {
  return isFormElement(el) ? el.form : el.closest("form");
}
function isFormElement(el) {
  return el.matches("textarea, input, select, button");
}
function trackFormReset(el, callback) {
  if (!el) return;
  const form = getClosestForm(el);
  const onReset = (e) => {
    if (e.defaultPrevented) return;
    callback();
  };
  form == null ? void 0 : form.addEventListener("reset", onReset, { passive: true });
  return () => form == null ? void 0 : form.removeEventListener("reset", onReset);
}
function trackFieldsetDisabled(el, callback) {
  const fieldset = el == null ? void 0 : el.closest("fieldset");
  if (!fieldset) return;
  callback(fieldset.disabled);
  const win = getWindow(fieldset);
  const obs = new win.MutationObserver(() => callback(fieldset.disabled));
  obs.observe(fieldset, {
    attributes: true,
    attributeFilter: ["disabled"]
  });
  return () => obs.disconnect();
}
function trackFormControl(el, options) {
  if (!el) return;
  const { onFieldsetDisabledChange, onFormReset } = options;
  const cleanups2 = [trackFormReset(el, onFormReset), trackFieldsetDisabled(el, onFieldsetDisabledChange)];
  return () => cleanups2.forEach((cleanup) => cleanup == null ? void 0 : cleanup());
}
var isFrame = (el) => isHTMLElement(el) && el.tagName === "IFRAME";
var hasTabIndex = (el) => !Number.isNaN(parseInt(el.getAttribute("tabindex") || "0", 10));
var hasNegativeTabIndex = (el) => parseInt(el.getAttribute("tabindex") || "0", 10) < 0;
var focusableSelector = "input:not([type='hidden']):not([disabled]), select:not([disabled]), textarea:not([disabled]), a[href], button:not([disabled]), [tabindex], iframe, object, embed, area[href], audio[controls], video[controls], [contenteditable]:not([contenteditable='false']), details > summary:first-of-type";
var getFocusables = (container, includeContainer = false) => {
  if (!container) return [];
  const elements = Array.from(container.querySelectorAll(focusableSelector));
  const include = includeContainer == true || includeContainer == "if-empty" && elements.length === 0;
  if (include && isHTMLElement(container) && isFocusable(container)) {
    elements.unshift(container);
  }
  const focusableElements = elements.filter(isFocusable);
  focusableElements.forEach((element, i) => {
    if (isFrame(element) && element.contentDocument) {
      const frameBody = element.contentDocument.body;
      focusableElements.splice(i, 1, ...getFocusables(frameBody));
    }
  });
  return focusableElements;
};
function isFocusable(element) {
  if (!element || element.closest("[inert]")) return false;
  return element.matches(focusableSelector) && isElementVisible(element);
}
function getTabbables(container, includeContainer) {
  if (!container) return [];
  const elements = Array.from(container.querySelectorAll(focusableSelector));
  const tabbableElements = elements.filter(isTabbable);
  if (includeContainer && isTabbable(container)) {
    tabbableElements.unshift(container);
  }
  tabbableElements.forEach((element, i) => {
    if (isFrame(element) && element.contentDocument) {
      const frameBody = element.contentDocument.body;
      const allFrameTabbable = getTabbables(frameBody);
      tabbableElements.splice(i, 1, ...allFrameTabbable);
    }
  });
  if (!tabbableElements.length && includeContainer) {
    return elements;
  }
  return tabbableElements;
}
function isTabbable(el) {
  if (el != null && el.tabIndex > 0) return true;
  return isFocusable(el) && !hasNegativeTabIndex(el);
}
function getTabbableEdges(container, includeContainer) {
  const elements = getTabbables(container, includeContainer);
  const first2 = elements[0] || null;
  const last2 = elements[elements.length - 1] || null;
  return [first2, last2];
}
function getNextTabbable(container, current) {
  const tabbables = getTabbables(container);
  const doc = (container == null ? void 0 : container.ownerDocument) || document;
  const currentElement = current ?? doc.activeElement;
  if (!currentElement) return null;
  const index = tabbables.indexOf(currentElement);
  return tabbables[index + 1] || null;
}
function getTabIndex(node) {
  if (node.tabIndex < 0) {
    if ((/^(audio|video|details)$/.test(node.localName) || isEditableElement(node)) && !hasTabIndex(node)) {
      return 0;
    }
  }
  return node.tabIndex;
}
function getInitialFocus(options) {
  const { root, getInitialEl, filter, enabled = true } = options;
  if (!enabled) return;
  let node = null;
  node || (node = typeof getInitialEl === "function" ? getInitialEl() : getInitialEl);
  node || (node = root == null ? void 0 : root.querySelector("[data-autofocus],[autofocus]"));
  if (!node) {
    const tabbables = getTabbables(root);
    node = filter ? tabbables.filter(filter)[0] : tabbables[0];
  }
  return node || root || void 0;
}
function isValidTabEvent(event) {
  const container = event.currentTarget;
  if (!container) return false;
  const [firstTabbable, lastTabbable] = getTabbableEdges(container);
  const doc = container.ownerDocument || document;
  if (doc.activeElement === firstTabbable && event.shiftKey) return false;
  if (doc.activeElement === lastTabbable && !event.shiftKey) return false;
  if (!firstTabbable && !lastTabbable) return false;
  return true;
}
function nextTick(fn) {
  const set22 = /* @__PURE__ */ new Set();
  function raf22(fn2) {
    const id = globalThis.requestAnimationFrame(fn2);
    set22.add(() => globalThis.cancelAnimationFrame(id));
  }
  raf22(() => raf22(fn));
  return function cleanup() {
    set22.forEach((fn2) => fn2());
  };
}
function raf(fn) {
  const id = globalThis.requestAnimationFrame(fn);
  return () => {
    globalThis.cancelAnimationFrame(id);
  };
}
function queueBeforeEvent(el, type, cb) {
  const cancelTimer = raf(() => {
    el.removeEventListener(type, exec2, true);
    cb();
  });
  const exec2 = () => {
    cancelTimer();
    cb();
  };
  el.addEventListener(type, exec2, { once: true, capture: true });
  return cancelTimer;
}
function observeAttributesImpl(node, options) {
  if (!node) return;
  const { attributes, callback: fn } = options;
  const win = node.ownerDocument.defaultView || window;
  const obs = new win.MutationObserver((changes) => {
    for (const change of changes) {
      if (change.type === "attributes" && change.attributeName && attributes.includes(change.attributeName)) {
        fn(change);
      }
    }
  });
  obs.observe(node, { attributes: true, attributeFilter: attributes });
  return () => obs.disconnect();
}
function observeAttributes(nodeOrFn, options) {
  const { defer } = options;
  const func = defer ? raf : (v) => v();
  const cleanups2 = [];
  cleanups2.push(
    func(() => {
      const node = typeof nodeOrFn === "function" ? nodeOrFn() : nodeOrFn;
      cleanups2.push(observeAttributesImpl(node, options));
    })
  );
  return () => {
    cleanups2.forEach((fn) => fn == null ? void 0 : fn());
  };
}
function observeChildrenImpl(node, options) {
  const { callback: fn } = options;
  if (!node) return;
  const win = node.ownerDocument.defaultView || window;
  const obs = new win.MutationObserver(fn);
  obs.observe(node, { childList: true, subtree: true });
  return () => obs.disconnect();
}
function observeChildren(nodeOrFn, options) {
  const { defer } = options;
  const func = defer ? raf : (v) => v();
  const cleanups2 = [];
  cleanups2.push(
    func(() => {
      const node = typeof nodeOrFn === "function" ? nodeOrFn() : nodeOrFn;
      cleanups2.push(observeChildrenImpl(node, options));
    })
  );
  return () => {
    cleanups2.forEach((fn) => fn == null ? void 0 : fn());
  };
}
function clickIfLink(el) {
  const click = () => el.click();
  if (isFirefox()) {
    queueBeforeEvent(el, "keyup", click);
  } else {
    queueMicrotask(click);
  }
}
function getNearestOverflowAncestor(el) {
  const parentNode = getParentNode(el);
  if (isRootElement(parentNode)) return getDocument(parentNode).body;
  if (isHTMLElement(parentNode) && isOverflowElement(parentNode)) return parentNode;
  return getNearestOverflowAncestor(parentNode);
}
function getOverflowAncestors(el, list = []) {
  const scrollableAncestor = getNearestOverflowAncestor(el);
  const isBody = scrollableAncestor === el.ownerDocument.body;
  const win = getWindow(scrollableAncestor);
  if (isBody) {
    return list.concat(win, win.visualViewport || [], isOverflowElement(scrollableAncestor) ? scrollableAncestor : []);
  }
  return list.concat(scrollableAncestor, getOverflowAncestors(scrollableAncestor, []));
}
var OVERFLOW_RE = /auto|scroll|overlay|hidden|clip/;
function isOverflowElement(el) {
  const win = getWindow(el);
  const { overflow, overflowX, overflowY, display } = win.getComputedStyle(el);
  return OVERFLOW_RE.test(overflow + overflowY + overflowX) && !["inline", "contents"].includes(display);
}
function isScrollable(el) {
  return el.scrollHeight > el.clientHeight || el.scrollWidth > el.clientWidth;
}
function scrollIntoView(el, options) {
  const { rootEl, ...scrollOptions } = options || {};
  if (!el || !rootEl) return;
  if (!isOverflowElement(rootEl) || !isScrollable(rootEl)) return;
  el.scrollIntoView(scrollOptions);
}
function getRelativePoint(point, element) {
  const { left, top, width, height } = element.getBoundingClientRect();
  const offset3 = { x: point.x - left, y: point.y - top };
  const percent = { x: clamp(offset3.x / width), y: clamp(offset3.y / height) };
  function getPercentValue2(options = {}) {
    const { dir = "ltr", orientation = "horizontal", inverted } = options;
    const invertX = typeof inverted === "object" ? inverted.x : inverted;
    const invertY = typeof inverted === "object" ? inverted.y : inverted;
    if (orientation === "horizontal") {
      return dir === "rtl" || invertX ? 1 - percent.x : percent.x;
    }
    return invertY ? 1 - percent.y : percent.y;
  }
  return { offset: offset3, percent, getPercentValue: getPercentValue2 };
}
function requestPointerLock(doc, fn) {
  const body = doc.body;
  const supported = "pointerLockElement" in doc || "mozPointerLockElement" in doc;
  const isLocked = () => !!doc.pointerLockElement;
  function onPointerChange() {
    fn == null ? void 0 : fn(isLocked());
  }
  function onPointerError(event) {
    if (isLocked()) fn == null ? void 0 : fn(false);
    console.error("PointerLock error occurred:", event);
    doc.exitPointerLock();
  }
  if (!supported) return;
  try {
    body.requestPointerLock();
  } catch {
  }
  const cleanup = [
    addDomEvent(doc, "pointerlockchange", onPointerChange, false),
    addDomEvent(doc, "pointerlockerror", onPointerError, false)
  ];
  return () => {
    cleanup.forEach((cleanup2) => cleanup2());
    doc.exitPointerLock();
  };
}
var state = "default";
var userSelect = "";
var elementMap = /* @__PURE__ */ new WeakMap();
function disableTextSelectionImpl(options = {}) {
  const { target, doc } = options;
  const docNode = doc ?? document;
  const rootEl = docNode.documentElement;
  if (isIos()) {
    if (state === "default") {
      userSelect = rootEl.style.webkitUserSelect;
      rootEl.style.webkitUserSelect = "none";
    }
    state = "disabled";
  } else if (target) {
    elementMap.set(target, target.style.userSelect);
    target.style.userSelect = "none";
  }
  return () => restoreTextSelection({ target, doc: docNode });
}
function restoreTextSelection(options = {}) {
  const { target, doc } = options;
  const docNode = doc ?? document;
  const rootEl = docNode.documentElement;
  if (isIos()) {
    if (state !== "disabled") return;
    state = "restoring";
    setTimeout(() => {
      nextTick(() => {
        if (state === "restoring") {
          if (rootEl.style.webkitUserSelect === "none") {
            rootEl.style.webkitUserSelect = userSelect || "";
          }
          userSelect = "";
          state = "default";
        }
      });
    }, 300);
  } else {
    if (target && elementMap.has(target)) {
      const prevUserSelect = elementMap.get(target);
      if (target.style.userSelect === "none") {
        target.style.userSelect = prevUserSelect ?? "";
      }
      if (target.getAttribute("style") === "") {
        target.removeAttribute("style");
      }
      elementMap.delete(target);
    }
  }
}
function disableTextSelection(options = {}) {
  const { defer, target, ...restOptions } = options;
  const func = defer ? raf : (v) => v();
  const cleanups2 = [];
  cleanups2.push(
    func(() => {
      const node = typeof target === "function" ? target() : target;
      cleanups2.push(disableTextSelectionImpl({ ...restOptions, target: node }));
    })
  );
  return () => {
    cleanups2.forEach((fn) => fn == null ? void 0 : fn());
  };
}
function trackPointerMove(doc, handlers) {
  const { onPointerMove, onPointerUp } = handlers;
  const handleMove = (event) => {
    const point = getEventPoint(event);
    const distance = Math.sqrt(point.x ** 2 + point.y ** 2);
    const moveBuffer = event.pointerType === "touch" ? 10 : 5;
    if (distance < moveBuffer) return;
    if (event.pointerType === "mouse" && event.button === 0) {
      onPointerUp();
      return;
    }
    onPointerMove({ point, event });
  };
  const cleanups2 = [
    addDomEvent(doc, "pointermove", handleMove, false),
    addDomEvent(doc, "pointerup", onPointerUp, false),
    addDomEvent(doc, "pointercancel", onPointerUp, false),
    addDomEvent(doc, "contextmenu", onPointerUp, false),
    disableTextSelection({ doc })
  ];
  return () => {
    cleanups2.forEach((cleanup) => cleanup());
  };
}
function trackPress(options) {
  const {
    pointerNode,
    keyboardNode = pointerNode,
    onPress,
    onPressStart,
    onPressEnd,
    isValidKey: isValidKey2 = (e) => e.key === "Enter"
  } = options;
  if (!pointerNode) return noop;
  const win = getWindow(pointerNode);
  const doc = getDocument(pointerNode);
  let removeStartListeners = noop;
  let removeEndListeners = noop;
  let removeAccessibleListeners = noop;
  const getInfo = (event) => ({
    point: getEventPoint(event),
    event
  });
  function startPress(event) {
    onPressStart == null ? void 0 : onPressStart(getInfo(event));
  }
  function cancelPress(event) {
    onPressEnd == null ? void 0 : onPressEnd(getInfo(event));
  }
  const startPointerPress = (startEvent) => {
    removeEndListeners();
    const endPointerPress = (endEvent) => {
      const target = getEventTarget(endEvent);
      if (contains(pointerNode, target)) {
        onPress == null ? void 0 : onPress(getInfo(endEvent));
      } else {
        onPressEnd == null ? void 0 : onPressEnd(getInfo(endEvent));
      }
    };
    const removePointerUpListener = addDomEvent(win, "pointerup", endPointerPress, { passive: !onPress });
    const removePointerCancelListener = addDomEvent(win, "pointercancel", cancelPress, { passive: !onPressEnd });
    removeEndListeners = pipe(removePointerUpListener, removePointerCancelListener);
    if (doc.activeElement === keyboardNode && startEvent.pointerType === "mouse") {
      startEvent.preventDefault();
    }
    startPress(startEvent);
  };
  const removePointerListener = addDomEvent(pointerNode, "pointerdown", startPointerPress, { passive: !onPressStart });
  const removeFocusListener = addDomEvent(keyboardNode, "focus", startAccessiblePress);
  removeStartListeners = pipe(removePointerListener, removeFocusListener);
  function startAccessiblePress() {
    const handleKeydown = (keydownEvent) => {
      if (!isValidKey2(keydownEvent)) return;
      const handleKeyup = (keyupEvent) => {
        if (!isValidKey2(keyupEvent)) return;
        const evt2 = new win.PointerEvent("pointerup");
        const info = getInfo(evt2);
        onPress == null ? void 0 : onPress(info);
        onPressEnd == null ? void 0 : onPressEnd(info);
      };
      removeEndListeners();
      removeEndListeners = addDomEvent(keyboardNode, "keyup", handleKeyup);
      const evt = new win.PointerEvent("pointerdown");
      startPress(evt);
    };
    const handleBlur = () => {
      const evt = new win.PointerEvent("pointercancel");
      cancelPress(evt);
    };
    const removeKeydownListener = addDomEvent(keyboardNode, "keydown", handleKeydown);
    const removeBlurListener = addDomEvent(keyboardNode, "blur", handleBlur);
    removeAccessibleListeners = pipe(removeKeydownListener, removeBlurListener);
  }
  return () => {
    removeStartListeners();
    removeEndListeners();
    removeAccessibleListeners();
  };
}
function proxyTabFocusImpl(container, options = {}) {
  const { triggerElement, onFocus } = options;
  const doc = (container == null ? void 0 : container.ownerDocument) || document;
  const body = doc.body;
  function onKeyDown(event) {
    if (event.key !== "Tab") return;
    let elementToFocus = null;
    const [firstTabbable, lastTabbable] = getTabbableEdges(container, true);
    const noTabbableElements = !firstTabbable && !lastTabbable;
    if (event.shiftKey && (doc.activeElement === firstTabbable || noTabbableElements)) {
      elementToFocus = triggerElement;
    } else if (!event.shiftKey && doc.activeElement === triggerElement) {
      elementToFocus = firstTabbable;
    } else if (!event.shiftKey && (doc.activeElement === lastTabbable || noTabbableElements)) {
      elementToFocus = getNextTabbable(body, triggerElement);
    }
    if (!elementToFocus) return;
    event.preventDefault();
    if (typeof onFocus === "function") {
      onFocus(elementToFocus);
    } else {
      elementToFocus.focus();
    }
  }
  return addDomEvent(doc, "keydown", onKeyDown, true);
}
function proxyTabFocus(container, options) {
  const { defer, triggerElement, ...restOptions } = options;
  const func = defer ? raf : (v) => v();
  const cleanups2 = [];
  cleanups2.push(
    func(() => {
      const node = typeof container === "function" ? container() : container;
      const trigger = typeof triggerElement === "function" ? triggerElement() : triggerElement;
      cleanups2.push(proxyTabFocusImpl(node, { triggerElement: trigger, ...restOptions }));
    })
  );
  return () => {
    cleanups2.forEach((fn) => fn == null ? void 0 : fn());
  };
}
function queryAll(root, selector) {
  return Array.from((root == null ? void 0 : root.querySelectorAll(selector)) ?? []);
}
function query(root, selector) {
  return (root == null ? void 0 : root.querySelector(selector)) ?? null;
}
var defaultItemToId = (v) => v.id;
function itemById(v, id, itemToId = defaultItemToId) {
  return v.find((item) => itemToId(item) === id);
}
function indexOfId(v, id, itemToId = defaultItemToId) {
  const item = itemById(v, id, itemToId);
  return item ? v.indexOf(item) : -1;
}
function nextById(v, id, loop = true) {
  let idx = indexOfId(v, id);
  idx = loop ? (idx + 1) % v.length : Math.min(idx + 1, v.length - 1);
  return v[idx];
}
function prevById(v, id, loop = true) {
  let idx = indexOfId(v, id);
  if (idx === -1) return loop ? v[v.length - 1] : null;
  idx = loop ? (idx - 1 + v.length) % v.length : Math.max(0, idx - 1);
  return v[idx];
}
function createScope(methods) {
  const dom23 = {
    getRootNode: (ctx) => {
      var _a8;
      return ((_a8 = ctx.getRootNode) == null ? void 0 : _a8.call(ctx)) ?? document;
    },
    getDoc: (ctx) => getDocument(dom23.getRootNode(ctx)),
    getWin: (ctx) => dom23.getDoc(ctx).defaultView ?? window,
    getActiveElement: (ctx) => getActiveElement(dom23.getRootNode(ctx)),
    isActiveElement: (ctx, elem) => elem === dom23.getActiveElement(ctx),
    getById: (ctx, id) => dom23.getRootNode(ctx).getElementById(id),
    setValue: (elem, value) => {
      if (elem == null || value == null) return;
      setElementValue(elem, value.toString());
    }
  };
  return { ...dom23, ...methods };
}
var sanitize = (str) => str.split("").map((char) => {
  const code = char.charCodeAt(0);
  if (code > 0 && code < 128) return char;
  if (code >= 128 && code <= 255) return `/x${code.toString(16)}`.replace("/", "\\");
  return "";
}).join("").trim();
var getValueText = (el) => {
  var _a8;
  return sanitize(((_a8 = el.dataset) == null ? void 0 : _a8.valuetext) ?? el.textContent ?? "");
};
var match = (valueText, query2) => {
  return valueText.trim().toLowerCase().startsWith(query2.toLowerCase());
};
function getByText(v, text, currentId, itemToId = defaultItemToId) {
  const index = currentId ? indexOfId(v, currentId, itemToId) : -1;
  let items = currentId ? wrap2(v, index) : v;
  const isSingleKey = text.length === 1;
  if (isSingleKey) {
    items = items.filter((item) => itemToId(item) !== currentId);
  }
  return items.find((item) => match(getValueText(item), text));
}
var cleanups = /* @__PURE__ */ new WeakMap();
function set(element, key, setup) {
  if (!cleanups.has(element)) {
    cleanups.set(element, /* @__PURE__ */ new Map());
  }
  const elementCleanups = cleanups.get(element);
  const prevCleanup = elementCleanups.get(key);
  if (!prevCleanup) {
    elementCleanups.set(key, setup());
    return () => {
      var _a8;
      (_a8 = elementCleanups.get(key)) == null ? void 0 : _a8();
      elementCleanups.delete(key);
    };
  }
  const cleanup = setup();
  const nextCleanup = () => {
    cleanup();
    prevCleanup();
    elementCleanups.delete(key);
  };
  elementCleanups.set(key, nextCleanup);
  return () => {
    const isCurrent = elementCleanups.get(key) === nextCleanup;
    if (!isCurrent) return;
    cleanup();
    elementCleanups.set(key, prevCleanup);
  };
}
function setStyle(element, style) {
  if (!element) return () => {
  };
  const setup = () => {
    const prevStyle = element.style.cssText;
    Object.assign(element.style, style);
    return () => {
      element.style.cssText = prevStyle;
    };
  };
  return set(element, "style", setup);
}
function getByTypeaheadImpl(baseItems, options) {
  const { state: state2, activeId, key, timeout = 350, itemToId } = options;
  const search = state2.keysSoFar + key;
  const isRepeated = search.length > 1 && Array.from(search).every((char) => char === search[0]);
  const query2 = isRepeated ? search[0] : search;
  let items = baseItems.slice();
  const next2 = getByText(items, query2, activeId, itemToId);
  function cleanup() {
    clearTimeout(state2.timer);
    state2.timer = -1;
  }
  function update(value) {
    state2.keysSoFar = value;
    cleanup();
    if (value !== "") {
      state2.timer = +setTimeout(() => {
        update("");
        cleanup();
      }, timeout);
    }
  }
  update(search);
  return next2;
}
var getByTypeahead = Object.assign(getByTypeaheadImpl, {
  defaultOptions: { keysSoFar: "", timer: -1 },
  isValidEvent: isValidTypeaheadEvent
});
function isValidTypeaheadEvent(event) {
  return event.key.length === 1 && !event.ctrlKey && !event.metaKey;
}
var visuallyHiddenStyle = {
  border: "0",
  clip: "rect(0 0 0 0)",
  height: "1px",
  margin: "-1px",
  overflow: "hidden",
  padding: "0",
  position: "absolute",
  width: "1px",
  whiteSpace: "nowrap",
  wordWrap: "normal"
};
var fps = 1e3 / 60;
function waitForElement(query2, cb) {
  const el = query2();
  if (isHTMLElement(el) && el.isConnected) {
    cb(el);
    return () => void 0;
  } else {
    const timerId = setInterval(() => {
      const el2 = query2();
      if (isHTMLElement(el2) && el2.isConnected) {
        cb(el2);
        clearInterval(timerId);
      }
    }, fps);
    return () => clearInterval(timerId);
  }
}
function waitForElements(queries, cb) {
  const cleanups2 = [];
  queries == null ? void 0 : queries.forEach((query2) => {
    const clean = waitForElement(query2, cb);
    cleanups2.push(clean);
  });
  return () => {
    cleanups2.forEach((fn) => fn());
  };
}

// node_modules/@zag-js/utils/dist/index.mjs
var fromLength = (length) => Array.from(Array(length).keys());
var first = (v) => v[0];
var last = (v) => v[v.length - 1];
var has = (v, t) => v.indexOf(t) !== -1;
var add2 = (v, ...items) => v.concat(items);
var remove = (v, ...items) => v.filter((t) => !items.includes(t));
var removeAt = (v, i) => v.filter((_, idx) => idx !== i);
var uniq2 = (v) => Array.from(new Set(v));
var addOrRemove = (v, item) => {
  if (has(v, item)) return remove(v, item);
  return add2(v, item);
};
function clear(v) {
  while (v.length > 0) v.pop();
  return v;
}
function nextIndex(v, idx, opts = {}) {
  const { step = 1, loop = true } = opts;
  const next2 = idx + step;
  const len = v.length;
  const last2 = len - 1;
  if (idx === -1) return step > 0 ? 0 : last2;
  if (next2 < 0) return loop ? last2 : 0;
  if (next2 >= len) return loop ? 0 : idx > len ? len : idx;
  return next2;
}
function next(v, idx, opts = {}) {
  return v[nextIndex(v, idx, opts)];
}
function prevIndex(v, idx, opts = {}) {
  const { step = 1, loop = true } = opts;
  return nextIndex(v, idx, { step: -step, loop });
}
function prev(v, index, opts = {}) {
  return v[prevIndex(v, index, opts)];
}
var chunk = (v, size3) => {
  const res = [];
  return v.reduce((rows, value, index) => {
    var _a8;
    if (index % size3 === 0) rows.push([value]);
    else (_a8 = last(rows)) == null ? void 0 : _a8.push(value);
    return rows;
  }, res);
};
var isArrayLike = (value) => (value == null ? void 0 : value.constructor.name) === "Array";
var isArrayEqual = (a, b) => {
  if (a.length !== b.length) return false;
  for (let i = 0; i < a.length; i++) {
    if (!isEqual(a[i], b[i])) return false;
  }
  return true;
};
var isEqual = (a, b) => {
  if (Object.is(a, b)) return true;
  if (a == null && b != null || a != null && b == null) return false;
  if (typeof (a == null ? void 0 : a.isEqual) === "function" && typeof (b == null ? void 0 : b.isEqual) === "function") {
    return a.isEqual(b);
  }
  if (typeof a === "function" && typeof b === "function") {
    return a.toString() === b.toString();
  }
  if (isArrayLike(a) && isArrayLike(b)) {
    return isArrayEqual(Array.from(a), Array.from(b));
  }
  if (!(typeof a === "object") || !(typeof b === "object")) return false;
  const keys = Object.keys(b ?? /* @__PURE__ */ Object.create(null));
  const length = keys.length;
  for (let i = 0; i < length; i++) {
    const hasKey = Reflect.has(a, keys[i]);
    if (!hasKey) return false;
  }
  for (let i = 0; i < length; i++) {
    const key = keys[i];
    if (!isEqual(a[key], b[key])) return false;
  }
  return true;
};
var runIfFn = (v, ...a) => {
  const res = typeof v === "function" ? v(...a) : v;
  return res ?? void 0;
};
var cast = (v) => v;
var noop2 = () => {
};
var callAll = (...fns) => (...a) => {
  fns.forEach(function(fn) {
    fn == null ? void 0 : fn(...a);
  });
};
var uuid = /* @__PURE__ */ (() => {
  let id = 0;
  return () => {
    id++;
    return id.toString(36);
  };
})();
function match2(key, record, ...args) {
  var _a8;
  if (key in record) {
    const fn = record[key];
    return typeof fn === "function" ? fn(...args) : fn;
  }
  const error = new Error(`No matching key: ${JSON.stringify(key)} in ${JSON.stringify(Object.keys(record))}`);
  (_a8 = Error.captureStackTrace) == null ? void 0 : _a8.call(Error, error, match2);
  throw error;
}
var tryCatch = (fn, fallback4) => {
  var _a8;
  try {
    return fn();
  } catch (error) {
    if (error instanceof Error) {
      (_a8 = Error.captureStackTrace) == null ? void 0 : _a8.call(Error, error, tryCatch);
    }
    return fallback4 == null ? void 0 : fallback4();
  }
};
var isDev = () => true;
var isArray = (v) => Array.isArray(v);
var isBoolean = (v) => v === true || v === false;
var isObjectLike = (v) => v != null && typeof v === "object";
var isObject3 = (v) => isObjectLike(v) && !isArray(v);
var isNumber = (v) => typeof v === "number" && !Number.isNaN(v);
var isString2 = (v) => typeof v === "string";
var isFunction2 = (v) => typeof v === "function";
var isNull = (v) => v == null;
var hasProp = (obj, prop) => Object.prototype.hasOwnProperty.call(obj, prop);
var baseGetTag = (v) => Object.prototype.toString.call(v);
var fnToString = Function.prototype.toString;
var objectCtorString = fnToString.call(Object);
var isPlainObject = (v) => {
  if (!isObjectLike(v) || baseGetTag(v) != "[object Object]") return false;
  const proto = Object.getPrototypeOf(v);
  if (proto === null) return true;
  const Ctor = hasProp(proto, "constructor") && proto.constructor;
  return typeof Ctor == "function" && Ctor instanceof Ctor && fnToString.call(Ctor) == objectCtorString;
};
var { floor, abs, round, min, max, pow, sign } = Math;
var isNaN2 = (v) => Number.isNaN(v);
var nan = (v) => isNaN2(v) ? 0 : v;
var mod = (v, m) => (v % m + m) % m;
var wrap3 = (v, vmax) => (v % vmax + vmax) % vmax;
var getMinValueAtIndex = (i, v, vmin) => i === 0 ? vmin : v[i - 1];
var getMaxValueAtIndex = (i, v, vmax) => i === v.length - 1 ? vmax : v[i + 1];
var isValueAtMax = (v, vmax) => nan(v) >= vmax;
var isValueAtMin = (v, vmin) => nan(v) <= vmin;
var isValueWithinRange = (v, vmin, vmax) => nan(v) >= vmin && nan(v) <= vmax;
var roundValue = (v, vmin, step) => round((nan(v) - vmin) / step) * step + vmin;
var clampValue = (v, vmin, vmax) => min(max(nan(v), vmin), vmax);
var getValuePercent = (v, vmin, vmax) => (nan(v) - vmin) / (vmax - vmin);
var getPercentValue = (p, vmin, vmax, step) => clampValue(roundValue(p * (vmax - vmin) + vmin, vmin, step), vmin, vmax);
var roundToStepPrecision = (v, step) => {
  let rv = v;
  let ss = step.toString();
  let pi = ss.indexOf(".");
  let p = pi >= 0 ? ss.length - pi : 0;
  if (p > 0) {
    let pw = pow(10, p);
    rv = round(rv * pw) / pw;
  }
  return rv;
};
var roundToDpr = (v, dpr) => typeof dpr === "number" ? floor(v * dpr + 0.5) / dpr : round(v);
var snapValueToStep = (v, vmin, vmax, step) => {
  vmin = Number(vmin);
  vmax = Number(vmax);
  let remainder = (v - (isNaN2(vmin) ? 0 : vmin)) % step;
  let sv = roundToStepPrecision(
    abs(remainder) * 2 >= step ? v + sign(remainder) * (step - abs(remainder)) : v - remainder,
    step
  );
  if (!isNaN2(vmin)) {
    if (sv < vmin) {
      sv = vmin;
    } else if (!isNaN2(vmax) && sv > vmax) {
      sv = vmin + floor(roundToStepPrecision((vmax - vmin) / step, step)) * step;
    }
  } else if (!isNaN2(vmax) && sv > vmax) {
    sv = vmin + floor(roundToStepPrecision((vmax - vmin) / step, step)) * step;
  }
  return roundToStepPrecision(sv, step);
};
var setValueAtIndex = (vs, i, v) => {
  if (vs[i] === v) return vs;
  return [...vs.slice(0, i), v, ...vs.slice(i + 1)];
};
function getValueSetterAtIndex(index, ctx) {
  const minValueAtIndex = getMinValueAtIndex(index, ctx.values, ctx.min);
  const maxValueAtIndex = getMaxValueAtIndex(index, ctx.values, ctx.max);
  let nextValues = ctx.values.slice();
  return function setValue(value) {
    let nextValue = snapValueToStep(value, minValueAtIndex, maxValueAtIndex, ctx.step);
    nextValues = setValueAtIndex(nextValues, index, value);
    nextValues[index] = nextValue;
    return nextValues;
  };
}
function getNextStepValue(index, ctx) {
  const nextValue = ctx.values[index] + ctx.step;
  return getValueSetterAtIndex(index, ctx)(nextValue);
}
function getPreviousStepValue(index, ctx) {
  const nextValue = ctx.values[index] - ctx.step;
  return getValueSetterAtIndex(index, ctx)(nextValue);
}
var getClosestValueIndex = (vs, t) => {
  let i = vs.findIndex((v) => t - v < 0);
  if (i === 0) return i;
  if (i === -1) return vs.length - 1;
  let vLeft = vs[i - 1];
  let vRight = vs[i];
  if (abs(vLeft - t) < abs(vRight - t)) return i - 1;
  return i;
};
var getValueRanges = (vs, vmin, vmax, gap) => vs.map((v, i) => ({
  min: i === 0 ? vmin : vs[i - 1] + gap,
  max: i === vs.length - 1 ? vmax : vs[i + 1] - gap,
  value: v
}));
var getValueTransformer = (va, vb) => {
  const [a, b] = va;
  const [c, d] = vb;
  return (v) => a === b || c === d ? c : c + (d - c) / (b - a) * (v - a);
};
var toFixedNumber = (v, d = 0, b = 10) => {
  const pow2 = Math.pow(b, d);
  return round(v * pow2) / pow2;
};
var countDecimals = (value) => {
  if (!Number.isFinite(value)) return 0;
  let e = 1, p = 0;
  while (Math.round(value * e) / e !== value) {
    e *= 10;
    p += 1;
  }
  return p;
};
var decimalOp = (a, op, b) => {
  let result = op === "+" ? a + b : a - b;
  if (a % 1 !== 0 || b % 1 !== 0) {
    const multiplier = 10 ** Math.max(countDecimals(a), countDecimals(b));
    a = Math.round(a * multiplier);
    b = Math.round(b * multiplier);
    result = op === "+" ? a + b : a - b;
    result /= multiplier;
  }
  return result;
};
var incrementValue = (v, s) => decimalOp(nan(v), "+", s);
var decrementValue = (v, s) => decimalOp(nan(v), "-", s);
function compact2(obj) {
  if (!isPlainObject2(obj) || obj === void 0) return obj;
  const keys = Reflect.ownKeys(obj).filter((key) => typeof key === "string");
  const filtered = {};
  for (const key of keys) {
    const value = obj[key];
    if (value !== void 0) {
      filtered[key] = compact2(value);
    }
  }
  return filtered;
}
var isPlainObject2 = (v) => {
  return v && typeof v === "object" && v.constructor === Object;
};
function splitProps2(props21, keys) {
  const rest = {};
  const result = {};
  const keySet = new Set(keys);
  for (const key in props21) {
    if (keySet.has(key)) {
      result[key] = props21[key];
    } else {
      rest[key] = props21[key];
    }
  }
  return [result, rest];
}
var createSplitProps = (keys) => {
  return function split(props21) {
    return splitProps2(props21, keys);
  };
};
function warn(...a) {
  const m = a.length === 1 ? a[0] : a[1];
  const c = a.length === 2 ? a[0] : true;
  if (c && true) {
    console.warn(m);
  }
}
function invariant(...a) {
  const m = a.length === 1 ? a[0] : a[1];
  const c = a.length === 2 ? a[0] : true;
  if (c && true) {
    throw new Error(m);
  }
}

// node_modules/proxy-compare/dist/index.js
var TRACK_MEMO_SYMBOL = Symbol();
var GET_ORIGINAL_SYMBOL = Symbol();
var AFFECTED_PROPERTY = "a";
var IS_TARGET_COPIED_PROPERTY = "f";
var PROXY_PROPERTY = "p";
var PROXY_CACHE_PROPERTY = "c";
var TARGET_CACHE_PROPERTY = "t";
var HAS_KEY_PROPERTY = "h";
var ALL_OWN_KEYS_PROPERTY = "w";
var HAS_OWN_KEY_PROPERTY = "o";
var KEYS_PROPERTY = "k";
var newProxy = (target, handler) => new Proxy(target, handler);
var getProto = Object.getPrototypeOf;
var objectsToTrack = /* @__PURE__ */ new WeakMap();
var isObjectToTrack = (obj) => obj && (objectsToTrack.has(obj) ? objectsToTrack.get(obj) : getProto(obj) === Object.prototype || getProto(obj) === Array.prototype);
var isObject4 = (x) => typeof x === "object" && x !== null;
var needsToCopyTargetObject = (obj) => Object.values(Object.getOwnPropertyDescriptors(obj)).some((descriptor) => !descriptor.configurable && !descriptor.writable);
var copyTargetObject = (obj) => {
  if (Array.isArray(obj)) {
    return Array.from(obj);
  }
  const descriptors = Object.getOwnPropertyDescriptors(obj);
  Object.values(descriptors).forEach((desc) => {
    desc.configurable = true;
  });
  return Object.create(getProto(obj), descriptors);
};
var createProxyHandler = (origObj, isTargetCopied) => {
  const state2 = {
    [IS_TARGET_COPIED_PROPERTY]: isTargetCopied
  };
  let trackObject = false;
  const recordUsage = (type, key) => {
    if (!trackObject) {
      let used = state2[AFFECTED_PROPERTY].get(origObj);
      if (!used) {
        used = {};
        state2[AFFECTED_PROPERTY].set(origObj, used);
      }
      if (type === ALL_OWN_KEYS_PROPERTY) {
        used[ALL_OWN_KEYS_PROPERTY] = true;
      } else {
        let set19 = used[type];
        if (!set19) {
          set19 = /* @__PURE__ */ new Set();
          used[type] = set19;
        }
        set19.add(key);
      }
    }
  };
  const recordObjectAsUsed = () => {
    trackObject = true;
    state2[AFFECTED_PROPERTY].delete(origObj);
  };
  const handler = {
    get(target, key) {
      if (key === GET_ORIGINAL_SYMBOL) {
        return origObj;
      }
      recordUsage(KEYS_PROPERTY, key);
      return createProxy2(Reflect.get(target, key), state2[AFFECTED_PROPERTY], state2[PROXY_CACHE_PROPERTY], state2[TARGET_CACHE_PROPERTY]);
    },
    has(target, key) {
      if (key === TRACK_MEMO_SYMBOL) {
        recordObjectAsUsed();
        return true;
      }
      recordUsage(HAS_KEY_PROPERTY, key);
      return Reflect.has(target, key);
    },
    getOwnPropertyDescriptor(target, key) {
      recordUsage(HAS_OWN_KEY_PROPERTY, key);
      return Reflect.getOwnPropertyDescriptor(target, key);
    },
    ownKeys(target) {
      recordUsage(ALL_OWN_KEYS_PROPERTY);
      return Reflect.ownKeys(target);
    }
  };
  if (isTargetCopied) {
    handler.set = handler.deleteProperty = () => false;
  }
  return [handler, state2];
};
var getOriginalObject = (obj) => (
  // unwrap proxy
  obj[GET_ORIGINAL_SYMBOL] || // otherwise
  obj
);
var createProxy2 = (obj, affected, proxyCache, targetCache3) => {
  if (!isObjectToTrack(obj))
    return obj;
  let targetAndCopied = targetCache3 && targetCache3.get(obj);
  if (!targetAndCopied) {
    const target2 = getOriginalObject(obj);
    if (needsToCopyTargetObject(target2)) {
      targetAndCopied = [target2, copyTargetObject(target2)];
    } else {
      targetAndCopied = [target2];
    }
    targetCache3 === null || targetCache3 === void 0 ? void 0 : targetCache3.set(obj, targetAndCopied);
  }
  const [target, copiedTarget] = targetAndCopied;
  let handlerAndState = proxyCache && proxyCache.get(target);
  if (!handlerAndState || handlerAndState[1][IS_TARGET_COPIED_PROPERTY] !== !!copiedTarget) {
    handlerAndState = createProxyHandler(target, !!copiedTarget);
    handlerAndState[1][PROXY_PROPERTY] = newProxy(copiedTarget || target, handlerAndState[0]);
    if (proxyCache) {
      proxyCache.set(target, handlerAndState);
    }
  }
  handlerAndState[1][AFFECTED_PROPERTY] = affected;
  handlerAndState[1][PROXY_CACHE_PROPERTY] = proxyCache;
  handlerAndState[1][TARGET_CACHE_PROPERTY] = targetCache3;
  return handlerAndState[1][PROXY_PROPERTY];
};
var isAllOwnKeysChanged = (prevObj, nextObj) => {
  const prevKeys = Reflect.ownKeys(prevObj);
  const nextKeys = Reflect.ownKeys(nextObj);
  return prevKeys.length !== nextKeys.length || prevKeys.some((k, i) => k !== nextKeys[i]);
};
var isChanged = (prevObj, nextObj, affected, cache, isEqual3 = Object.is) => {
  if (isEqual3(prevObj, nextObj)) {
    return false;
  }
  if (!isObject4(prevObj) || !isObject4(nextObj))
    return true;
  const used = affected.get(getOriginalObject(prevObj));
  if (!used)
    return true;
  if (cache) {
    const hit = cache.get(prevObj);
    if (hit === nextObj) {
      return false;
    }
    cache.set(prevObj, nextObj);
  }
  let changed = null;
  for (const key of used[HAS_KEY_PROPERTY] || []) {
    changed = Reflect.has(prevObj, key) !== Reflect.has(nextObj, key);
    if (changed)
      return changed;
  }
  if (used[ALL_OWN_KEYS_PROPERTY] === true) {
    changed = isAllOwnKeysChanged(prevObj, nextObj);
    if (changed)
      return changed;
  } else {
    for (const key of used[HAS_OWN_KEY_PROPERTY] || []) {
      const hasPrev = !!Reflect.getOwnPropertyDescriptor(prevObj, key);
      const hasNext = !!Reflect.getOwnPropertyDescriptor(nextObj, key);
      changed = hasPrev !== hasNext;
      if (changed)
        return changed;
    }
  }
  for (const key of used[KEYS_PROPERTY] || []) {
    changed = isChanged(prevObj[key], nextObj[key], affected, cache, isEqual3);
    if (changed)
      return changed;
  }
  if (changed === null)
    throw new Error("invalid used");
  return changed;
};
var trackMemo = (obj) => {
  if (isObjectToTrack(obj)) {
    return TRACK_MEMO_SYMBOL in obj;
  }
  return false;
};
var getUntracked = (obj) => {
  if (isObjectToTrack(obj)) {
    return obj[GET_ORIGINAL_SYMBOL] || null;
  }
  return null;
};
var markToTrack = (obj, mark = true) => {
  objectsToTrack.set(obj, mark);
};

// node_modules/@zag-js/store/dist/index.mjs
function glob() {
  if (typeof globalThis !== "undefined") return globalThis;
  if (typeof self !== "undefined") return self;
  if (typeof window !== "undefined") return window;
  if (typeof global !== "undefined") return global;
}
function globalRef(key, value) {
  const g = glob();
  if (!g) return value();
  g[key] || (g[key] = value());
  return g[key];
}
var refSet = globalRef("__zag__refSet", () => /* @__PURE__ */ new WeakSet());
var isReactElement = (x) => typeof x === "object" && x !== null && "$$typeof" in x && "props" in x;
var isVueElement = (x) => typeof x === "object" && x !== null && "__v_isVNode" in x;
var isDOMElement = (x) => typeof x === "object" && x !== null && "nodeType" in x && typeof x.nodeName === "string";
var isElement = (x) => isReactElement(x) || isVueElement(x) || isDOMElement(x);
var isObject5 = (x) => x !== null && typeof x === "object";
var canProxy = (x) => isObject5(x) && !refSet.has(x) && (Array.isArray(x) || !(Symbol.iterator in x)) && !isElement(x) && !(x instanceof WeakMap) && !(x instanceof WeakSet) && !(x instanceof Error) && !(x instanceof Number) && !(x instanceof Date) && !(x instanceof String) && !(x instanceof RegExp) && !(x instanceof ArrayBuffer) && !(x instanceof Promise);
var isDev2 = () => true;
function set2(obj, key, val) {
  if (typeof val.value === "object" && !canProxy(val.value)) val.value = clone2(val.value);
  if (!val.enumerable || val.get || val.set || !val.configurable || !val.writable || key === "__proto__") {
    Object.defineProperty(obj, key, val);
  } else obj[key] = val.value;
}
function clone2(x) {
  if (typeof x !== "object") return x;
  var i = 0, k, list, tmp, str = Object.prototype.toString.call(x);
  if (str === "[object Object]") {
    tmp = Object.create(Object.getPrototypeOf(x) || null);
  } else if (str === "[object Array]") {
    tmp = Array(x.length);
  } else if (str === "[object Set]") {
    tmp = /* @__PURE__ */ new Set();
    x.forEach(function(val) {
      tmp.add(clone2(val));
    });
  } else if (str === "[object Map]") {
    tmp = /* @__PURE__ */ new Map();
    x.forEach(function(val, key) {
      tmp.set(clone2(key), clone2(val));
    });
  } else if (str === "[object Date]") {
    tmp = /* @__PURE__ */ new Date(+x);
  } else if (str === "[object RegExp]") {
    tmp = new RegExp(x.source, x.flags);
  } else if (str === "[object DataView]") {
    tmp = new x.constructor(clone2(x.buffer));
  } else if (str === "[object ArrayBuffer]") {
    tmp = x.slice(0);
  } else if (str === "[object Blob]") {
    tmp = x.slice();
  } else if (str.slice(-6) === "Array]") {
    tmp = new x.constructor(x);
  }
  if (tmp) {
    for (list = Object.getOwnPropertySymbols(x); i < list.length; i++) {
      set2(tmp, list[i], Object.getOwnPropertyDescriptor(x, list[i]));
    }
    for (i = 0, list = Object.getOwnPropertyNames(x); i < list.length; i++) {
      if (Object.hasOwnProperty.call(tmp, k = list[i]) && tmp[k] === x[k]) continue;
      set2(tmp, k, Object.getOwnPropertyDescriptor(x, k));
    }
  }
  return tmp || x;
}
var proxyStateMap = globalRef("__zag__proxyStateMap", () => /* @__PURE__ */ new WeakMap());
var buildProxyFunction = (objectIs = Object.is, newProxy2 = (target, handler) => new Proxy(target, handler), snapCache = /* @__PURE__ */ new WeakMap(), createSnapshot = (target, version) => {
  const cache = snapCache.get(target);
  if ((cache == null ? void 0 : cache[0]) === version) {
    return cache[1];
  }
  const snap = Array.isArray(target) ? [] : Object.create(Object.getPrototypeOf(target));
  markToTrack(snap, true);
  snapCache.set(target, [version, snap]);
  Reflect.ownKeys(target).forEach((key) => {
    const value = Reflect.get(target, key);
    if (refSet.has(value)) {
      markToTrack(value, false);
      snap[key] = value;
    } else if (proxyStateMap.has(value)) {
      snap[key] = snapshot(value);
    } else {
      snap[key] = value;
    }
  });
  return Object.freeze(snap);
}, proxyCache = /* @__PURE__ */ new WeakMap(), versionHolder = [1, 1], proxyFunction2 = (initialObject) => {
  if (!isObject5(initialObject)) {
    throw new Error("object required");
  }
  const found = proxyCache.get(initialObject);
  if (found) {
    return found;
  }
  let version = versionHolder[0];
  const listeners = /* @__PURE__ */ new Set();
  const notifyUpdate = (op, nextVersion = ++versionHolder[0]) => {
    if (version !== nextVersion) {
      version = nextVersion;
      listeners.forEach((listener) => listener(op, nextVersion));
    }
  };
  let checkVersion = versionHolder[1];
  const ensureVersion = (nextCheckVersion = ++versionHolder[1]) => {
    if (checkVersion !== nextCheckVersion && !listeners.size) {
      checkVersion = nextCheckVersion;
      propProxyStates.forEach(([propProxyState]) => {
        const propVersion = propProxyState[1](nextCheckVersion);
        if (propVersion > version) {
          version = propVersion;
        }
      });
    }
    return version;
  };
  const createPropListener = (prop) => (op, nextVersion) => {
    const newOp = [...op];
    newOp[1] = [prop, ...newOp[1]];
    notifyUpdate(newOp, nextVersion);
  };
  const propProxyStates = /* @__PURE__ */ new Map();
  const addPropListener = (prop, propProxyState) => {
    if (isDev2() && propProxyStates.has(prop)) {
      throw new Error("prop listener already exists");
    }
    if (listeners.size) {
      const remove3 = propProxyState[3](createPropListener(prop));
      propProxyStates.set(prop, [propProxyState, remove3]);
    } else {
      propProxyStates.set(prop, [propProxyState]);
    }
  };
  const removePropListener = (prop) => {
    var _a8;
    const entry = propProxyStates.get(prop);
    if (entry) {
      propProxyStates.delete(prop);
      (_a8 = entry[1]) == null ? void 0 : _a8.call(entry);
    }
  };
  const addListener = (listener) => {
    listeners.add(listener);
    if (listeners.size === 1) {
      propProxyStates.forEach(([propProxyState, prevRemove], prop) => {
        if (isDev2() && prevRemove) {
          throw new Error("remove already exists");
        }
        const remove3 = propProxyState[3](createPropListener(prop));
        propProxyStates.set(prop, [propProxyState, remove3]);
      });
    }
    const removeListener = () => {
      listeners.delete(listener);
      if (listeners.size === 0) {
        propProxyStates.forEach(([propProxyState, remove3], prop) => {
          if (remove3) {
            remove3();
            propProxyStates.set(prop, [propProxyState]);
          }
        });
      }
    };
    return removeListener;
  };
  const baseObject = Array.isArray(initialObject) ? [] : Object.create(Object.getPrototypeOf(initialObject));
  const handler = {
    deleteProperty(target, prop) {
      const prevValue = Reflect.get(target, prop);
      removePropListener(prop);
      const deleted = Reflect.deleteProperty(target, prop);
      if (deleted) {
        notifyUpdate(["delete", [prop], prevValue]);
      }
      return deleted;
    },
    set(target, prop, value, receiver) {
      var _a8;
      const hasPrevValue = Reflect.has(target, prop);
      const prevValue = Reflect.get(target, prop, receiver);
      if (hasPrevValue && (objectIs(prevValue, value) || proxyCache.has(value) && objectIs(prevValue, proxyCache.get(value)))) {
        return true;
      }
      removePropListener(prop);
      if (isObject5(value)) {
        value = getUntracked(value) || value;
      }
      let nextValue = value;
      if ((_a8 = Object.getOwnPropertyDescriptor(target, prop)) == null ? void 0 : _a8.set) ;
      else {
        if (!proxyStateMap.has(value) && canProxy(value)) {
          nextValue = proxy(value);
        }
        const childProxyState = !refSet.has(nextValue) && proxyStateMap.get(nextValue);
        if (childProxyState) {
          addPropListener(prop, childProxyState);
        }
      }
      Reflect.set(target, prop, nextValue, receiver);
      notifyUpdate(["set", [prop], value, prevValue]);
      return true;
    }
  };
  const proxyObject = newProxy2(baseObject, handler);
  proxyCache.set(initialObject, proxyObject);
  const proxyState = [baseObject, ensureVersion, createSnapshot, addListener];
  proxyStateMap.set(proxyObject, proxyState);
  Reflect.ownKeys(initialObject).forEach((key) => {
    const desc = Object.getOwnPropertyDescriptor(initialObject, key);
    if (desc.get || desc.set) {
      Object.defineProperty(baseObject, key, desc);
    } else {
      proxyObject[key] = initialObject[key];
    }
  });
  return proxyObject;
}) => [
  // public functions
  proxyFunction2,
  // shared state
  proxyStateMap,
  refSet,
  // internal things
  objectIs,
  newProxy2,
  canProxy,
  snapCache,
  createSnapshot,
  proxyCache,
  versionHolder
];
var [proxyFunction] = buildProxyFunction();
function proxy(initialObject = {}) {
  return proxyFunction(initialObject);
}
function subscribe(proxyObject, callback, notifyInSync) {
  const proxyState = proxyStateMap.get(proxyObject);
  if (isDev2() && !proxyState) {
    console.warn("Please use proxy object");
  }
  let promise;
  const ops = [];
  const addListener = proxyState[3];
  let isListenerActive = false;
  const listener = (op) => {
    ops.push(op);
    if (notifyInSync) {
      callback(ops.splice(0));
      return;
    }
    if (!promise) {
      promise = Promise.resolve().then(() => {
        promise = void 0;
        if (isListenerActive) {
          callback(ops.splice(0));
        }
      });
    }
  };
  const removeListener = addListener(listener);
  isListenerActive = true;
  return () => {
    isListenerActive = false;
    removeListener();
  };
}
function snapshot(proxyObject) {
  const proxyState = proxyStateMap.get(proxyObject);
  if (isDev2() && !proxyState) {
    console.warn("Please use proxy object");
  }
  const [target, ensureVersion, createSnapshot] = proxyState;
  return createSnapshot(target, ensureVersion());
}
function ref(obj) {
  refSet.add(obj);
  return obj;
}
function proxyWithComputed(initialObject, computedFns) {
  const keys = Object.keys(computedFns);
  keys.forEach((key) => {
    if (Object.getOwnPropertyDescriptor(initialObject, key)) {
      throw new Error("object property already defined");
    }
    const computedFn = computedFns[key];
    const { get, set: set22 } = typeof computedFn === "function" ? { get: computedFn } : computedFn;
    const desc = {};
    desc.get = () => get(snapshot(proxyObject));
    if (set22) {
      desc.set = (newValue) => set22(proxyObject, newValue);
    }
    Object.defineProperty(initialObject, key, desc);
  });
  const proxyObject = proxy(initialObject);
  return proxyObject;
}

// node_modules/@zag-js/core/dist/index.mjs
var __defProp = Object.defineProperty;
var __defNormalProp = (obj, key, value) => key in obj ? __defProp(obj, key, { enumerable: true, configurable: true, writable: true, value }) : obj[key] = value;
var __publicField = (obj, key, value) => __defNormalProp(obj, typeof key !== "symbol" ? key + "" : key, value);
function deepMerge(source, ...objects) {
  for (const obj of objects) {
    const target = compact2(obj);
    for (const key in target) {
      if (isPlainObject(obj[key])) {
        if (!source[key]) {
          source[key] = {};
        }
        deepMerge(source[key], obj[key]);
      } else {
        source[key] = obj[key];
      }
    }
  }
  return source;
}
function toEvent(event) {
  const obj = isString2(event) ? { type: event } : event;
  return obj;
}
function toArray(value) {
  if (!value) return [];
  return isArray(value) ? value.slice() : [value];
}
function isGuardHelper(value) {
  return isObject3(value) && value.predicate != null;
}
var Truthy = () => true;
function exec(guardMap, ctx, event, meta) {
  return (guard) => {
    var _a8;
    if (isString2(guard)) {
      return !!((_a8 = guardMap[guard]) == null ? void 0 : _a8.call(guardMap, ctx, event, meta));
    }
    if (isFunction2(guard)) {
      return guard(ctx, event, meta);
    }
    return guard.predicate(guardMap)(ctx, event, meta);
  };
}
function or(...conditions) {
  return {
    predicate: (guardMap) => (ctx, event, meta) => conditions.map(exec(guardMap, ctx, event, meta)).some(Boolean)
  };
}
function and(...conditions) {
  return {
    predicate: (guardMap) => (ctx, event, meta) => conditions.map(exec(guardMap, ctx, event, meta)).every(Boolean)
  };
}
function not(condition) {
  return {
    predicate: (guardMap) => (ctx, event, meta) => {
      return !exec(guardMap, ctx, event, meta)(condition);
    }
  };
}
function stateIn(...values) {
  return (_ctx, _evt, meta) => meta.state.matches(...values);
}
var guards = { or, and, not, stateIn };
function choose(actions) {
  return {
    predicate: (guardMap) => (ctx, event, meta) => {
      var _a8;
      return (_a8 = actions.find((def) => {
        const guard = def.guard ?? Truthy;
        return exec(guardMap, ctx, event, meta)(guard);
      })) == null ? void 0 : _a8.actions;
    }
  };
}
function determineGuardFn(guard, guardMap) {
  guard = guard ?? Truthy;
  return (context, event, meta) => {
    if (isString2(guard)) {
      const value = guardMap[guard];
      return isFunction2(value) ? value(context, event, meta) : value;
    }
    if (isGuardHelper(guard)) {
      return guard.predicate(guardMap)(context, event, meta);
    }
    return guard == null ? void 0 : guard(context, event, meta);
  };
}
function determineActionsFn(values, guardMap) {
  return (context, event, meta) => {
    if (isGuardHelper(values)) {
      return values.predicate(guardMap)(context, event, meta);
    }
    return values;
  };
}
function createProxy3(config) {
  var _a8, _b7;
  const computedContext = config.computed ?? cast({});
  const initialContext = config.context ?? cast({});
  const initialTags = config.initial ? (_b7 = (_a8 = config.states) == null ? void 0 : _a8[config.initial]) == null ? void 0 : _b7.tags : [];
  const state2 = proxy({
    value: config.initial ?? "",
    previousValue: "",
    event: cast({}),
    previousEvent: cast({}),
    context: proxyWithComputed(initialContext, computedContext),
    done: false,
    tags: initialTags ?? [],
    hasTag(tag) {
      return this.tags.includes(tag);
    },
    matches(...value) {
      return value.includes(this.value);
    },
    can(event) {
      return cast(this).nextEvents.includes(event);
    },
    get nextEvents() {
      var _a9, _b8;
      const stateEvents = ((_b8 = (_a9 = config.states) == null ? void 0 : _a9[this.value]) == null ? void 0 : _b8["on"]) ?? {};
      const globalEvents = (config == null ? void 0 : config.on) ?? {};
      return Object.keys({ ...stateEvents, ...globalEvents });
    },
    get changed() {
      if (this.event.value === "machine.init" || !this.previousValue) return false;
      return this.value !== this.previousValue;
    }
  });
  return cast(state2);
}
function determineDelayFn(delay2, delaysMap) {
  return (context, event) => {
    if (isNumber(delay2)) return delay2;
    if (isFunction2(delay2)) {
      return delay2(context, event);
    }
    if (isString2(delay2)) {
      const value = Number.parseFloat(delay2);
      if (!Number.isNaN(value)) {
        return value;
      }
      if (delaysMap) {
        const valueOrFn = delaysMap == null ? void 0 : delaysMap[delay2];
        invariant(
          valueOrFn == null,
          `[@zag-js/core > determine-delay] Cannot determine delay for \`${delay2}\`. It doesn't exist in \`options.delays\``
        );
        return isFunction2(valueOrFn) ? valueOrFn(context, event) : valueOrFn;
      }
    }
  };
}
function toTarget(target) {
  return isString2(target) ? { target } : target;
}
function determineTransitionFn(transitions, guardMap) {
  return (context, event, meta) => {
    return toArray(transitions).map(toTarget).find((transition) => {
      const determineGuard = determineGuardFn(transition.guard, guardMap);
      const guard = determineGuard(context, event, meta);
      return guard ?? transition.target ?? transition.actions;
    });
  };
}
var Machine = class {
  // Let's get started!
  constructor(config, options) {
    var _a8, _b7, _c6, _d6, _e6;
    __publicField(
      this,
      "status",
      "Not Started"
      /* NotStarted */
    );
    __publicField(this, "state");
    __publicField(this, "initialState");
    __publicField(this, "initialContext");
    __publicField(this, "id");
    __publicField(
      this,
      "type",
      "machine"
      /* Machine */
    );
    __publicField(this, "activityEvents", /* @__PURE__ */ new Map());
    __publicField(this, "delayedEvents", /* @__PURE__ */ new Map());
    __publicField(this, "stateListeners", /* @__PURE__ */ new Set());
    __publicField(this, "doneListeners", /* @__PURE__ */ new Set());
    __publicField(this, "contextWatchers", /* @__PURE__ */ new Set());
    __publicField(this, "removeStateListener", noop2);
    __publicField(this, "parent");
    __publicField(this, "children", /* @__PURE__ */ new Map());
    __publicField(this, "guardMap");
    __publicField(this, "actionMap");
    __publicField(this, "delayMap");
    __publicField(this, "activityMap");
    __publicField(this, "sync");
    __publicField(this, "options");
    __publicField(this, "config");
    __publicField(this, "_created", () => {
      if (!this.config.created) return;
      const event = toEvent(
        "machine.created"
        /* Created */
      );
      this.executeActions(this.config.created, event);
    });
    __publicField(this, "start", (init) => {
      this.state.value = "";
      this.state.tags = [];
      if (this.status === "Running") {
        return this;
      }
      this.status = "Running";
      this.removeStateListener = subscribe(
        this.state,
        () => {
          this.stateListeners.forEach((listener) => {
            listener(this.stateSnapshot);
          });
        },
        this.sync
      );
      this.setupContextWatchers();
      this.executeActivities(
        toEvent(
          "machine.start"
          /* Start */
        ),
        toArray(this.config.activities),
        "machine.start"
        /* Start */
      );
      this.executeActions(this.config.entry, toEvent(
        "machine.start"
        /* Start */
      ));
      const event = toEvent(
        "machine.init"
        /* Init */
      );
      const target = isObject3(init) ? init.value : init;
      const context = isObject3(init) ? init.context : void 0;
      if (context) {
        this.setContext(context);
      }
      const transition = {
        target: target ?? this.config.initial
      };
      const next2 = this.getNextStateInfo(transition, event);
      this.initialState = next2;
      this.performStateChangeEffects(this.state.value, next2, event);
      return this;
    });
    __publicField(this, "setupContextWatchers", () => {
      const { watch } = this.config;
      if (!watch) return;
      let prev2 = snapshot(this.state.context);
      const cleanup = subscribe(this.state.context, () => {
        var _a9;
        const next2 = snapshot(this.state.context);
        for (const [key, fn] of Object.entries(watch)) {
          const isEqual3 = ((_a9 = this.options.compareFns) == null ? void 0 : _a9[key]) ?? Object.is;
          if (isEqual3(prev2[key], next2[key])) continue;
          this.executeActions(fn, this.state.event);
        }
        prev2 = next2;
      });
      this.contextWatchers.add(cleanup);
    });
    __publicField(this, "stop", () => {
      if (this.status === "Stopped") return;
      this.performExitEffects(this.state.value, toEvent(
        "machine.stop"
        /* Stop */
      ));
      this.executeActions(this.config.exit, toEvent(
        "machine.stop"
        /* Stop */
      ));
      this.setState("");
      this.setEvent(
        "machine.stop"
        /* Stop */
      );
      this.stopStateListeners();
      this.stopChildren();
      this.stopActivities();
      this.stopDelayedEvents();
      this.stopContextWatchers();
      this.status = "Stopped";
      return this;
    });
    __publicField(this, "stopStateListeners", () => {
      this.removeStateListener();
      this.stateListeners.clear();
    });
    __publicField(this, "stopContextWatchers", () => {
      this.contextWatchers.forEach((fn) => fn());
      this.contextWatchers.clear();
    });
    __publicField(this, "stopDelayedEvents", () => {
      this.delayedEvents.forEach((state2) => {
        state2.forEach((stop) => stop());
      });
      this.delayedEvents.clear();
    });
    __publicField(this, "stopActivities", (state2) => {
      var _a9, _b8;
      if (state2) {
        (_a9 = this.activityEvents.get(state2)) == null ? void 0 : _a9.forEach((stop) => stop());
        (_b8 = this.activityEvents.get(state2)) == null ? void 0 : _b8.clear();
        this.activityEvents.delete(state2);
      } else {
        this.activityEvents.forEach((state22) => {
          state22.forEach((stop) => stop());
          state22.clear();
        });
        this.activityEvents.clear();
      }
    });
    __publicField(this, "sendChild", (evt, to) => {
      const event = toEvent(evt);
      const id = runIfFn(to, this.contextSnapshot);
      const child = this.children.get(id);
      if (!child) {
        invariant(`[@zag-js/core] Cannot send '${event.type}' event to unknown child`);
      }
      child.send(event);
    });
    __publicField(this, "stopChild", (id) => {
      if (!this.children.has(id)) {
        invariant(`[@zag-js/core > stop-child] Cannot stop unknown child ${id}`);
      }
      this.children.get(id).stop();
      this.children.delete(id);
    });
    __publicField(this, "removeChild", (id) => {
      this.children.delete(id);
    });
    __publicField(this, "stopChildren", () => {
      this.children.forEach((child) => child.stop());
      this.children.clear();
    });
    __publicField(this, "setParent", (parent) => {
      this.parent = parent;
    });
    __publicField(this, "spawn", (src, id) => {
      const actor = runIfFn(src);
      if (id) actor.id = id;
      actor.type = "machine.actor";
      actor.setParent(this);
      this.children.set(actor.id, cast(actor));
      actor.onDone(() => {
        this.removeChild(actor.id);
      }).start();
      return cast(ref(actor));
    });
    __publicField(this, "stopActivity", (key) => {
      var _a9;
      if (!this.state.value) return;
      const cleanups2 = this.activityEvents.get(this.state.value);
      (_a9 = cleanups2 == null ? void 0 : cleanups2.get(key)) == null ? void 0 : _a9();
      cleanups2 == null ? void 0 : cleanups2.delete(key);
    });
    __publicField(this, "addActivityCleanup", (state2, key, cleanup) => {
      var _a9;
      if (!state2) return;
      if (!this.activityEvents.has(state2)) {
        this.activityEvents.set(state2, /* @__PURE__ */ new Map([[key, cleanup]]));
      } else {
        (_a9 = this.activityEvents.get(state2)) == null ? void 0 : _a9.set(key, cleanup);
      }
    });
    __publicField(this, "setState", (target) => {
      this.state.previousValue = this.state.value;
      this.state.value = target;
      const stateNode = this.getStateNode(target);
      if (target == null) {
        clear(this.state.tags);
      } else {
        this.state.tags = toArray(stateNode == null ? void 0 : stateNode.tags);
      }
    });
    __publicField(this, "setContext", (context) => {
      if (!context) return;
      deepMerge(this.state.context, compact2(context));
    });
    __publicField(this, "setOptions", (options2) => {
      const opts = compact2(options2);
      this.actionMap = { ...this.actionMap, ...opts.actions };
      this.delayMap = { ...this.delayMap, ...opts.delays };
      this.activityMap = { ...this.activityMap, ...opts.activities };
      this.guardMap = { ...this.guardMap, ...opts.guards };
    });
    __publicField(this, "getStateNode", (state2) => {
      var _a9;
      if (!state2) return;
      return (_a9 = this.config.states) == null ? void 0 : _a9[state2];
    });
    __publicField(this, "getNextStateInfo", (transitions, event) => {
      const transition = this.determineTransition(transitions, event);
      const isTargetless = !(transition == null ? void 0 : transition.target);
      const target = (transition == null ? void 0 : transition.target) ?? this.state.value;
      const changed = this.state.value !== target;
      const stateNode = this.getStateNode(target);
      const reenter = !isTargetless && !changed && !(transition == null ? void 0 : transition.internal);
      const info = {
        reenter,
        transition,
        stateNode,
        target,
        changed
      };
      this.log("NextState:", `[${event.type}]`, this.state.value, "---->", info.target);
      return info;
    });
    __publicField(this, "getAfterActions", (transition, delay2) => {
      let id;
      const current = this.state.value;
      return {
        entry: () => {
          id = globalThis.setTimeout(() => {
            const next2 = this.getNextStateInfo(transition, this.state.event);
            this.performStateChangeEffects(current, next2, this.state.event);
          }, delay2);
        },
        exit: () => {
          globalThis.clearTimeout(id);
        }
      };
    });
    __publicField(this, "getDelayedEventActions", (state2) => {
      const stateNode = this.getStateNode(state2);
      const event = this.state.event;
      if (!stateNode || !stateNode.after) return;
      const entries = [];
      const exits = [];
      if (isArray(stateNode.after)) {
        const transition = this.determineTransition(stateNode.after, event);
        if (!transition) return;
        if (!hasProp(transition, "delay")) {
          throw new Error(`[@zag-js/core > after] Delay is required for after transition: ${JSON.stringify(transition)}`);
        }
        const determineDelay = determineDelayFn(transition.delay, this.delayMap);
        const __delay = determineDelay(this.contextSnapshot, event);
        const actions = this.getAfterActions(transition, __delay);
        entries.push(actions.entry);
        exits.push(actions.exit);
        return { entries, exits };
      }
      if (isObject3(stateNode.after)) {
        for (const delay2 in stateNode.after) {
          const transition = stateNode.after[delay2];
          const determineDelay = determineDelayFn(delay2, this.delayMap);
          const __delay = determineDelay(this.contextSnapshot, event);
          const actions = this.getAfterActions(transition, __delay);
          entries.push(actions.entry);
          exits.push(actions.exit);
        }
      }
      return { entries, exits };
    });
    __publicField(this, "executeActions", (actions, event) => {
      var _a9;
      const pickedActions = determineActionsFn(actions, this.guardMap)(this.contextSnapshot, event, this.guardMeta);
      for (const action of toArray(pickedActions)) {
        const fn = isString2(action) ? (_a9 = this.actionMap) == null ? void 0 : _a9[action] : action;
        warn(
          isString2(action) && !fn,
          `[@zag-js/core > execute-actions] No implementation found for action: \`${action}\``
        );
        fn == null ? void 0 : fn(this.state.context, event, this.meta);
      }
    });
    __publicField(this, "executeActivities", (event, activities, state2) => {
      var _a9;
      for (const activity of activities) {
        const fn = isString2(activity) ? (_a9 = this.activityMap) == null ? void 0 : _a9[activity] : activity;
        if (!fn) {
          warn(`[@zag-js/core > execute-activity] No implementation found for activity: \`${activity}\``);
          continue;
        }
        const cleanup = fn(this.state.context, event, this.meta);
        if (cleanup) {
          const key = isString2(activity) ? activity : activity.name || uuid();
          this.addActivityCleanup(state2 ?? this.state.value, key, cleanup);
        }
      }
    });
    __publicField(this, "createEveryActivities", (every, callbackfn) => {
      if (!every) return;
      if (isArray(every)) {
        const picked = toArray(every).find((transition) => {
          const delayOrFn = transition.delay;
          const determineDelay2 = determineDelayFn(delayOrFn, this.delayMap);
          const delay22 = determineDelay2(this.contextSnapshot, this.state.event);
          const determineGuard = determineGuardFn(transition.guard, this.guardMap);
          const guard = determineGuard(this.contextSnapshot, this.state.event, this.guardMeta);
          return guard ?? delay22 != null;
        });
        if (!picked) return;
        const determineDelay = determineDelayFn(picked.delay, this.delayMap);
        const delay2 = determineDelay(this.contextSnapshot, this.state.event);
        const activity = () => {
          const id = globalThis.setInterval(() => {
            this.executeActions(picked.actions, this.state.event);
          }, delay2);
          return () => {
            globalThis.clearInterval(id);
          };
        };
        callbackfn(activity);
      } else {
        for (const interval in every) {
          const actions = every == null ? void 0 : every[interval];
          const determineDelay = determineDelayFn(interval, this.delayMap);
          const delay2 = determineDelay(this.contextSnapshot, this.state.event);
          const activity = () => {
            const id = globalThis.setInterval(() => {
              this.executeActions(actions, this.state.event);
            }, delay2);
            return () => {
              globalThis.clearInterval(id);
            };
          };
          callbackfn(activity);
        }
      }
    });
    __publicField(this, "setEvent", (event) => {
      this.state.previousEvent = this.state.event;
      this.state.event = ref(toEvent(event));
    });
    __publicField(this, "performExitEffects", (current, event) => {
      const currentState = this.state.value;
      if (currentState === "") return;
      const stateNode = current ? this.getStateNode(current) : void 0;
      this.stopActivities(currentState);
      const _exit = determineActionsFn(stateNode == null ? void 0 : stateNode.exit, this.guardMap)(this.contextSnapshot, event, this.guardMeta);
      const exitActions = toArray(_exit);
      const afterExitActions = this.delayedEvents.get(currentState);
      if (afterExitActions) {
        exitActions.push(...afterExitActions);
      }
      this.executeActions(exitActions, event);
      this.delayedEvents.delete(currentState);
    });
    __publicField(this, "performEntryEffects", (next2, event) => {
      const stateNode = this.getStateNode(next2);
      const activities = toArray(stateNode == null ? void 0 : stateNode.activities);
      this.createEveryActivities(stateNode == null ? void 0 : stateNode.every, (activity) => {
        activities.unshift(activity);
      });
      if (activities.length > 0) {
        this.executeActivities(event, activities);
      }
      const pickedActions = determineActionsFn(stateNode == null ? void 0 : stateNode.entry, this.guardMap)(
        this.contextSnapshot,
        event,
        this.guardMeta
      );
      const entryActions = toArray(pickedActions);
      const afterActions = this.getDelayedEventActions(next2);
      if ((stateNode == null ? void 0 : stateNode.after) && afterActions) {
        this.delayedEvents.set(next2, afterActions == null ? void 0 : afterActions.exits);
        entryActions.push(...afterActions.entries);
      }
      this.executeActions(entryActions, event);
      if ((stateNode == null ? void 0 : stateNode.type) === "final") {
        this.state.done = true;
        this.doneListeners.forEach((listener) => {
          listener(this.stateSnapshot);
        });
        this.stop();
      }
    });
    __publicField(this, "performTransitionEffects", (transitions, event) => {
      const transition = this.determineTransition(transitions, event);
      this.executeActions(transition == null ? void 0 : transition.actions, event);
    });
    __publicField(this, "performStateChangeEffects", (current, next2, event) => {
      this.setEvent(event);
      const changed = next2.changed || next2.reenter;
      if (changed) {
        this.performExitEffects(current, event);
      }
      this.performTransitionEffects(next2.transition, event);
      this.setState(next2.target);
      if (changed) {
        this.performEntryEffects(next2.target, event);
      }
    });
    __publicField(this, "determineTransition", (transition, event) => {
      const fn = determineTransitionFn(transition, this.guardMap);
      return fn == null ? void 0 : fn(this.contextSnapshot, event, this.guardMeta);
    });
    __publicField(this, "sendParent", (evt) => {
      var _a9;
      if (!this.parent) {
        invariant("[@zag-js/core > send-parent] Cannot send event to an unknown parent");
      }
      const event = toEvent(evt);
      (_a9 = this.parent) == null ? void 0 : _a9.send(event);
    });
    __publicField(this, "log", (...args) => {
      if (isDev() && this.options.debug) {
        console.log(...args);
      }
    });
    __publicField(this, "send", (evt) => {
      const event = toEvent(evt);
      this.transition(this.state.value, event);
    });
    __publicField(this, "transition", (state2, evt) => {
      var _a9, _b8;
      const stateNode = isString2(state2) ? this.getStateNode(state2) : state2 == null ? void 0 : state2.stateNode;
      const event = toEvent(evt);
      if (!stateNode && !this.config.on) {
        const msg = this.status === "Stopped" ? "[@zag-js/core > transition] Cannot transition a stopped machine" : `[@zag-js/core > transition] State does not have a definition for \`state\`: ${state2}, \`event\`: ${event.type}`;
        warn(msg);
        return;
      }
      const transitions = (
        // @ts-expect-error - Fix this
        ((_a9 = stateNode == null ? void 0 : stateNode.on) == null ? void 0 : _a9[event.type]) ?? ((_b8 = this.config.on) == null ? void 0 : _b8[event.type])
      );
      const next2 = this.getNextStateInfo(transitions, event);
      this.performStateChangeEffects(this.state.value, next2, event);
      return next2.stateNode;
    });
    __publicField(this, "subscribe", (listener) => {
      this.stateListeners.add(listener);
      if (this.status === "Running") {
        listener(this.stateSnapshot);
      }
      return () => {
        this.stateListeners.delete(listener);
      };
    });
    __publicField(this, "onDone", (listener) => {
      this.doneListeners.add(listener);
      return this;
    });
    __publicField(this, "onTransition", (listener) => {
      this.stateListeners.add(listener);
      if (this.status === "Running") {
        listener(this.stateSnapshot);
      }
      return this;
    });
    this.config = clone2(config);
    this.options = clone2(options ?? {});
    this.id = this.config.id ?? `machine-${uuid()}`;
    this.guardMap = ((_a8 = this.options) == null ? void 0 : _a8.guards) ?? {};
    this.actionMap = ((_b7 = this.options) == null ? void 0 : _b7.actions) ?? {};
    this.delayMap = ((_c6 = this.options) == null ? void 0 : _c6.delays) ?? {};
    this.activityMap = ((_d6 = this.options) == null ? void 0 : _d6.activities) ?? {};
    this.sync = ((_e6 = this.options) == null ? void 0 : _e6.sync) ?? false;
    this.state = createProxy3(this.config);
    this.initialContext = snapshot(this.state.context);
  }
  // immutable state value
  get stateSnapshot() {
    return cast(snapshot(this.state));
  }
  getState() {
    return this.stateSnapshot;
  }
  // immutable context value
  get contextSnapshot() {
    return this.stateSnapshot.context;
  }
  /**
   * A reference to the instance methods of the machine.
   * Useful when spawning child machines and managing the communication between them.
   */
  get self() {
    const self2 = this;
    return {
      id: this.id,
      send: this.send.bind(this),
      sendParent: this.sendParent.bind(this),
      sendChild: this.sendChild.bind(this),
      stop: this.stop.bind(this),
      stopChild: this.stopChild.bind(this),
      spawn: this.spawn.bind(this),
      stopActivity: this.stopActivity.bind(this),
      get state() {
        return self2.stateSnapshot;
      },
      get initialContext() {
        return self2.initialContext;
      },
      get initialState() {
        var _a8;
        return ((_a8 = self2.initialState) == null ? void 0 : _a8.target) ?? "";
      }
    };
  }
  get meta() {
    var _a8;
    return {
      state: this.stateSnapshot,
      guards: this.guardMap,
      send: this.send.bind(this),
      self: this.self,
      initialContext: this.initialContext,
      initialState: ((_a8 = this.initialState) == null ? void 0 : _a8.target) ?? "",
      getState: () => this.stateSnapshot,
      getAction: (key) => this.actionMap[key],
      getGuard: (key) => this.guardMap[key]
    };
  }
  get guardMeta() {
    return {
      state: this.stateSnapshot
    };
  }
  get [Symbol.toStringTag]() {
    return "Machine";
  }
  getHydrationState() {
    const state2 = this.getState();
    return {
      value: state2.value,
      tags: state2.tags
    };
  }
};
var createMachine = (config, options) => new Machine(config, options);
var isMachine = (value) => {
  return value instanceof Machine || (value == null ? void 0 : value.type) === "machine";
};
var clsx = (...args) => args.map((str) => {
  var _a8;
  return (_a8 = str == null ? void 0 : str.trim) == null ? void 0 : _a8.call(str);
}).filter(Boolean).join(" ");
var CSS_REGEX = /((?:--)?(?:\w+-?)+)\s*:\s*([^;]*)/g;
var serialize = (style) => {
  const res = {};
  let match4;
  while (match4 = CSS_REGEX.exec(style)) {
    res[match4[1]] = match4[2];
  }
  return res;
};
var css = (a, b) => {
  if (isString2(a)) {
    if (isString2(b)) return `${a};${b}`;
    a = serialize(a);
  } else if (isString2(b)) {
    b = serialize(b);
  }
  return Object.assign({}, a ?? {}, b ?? {});
};
function mergeProps(...args) {
  let result = {};
  for (let props21 of args) {
    for (let key in result) {
      if (key.startsWith("on") && typeof result[key] === "function" && typeof props21[key] === "function") {
        result[key] = callAll(props21[key], result[key]);
        continue;
      }
      if (key === "className" || key === "class") {
        result[key] = clsx(result[key], props21[key]);
        continue;
      }
      if (key === "style") {
        result[key] = css(result[key], props21[key]);
        continue;
      }
      result[key] = props21[key] !== void 0 ? props21[key] : result[key];
    }
    for (let key in props21) {
      if (result[key] === void 0) {
        result[key] = props21[key];
      }
    }
  }
  return result;
}

// node_modules/@zag-js/types/dist/index.mjs
function createNormalizer(fn) {
  return new Proxy({}, {
    get() {
      return fn;
    }
  });
}
var createProps2 = () => (props21) => Array.from(new Set(props21));

// node_modules/@zag-js/accordion/dist/index.mjs
var anatomy = createAnatomy("accordion").parts("root", "item", "itemTrigger", "itemContent", "itemIndicator");
var parts = anatomy.build();
var dom = createScope({
  getRootId: (ctx) => {
    var _a8;
    return ((_a8 = ctx.ids) == null ? void 0 : _a8.root) ?? `accordion:${ctx.id}`;
  },
  getItemId: (ctx, value) => {
    var _a8, _b7;
    return ((_b7 = (_a8 = ctx.ids) == null ? void 0 : _a8.item) == null ? void 0 : _b7.call(_a8, value)) ?? `accordion:${ctx.id}:item:${value}`;
  },
  getItemContentId: (ctx, value) => {
    var _a8, _b7;
    return ((_b7 = (_a8 = ctx.ids) == null ? void 0 : _a8.itemContent) == null ? void 0 : _b7.call(_a8, value)) ?? `accordion:${ctx.id}:content:${value}`;
  },
  getItemTriggerId: (ctx, value) => {
    var _a8, _b7;
    return ((_b7 = (_a8 = ctx.ids) == null ? void 0 : _a8.itemTrigger) == null ? void 0 : _b7.call(_a8, value)) ?? `accordion:${ctx.id}:trigger:${value}`;
  },
  getRootEl: (ctx) => dom.getById(ctx, dom.getRootId(ctx)),
  getTriggerEls: (ctx) => {
    const ownerId = CSS.escape(dom.getRootId(ctx));
    const selector = `[aria-controls][data-ownedby='${ownerId}']:not([disabled])`;
    return queryAll(dom.getRootEl(ctx), selector);
  },
  getFirstTriggerEl: (ctx) => first(dom.getTriggerEls(ctx)),
  getLastTriggerEl: (ctx) => last(dom.getTriggerEls(ctx)),
  getNextTriggerEl: (ctx, id) => nextById(dom.getTriggerEls(ctx), dom.getItemTriggerId(ctx, id)),
  getPrevTriggerEl: (ctx, id) => prevById(dom.getTriggerEls(ctx), dom.getItemTriggerId(ctx, id))
});
function connect(state2, send, normalize2) {
  const focusedValue = state2.context.focusedValue;
  const value = state2.context.value;
  const multiple = state2.context.multiple;
  function setValue(value2) {
    let nextValue = value2;
    if (multiple && nextValue.length > 1) {
      nextValue = [nextValue[0]];
    }
    send({ type: "VALUE.SET", value: nextValue });
  }
  function getItemState(props22) {
    return {
      expanded: value.includes(props22.value),
      focused: focusedValue === props22.value,
      disabled: Boolean(props22.disabled ?? state2.context.disabled)
    };
  }
  return {
    focusedValue,
    value,
    setValue,
    getItemState,
    getRootProps() {
      return normalize2.element({
        ...parts.root.attrs,
        dir: state2.context.dir,
        id: dom.getRootId(state2.context),
        "data-orientation": state2.context.orientation
      });
    },
    getItemProps(props22) {
      const itemState = getItemState(props22);
      return normalize2.element({
        ...parts.item.attrs,
        dir: state2.context.dir,
        id: dom.getItemId(state2.context, props22.value),
        "data-state": itemState.expanded ? "open" : "closed",
        "data-focus": dataAttr(itemState.focused),
        "data-disabled": dataAttr(itemState.disabled),
        "data-orientation": state2.context.orientation
      });
    },
    getItemContentProps(props22) {
      const itemState = getItemState(props22);
      return normalize2.element({
        ...parts.itemContent.attrs,
        dir: state2.context.dir,
        role: "region",
        id: dom.getItemContentId(state2.context, props22.value),
        "aria-labelledby": dom.getItemTriggerId(state2.context, props22.value),
        hidden: !itemState.expanded,
        "data-state": itemState.expanded ? "open" : "closed",
        "data-disabled": dataAttr(itemState.disabled),
        "data-focus": dataAttr(itemState.focused),
        "data-orientation": state2.context.orientation
      });
    },
    getItemIndicatorProps(props22) {
      const itemState = getItemState(props22);
      return normalize2.element({
        ...parts.itemIndicator.attrs,
        dir: state2.context.dir,
        "aria-hidden": true,
        "data-state": itemState.expanded ? "open" : "closed",
        "data-disabled": dataAttr(itemState.disabled),
        "data-focus": dataAttr(itemState.focused),
        "data-orientation": state2.context.orientation
      });
    },
    getItemTriggerProps(props22) {
      const { value: value2 } = props22;
      const itemState = getItemState(props22);
      return normalize2.button({
        ...parts.itemTrigger.attrs,
        type: "button",
        dir: state2.context.dir,
        id: dom.getItemTriggerId(state2.context, value2),
        "aria-controls": dom.getItemContentId(state2.context, value2),
        "aria-expanded": itemState.expanded,
        disabled: itemState.disabled,
        "data-orientation": state2.context.orientation,
        "aria-disabled": itemState.disabled,
        "data-state": itemState.expanded ? "open" : "closed",
        "data-ownedby": dom.getRootId(state2.context),
        onFocus() {
          if (itemState.disabled) return;
          send({ type: "TRIGGER.FOCUS", value: value2 });
        },
        onBlur() {
          if (itemState.disabled) return;
          send("TRIGGER.BLUR");
        },
        onClick(event) {
          if (itemState.disabled) return;
          if (isSafari()) {
            event.currentTarget.focus();
          }
          send({ type: "TRIGGER.CLICK", value: value2 });
        },
        onKeyDown(event) {
          if (event.defaultPrevented) return;
          if (itemState.disabled) return;
          const keyMap2 = {
            ArrowDown() {
              if (state2.context.isHorizontal) return;
              send({ type: "GOTO.NEXT", value: value2 });
            },
            ArrowUp() {
              if (state2.context.isHorizontal) return;
              send({ type: "GOTO.PREV", value: value2 });
            },
            ArrowRight() {
              if (!state2.context.isHorizontal) return;
              send({ type: "GOTO.NEXT", value: value2 });
            },
            ArrowLeft() {
              if (!state2.context.isHorizontal) return;
              send({ type: "GOTO.PREV", value: value2 });
            },
            Home() {
              send({ type: "GOTO.FIRST", value: value2 });
            },
            End() {
              send({ type: "GOTO.LAST", value: value2 });
            }
          };
          const key = getEventKey(event, {
            dir: state2.context.dir,
            orientation: state2.context.orientation
          });
          const exec2 = keyMap2[key];
          if (exec2) {
            exec2(event);
            event.preventDefault();
          }
        }
      });
    }
  };
}
var { and: and2, not: not2 } = guards;
function machine(userContext) {
  const ctx = compact2(userContext);
  return createMachine(
    {
      id: "accordion",
      initial: "idle",
      context: {
        focusedValue: null,
        value: [],
        collapsible: false,
        multiple: false,
        orientation: "vertical",
        ...ctx
      },
      watch: {
        value: "coarseValue",
        multiple: "coarseValue"
      },
      created: "coarseValue",
      computed: {
        isHorizontal: (ctx2) => ctx2.orientation === "horizontal"
      },
      on: {
        "VALUE.SET": {
          actions: ["setValue"]
        }
      },
      states: {
        idle: {
          on: {
            "TRIGGER.FOCUS": {
              target: "focused",
              actions: "setFocusedValue"
            }
          }
        },
        focused: {
          on: {
            "GOTO.NEXT": {
              actions: "focusNextTrigger"
            },
            "GOTO.PREV": {
              actions: "focusPrevTrigger"
            },
            "TRIGGER.CLICK": [
              {
                guard: and2("isExpanded", "canToggle"),
                actions: ["collapse"]
              },
              {
                guard: not2("isExpanded"),
                actions: ["expand"]
              }
            ],
            "GOTO.FIRST": {
              actions: "focusFirstTrigger"
            },
            "GOTO.LAST": {
              actions: "focusLastTrigger"
            },
            "TRIGGER.BLUR": {
              target: "idle",
              actions: "clearFocusedValue"
            }
          }
        }
      }
    },
    {
      guards: {
        canToggle: (ctx2) => !!ctx2.collapsible || !!ctx2.multiple,
        isExpanded: (ctx2, evt) => ctx2.value.includes(evt.value)
      },
      actions: {
        collapse(ctx2, evt) {
          const next2 = ctx2.multiple ? remove(ctx2.value, evt.value) : [];
          set3.value(ctx2, ctx2.multiple ? next2 : []);
        },
        expand(ctx2, evt) {
          const next2 = ctx2.multiple ? add2(ctx2.value, evt.value) : [evt.value];
          set3.value(ctx2, next2);
        },
        focusFirstTrigger(ctx2) {
          var _a8;
          (_a8 = dom.getFirstTriggerEl(ctx2)) == null ? void 0 : _a8.focus();
        },
        focusLastTrigger(ctx2) {
          var _a8;
          (_a8 = dom.getLastTriggerEl(ctx2)) == null ? void 0 : _a8.focus();
        },
        focusNextTrigger(ctx2) {
          if (!ctx2.focusedValue) return;
          const triggerEl = dom.getNextTriggerEl(ctx2, ctx2.focusedValue);
          triggerEl == null ? void 0 : triggerEl.focus();
        },
        focusPrevTrigger(ctx2) {
          if (!ctx2.focusedValue) return;
          const triggerEl = dom.getPrevTriggerEl(ctx2, ctx2.focusedValue);
          triggerEl == null ? void 0 : triggerEl.focus();
        },
        setFocusedValue(ctx2, evt) {
          set3.focusedValue(ctx2, evt.value);
        },
        clearFocusedValue(ctx2) {
          set3.focusedValue(ctx2, null);
        },
        setValue(ctx2, evt) {
          set3.value(ctx2, evt.value);
        },
        coarseValue(ctx2) {
          if (!ctx2.multiple && ctx2.value.length > 1) {
            warn(`The value of accordion should be a single value when multiple is false.`);
            ctx2.value = [ctx2.value[0]];
          }
        }
      }
    }
  );
}
var invoke = {
  change(ctx) {
    var _a8;
    (_a8 = ctx.onValueChange) == null ? void 0 : _a8.call(ctx, { value: Array.from(ctx.value) });
  },
  focusChange(ctx) {
    var _a8;
    (_a8 = ctx.onFocusChange) == null ? void 0 : _a8.call(ctx, { value: ctx.focusedValue });
  }
};
var set3 = {
  value(ctx, value) {
    if (isEqual(ctx.value, value)) return;
    ctx.value = value;
    invoke.change(ctx);
  },
  focusedValue(ctx, value) {
    if (isEqual(ctx.focusedValue, value)) return;
    ctx.focusedValue = value;
    invoke.focusChange(ctx);
  }
};
var props = createProps2()([
  "collapsible",
  "dir",
  "disabled",
  "getRootNode",
  "id",
  "ids",
  "multiple",
  "onFocusChange",
  "onValueChange",
  "orientation",
  "value"
]);
var splitProps3 = createSplitProps(props);
var itemProps = createProps2()(["value", "disabled"]);
var splitItemProps = createSplitProps(itemProps);

// node_modules/@zag-js/react/dist/index.mjs
var import_react2 = __toESM(require_react(), 1);
var import_react_dom = __toESM(require_react_dom(), 1);
var import_jsx_runtime = __toESM(require_jsx_runtime(), 1);
var normalizeProps = createNormalizer((v) => v);
var isArrayLike2 = (value) => (value == null ? void 0 : value.constructor.name) === "Array";
var isArrayEqual2 = (a, b) => {
  if (a.length !== b.length) return false;
  for (let i = 0; i < a.length; i++) {
    if (!isEqual2(a[i], b[i])) return false;
  }
  return true;
};
var isEqual2 = (a, b) => {
  if (Object.is(a, b)) return true;
  if (a == null && b != null || a != null && b == null) return false;
  if (typeof (a == null ? void 0 : a.isEqual) === "function" && typeof (b == null ? void 0 : b.isEqual) === "function") {
    return a.isEqual(b);
  }
  if (typeof a === "function" && typeof b === "function") {
    return a.toString() === b.toString();
  }
  if (isArrayLike2(a) && isArrayLike2(b)) {
    return isArrayEqual2(Array.from(a), Array.from(b));
  }
  if (!(typeof a === "object") || !(typeof b === "object")) return false;
  const keys = Object.keys(b ?? /* @__PURE__ */ Object.create(null));
  const length = keys.length;
  for (let i = 0; i < length; i++) {
    const hasKey = Reflect.has(a, keys[i]);
    if (!hasKey) return false;
  }
  for (let i = 0; i < length; i++) {
    const key = keys[i];
    if (!isEqual2(a[key], b[key])) return false;
  }
  return true;
};
var isDev3 = () => true;
var fnToString2 = Function.prototype.toString;
fnToString2.call(Object);
function compact3(obj) {
  if (!isPlainObject3(obj) || obj === void 0) return obj;
  const keys = Reflect.ownKeys(obj).filter((key) => typeof key === "string");
  const filtered = {};
  for (const key of keys) {
    const value = obj[key];
    if (value !== void 0) {
      filtered[key] = compact3(value);
    }
  }
  return filtered;
}
var isPlainObject3 = (v) => {
  return v && typeof v === "object" && v.constructor === Object;
};
function useUpdateEffect(callback, deps) {
  const render = (0, import_react2.useRef)(false);
  const effect = (0, import_react2.useRef)(false);
  (0, import_react2.useEffect)(() => {
    const mounted = render.current;
    const run = mounted && effect.current;
    if (run) {
      return callback();
    }
    effect.current = true;
  }, deps);
  (0, import_react2.useEffect)(() => {
    render.current = true;
    return () => {
      render.current = false;
    };
  }, []);
}
var targetCache = globalRef("__zag__targetCache", () => /* @__PURE__ */ new WeakMap());
function useSnapshot(service, options) {
  const { actions, context, sync: notifyInSync } = options ?? {};
  const lastSnapshot = (0, import_react2.useRef)(void 0);
  const lastAffected = (0, import_react2.useRef)(void 0);
  const currSnapshot = (0, import_react2.useSyncExternalStore)(
    (0, import_react2.useCallback)((callback) => subscribe(service.state, callback, notifyInSync), [notifyInSync]),
    () => {
      const nextSnapshot = snapshot(service.state);
      try {
        if (lastSnapshot.current && lastAffected.current && !isChanged(lastSnapshot.current, nextSnapshot, lastAffected.current, /* @__PURE__ */ new WeakMap())) {
          return lastSnapshot.current;
        }
      } catch {
      }
      return nextSnapshot;
    },
    () => snapshot(service.state)
  );
  service.setOptions({ actions });
  const ctx = (0, import_react2.useMemo)(() => compact3(context ?? {}), [context]);
  useUpdateEffect(() => {
    const entries = Object.entries(ctx);
    const previousCtx = service.contextSnapshot ?? {};
    const equality = entries.map(([key, value]) => ({
      key,
      curr: value,
      prev: previousCtx[key],
      equal: isEqual2(previousCtx[key], value)
    }));
    const allEqual = equality.every(({ equal }) => equal);
    if (!allEqual) {
      service.setContext(ctx);
    }
  }, [ctx]);
  const currAffected = /* @__PURE__ */ new WeakMap();
  (0, import_react2.useEffect)(() => {
    lastSnapshot.current = currSnapshot;
    lastAffected.current = currAffected;
  });
  const proxyCache = (0, import_react2.useMemo)(() => /* @__PURE__ */ new WeakMap(), []);
  return createProxy2(currSnapshot, currAffected, proxyCache, targetCache);
}
function useActor(service) {
  const state2 = useSnapshot(service);
  return [state2, service.send];
}
function useConstant(fn) {
  const ref2 = (0, import_react2.useRef)(void 0);
  if (!ref2.current) ref2.current = { v: fn() };
  return ref2.current.v;
}
var useSafeLayoutEffect = typeof document !== "undefined" ? import_react2.useLayoutEffect : import_react2.useEffect;
function useService(machine24, options) {
  const { state: hydratedState, context } = options ?? {};
  const service = useConstant(() => {
    const instance = typeof machine24 === "function" ? machine24() : machine24;
    if (context) instance.setContext(context);
    instance._created();
    return instance;
  });
  const snapshotRef = (0, import_react2.useRef)(void 0);
  useSafeLayoutEffect(() => {
    const stateInit = hydratedState ?? snapshotRef.current;
    service.start(stateInit);
    return () => {
      if (isDev3()) {
        snapshotRef.current = service.getHydrationState();
      }
      service.stop();
    };
  }, []);
  return service;
}
function useMachine(machine24, options) {
  const service = useService(machine24, options);
  const state2 = useSnapshot(service, options);
  return [state2, service.send, service];
}

// node_modules/@ark-ui/react/dist/components/accordion/accordion-item.js
var import_react10 = __toESM(require_react(), 1);

// node_modules/@ark-ui/react/dist/components/accordion/use-accordion-item-context.js
var [AccordionItemProvider, useAccordionItemContext] = createContext({
  name: "AccordionItemContext",
  hookName: "useAccordionItemContext",
  providerName: "<AccordionItemProvider />"
});

// node_modules/@ark-ui/react/dist/components/collapsible/collapsible-root.js
var import_jsx_runtime2 = __toESM(require_jsx_runtime(), 1);
var import_react8 = __toESM(require_react(), 1);

// node_modules/@ark-ui/react/dist/components/factory.js
var import_react3 = __toESM(require_react(), 1);

// node_modules/@ark-ui/react/dist/utils/compose-refs.js
function setRef(ref2, value) {
  if (typeof ref2 === "function") {
    ref2(value);
  } else if (ref2 !== null && ref2 !== void 0) {
    ref2.current = value;
  }
}
function composeRefs(...refs) {
  return (node) => {
    for (const ref2 of refs) {
      setRef(ref2, node);
    }
  };
}

// node_modules/@ark-ui/react/dist/components/factory.js
function getRef(element) {
  var _a8, _b7;
  let getter = (_a8 = Object.getOwnPropertyDescriptor(element.props, "ref")) == null ? void 0 : _a8.get;
  let mayWarn = getter && "isReactWarning" in getter && getter.isReactWarning;
  if (mayWarn) {
    return element.ref;
  }
  getter = (_b7 = Object.getOwnPropertyDescriptor(element, "ref")) == null ? void 0 : _b7.get;
  mayWarn = getter && "isReactWarning" in getter && getter.isReactWarning;
  if (mayWarn) {
    return element.props.ref;
  }
  return element.props.ref || element.ref;
}
var withAsChild = (Component) => {
  const Comp = (0, import_react3.memo)(
    (0, import_react3.forwardRef)((props21, ref2) => {
      const { asChild, children, ...restProps } = props21;
      if (!asChild) {
        return (0, import_react3.createElement)(Component, { ...restProps, ref: ref2 }, children);
      }
      const onlyChild = import_react3.Children.only(children);
      if (!(0, import_react3.isValidElement)(onlyChild)) {
        return null;
      }
      const childRef = getRef(onlyChild);
      return (0, import_react3.cloneElement)(onlyChild, {
        ...mergeProps(restProps, onlyChild.props),
        ref: ref2 ? composeRefs(ref2, childRef) : childRef
      });
    })
  );
  Comp.displayName = Component.displayName || Component.name;
  return Comp;
};
var jsxFactory = () => {
  const cache = /* @__PURE__ */ new Map();
  return new Proxy(withAsChild, {
    apply(_target, _thisArg, argArray) {
      return withAsChild(argArray[0]);
    },
    get(_, element) {
      const asElement = element;
      if (!cache.has(asElement)) {
        cache.set(asElement, withAsChild(asElement));
      }
      return cache.get(asElement);
    }
  });
};
var ark = jsxFactory();

// node_modules/@ark-ui/react/dist/utils/create-split-props.js
var createSplitProps2 = () => (props21, keys) => keys.reduce(
  (previousValue, currentValue) => {
    const [target, source] = previousValue;
    const key = currentValue;
    if (source[key] !== void 0) {
      target[key] = source[key];
    }
    delete source[key];
    return [target, source];
  },
  [{}, { ...props21 }]
);

// node_modules/@ark-ui/react/dist/components/collapsible/split-collapsible-props.js
var splitCollapsibleProps = (props21) => createSplitProps2()(props21, [
  "defaultOpen",
  "disabled",
  "id",
  "ids",
  "lazyMount",
  "onExitComplete",
  "onOpenChange",
  "open",
  "unmountOnExit"
]);

// node_modules/@zag-js/collapsible/dist/index.mjs
var anatomy2 = createAnatomy("collapsible").parts("root", "trigger", "content");
var parts2 = anatomy2.build();
var dom2 = createScope({
  getRootId: (ctx) => {
    var _a8;
    return ((_a8 = ctx.ids) == null ? void 0 : _a8.root) ?? `collapsible:${ctx.id}`;
  },
  getContentId: (ctx) => {
    var _a8;
    return ((_a8 = ctx.ids) == null ? void 0 : _a8.content) ?? `collapsible:${ctx.id}:content`;
  },
  getTriggerId: (ctx) => {
    var _a8;
    return ((_a8 = ctx.ids) == null ? void 0 : _a8.trigger) ?? `collapsible:${ctx.id}:trigger`;
  },
  getRootEl: (ctx) => dom2.getById(ctx, dom2.getRootId(ctx)),
  getContentEl: (ctx) => dom2.getById(ctx, dom2.getContentId(ctx)),
  getTriggerEl: (ctx) => dom2.getById(ctx, dom2.getTriggerId(ctx))
});
function connect2(state2, send, normalize2) {
  const visible = state2.matches("open", "closing");
  const open = state2.matches("open");
  const height = state2.context.height;
  const width = state2.context.width;
  const disabled = !!state2.context.disabled;
  const skip = !state2.context.initial && open;
  return {
    disabled,
    visible,
    open,
    measureSize() {
      send("SIZE.MEASURE");
    },
    setOpen(nextOpen) {
      if (nextOpen === open) return;
      send(nextOpen ? "OPEN" : "CLOSE");
    },
    getRootProps() {
      return normalize2.element({
        ...parts2.root.attrs,
        "data-state": open ? "open" : "closed",
        dir: state2.context.dir,
        id: dom2.getRootId(state2.context)
      });
    },
    getContentProps() {
      return normalize2.element({
        ...parts2.content.attrs,
        "data-collapsible": "",
        "data-state": skip ? void 0 : open ? "open" : "closed",
        id: dom2.getContentId(state2.context),
        "data-disabled": dataAttr(disabled),
        hidden: !visible,
        style: {
          "--height": height != null ? `${height}px` : void 0,
          "--width": width != null ? `${width}px` : void 0
        }
      });
    },
    getTriggerProps() {
      return normalize2.element({
        ...parts2.trigger.attrs,
        id: dom2.getTriggerId(state2.context),
        dir: state2.context.dir,
        type: "button",
        "data-state": open ? "open" : "closed",
        "data-disabled": dataAttr(disabled),
        "aria-controls": dom2.getContentId(state2.context),
        "aria-expanded": visible || false,
        onClick(event) {
          if (event.defaultPrevented) return;
          if (disabled) return;
          send({ type: open ? "CLOSE" : "OPEN", src: "trigger.click" });
        }
      });
    }
  };
}
function machine2(userContext) {
  const ctx = compact2(userContext);
  return createMachine(
    {
      id: "collapsible",
      initial: ctx.open ? "open" : "closed",
      context: {
        ...ctx,
        height: 0,
        width: 0,
        initial: false,
        stylesRef: null,
        unmountAnimationName: null
      },
      watch: {
        open: ["setInitial", "computeSize", "toggleVisibility"]
      },
      exit: ["clearInitial", "cleanupNode"],
      states: {
        closed: {
          tags: ["closed"],
          on: {
            "CONTROLLED.OPEN": "open",
            OPEN: [
              {
                guard: "isOpenControlled",
                actions: ["invokeOnOpen"]
              },
              {
                target: "open",
                actions: ["setInitial", "computeSize", "invokeOnOpen"]
              }
            ]
          }
        },
        closing: {
          tags: ["open"],
          activities: ["trackExitAnimation"],
          on: {
            "CONTROLLED.CLOSE": "closed",
            "CONTROLLED.OPEN": "open",
            OPEN: [
              {
                guard: "isOpenControlled",
                actions: ["invokeOnOpen"]
              },
              {
                target: "open",
                actions: ["setInitial", "invokeOnOpen"]
              }
            ],
            CLOSE: [
              {
                guard: "isOpenControlled",
                actions: ["invokeOnExitComplete"]
              },
              {
                target: "closed",
                actions: ["setInitial", "computeSize", "invokeOnExitComplete"]
              }
            ],
            "ANIMATION.END": {
              target: "closed",
              actions: ["invokeOnExitComplete", "clearInitial"]
            }
          }
        },
        open: {
          tags: ["open"],
          activities: ["trackEnterAnimation"],
          on: {
            "CONTROLLED.CLOSE": "closing",
            CLOSE: [
              {
                guard: "isOpenControlled",
                actions: ["invokeOnClose"]
              },
              {
                target: "closing",
                actions: ["setInitial", "computeSize", "invokeOnClose"]
              }
            ],
            "SIZE.MEASURE": {
              actions: ["measureSize"]
            },
            "ANIMATION.END": {
              actions: ["clearInitial"]
            }
          }
        }
      }
    },
    {
      guards: {
        isOpenControlled: (ctx2) => !!ctx2["open.controlled"]
      },
      activities: {
        trackEnterAnimation(ctx2, _evt, { send }) {
          let cleanup;
          const rafCleanup = raf(() => {
            const contentEl = dom2.getContentEl(ctx2);
            if (!contentEl) return;
            const animationName = getComputedStyle(contentEl).animationName;
            const hasNoAnimation = !animationName || animationName === "none";
            if (hasNoAnimation) {
              send({ type: "ANIMATION.END" });
              return;
            }
            const onEnd = (event) => {
              const target = getEventTarget(event);
              if (target === contentEl) {
                send({ type: "ANIMATION.END" });
              }
            };
            contentEl.addEventListener("animationend", onEnd);
            cleanup = () => {
              contentEl.removeEventListener("animationend", onEnd);
            };
          });
          return () => {
            rafCleanup();
            cleanup == null ? void 0 : cleanup();
          };
        },
        trackExitAnimation(ctx2, _evt, { send }) {
          let cleanup;
          const rafCleanup = raf(() => {
            const contentEl = dom2.getContentEl(ctx2);
            if (!contentEl) return;
            const animationName = getComputedStyle(contentEl).animationName;
            const hasNoAnimation = !animationName || animationName === "none";
            if (hasNoAnimation) {
              send({ type: "ANIMATION.END" });
              return;
            }
            const onEnd = (event) => {
              const win = contentEl.ownerDocument.defaultView || window;
              const animationName2 = win.getComputedStyle(contentEl).animationName;
              const target = getEventTarget(event);
              if (target === contentEl && animationName2 === ctx2.unmountAnimationName) {
                send({ type: "ANIMATION.END" });
              }
            };
            contentEl.addEventListener("animationend", onEnd);
            cleanup = () => {
              contentEl.removeEventListener("animationend", onEnd);
            };
          });
          return () => {
            rafCleanup();
            cleanup == null ? void 0 : cleanup();
          };
        }
      },
      actions: {
        setInitial(ctx2) {
          ctx2.initial = true;
        },
        clearInitial(ctx2) {
          raf(() => {
            ctx2.initial = false;
          });
        },
        cleanupNode(ctx2) {
          ctx2.stylesRef = null;
        },
        measureSize(ctx2) {
          const contentEl = dom2.getContentEl(ctx2);
          if (!contentEl) return;
          const { height, width } = contentEl.getBoundingClientRect();
          ctx2.height = height;
          ctx2.width = width;
        },
        computeSize(ctx2, evt) {
          var _a8;
          (_a8 = ctx2._rafCleanup) == null ? void 0 : _a8.call(ctx2);
          ctx2._rafCleanup = raf(() => {
            const contentEl = dom2.getContentEl(ctx2);
            if (!contentEl) return;
            ctx2.stylesRef || (ctx2.stylesRef = ref({
              animationName: contentEl.style.animationName,
              animationDuration: contentEl.style.animationDuration
            }));
            if (evt.type === "CLOSE" || !ctx2.open) {
              const win = contentEl.ownerDocument.defaultView || window;
              ctx2.unmountAnimationName = win.getComputedStyle(contentEl).animationName;
            }
            const hidden = contentEl.hidden;
            contentEl.style.animationName = "none";
            contentEl.style.animationDuration = "0s";
            contentEl.hidden = false;
            const rect = contentEl.getBoundingClientRect();
            ctx2.height = rect.height;
            ctx2.width = rect.width;
            if (ctx2.initial) {
              contentEl.style.animationName = ctx2.stylesRef.animationName;
              contentEl.style.animationDuration = ctx2.stylesRef.animationDuration;
            }
            contentEl.hidden = hidden;
          });
        },
        invokeOnOpen: (ctx2) => {
          var _a8;
          (_a8 = ctx2.onOpenChange) == null ? void 0 : _a8.call(ctx2, { open: true });
        },
        invokeOnClose: (ctx2) => {
          var _a8;
          (_a8 = ctx2.onOpenChange) == null ? void 0 : _a8.call(ctx2, { open: false });
        },
        invokeOnExitComplete(ctx2) {
          var _a8;
          (_a8 = ctx2.onExitComplete) == null ? void 0 : _a8.call(ctx2);
        },
        toggleVisibility: (ctx2, _evt, { send }) => {
          send({ type: ctx2.open ? "CONTROLLED.OPEN" : "CONTROLLED.CLOSE" });
        }
      }
    }
  );
}
var props2 = createProps2()([
  "dir",
  "disabled",
  "getRootNode",
  "id",
  "ids",
  "onExitComplete",
  "onOpenChange",
  "open.controlled",
  "open"
]);
var splitProps4 = createSplitProps(props2);

// node_modules/@ark-ui/react/dist/components/collapsible/use-collapsible.js
var import_react6 = __toESM(require_react(), 1);

// node_modules/@ark-ui/react/dist/providers/environment/use-environment-context.js
var [EnvironmentContextProvider, useEnvironmentContext] = createContext({
  name: "EnvironmentContext",
  hookName: "useEnvironmentContext",
  providerName: "<EnvironmentProvider />",
  strict: false,
  defaultValue: {
    getRootNode: () => document,
    getDocument: () => document,
    getWindow: () => window
  }
});

// node_modules/@ark-ui/react/dist/providers/locale/use-locale-context.js
var [LocaleContextProvider, useLocaleContext] = createContext({
  name: "LocaleContext",
  hookName: "useLocaleContext",
  providerName: "<LocaleProvider />",
  strict: false,
  defaultValue: { dir: "ltr", locale: "en-US" }
});

// node_modules/@ark-ui/react/dist/utils/use-event.js
var import_react4 = __toESM(require_react(), 1);
function useEvent(callback, opts = {}) {
  const { sync: sync5 = false } = opts;
  const callbackRef = useLatestRef(callback);
  return (0, import_react4.useCallback)(
    // biome-ignore lint/suspicious/noExplicitAny: <explanation>
    (...args) => {
      var _a8;
      if (sync5) return queueMicrotask(() => {
        var _a9;
        return (_a9 = callbackRef.current) == null ? void 0 : _a9.call(callbackRef, ...args);
      });
      return (_a8 = callbackRef.current) == null ? void 0 : _a8.call(callbackRef, ...args);
    },
    [sync5, callbackRef]
  );
}
function useLatestRef(value) {
  const ref2 = (0, import_react4.useRef)(value);
  ref2.current = value;
  return ref2;
}

// node_modules/@ark-ui/react/dist/components/collapsible/use-collapsible.js
var useCollapsible = (props21 = {}) => {
  const { lazyMount, unmountOnExit, ...collapsibleProps } = props21;
  const wasVisible = (0, import_react6.useRef)(false);
  const { dir } = useLocaleContext();
  const { getRootNode } = useEnvironmentContext();
  const initialContext = {
    id: (0, import_react6.useId)(),
    dir,
    getRootNode,
    open: props21.defaultOpen,
    "open.controlled": props21.open !== void 0,
    ...collapsibleProps
  };
  const context = {
    ...initialContext,
    open: props21.open,
    onOpenChange: useEvent(props21.onOpenChange, { sync: true })
  };
  const [state2, send] = useMachine(machine2(initialContext), { context });
  const api = connect2(state2, send, normalizeProps);
  if (api.visible) {
    wasVisible.current = true;
  }
  const isUnmounted = !api.visible && !wasVisible.current && lazyMount || unmountOnExit && !api.visible && wasVisible.current;
  return { ...api, isUnmounted };
};

// node_modules/@ark-ui/react/dist/components/collapsible/use-collapsible-context.js
var [CollapsibleProvider, useCollapsibleContext] = createContext({
  name: "CollapsibleContext",
  hookName: "useCollapsibleContext",
  providerName: "<CollapsibleProvider />"
});

// node_modules/@ark-ui/react/dist/components/collapsible/collapsible-root.js
var CollapsibleRoot = (0, import_react8.forwardRef)((props21, ref2) => {
  const [useCollapsibleProps, localProps] = splitCollapsibleProps(props21);
  const collapsible = useCollapsible(useCollapsibleProps);
  const mergedProps = mergeProps(collapsible.getRootProps(), localProps);
  return (0, import_jsx_runtime2.jsx)(CollapsibleProvider, { value: collapsible, children: (0, import_jsx_runtime2.jsx)(ark.div, { ...mergedProps, ref: ref2 }) });
});
CollapsibleRoot.displayName = "CollapsibleRoot";

// node_modules/@zag-js/color-utils/dist/index.mjs
var __defProp2 = Object.defineProperty;
var __defNormalProp2 = (obj, key, value) => key in obj ? __defProp2(obj, key, { enumerable: true, configurable: true, writable: true, value }) : obj[key] = value;
var __publicField2 = (obj, key, value) => __defNormalProp2(obj, key + "", value);
var generateRGB_R = (orientation, dir, zValue) => {
  const maskImage = `linear-gradient(to ${orientation[Number(!dir)]}, transparent, #000)`;
  const result = {
    areaStyles: {
      backgroundImage: `linear-gradient(to ${orientation[Number(dir)]},rgb(${zValue},0,0),rgb(${zValue},255,0))`
    },
    areaGradientStyles: {
      backgroundImage: `linear-gradient(to ${orientation[Number(dir)]},rgb(${zValue},0,255),rgb(${zValue},255,255))`,
      WebkitMaskImage: maskImage,
      maskImage
    }
  };
  return result;
};
var generateRGB_G = (orientation, dir, zValue) => {
  const maskImage = `linear-gradient(to ${orientation[Number(!dir)]}, transparent, #000)`;
  const result = {
    areaStyles: {
      backgroundImage: `linear-gradient(to ${orientation[Number(dir)]},rgb(0,${zValue},0),rgb(255,${zValue},0))`
    },
    areaGradientStyles: {
      backgroundImage: `linear-gradient(to ${orientation[Number(dir)]},rgb(0,${zValue},255),rgb(255,${zValue},255))`,
      WebkitMaskImage: maskImage,
      maskImage
    }
  };
  return result;
};
var generateRGB_B = (orientation, dir, zValue) => {
  const maskImage = `linear-gradient(to ${orientation[Number(!dir)]}, transparent, #000)`;
  const result = {
    areaStyles: {
      backgroundImage: `linear-gradient(to ${orientation[Number(dir)]},rgb(0,0,${zValue}),rgb(255,0,${zValue}))`
    },
    areaGradientStyles: {
      backgroundImage: `linear-gradient(to ${orientation[Number(dir)]},rgb(0,255,${zValue}),rgb(255,255,${zValue}))`,
      WebkitMaskImage: maskImage,
      maskImage
    }
  };
  return result;
};
var generateHSL_H = (orientation, dir, zValue) => {
  const result = {
    areaStyles: {},
    areaGradientStyles: {
      background: [
        `linear-gradient(to ${orientation[Number(dir)]}, hsla(0,0%,0%,1) 0%, hsla(0,0%,0%,0) 50%, hsla(0,0%,100%,0) 50%, hsla(0,0%,100%,1) 100%)`,
        `linear-gradient(to ${orientation[Number(!dir)]},hsl(0,0%,50%),hsla(0,0%,50%,0))`,
        `hsl(${zValue}, 100%, 50%)`
      ].join(",")
    }
  };
  return result;
};
var generateHSL_S = (orientation, dir, alphaValue) => {
  const result = {
    areaStyles: {},
    areaGradientStyles: {
      background: [
        `linear-gradient(to ${orientation[Number(!dir)]}, hsla(0,0%,0%,${alphaValue}) 0%, hsla(0,0%,0%,0) 50%, hsla(0,0%,100%,0) 50%, hsla(0,0%,100%,${alphaValue}) 100%)`,
        `linear-gradient(to ${orientation[Number(dir)]},hsla(0,100%,50%,${alphaValue}),hsla(60,100%,50%,${alphaValue}),hsla(120,100%,50%,${alphaValue}),hsla(180,100%,50%,${alphaValue}),hsla(240,100%,50%,${alphaValue}),hsla(300,100%,50%,${alphaValue}),hsla(359,100%,50%,${alphaValue}))`,
        "hsl(0, 0%, 50%)"
      ].join(",")
    }
  };
  return result;
};
var generateHSL_L = (orientation, dir, zValue) => {
  const result = {
    areaStyles: {},
    areaGradientStyles: {
      backgroundImage: [
        `linear-gradient(to ${orientation[Number(!dir)]},hsl(0,0%,${zValue}%),hsla(0,0%,${zValue}%,0))`,
        `linear-gradient(to ${orientation[Number(dir)]},hsl(0,100%,${zValue}%),hsl(60,100%,${zValue}%),hsl(120,100%,${zValue}%),hsl(180,100%,${zValue}%),hsl(240,100%,${zValue}%),hsl(300,100%,${zValue}%),hsl(360,100%,${zValue}%))`
      ].join(",")
    }
  };
  return result;
};
var generateHSB_H = (orientation, dir, zValue) => {
  const result = {
    areaStyles: {},
    areaGradientStyles: {
      background: [
        `linear-gradient(to ${orientation[Number(dir)]},hsl(0,0%,0%),hsla(0,0%,0%,0))`,
        `linear-gradient(to ${orientation[Number(!dir)]},hsl(0,0%,100%),hsla(0,0%,100%,0))`,
        `hsl(${zValue}, 100%, 50%)`
      ].join(",")
    }
  };
  return result;
};
var generateHSB_S = (orientation, dir, alphaValue) => {
  const result = {
    areaStyles: {},
    areaGradientStyles: {
      background: [
        `linear-gradient(to ${orientation[Number(!dir)]},hsla(0,0%,0%,${alphaValue}),hsla(0,0%,0%,0))`,
        `linear-gradient(to ${orientation[Number(dir)]},hsla(0,100%,50%,${alphaValue}),hsla(60,100%,50%,${alphaValue}),hsla(120,100%,50%,${alphaValue}),hsla(180,100%,50%,${alphaValue}),hsla(240,100%,50%,${alphaValue}),hsla(300,100%,50%,${alphaValue}),hsla(359,100%,50%,${alphaValue}))`,
        `linear-gradient(to ${orientation[Number(!dir)]},hsl(0,0%,0%),hsl(0,0%,100%))`
      ].join(",")
    }
  };
  return result;
};
var generateHSB_B = (orientation, dir, alphaValue) => {
  const result = {
    areaStyles: {},
    areaGradientStyles: {
      background: [
        `linear-gradient(to ${orientation[Number(!dir)]},hsla(0,0%,100%,${alphaValue}),hsla(0,0%,100%,0))`,
        `linear-gradient(to ${orientation[Number(dir)]},hsla(0,100%,50%,${alphaValue}),hsla(60,100%,50%,${alphaValue}),hsla(120,100%,50%,${alphaValue}),hsla(180,100%,50%,${alphaValue}),hsla(240,100%,50%,${alphaValue}),hsla(300,100%,50%,${alphaValue}),hsla(359,100%,50%,${alphaValue}))`,
        "#000"
      ].join(",")
    }
  };
  return result;
};
function getColorAreaGradient(color, options) {
  const { xChannel, yChannel, dir: dirProp = "ltr" } = options;
  const { zChannel } = color.getColorAxes({ xChannel, yChannel });
  const zValue = color.getChannelValue(zChannel);
  const { minValue: zMin, maxValue: zMax } = color.getChannelRange(zChannel);
  const orientation = ["top", dirProp === "rtl" ? "left" : "right"];
  let dir = false;
  let background = { areaStyles: {}, areaGradientStyles: {} };
  let alphaValue = (zValue - zMin) / (zMax - zMin);
  let isHSL = color.getFormat() === "hsla";
  switch (zChannel) {
    case "red": {
      dir = xChannel === "green";
      background = generateRGB_R(orientation, dir, zValue);
      break;
    }
    case "green": {
      dir = xChannel === "red";
      background = generateRGB_G(orientation, dir, zValue);
      break;
    }
    case "blue": {
      dir = xChannel === "red";
      background = generateRGB_B(orientation, dir, zValue);
      break;
    }
    case "hue": {
      dir = xChannel !== "saturation";
      if (isHSL) {
        background = generateHSL_H(orientation, dir, zValue);
      } else {
        background = generateHSB_H(orientation, dir, zValue);
      }
      break;
    }
    case "saturation": {
      dir = xChannel === "hue";
      if (isHSL) {
        background = generateHSL_S(orientation, dir, alphaValue);
      } else {
        background = generateHSB_S(orientation, dir, alphaValue);
      }
      break;
    }
    case "brightness": {
      dir = xChannel === "hue";
      background = generateHSB_B(orientation, dir, alphaValue);
      break;
    }
    case "lightness": {
      dir = xChannel === "hue";
      background = generateHSL_L(orientation, dir, zValue);
      break;
    }
  }
  return background;
}
var isEqualObject = (a, b) => {
  if (Object.keys(a).length !== Object.keys(b).length) return false;
  for (let key in a) if (a[key] !== b[key]) return false;
  return true;
};
var Color = class {
  toHexInt() {
    return this.toFormat("rgba").toHexInt();
  }
  getChannelValue(channel) {
    if (channel in this) return this[channel];
    throw new Error("Unsupported color channel: " + channel);
  }
  getChannelValuePercent(channel, valueToCheck) {
    const value = valueToCheck ?? this.getChannelValue(channel);
    const { minValue, maxValue: maxValue2 } = this.getChannelRange(channel);
    return getValuePercent(value, minValue, maxValue2);
  }
  getChannelPercentValue(channel, percentToCheck) {
    const { minValue, maxValue: maxValue2, step } = this.getChannelRange(channel);
    const percentValue = getPercentValue(percentToCheck, minValue, maxValue2, step);
    return snapValueToStep(percentValue, minValue, maxValue2, step);
  }
  withChannelValue(channel, value) {
    const { minValue, maxValue: maxValue2 } = this.getChannelRange(channel);
    if (channel in this) {
      let clone3 = this.clone();
      clone3[channel] = clampValue(value, minValue, maxValue2);
      return clone3;
    }
    throw new Error("Unsupported color channel: " + channel);
  }
  getColorAxes(xyChannels) {
    let { xChannel, yChannel } = xyChannels;
    let xCh = xChannel || this.getChannels().find((c) => c !== yChannel);
    let yCh = yChannel || this.getChannels().find((c) => c !== xCh);
    let zCh = this.getChannels().find((c) => c !== xCh && c !== yCh);
    return { xChannel: xCh, yChannel: yCh, zChannel: zCh };
  }
  incrementChannel(channel, stepSize) {
    const { minValue, maxValue: maxValue2, step } = this.getChannelRange(channel);
    const value = snapValueToStep(
      clampValue(this.getChannelValue(channel) + stepSize, minValue, maxValue2),
      minValue,
      maxValue2,
      step
    );
    return this.withChannelValue(channel, value);
  }
  decrementChannel(channel, stepSize) {
    return this.incrementChannel(channel, -stepSize);
  }
  isEqual(color) {
    const isSame = isEqualObject(this.toJSON(), color.toJSON());
    return isSame && this.getChannelValue("alpha") === color.getChannelValue("alpha");
  }
};
var _RGBColor = class _RGBColor2 extends Color {
  constructor(red, green, blue, alpha) {
    super();
    this.red = red;
    this.green = green;
    this.blue = blue;
    this.alpha = alpha;
  }
  static parse(value) {
    let colors2 = [];
    if (/^#[\da-f]+$/i.test(value) && [4, 5, 7, 9].includes(value.length)) {
      const values = (value.length < 6 ? value.replace(/[^#]/gi, "$&$&") : value).slice(1).split("");
      while (values.length > 0) {
        colors2.push(parseInt(values.splice(0, 2).join(""), 16));
      }
      colors2[3] = colors2[3] !== void 0 ? colors2[3] / 255 : void 0;
    }
    const match4 = value.match(/^rgba?\((.*)\)$/);
    if (match4 == null ? void 0 : match4[1]) {
      colors2 = match4[1].split(",").map((value2) => Number(value2.trim())).map((num, i) => clampValue(num, 0, i < 3 ? 255 : 1));
    }
    return colors2.length < 3 ? void 0 : new _RGBColor2(colors2[0], colors2[1], colors2[2], colors2[3] ?? 1);
  }
  toString(format) {
    switch (format) {
      case "hex":
        return "#" + (this.red.toString(16).padStart(2, "0") + this.green.toString(16).padStart(2, "0") + this.blue.toString(16).padStart(2, "0")).toUpperCase();
      case "hexa":
        return "#" + (this.red.toString(16).padStart(2, "0") + this.green.toString(16).padStart(2, "0") + this.blue.toString(16).padStart(2, "0") + Math.round(this.alpha * 255).toString(16).padStart(2, "0")).toUpperCase();
      case "rgb":
        return `rgb(${this.red}, ${this.green}, ${this.blue})`;
      case "css":
      case "rgba":
        return `rgba(${this.red}, ${this.green}, ${this.blue}, ${this.alpha})`;
      case "hsl":
        return this.toHSL().toString("hsl");
      case "hsb":
        return this.toHSB().toString("hsb");
      default:
        return this.toFormat(format).toString(format);
    }
  }
  toFormat(format) {
    switch (format) {
      case "rgba":
        return this;
      case "hsba":
        return this.toHSB();
      case "hsla":
        return this.toHSL();
      default:
        throw new Error("Unsupported color conversion: rgb -> " + format);
    }
  }
  toHexInt() {
    return this.red << 16 | this.green << 8 | this.blue;
  }
  /**
   * Converts an RGB color value to HSB.
   * Conversion formula adapted from https://en.wikipedia.org/wiki/HSL_and_HSV#From_RGB.
   * @returns An HSBColor object.
   */
  toHSB() {
    const red = this.red / 255;
    const green = this.green / 255;
    const blue = this.blue / 255;
    const min4 = Math.min(red, green, blue);
    const brightness = Math.max(red, green, blue);
    const chroma = brightness - min4;
    const saturation = brightness === 0 ? 0 : chroma / brightness;
    let hue = 0;
    if (chroma !== 0) {
      switch (brightness) {
        case red:
          hue = (green - blue) / chroma + (green < blue ? 6 : 0);
          break;
        case green:
          hue = (blue - red) / chroma + 2;
          break;
        case blue:
          hue = (red - green) / chroma + 4;
          break;
      }
      hue /= 6;
    }
    return new HSBColor(
      toFixedNumber(hue * 360, 2),
      toFixedNumber(saturation * 100, 2),
      toFixedNumber(brightness * 100, 2),
      toFixedNumber(this.alpha, 2)
    );
  }
  /**
   * Converts an RGB color value to HSL.
   * Conversion formula adapted from https://en.wikipedia.org/wiki/HSL_and_HSV#From_RGB.
   * @returns An HSLColor object.
   */
  toHSL() {
    const red = this.red / 255;
    const green = this.green / 255;
    const blue = this.blue / 255;
    const min4 = Math.min(red, green, blue);
    const max4 = Math.max(red, green, blue);
    const lightness = (max4 + min4) / 2;
    const chroma = max4 - min4;
    let hue = -1;
    let saturation = -1;
    if (chroma === 0) {
      hue = saturation = 0;
    } else {
      saturation = chroma / (lightness < 0.5 ? max4 + min4 : 2 - max4 - min4);
      switch (max4) {
        case red:
          hue = (green - blue) / chroma + (green < blue ? 6 : 0);
          break;
        case green:
          hue = (blue - red) / chroma + 2;
          break;
        case blue:
          hue = (red - green) / chroma + 4;
          break;
      }
      hue /= 6;
    }
    return new HSLColor(
      toFixedNumber(hue * 360, 2),
      toFixedNumber(saturation * 100, 2),
      toFixedNumber(lightness * 100, 2),
      toFixedNumber(this.alpha, 2)
    );
  }
  clone() {
    return new _RGBColor2(this.red, this.green, this.blue, this.alpha);
  }
  getChannelFormatOptions(channel) {
    switch (channel) {
      case "red":
      case "green":
      case "blue":
        return { style: "decimal" };
      case "alpha":
        return { style: "percent" };
      default:
        throw new Error("Unknown color channel: " + channel);
    }
  }
  formatChannelValue(channel, locale) {
    let options = this.getChannelFormatOptions(channel);
    let value = this.getChannelValue(channel);
    return new Intl.NumberFormat(locale, options).format(value);
  }
  getChannelRange(channel) {
    switch (channel) {
      case "red":
      case "green":
      case "blue":
        return { minValue: 0, maxValue: 255, step: 1, pageSize: 17 };
      case "alpha":
        return { minValue: 0, maxValue: 1, step: 0.01, pageSize: 0.1 };
      default:
        throw new Error("Unknown color channel: " + channel);
    }
  }
  toJSON() {
    return { r: this.red, g: this.green, b: this.blue, a: this.alpha };
  }
  getFormat() {
    return "rgba";
  }
  getChannels() {
    return _RGBColor2.colorChannels;
  }
};
__publicField2(_RGBColor, "colorChannels", ["red", "green", "blue"]);
var RGBColor = _RGBColor;
var HSL_REGEX = /hsl\(([-+]?\d+(?:.\d+)?\s*,\s*[-+]?\d+(?:.\d+)?%\s*,\s*[-+]?\d+(?:.\d+)?%)\)|hsla\(([-+]?\d+(?:.\d+)?\s*,\s*[-+]?\d+(?:.\d+)?%\s*,\s*[-+]?\d+(?:.\d+)?%\s*,\s*[-+]?\d(.\d+)?)\)/;
var _HSLColor = class _HSLColor2 extends Color {
  constructor(hue, saturation, lightness, alpha) {
    super();
    this.hue = hue;
    this.saturation = saturation;
    this.lightness = lightness;
    this.alpha = alpha;
  }
  static parse(value) {
    let m;
    if (m = value.match(HSL_REGEX)) {
      const [h, s, l, a] = (m[1] ?? m[2]).split(",").map((n) => Number(n.trim().replace("%", "")));
      return new _HSLColor2(mod(h, 360), clampValue(s, 0, 100), clampValue(l, 0, 100), clampValue(a ?? 1, 0, 1));
    }
  }
  toString(format) {
    switch (format) {
      case "hex":
        return this.toRGB().toString("hex");
      case "hexa":
        return this.toRGB().toString("hexa");
      case "hsl":
        return `hsl(${this.hue}, ${toFixedNumber(this.saturation, 2)}%, ${toFixedNumber(this.lightness, 2)}%)`;
      case "css":
      case "hsla":
        return `hsla(${this.hue}, ${toFixedNumber(this.saturation, 2)}%, ${toFixedNumber(this.lightness, 2)}%, ${this.alpha})`;
      case "hsb":
        return this.toHSB().toString("hsb");
      case "rgb":
        return this.toRGB().toString("rgb");
      default:
        return this.toFormat(format).toString(format);
    }
  }
  toFormat(format) {
    switch (format) {
      case "hsla":
        return this;
      case "hsba":
        return this.toHSB();
      case "rgba":
        return this.toRGB();
      default:
        throw new Error("Unsupported color conversion: hsl -> " + format);
    }
  }
  /**
   * Converts a HSL color to HSB.
   * Conversion formula adapted from https://en.wikipedia.org/wiki/HSL_and_HSV#HSL_to_HSV.
   * @returns An HSBColor object.
   */
  toHSB() {
    let saturation = this.saturation / 100;
    let lightness = this.lightness / 100;
    let brightness = lightness + saturation * Math.min(lightness, 1 - lightness);
    saturation = brightness === 0 ? 0 : 2 * (1 - lightness / brightness);
    return new HSBColor(
      toFixedNumber(this.hue, 2),
      toFixedNumber(saturation * 100, 2),
      toFixedNumber(brightness * 100, 2),
      toFixedNumber(this.alpha, 2)
    );
  }
  /**
   * Converts a HSL color to RGB.
   * Conversion formula adapted from https://en.wikipedia.org/wiki/HSL_and_HSV#HSL_to_RGB_alternative.
   * @returns An RGBColor object.
   */
  toRGB() {
    let hue = this.hue;
    let saturation = this.saturation / 100;
    let lightness = this.lightness / 100;
    let a = saturation * Math.min(lightness, 1 - lightness);
    let fn = (n, k = (n + hue / 30) % 12) => lightness - a * Math.max(Math.min(k - 3, 9 - k, 1), -1);
    return new RGBColor(
      Math.round(fn(0) * 255),
      Math.round(fn(8) * 255),
      Math.round(fn(4) * 255),
      toFixedNumber(this.alpha, 2)
    );
  }
  clone() {
    return new _HSLColor2(this.hue, this.saturation, this.lightness, this.alpha);
  }
  getChannelFormatOptions(channel) {
    switch (channel) {
      case "hue":
        return { style: "unit", unit: "degree", unitDisplay: "narrow" };
      case "saturation":
      case "lightness":
      case "alpha":
        return { style: "percent" };
      default:
        throw new Error("Unknown color channel: " + channel);
    }
  }
  formatChannelValue(channel, locale) {
    let options = this.getChannelFormatOptions(channel);
    let value = this.getChannelValue(channel);
    if (channel === "saturation" || channel === "lightness") {
      value /= 100;
    }
    return new Intl.NumberFormat(locale, options).format(value);
  }
  getChannelRange(channel) {
    switch (channel) {
      case "hue":
        return { minValue: 0, maxValue: 360, step: 1, pageSize: 15 };
      case "saturation":
      case "lightness":
        return { minValue: 0, maxValue: 100, step: 1, pageSize: 10 };
      case "alpha":
        return { minValue: 0, maxValue: 1, step: 0.01, pageSize: 0.1 };
      default:
        throw new Error("Unknown color channel: " + channel);
    }
  }
  toJSON() {
    return { h: this.hue, s: this.saturation, l: this.lightness, a: this.alpha };
  }
  getFormat() {
    return "hsla";
  }
  getChannels() {
    return _HSLColor2.colorChannels;
  }
};
__publicField2(_HSLColor, "colorChannels", ["hue", "saturation", "lightness"]);
var HSLColor = _HSLColor;
var HSB_REGEX = /hsb\(([-+]?\d+(?:.\d+)?\s*,\s*[-+]?\d+(?:.\d+)?%\s*,\s*[-+]?\d+(?:.\d+)?%)\)|hsba\(([-+]?\d+(?:.\d+)?\s*,\s*[-+]?\d+(?:.\d+)?%\s*,\s*[-+]?\d+(?:.\d+)?%\s*,\s*[-+]?\d(.\d+)?)\)/;
var _HSBColor = class _HSBColor2 extends Color {
  constructor(hue, saturation, brightness, alpha) {
    super();
    this.hue = hue;
    this.saturation = saturation;
    this.brightness = brightness;
    this.alpha = alpha;
  }
  static parse(value) {
    let m;
    if (m = value.match(HSB_REGEX)) {
      const [h, s, b, a] = (m[1] ?? m[2]).split(",").map((n) => Number(n.trim().replace("%", "")));
      return new _HSBColor2(mod(h, 360), clampValue(s, 0, 100), clampValue(b, 0, 100), clampValue(a ?? 1, 0, 1));
    }
  }
  toString(format) {
    switch (format) {
      case "css":
        return this.toHSL().toString("css");
      case "hex":
        return this.toRGB().toString("hex");
      case "hexa":
        return this.toRGB().toString("hexa");
      case "hsb":
        return `hsb(${this.hue}, ${toFixedNumber(this.saturation, 2)}%, ${toFixedNumber(this.brightness, 2)}%)`;
      case "hsba":
        return `hsba(${this.hue}, ${toFixedNumber(this.saturation, 2)}%, ${toFixedNumber(this.brightness, 2)}%, ${this.alpha})`;
      case "hsl":
        return this.toHSL().toString("hsl");
      case "rgb":
        return this.toRGB().toString("rgb");
      default:
        return this.toFormat(format).toString(format);
    }
  }
  toFormat(format) {
    switch (format) {
      case "hsba":
        return this;
      case "hsla":
        return this.toHSL();
      case "rgba":
        return this.toRGB();
      default:
        throw new Error("Unsupported color conversion: hsb -> " + format);
    }
  }
  /**
   * Converts a HSB color to HSL.
   * Conversion formula adapted from https://en.wikipedia.org/wiki/HSL_and_HSV#HSV_to_HSL.
   * @returns An HSLColor object.
   */
  toHSL() {
    let saturation = this.saturation / 100;
    let brightness = this.brightness / 100;
    let lightness = brightness * (1 - saturation / 2);
    saturation = lightness === 0 || lightness === 1 ? 0 : (brightness - lightness) / Math.min(lightness, 1 - lightness);
    return new HSLColor(
      toFixedNumber(this.hue, 2),
      toFixedNumber(saturation * 100, 2),
      toFixedNumber(lightness * 100, 2),
      toFixedNumber(this.alpha, 2)
    );
  }
  /**
   * Converts a HSV color value to RGB.
   * Conversion formula adapted from https://en.wikipedia.org/wiki/HSL_and_HSV#HSV_to_RGB_alternative.
   * @returns An RGBColor object.
   */
  toRGB() {
    let hue = this.hue;
    let saturation = this.saturation / 100;
    let brightness = this.brightness / 100;
    let fn = (n, k = (n + hue / 60) % 6) => brightness - saturation * brightness * Math.max(Math.min(k, 4 - k, 1), 0);
    return new RGBColor(
      Math.round(fn(5) * 255),
      Math.round(fn(3) * 255),
      Math.round(fn(1) * 255),
      toFixedNumber(this.alpha, 2)
    );
  }
  clone() {
    return new _HSBColor2(this.hue, this.saturation, this.brightness, this.alpha);
  }
  getChannelFormatOptions(channel) {
    switch (channel) {
      case "hue":
        return { style: "unit", unit: "degree", unitDisplay: "narrow" };
      case "saturation":
      case "brightness":
      case "alpha":
        return { style: "percent" };
      default:
        throw new Error("Unknown color channel: " + channel);
    }
  }
  formatChannelValue(channel, locale) {
    let options = this.getChannelFormatOptions(channel);
    let value = this.getChannelValue(channel);
    if (channel === "saturation" || channel === "brightness") {
      value /= 100;
    }
    return new Intl.NumberFormat(locale, options).format(value);
  }
  getChannelRange(channel) {
    switch (channel) {
      case "hue":
        return { minValue: 0, maxValue: 360, step: 1, pageSize: 15 };
      case "saturation":
      case "brightness":
        return { minValue: 0, maxValue: 100, step: 1, pageSize: 10 };
      case "alpha":
        return { minValue: 0, maxValue: 1, step: 0.01, pageSize: 0.1 };
      default:
        throw new Error("Unknown color channel: " + channel);
    }
  }
  toJSON() {
    return { h: this.hue, s: this.saturation, b: this.brightness, a: this.alpha };
  }
  getFormat() {
    return "hsba";
  }
  getChannels() {
    return _HSBColor2.colorChannels;
  }
};
__publicField2(_HSBColor, "colorChannels", ["hue", "saturation", "brightness"]);
var HSBColor = _HSBColor;
var nativeColors = "aliceblue:f0f8ff,antiquewhite:faebd7,aqua:00ffff,aquamarine:7fffd4,azure:f0ffff,beige:f5f5dc,bisque:ffe4c4,black:000000,blanchedalmond:ffebcd,blue:0000ff,blueviolet:8a2be2,brown:a52a2a,burlywood:deb887,cadetblue:5f9ea0,chartreuse:7fff00,chocolate:d2691e,coral:ff7f50,cornflowerblue:6495ed,cornsilk:fff8dc,crimson:dc143c,cyan:00ffff,darkblue:00008b,darkcyan:008b8b,darkgoldenrod:b8860b,darkgray:a9a9a9,darkgreen:006400,darkkhaki:bdb76b,darkmagenta:8b008b,darkolivegreen:556b2f,darkorange:ff8c00,darkorchid:9932cc,darkred:8b0000,darksalmon:e9967a,darkseagreen:8fbc8f,darkslateblue:483d8b,darkslategray:2f4f4f,darkturquoise:00ced1,darkviolet:9400d3,deeppink:ff1493,deepskyblue:00bfff,dimgray:696969,dodgerblue:1e90ff,firebrick:b22222,floralwhite:fffaf0,forestgreen:228b22,fuchsia:ff00ff,gainsboro:dcdcdc,ghostwhite:f8f8ff,gold:ffd700,goldenrod:daa520,gray:808080,green:008000,greenyellow:adff2f,honeydew:f0fff0,hotpink:ff69b4,indianred:cd5c5c,indigo:4b0082,ivory:fffff0,khaki:f0e68c,lavender:e6e6fa,lavenderblush:fff0f5,lawngreen:7cfc00,lemonchiffon:fffacd,lightblue:add8e6,lightcoral:f08080,lightcyan:e0ffff,lightgoldenrodyellow:fafad2,lightgrey:d3d3d3,lightgreen:90ee90,lightpink:ffb6c1,lightsalmon:ffa07a,lightseagreen:20b2aa,lightskyblue:87cefa,lightslategray:778899,lightsteelblue:b0c4de,lightyellow:ffffe0,lime:00ff00,limegreen:32cd32,linen:faf0e6,magenta:ff00ff,maroon:800000,mediumaquamarine:66cdaa,mediumblue:0000cd,mediumorchid:ba55d3,mediumpurple:9370d8,mediumseagreen:3cb371,mediumslateblue:7b68ee,mediumspringgreen:00fa9a,mediumturquoise:48d1cc,mediumvioletred:c71585,midnightblue:191970,mintcream:f5fffa,mistyrose:ffe4e1,moccasin:ffe4b5,navajowhite:ffdead,navy:000080,oldlace:fdf5e6,olive:808000,olivedrab:6b8e23,orange:ffa500,orangered:ff4500,orchid:da70d6,palegoldenrod:eee8aa,palegreen:98fb98,paleturquoise:afeeee,palevioletred:d87093,papayawhip:ffefd5,peachpuff:ffdab9,peru:cd853f,pink:ffc0cb,plum:dda0dd,powderblue:b0e0e6,purple:800080,rebeccapurple:663399,red:ff0000,rosybrown:bc8f8f,royalblue:4169e1,saddlebrown:8b4513,salmon:fa8072,sandybrown:f4a460,seagreen:2e8b57,seashell:fff5ee,sienna:a0522d,silver:c0c0c0,skyblue:87ceeb,slateblue:6a5acd,slategray:708090,snow:fffafa,springgreen:00ff7f,steelblue:4682b4,tan:d2b48c,teal:008080,thistle:d8bfd8,tomato:ff6347,turquoise:40e0d0,violet:ee82ee,wheat:f5deb3,white:ffffff,whitesmoke:f5f5f5,yellow:ffff00,yellowgreen:9acd32";
var makeMap = (str) => {
  const map2 = /* @__PURE__ */ new Map();
  const list = str.split(",");
  for (let i = 0; i < list.length; i++) {
    const [key, val] = list[i].split(":");
    map2.set(key, `#${val}`);
    if (key.includes("gray")) map2.set(key.replace("gray", "grey"), `#${val}`);
  }
  return map2;
};
var nativeColorMap = makeMap(nativeColors);
var parseColor = (value) => {
  var _a8;
  if (nativeColorMap.has(value)) {
    return parseColor(nativeColorMap.get(value));
  }
  const result = RGBColor.parse(value) || HSBColor.parse(value) || HSLColor.parse(value);
  if (!result) {
    const error = new Error("Invalid color value: " + value);
    (_a8 = Error.captureStackTrace) == null ? void 0 : _a8.call(Error, error, parseColor);
    throw error;
  }
  return result;
};
var normalizeColor = (v) => {
  return typeof v === "string" ? parseColor(v) : v;
};

// node_modules/@floating-ui/utils/dist/floating-ui.utils.mjs
var sides = ["top", "right", "bottom", "left"];
var alignments = ["start", "end"];
var placements = sides.reduce((acc, side) => acc.concat(side, side + "-" + alignments[0], side + "-" + alignments[1]), []);
var min2 = Math.min;
var max2 = Math.max;
var round2 = Math.round;
var floor2 = Math.floor;
var createCoords = (v) => ({
  x: v,
  y: v
});
var oppositeSideMap = {
  left: "right",
  right: "left",
  bottom: "top",
  top: "bottom"
};
var oppositeAlignmentMap = {
  start: "end",
  end: "start"
};
function clamp2(start, value, end) {
  return max2(start, min2(value, end));
}
function evaluate(value, param) {
  return typeof value === "function" ? value(param) : value;
}
function getSide(placement) {
  return placement.split("-")[0];
}
function getAlignment(placement) {
  return placement.split("-")[1];
}
function getOppositeAxis(axis) {
  return axis === "x" ? "y" : "x";
}
function getAxisLength(axis) {
  return axis === "y" ? "height" : "width";
}
function getSideAxis(placement) {
  return ["top", "bottom"].includes(getSide(placement)) ? "y" : "x";
}
function getAlignmentAxis(placement) {
  return getOppositeAxis(getSideAxis(placement));
}
function getAlignmentSides(placement, rects, rtl) {
  if (rtl === void 0) {
    rtl = false;
  }
  const alignment = getAlignment(placement);
  const alignmentAxis = getAlignmentAxis(placement);
  const length = getAxisLength(alignmentAxis);
  let mainAlignmentSide = alignmentAxis === "x" ? alignment === (rtl ? "end" : "start") ? "right" : "left" : alignment === "start" ? "bottom" : "top";
  if (rects.reference[length] > rects.floating[length]) {
    mainAlignmentSide = getOppositePlacement(mainAlignmentSide);
  }
  return [mainAlignmentSide, getOppositePlacement(mainAlignmentSide)];
}
function getExpandedPlacements(placement) {
  const oppositePlacement = getOppositePlacement(placement);
  return [getOppositeAlignmentPlacement(placement), oppositePlacement, getOppositeAlignmentPlacement(oppositePlacement)];
}
function getOppositeAlignmentPlacement(placement) {
  return placement.replace(/start|end/g, (alignment) => oppositeAlignmentMap[alignment]);
}
function getSideList(side, isStart, rtl) {
  const lr = ["left", "right"];
  const rl = ["right", "left"];
  const tb = ["top", "bottom"];
  const bt = ["bottom", "top"];
  switch (side) {
    case "top":
    case "bottom":
      if (rtl) return isStart ? rl : lr;
      return isStart ? lr : rl;
    case "left":
    case "right":
      return isStart ? tb : bt;
    default:
      return [];
  }
}
function getOppositeAxisPlacements(placement, flipAlignment, direction, rtl) {
  const alignment = getAlignment(placement);
  let list = getSideList(getSide(placement), direction === "start", rtl);
  if (alignment) {
    list = list.map((side) => side + "-" + alignment);
    if (flipAlignment) {
      list = list.concat(list.map(getOppositeAlignmentPlacement));
    }
  }
  return list;
}
function getOppositePlacement(placement) {
  return placement.replace(/left|right|bottom|top/g, (side) => oppositeSideMap[side]);
}
function expandPaddingObject(padding) {
  return {
    top: 0,
    right: 0,
    bottom: 0,
    left: 0,
    ...padding
  };
}
function getPaddingObject(padding) {
  return typeof padding !== "number" ? expandPaddingObject(padding) : {
    top: padding,
    right: padding,
    bottom: padding,
    left: padding
  };
}
function rectToClientRect(rect) {
  const {
    x,
    y,
    width,
    height
  } = rect;
  return {
    width,
    height,
    top: y,
    left: x,
    right: x + width,
    bottom: y + height,
    x,
    y
  };
}

// node_modules/@floating-ui/core/dist/floating-ui.core.mjs
function computeCoordsFromPlacement(_ref, placement, rtl) {
  let {
    reference,
    floating
  } = _ref;
  const sideAxis = getSideAxis(placement);
  const alignmentAxis = getAlignmentAxis(placement);
  const alignLength = getAxisLength(alignmentAxis);
  const side = getSide(placement);
  const isVertical = sideAxis === "y";
  const commonX = reference.x + reference.width / 2 - floating.width / 2;
  const commonY = reference.y + reference.height / 2 - floating.height / 2;
  const commonAlign = reference[alignLength] / 2 - floating[alignLength] / 2;
  let coords;
  switch (side) {
    case "top":
      coords = {
        x: commonX,
        y: reference.y - floating.height
      };
      break;
    case "bottom":
      coords = {
        x: commonX,
        y: reference.y + reference.height
      };
      break;
    case "right":
      coords = {
        x: reference.x + reference.width,
        y: commonY
      };
      break;
    case "left":
      coords = {
        x: reference.x - floating.width,
        y: commonY
      };
      break;
    default:
      coords = {
        x: reference.x,
        y: reference.y
      };
  }
  switch (getAlignment(placement)) {
    case "start":
      coords[alignmentAxis] -= commonAlign * (rtl && isVertical ? -1 : 1);
      break;
    case "end":
      coords[alignmentAxis] += commonAlign * (rtl && isVertical ? -1 : 1);
      break;
  }
  return coords;
}
var computePosition = async (reference, floating, config) => {
  const {
    placement = "bottom",
    strategy = "absolute",
    middleware = [],
    platform: platform2
  } = config;
  const validMiddleware = middleware.filter(Boolean);
  const rtl = await (platform2.isRTL == null ? void 0 : platform2.isRTL(floating));
  let rects = await platform2.getElementRects({
    reference,
    floating,
    strategy
  });
  let {
    x,
    y
  } = computeCoordsFromPlacement(rects, placement, rtl);
  let statefulPlacement = placement;
  let middlewareData = {};
  let resetCount = 0;
  for (let i = 0; i < validMiddleware.length; i++) {
    const {
      name,
      fn
    } = validMiddleware[i];
    const {
      x: nextX,
      y: nextY,
      data,
      reset
    } = await fn({
      x,
      y,
      initialPlacement: placement,
      placement: statefulPlacement,
      strategy,
      middlewareData,
      rects,
      platform: platform2,
      elements: {
        reference,
        floating
      }
    });
    x = nextX != null ? nextX : x;
    y = nextY != null ? nextY : y;
    middlewareData = {
      ...middlewareData,
      [name]: {
        ...middlewareData[name],
        ...data
      }
    };
    if (reset && resetCount <= 50) {
      resetCount++;
      if (typeof reset === "object") {
        if (reset.placement) {
          statefulPlacement = reset.placement;
        }
        if (reset.rects) {
          rects = reset.rects === true ? await platform2.getElementRects({
            reference,
            floating,
            strategy
          }) : reset.rects;
        }
        ({
          x,
          y
        } = computeCoordsFromPlacement(rects, statefulPlacement, rtl));
      }
      i = -1;
    }
  }
  return {
    x,
    y,
    placement: statefulPlacement,
    strategy,
    middlewareData
  };
};
async function detectOverflow(state2, options) {
  var _await$platform$isEle;
  if (options === void 0) {
    options = {};
  }
  const {
    x,
    y,
    platform: platform2,
    rects,
    elements,
    strategy
  } = state2;
  const {
    boundary = "clippingAncestors",
    rootBoundary = "viewport",
    elementContext = "floating",
    altBoundary = false,
    padding = 0
  } = evaluate(options, state2);
  const paddingObject = getPaddingObject(padding);
  const altContext = elementContext === "floating" ? "reference" : "floating";
  const element = elements[altBoundary ? altContext : elementContext];
  const clippingClientRect = rectToClientRect(await platform2.getClippingRect({
    element: ((_await$platform$isEle = await (platform2.isElement == null ? void 0 : platform2.isElement(element))) != null ? _await$platform$isEle : true) ? element : element.contextElement || await (platform2.getDocumentElement == null ? void 0 : platform2.getDocumentElement(elements.floating)),
    boundary,
    rootBoundary,
    strategy
  }));
  const rect = elementContext === "floating" ? {
    x,
    y,
    width: rects.floating.width,
    height: rects.floating.height
  } : rects.reference;
  const offsetParent = await (platform2.getOffsetParent == null ? void 0 : platform2.getOffsetParent(elements.floating));
  const offsetScale = await (platform2.isElement == null ? void 0 : platform2.isElement(offsetParent)) ? await (platform2.getScale == null ? void 0 : platform2.getScale(offsetParent)) || {
    x: 1,
    y: 1
  } : {
    x: 1,
    y: 1
  };
  const elementClientRect = rectToClientRect(platform2.convertOffsetParentRelativeRectToViewportRelativeRect ? await platform2.convertOffsetParentRelativeRectToViewportRelativeRect({
    elements,
    rect,
    offsetParent,
    strategy
  }) : rect);
  return {
    top: (clippingClientRect.top - elementClientRect.top + paddingObject.top) / offsetScale.y,
    bottom: (elementClientRect.bottom - clippingClientRect.bottom + paddingObject.bottom) / offsetScale.y,
    left: (clippingClientRect.left - elementClientRect.left + paddingObject.left) / offsetScale.x,
    right: (elementClientRect.right - clippingClientRect.right + paddingObject.right) / offsetScale.x
  };
}
var arrow = (options) => ({
  name: "arrow",
  options,
  async fn(state2) {
    const {
      x,
      y,
      placement,
      rects,
      platform: platform2,
      elements,
      middlewareData
    } = state2;
    const {
      element,
      padding = 0
    } = evaluate(options, state2) || {};
    if (element == null) {
      return {};
    }
    const paddingObject = getPaddingObject(padding);
    const coords = {
      x,
      y
    };
    const axis = getAlignmentAxis(placement);
    const length = getAxisLength(axis);
    const arrowDimensions = await platform2.getDimensions(element);
    const isYAxis = axis === "y";
    const minProp = isYAxis ? "top" : "left";
    const maxProp = isYAxis ? "bottom" : "right";
    const clientProp = isYAxis ? "clientHeight" : "clientWidth";
    const endDiff = rects.reference[length] + rects.reference[axis] - coords[axis] - rects.floating[length];
    const startDiff = coords[axis] - rects.reference[axis];
    const arrowOffsetParent = await (platform2.getOffsetParent == null ? void 0 : platform2.getOffsetParent(element));
    let clientSize = arrowOffsetParent ? arrowOffsetParent[clientProp] : 0;
    if (!clientSize || !await (platform2.isElement == null ? void 0 : platform2.isElement(arrowOffsetParent))) {
      clientSize = elements.floating[clientProp] || rects.floating[length];
    }
    const centerToReference = endDiff / 2 - startDiff / 2;
    const largestPossiblePadding = clientSize / 2 - arrowDimensions[length] / 2 - 1;
    const minPadding = min2(paddingObject[minProp], largestPossiblePadding);
    const maxPadding = min2(paddingObject[maxProp], largestPossiblePadding);
    const min$1 = minPadding;
    const max4 = clientSize - arrowDimensions[length] - maxPadding;
    const center = clientSize / 2 - arrowDimensions[length] / 2 + centerToReference;
    const offset3 = clamp2(min$1, center, max4);
    const shouldAddOffset = !middlewareData.arrow && getAlignment(placement) != null && center !== offset3 && rects.reference[length] / 2 - (center < min$1 ? minPadding : maxPadding) - arrowDimensions[length] / 2 < 0;
    const alignmentOffset = shouldAddOffset ? center < min$1 ? center - min$1 : center - max4 : 0;
    return {
      [axis]: coords[axis] + alignmentOffset,
      data: {
        [axis]: offset3,
        centerOffset: center - offset3 - alignmentOffset,
        ...shouldAddOffset && {
          alignmentOffset
        }
      },
      reset: shouldAddOffset
    };
  }
});
var flip = function(options) {
  if (options === void 0) {
    options = {};
  }
  return {
    name: "flip",
    options,
    async fn(state2) {
      var _middlewareData$arrow, _middlewareData$flip;
      const {
        placement,
        middlewareData,
        rects,
        initialPlacement,
        platform: platform2,
        elements
      } = state2;
      const {
        mainAxis: checkMainAxis = true,
        crossAxis: checkCrossAxis = true,
        fallbackPlacements: specifiedFallbackPlacements,
        fallbackStrategy = "bestFit",
        fallbackAxisSideDirection = "none",
        flipAlignment = true,
        ...detectOverflowOptions
      } = evaluate(options, state2);
      if ((_middlewareData$arrow = middlewareData.arrow) != null && _middlewareData$arrow.alignmentOffset) {
        return {};
      }
      const side = getSide(placement);
      const initialSideAxis = getSideAxis(initialPlacement);
      const isBasePlacement = getSide(initialPlacement) === initialPlacement;
      const rtl = await (platform2.isRTL == null ? void 0 : platform2.isRTL(elements.floating));
      const fallbackPlacements = specifiedFallbackPlacements || (isBasePlacement || !flipAlignment ? [getOppositePlacement(initialPlacement)] : getExpandedPlacements(initialPlacement));
      const hasFallbackAxisSideDirection = fallbackAxisSideDirection !== "none";
      if (!specifiedFallbackPlacements && hasFallbackAxisSideDirection) {
        fallbackPlacements.push(...getOppositeAxisPlacements(initialPlacement, flipAlignment, fallbackAxisSideDirection, rtl));
      }
      const placements2 = [initialPlacement, ...fallbackPlacements];
      const overflow = await detectOverflow(state2, detectOverflowOptions);
      const overflows = [];
      let overflowsData = ((_middlewareData$flip = middlewareData.flip) == null ? void 0 : _middlewareData$flip.overflows) || [];
      if (checkMainAxis) {
        overflows.push(overflow[side]);
      }
      if (checkCrossAxis) {
        const sides2 = getAlignmentSides(placement, rects, rtl);
        overflows.push(overflow[sides2[0]], overflow[sides2[1]]);
      }
      overflowsData = [...overflowsData, {
        placement,
        overflows
      }];
      if (!overflows.every((side2) => side2 <= 0)) {
        var _middlewareData$flip2, _overflowsData$filter;
        const nextIndex2 = (((_middlewareData$flip2 = middlewareData.flip) == null ? void 0 : _middlewareData$flip2.index) || 0) + 1;
        const nextPlacement = placements2[nextIndex2];
        if (nextPlacement) {
          return {
            data: {
              index: nextIndex2,
              overflows: overflowsData
            },
            reset: {
              placement: nextPlacement
            }
          };
        }
        let resetPlacement = (_overflowsData$filter = overflowsData.filter((d) => d.overflows[0] <= 0).sort((a, b) => a.overflows[1] - b.overflows[1])[0]) == null ? void 0 : _overflowsData$filter.placement;
        if (!resetPlacement) {
          switch (fallbackStrategy) {
            case "bestFit": {
              var _overflowsData$filter2;
              const placement2 = (_overflowsData$filter2 = overflowsData.filter((d) => {
                if (hasFallbackAxisSideDirection) {
                  const currentSideAxis = getSideAxis(d.placement);
                  return currentSideAxis === initialSideAxis || // Create a bias to the `y` side axis due to horizontal
                  // reading directions favoring greater width.
                  currentSideAxis === "y";
                }
                return true;
              }).map((d) => [d.placement, d.overflows.filter((overflow2) => overflow2 > 0).reduce((acc, overflow2) => acc + overflow2, 0)]).sort((a, b) => a[1] - b[1])[0]) == null ? void 0 : _overflowsData$filter2[0];
              if (placement2) {
                resetPlacement = placement2;
              }
              break;
            }
            case "initialPlacement":
              resetPlacement = initialPlacement;
              break;
          }
        }
        if (placement !== resetPlacement) {
          return {
            reset: {
              placement: resetPlacement
            }
          };
        }
      }
      return {};
    }
  };
};
function getSideOffsets(overflow, rect) {
  return {
    top: overflow.top - rect.height,
    right: overflow.right - rect.width,
    bottom: overflow.bottom - rect.height,
    left: overflow.left - rect.width
  };
}
function isAnySideFullyClipped(overflow) {
  return sides.some((side) => overflow[side] >= 0);
}
var hide = function(options) {
  if (options === void 0) {
    options = {};
  }
  return {
    name: "hide",
    options,
    async fn(state2) {
      const {
        rects
      } = state2;
      const {
        strategy = "referenceHidden",
        ...detectOverflowOptions
      } = evaluate(options, state2);
      switch (strategy) {
        case "referenceHidden": {
          const overflow = await detectOverflow(state2, {
            ...detectOverflowOptions,
            elementContext: "reference"
          });
          const offsets = getSideOffsets(overflow, rects.reference);
          return {
            data: {
              referenceHiddenOffsets: offsets,
              referenceHidden: isAnySideFullyClipped(offsets)
            }
          };
        }
        case "escaped": {
          const overflow = await detectOverflow(state2, {
            ...detectOverflowOptions,
            altBoundary: true
          });
          const offsets = getSideOffsets(overflow, rects.floating);
          return {
            data: {
              escapedOffsets: offsets,
              escaped: isAnySideFullyClipped(offsets)
            }
          };
        }
        default: {
          return {};
        }
      }
    }
  };
};
async function convertValueToCoords(state2, options) {
  const {
    placement,
    platform: platform2,
    elements
  } = state2;
  const rtl = await (platform2.isRTL == null ? void 0 : platform2.isRTL(elements.floating));
  const side = getSide(placement);
  const alignment = getAlignment(placement);
  const isVertical = getSideAxis(placement) === "y";
  const mainAxisMulti = ["left", "top"].includes(side) ? -1 : 1;
  const crossAxisMulti = rtl && isVertical ? -1 : 1;
  const rawValue = evaluate(options, state2);
  let {
    mainAxis,
    crossAxis,
    alignmentAxis
  } = typeof rawValue === "number" ? {
    mainAxis: rawValue,
    crossAxis: 0,
    alignmentAxis: null
  } : {
    mainAxis: rawValue.mainAxis || 0,
    crossAxis: rawValue.crossAxis || 0,
    alignmentAxis: rawValue.alignmentAxis
  };
  if (alignment && typeof alignmentAxis === "number") {
    crossAxis = alignment === "end" ? alignmentAxis * -1 : alignmentAxis;
  }
  return isVertical ? {
    x: crossAxis * crossAxisMulti,
    y: mainAxis * mainAxisMulti
  } : {
    x: mainAxis * mainAxisMulti,
    y: crossAxis * crossAxisMulti
  };
}
var offset = function(options) {
  if (options === void 0) {
    options = 0;
  }
  return {
    name: "offset",
    options,
    async fn(state2) {
      var _middlewareData$offse, _middlewareData$arrow;
      const {
        x,
        y,
        placement,
        middlewareData
      } = state2;
      const diffCoords = await convertValueToCoords(state2, options);
      if (placement === ((_middlewareData$offse = middlewareData.offset) == null ? void 0 : _middlewareData$offse.placement) && (_middlewareData$arrow = middlewareData.arrow) != null && _middlewareData$arrow.alignmentOffset) {
        return {};
      }
      return {
        x: x + diffCoords.x,
        y: y + diffCoords.y,
        data: {
          ...diffCoords,
          placement
        }
      };
    }
  };
};
var shift = function(options) {
  if (options === void 0) {
    options = {};
  }
  return {
    name: "shift",
    options,
    async fn(state2) {
      const {
        x,
        y,
        placement
      } = state2;
      const {
        mainAxis: checkMainAxis = true,
        crossAxis: checkCrossAxis = false,
        limiter = {
          fn: (_ref) => {
            let {
              x: x2,
              y: y2
            } = _ref;
            return {
              x: x2,
              y: y2
            };
          }
        },
        ...detectOverflowOptions
      } = evaluate(options, state2);
      const coords = {
        x,
        y
      };
      const overflow = await detectOverflow(state2, detectOverflowOptions);
      const crossAxis = getSideAxis(getSide(placement));
      const mainAxis = getOppositeAxis(crossAxis);
      let mainAxisCoord = coords[mainAxis];
      let crossAxisCoord = coords[crossAxis];
      if (checkMainAxis) {
        const minSide = mainAxis === "y" ? "top" : "left";
        const maxSide = mainAxis === "y" ? "bottom" : "right";
        const min4 = mainAxisCoord + overflow[minSide];
        const max4 = mainAxisCoord - overflow[maxSide];
        mainAxisCoord = clamp2(min4, mainAxisCoord, max4);
      }
      if (checkCrossAxis) {
        const minSide = crossAxis === "y" ? "top" : "left";
        const maxSide = crossAxis === "y" ? "bottom" : "right";
        const min4 = crossAxisCoord + overflow[minSide];
        const max4 = crossAxisCoord - overflow[maxSide];
        crossAxisCoord = clamp2(min4, crossAxisCoord, max4);
      }
      const limitedCoords = limiter.fn({
        ...state2,
        [mainAxis]: mainAxisCoord,
        [crossAxis]: crossAxisCoord
      });
      return {
        ...limitedCoords,
        data: {
          x: limitedCoords.x - x,
          y: limitedCoords.y - y,
          enabled: {
            [mainAxis]: checkMainAxis,
            [crossAxis]: checkCrossAxis
          }
        }
      };
    }
  };
};
var limitShift = function(options) {
  if (options === void 0) {
    options = {};
  }
  return {
    options,
    fn(state2) {
      const {
        x,
        y,
        placement,
        rects,
        middlewareData
      } = state2;
      const {
        offset: offset3 = 0,
        mainAxis: checkMainAxis = true,
        crossAxis: checkCrossAxis = true
      } = evaluate(options, state2);
      const coords = {
        x,
        y
      };
      const crossAxis = getSideAxis(placement);
      const mainAxis = getOppositeAxis(crossAxis);
      let mainAxisCoord = coords[mainAxis];
      let crossAxisCoord = coords[crossAxis];
      const rawOffset = evaluate(offset3, state2);
      const computedOffset = typeof rawOffset === "number" ? {
        mainAxis: rawOffset,
        crossAxis: 0
      } : {
        mainAxis: 0,
        crossAxis: 0,
        ...rawOffset
      };
      if (checkMainAxis) {
        const len = mainAxis === "y" ? "height" : "width";
        const limitMin = rects.reference[mainAxis] - rects.floating[len] + computedOffset.mainAxis;
        const limitMax = rects.reference[mainAxis] + rects.reference[len] - computedOffset.mainAxis;
        if (mainAxisCoord < limitMin) {
          mainAxisCoord = limitMin;
        } else if (mainAxisCoord > limitMax) {
          mainAxisCoord = limitMax;
        }
      }
      if (checkCrossAxis) {
        var _middlewareData$offse, _middlewareData$offse2;
        const len = mainAxis === "y" ? "width" : "height";
        const isOriginSide = ["top", "left"].includes(getSide(placement));
        const limitMin = rects.reference[crossAxis] - rects.floating[len] + (isOriginSide ? ((_middlewareData$offse = middlewareData.offset) == null ? void 0 : _middlewareData$offse[crossAxis]) || 0 : 0) + (isOriginSide ? 0 : computedOffset.crossAxis);
        const limitMax = rects.reference[crossAxis] + rects.reference[len] + (isOriginSide ? 0 : ((_middlewareData$offse2 = middlewareData.offset) == null ? void 0 : _middlewareData$offse2[crossAxis]) || 0) - (isOriginSide ? computedOffset.crossAxis : 0);
        if (crossAxisCoord < limitMin) {
          crossAxisCoord = limitMin;
        } else if (crossAxisCoord > limitMax) {
          crossAxisCoord = limitMax;
        }
      }
      return {
        [mainAxis]: mainAxisCoord,
        [crossAxis]: crossAxisCoord
      };
    }
  };
};
var size = function(options) {
  if (options === void 0) {
    options = {};
  }
  return {
    name: "size",
    options,
    async fn(state2) {
      var _state$middlewareData, _state$middlewareData2;
      const {
        placement,
        rects,
        platform: platform2,
        elements
      } = state2;
      const {
        apply = () => {
        },
        ...detectOverflowOptions
      } = evaluate(options, state2);
      const overflow = await detectOverflow(state2, detectOverflowOptions);
      const side = getSide(placement);
      const alignment = getAlignment(placement);
      const isYAxis = getSideAxis(placement) === "y";
      const {
        width,
        height
      } = rects.floating;
      let heightSide;
      let widthSide;
      if (side === "top" || side === "bottom") {
        heightSide = side;
        widthSide = alignment === (await (platform2.isRTL == null ? void 0 : platform2.isRTL(elements.floating)) ? "start" : "end") ? "left" : "right";
      } else {
        widthSide = side;
        heightSide = alignment === "end" ? "top" : "bottom";
      }
      const maximumClippingHeight = height - overflow.top - overflow.bottom;
      const maximumClippingWidth = width - overflow.left - overflow.right;
      const overflowAvailableHeight = min2(height - overflow[heightSide], maximumClippingHeight);
      const overflowAvailableWidth = min2(width - overflow[widthSide], maximumClippingWidth);
      const noShift = !state2.middlewareData.shift;
      let availableHeight = overflowAvailableHeight;
      let availableWidth = overflowAvailableWidth;
      if ((_state$middlewareData = state2.middlewareData.shift) != null && _state$middlewareData.enabled.x) {
        availableWidth = maximumClippingWidth;
      }
      if ((_state$middlewareData2 = state2.middlewareData.shift) != null && _state$middlewareData2.enabled.y) {
        availableHeight = maximumClippingHeight;
      }
      if (noShift && !alignment) {
        const xMin = max2(overflow.left, 0);
        const xMax = max2(overflow.right, 0);
        const yMin = max2(overflow.top, 0);
        const yMax = max2(overflow.bottom, 0);
        if (isYAxis) {
          availableWidth = width - 2 * (xMin !== 0 || xMax !== 0 ? xMin + xMax : max2(overflow.left, overflow.right));
        } else {
          availableHeight = height - 2 * (yMin !== 0 || yMax !== 0 ? yMin + yMax : max2(overflow.top, overflow.bottom));
        }
      }
      await apply({
        ...state2,
        availableWidth,
        availableHeight
      });
      const nextDimensions = await platform2.getDimensions(elements.floating);
      if (width !== nextDimensions.width || height !== nextDimensions.height) {
        return {
          reset: {
            rects: true
          }
        };
      }
      return {};
    }
  };
};

// node_modules/@floating-ui/utils/dist/floating-ui.utils.dom.mjs
function hasWindow() {
  return typeof window !== "undefined";
}
function getNodeName2(node) {
  if (isNode2(node)) {
    return (node.nodeName || "").toLowerCase();
  }
  return "#document";
}
function getWindow2(node) {
  var _node$ownerDocument;
  return (node == null || (_node$ownerDocument = node.ownerDocument) == null ? void 0 : _node$ownerDocument.defaultView) || window;
}
function getDocumentElement2(node) {
  var _ref;
  return (_ref = (isNode2(node) ? node.ownerDocument : node.document) || window.document) == null ? void 0 : _ref.documentElement;
}
function isNode2(value) {
  if (!hasWindow()) {
    return false;
  }
  return value instanceof Node || value instanceof getWindow2(value).Node;
}
function isElement2(value) {
  if (!hasWindow()) {
    return false;
  }
  return value instanceof Element || value instanceof getWindow2(value).Element;
}
function isHTMLElement2(value) {
  if (!hasWindow()) {
    return false;
  }
  return value instanceof HTMLElement || value instanceof getWindow2(value).HTMLElement;
}
function isShadowRoot2(value) {
  if (!hasWindow() || typeof ShadowRoot === "undefined") {
    return false;
  }
  return value instanceof ShadowRoot || value instanceof getWindow2(value).ShadowRoot;
}
function isOverflowElement2(element) {
  const {
    overflow,
    overflowX,
    overflowY,
    display
  } = getComputedStyle2(element);
  return /auto|scroll|overlay|hidden|clip/.test(overflow + overflowY + overflowX) && !["inline", "contents"].includes(display);
}
function isTableElement(element) {
  return ["table", "td", "th"].includes(getNodeName2(element));
}
function isTopLayer(element) {
  return [":popover-open", ":modal"].some((selector) => {
    try {
      return element.matches(selector);
    } catch (e) {
      return false;
    }
  });
}
function isContainingBlock(elementOrCss) {
  const webkit = isWebKit();
  const css2 = isElement2(elementOrCss) ? getComputedStyle2(elementOrCss) : elementOrCss;
  return ["transform", "translate", "scale", "rotate", "perspective"].some((value) => css2[value] ? css2[value] !== "none" : false) || (css2.containerType ? css2.containerType !== "normal" : false) || !webkit && (css2.backdropFilter ? css2.backdropFilter !== "none" : false) || !webkit && (css2.filter ? css2.filter !== "none" : false) || ["transform", "translate", "scale", "rotate", "perspective", "filter"].some((value) => (css2.willChange || "").includes(value)) || ["paint", "layout", "strict", "content"].some((value) => (css2.contain || "").includes(value));
}
function getContainingBlock(element) {
  let currentNode = getParentNode2(element);
  while (isHTMLElement2(currentNode) && !isLastTraversableNode(currentNode)) {
    if (isContainingBlock(currentNode)) {
      return currentNode;
    } else if (isTopLayer(currentNode)) {
      return null;
    }
    currentNode = getParentNode2(currentNode);
  }
  return null;
}
function isWebKit() {
  if (typeof CSS === "undefined" || !CSS.supports) return false;
  return CSS.supports("-webkit-backdrop-filter", "none");
}
function isLastTraversableNode(node) {
  return ["html", "body", "#document"].includes(getNodeName2(node));
}
function getComputedStyle2(element) {
  return getWindow2(element).getComputedStyle(element);
}
function getNodeScroll(element) {
  if (isElement2(element)) {
    return {
      scrollLeft: element.scrollLeft,
      scrollTop: element.scrollTop
    };
  }
  return {
    scrollLeft: element.scrollX,
    scrollTop: element.scrollY
  };
}
function getParentNode2(node) {
  if (getNodeName2(node) === "html") {
    return node;
  }
  const result = (
    // Step into the shadow DOM of the parent of a slotted node.
    node.assignedSlot || // DOM Element detected.
    node.parentNode || // ShadowRoot detected.
    isShadowRoot2(node) && node.host || // Fallback.
    getDocumentElement2(node)
  );
  return isShadowRoot2(result) ? result.host : result;
}
function getNearestOverflowAncestor2(node) {
  const parentNode = getParentNode2(node);
  if (isLastTraversableNode(parentNode)) {
    return node.ownerDocument ? node.ownerDocument.body : node.body;
  }
  if (isHTMLElement2(parentNode) && isOverflowElement2(parentNode)) {
    return parentNode;
  }
  return getNearestOverflowAncestor2(parentNode);
}
function getOverflowAncestors2(node, list, traverseIframes) {
  var _node$ownerDocument2;
  if (list === void 0) {
    list = [];
  }
  if (traverseIframes === void 0) {
    traverseIframes = true;
  }
  const scrollableAncestor = getNearestOverflowAncestor2(node);
  const isBody = scrollableAncestor === ((_node$ownerDocument2 = node.ownerDocument) == null ? void 0 : _node$ownerDocument2.body);
  const win = getWindow2(scrollableAncestor);
  if (isBody) {
    const frameElement = getFrameElement(win);
    return list.concat(win, win.visualViewport || [], isOverflowElement2(scrollableAncestor) ? scrollableAncestor : [], frameElement && traverseIframes ? getOverflowAncestors2(frameElement) : []);
  }
  return list.concat(scrollableAncestor, getOverflowAncestors2(scrollableAncestor, [], traverseIframes));
}
function getFrameElement(win) {
  return win.parent && Object.getPrototypeOf(win.parent) ? win.frameElement : null;
}

// node_modules/@floating-ui/dom/dist/floating-ui.dom.mjs
function getCssDimensions(element) {
  const css2 = getComputedStyle2(element);
  let width = parseFloat(css2.width) || 0;
  let height = parseFloat(css2.height) || 0;
  const hasOffset = isHTMLElement2(element);
  const offsetWidth = hasOffset ? element.offsetWidth : width;
  const offsetHeight = hasOffset ? element.offsetHeight : height;
  const shouldFallback = round2(width) !== offsetWidth || round2(height) !== offsetHeight;
  if (shouldFallback) {
    width = offsetWidth;
    height = offsetHeight;
  }
  return {
    width,
    height,
    $: shouldFallback
  };
}
function unwrapElement(element) {
  return !isElement2(element) ? element.contextElement : element;
}
function getScale(element) {
  const domElement = unwrapElement(element);
  if (!isHTMLElement2(domElement)) {
    return createCoords(1);
  }
  const rect = domElement.getBoundingClientRect();
  const {
    width,
    height,
    $
  } = getCssDimensions(domElement);
  let x = ($ ? round2(rect.width) : rect.width) / width;
  let y = ($ ? round2(rect.height) : rect.height) / height;
  if (!x || !Number.isFinite(x)) {
    x = 1;
  }
  if (!y || !Number.isFinite(y)) {
    y = 1;
  }
  return {
    x,
    y
  };
}
var noOffsets = createCoords(0);
function getVisualOffsets(element) {
  const win = getWindow2(element);
  if (!isWebKit() || !win.visualViewport) {
    return noOffsets;
  }
  return {
    x: win.visualViewport.offsetLeft,
    y: win.visualViewport.offsetTop
  };
}
function shouldAddVisualOffsets(element, isFixed, floatingOffsetParent) {
  if (isFixed === void 0) {
    isFixed = false;
  }
  if (!floatingOffsetParent || isFixed && floatingOffsetParent !== getWindow2(element)) {
    return false;
  }
  return isFixed;
}
function getBoundingClientRect(element, includeScale, isFixedStrategy, offsetParent) {
  if (includeScale === void 0) {
    includeScale = false;
  }
  if (isFixedStrategy === void 0) {
    isFixedStrategy = false;
  }
  const clientRect = element.getBoundingClientRect();
  const domElement = unwrapElement(element);
  let scale = createCoords(1);
  if (includeScale) {
    if (offsetParent) {
      if (isElement2(offsetParent)) {
        scale = getScale(offsetParent);
      }
    } else {
      scale = getScale(element);
    }
  }
  const visualOffsets = shouldAddVisualOffsets(domElement, isFixedStrategy, offsetParent) ? getVisualOffsets(domElement) : createCoords(0);
  let x = (clientRect.left + visualOffsets.x) / scale.x;
  let y = (clientRect.top + visualOffsets.y) / scale.y;
  let width = clientRect.width / scale.x;
  let height = clientRect.height / scale.y;
  if (domElement) {
    const win = getWindow2(domElement);
    const offsetWin = offsetParent && isElement2(offsetParent) ? getWindow2(offsetParent) : offsetParent;
    let currentWin = win;
    let currentIFrame = getFrameElement(currentWin);
    while (currentIFrame && offsetParent && offsetWin !== currentWin) {
      const iframeScale = getScale(currentIFrame);
      const iframeRect = currentIFrame.getBoundingClientRect();
      const css2 = getComputedStyle2(currentIFrame);
      const left = iframeRect.left + (currentIFrame.clientLeft + parseFloat(css2.paddingLeft)) * iframeScale.x;
      const top = iframeRect.top + (currentIFrame.clientTop + parseFloat(css2.paddingTop)) * iframeScale.y;
      x *= iframeScale.x;
      y *= iframeScale.y;
      width *= iframeScale.x;
      height *= iframeScale.y;
      x += left;
      y += top;
      currentWin = getWindow2(currentIFrame);
      currentIFrame = getFrameElement(currentWin);
    }
  }
  return rectToClientRect({
    width,
    height,
    x,
    y
  });
}
function getWindowScrollBarX(element, rect) {
  const leftScroll = getNodeScroll(element).scrollLeft;
  if (!rect) {
    return getBoundingClientRect(getDocumentElement2(element)).left + leftScroll;
  }
  return rect.left + leftScroll;
}
function getHTMLOffset(documentElement, scroll, ignoreScrollbarX) {
  if (ignoreScrollbarX === void 0) {
    ignoreScrollbarX = false;
  }
  const htmlRect = documentElement.getBoundingClientRect();
  const x = htmlRect.left + scroll.scrollLeft - (ignoreScrollbarX ? 0 : (
    // RTL <body> scrollbar.
    getWindowScrollBarX(documentElement, htmlRect)
  ));
  const y = htmlRect.top + scroll.scrollTop;
  return {
    x,
    y
  };
}
function convertOffsetParentRelativeRectToViewportRelativeRect(_ref) {
  let {
    elements,
    rect,
    offsetParent,
    strategy
  } = _ref;
  const isFixed = strategy === "fixed";
  const documentElement = getDocumentElement2(offsetParent);
  const topLayer = elements ? isTopLayer(elements.floating) : false;
  if (offsetParent === documentElement || topLayer && isFixed) {
    return rect;
  }
  let scroll = {
    scrollLeft: 0,
    scrollTop: 0
  };
  let scale = createCoords(1);
  const offsets = createCoords(0);
  const isOffsetParentAnElement = isHTMLElement2(offsetParent);
  if (isOffsetParentAnElement || !isOffsetParentAnElement && !isFixed) {
    if (getNodeName2(offsetParent) !== "body" || isOverflowElement2(documentElement)) {
      scroll = getNodeScroll(offsetParent);
    }
    if (isHTMLElement2(offsetParent)) {
      const offsetRect = getBoundingClientRect(offsetParent);
      scale = getScale(offsetParent);
      offsets.x = offsetRect.x + offsetParent.clientLeft;
      offsets.y = offsetRect.y + offsetParent.clientTop;
    }
  }
  const htmlOffset = documentElement && !isOffsetParentAnElement && !isFixed ? getHTMLOffset(documentElement, scroll, true) : createCoords(0);
  return {
    width: rect.width * scale.x,
    height: rect.height * scale.y,
    x: rect.x * scale.x - scroll.scrollLeft * scale.x + offsets.x + htmlOffset.x,
    y: rect.y * scale.y - scroll.scrollTop * scale.y + offsets.y + htmlOffset.y
  };
}
function getClientRects(element) {
  return Array.from(element.getClientRects());
}
function getDocumentRect(element) {
  const html = getDocumentElement2(element);
  const scroll = getNodeScroll(element);
  const body = element.ownerDocument.body;
  const width = max2(html.scrollWidth, html.clientWidth, body.scrollWidth, body.clientWidth);
  const height = max2(html.scrollHeight, html.clientHeight, body.scrollHeight, body.clientHeight);
  let x = -scroll.scrollLeft + getWindowScrollBarX(element);
  const y = -scroll.scrollTop;
  if (getComputedStyle2(body).direction === "rtl") {
    x += max2(html.clientWidth, body.clientWidth) - width;
  }
  return {
    width,
    height,
    x,
    y
  };
}
function getViewportRect(element, strategy) {
  const win = getWindow2(element);
  const html = getDocumentElement2(element);
  const visualViewport = win.visualViewport;
  let width = html.clientWidth;
  let height = html.clientHeight;
  let x = 0;
  let y = 0;
  if (visualViewport) {
    width = visualViewport.width;
    height = visualViewport.height;
    const visualViewportBased = isWebKit();
    if (!visualViewportBased || visualViewportBased && strategy === "fixed") {
      x = visualViewport.offsetLeft;
      y = visualViewport.offsetTop;
    }
  }
  return {
    width,
    height,
    x,
    y
  };
}
function getInnerBoundingClientRect(element, strategy) {
  const clientRect = getBoundingClientRect(element, true, strategy === "fixed");
  const top = clientRect.top + element.clientTop;
  const left = clientRect.left + element.clientLeft;
  const scale = isHTMLElement2(element) ? getScale(element) : createCoords(1);
  const width = element.clientWidth * scale.x;
  const height = element.clientHeight * scale.y;
  const x = left * scale.x;
  const y = top * scale.y;
  return {
    width,
    height,
    x,
    y
  };
}
function getClientRectFromClippingAncestor(element, clippingAncestor, strategy) {
  let rect;
  if (clippingAncestor === "viewport") {
    rect = getViewportRect(element, strategy);
  } else if (clippingAncestor === "document") {
    rect = getDocumentRect(getDocumentElement2(element));
  } else if (isElement2(clippingAncestor)) {
    rect = getInnerBoundingClientRect(clippingAncestor, strategy);
  } else {
    const visualOffsets = getVisualOffsets(element);
    rect = {
      x: clippingAncestor.x - visualOffsets.x,
      y: clippingAncestor.y - visualOffsets.y,
      width: clippingAncestor.width,
      height: clippingAncestor.height
    };
  }
  return rectToClientRect(rect);
}
function hasFixedPositionAncestor(element, stopNode) {
  const parentNode = getParentNode2(element);
  if (parentNode === stopNode || !isElement2(parentNode) || isLastTraversableNode(parentNode)) {
    return false;
  }
  return getComputedStyle2(parentNode).position === "fixed" || hasFixedPositionAncestor(parentNode, stopNode);
}
function getClippingElementAncestors(element, cache) {
  const cachedResult = cache.get(element);
  if (cachedResult) {
    return cachedResult;
  }
  let result = getOverflowAncestors2(element, [], false).filter((el) => isElement2(el) && getNodeName2(el) !== "body");
  let currentContainingBlockComputedStyle = null;
  const elementIsFixed = getComputedStyle2(element).position === "fixed";
  let currentNode = elementIsFixed ? getParentNode2(element) : element;
  while (isElement2(currentNode) && !isLastTraversableNode(currentNode)) {
    const computedStyle = getComputedStyle2(currentNode);
    const currentNodeIsContaining = isContainingBlock(currentNode);
    if (!currentNodeIsContaining && computedStyle.position === "fixed") {
      currentContainingBlockComputedStyle = null;
    }
    const shouldDropCurrentNode = elementIsFixed ? !currentNodeIsContaining && !currentContainingBlockComputedStyle : !currentNodeIsContaining && computedStyle.position === "static" && !!currentContainingBlockComputedStyle && ["absolute", "fixed"].includes(currentContainingBlockComputedStyle.position) || isOverflowElement2(currentNode) && !currentNodeIsContaining && hasFixedPositionAncestor(element, currentNode);
    if (shouldDropCurrentNode) {
      result = result.filter((ancestor) => ancestor !== currentNode);
    } else {
      currentContainingBlockComputedStyle = computedStyle;
    }
    currentNode = getParentNode2(currentNode);
  }
  cache.set(element, result);
  return result;
}
function getClippingRect(_ref) {
  let {
    element,
    boundary,
    rootBoundary,
    strategy
  } = _ref;
  const elementClippingAncestors = boundary === "clippingAncestors" ? isTopLayer(element) ? [] : getClippingElementAncestors(element, this._c) : [].concat(boundary);
  const clippingAncestors = [...elementClippingAncestors, rootBoundary];
  const firstClippingAncestor = clippingAncestors[0];
  const clippingRect = clippingAncestors.reduce((accRect, clippingAncestor) => {
    const rect = getClientRectFromClippingAncestor(element, clippingAncestor, strategy);
    accRect.top = max2(rect.top, accRect.top);
    accRect.right = min2(rect.right, accRect.right);
    accRect.bottom = min2(rect.bottom, accRect.bottom);
    accRect.left = max2(rect.left, accRect.left);
    return accRect;
  }, getClientRectFromClippingAncestor(element, firstClippingAncestor, strategy));
  return {
    width: clippingRect.right - clippingRect.left,
    height: clippingRect.bottom - clippingRect.top,
    x: clippingRect.left,
    y: clippingRect.top
  };
}
function getDimensions(element) {
  const {
    width,
    height
  } = getCssDimensions(element);
  return {
    width,
    height
  };
}
function getRectRelativeToOffsetParent(element, offsetParent, strategy) {
  const isOffsetParentAnElement = isHTMLElement2(offsetParent);
  const documentElement = getDocumentElement2(offsetParent);
  const isFixed = strategy === "fixed";
  const rect = getBoundingClientRect(element, true, isFixed, offsetParent);
  let scroll = {
    scrollLeft: 0,
    scrollTop: 0
  };
  const offsets = createCoords(0);
  if (isOffsetParentAnElement || !isOffsetParentAnElement && !isFixed) {
    if (getNodeName2(offsetParent) !== "body" || isOverflowElement2(documentElement)) {
      scroll = getNodeScroll(offsetParent);
    }
    if (isOffsetParentAnElement) {
      const offsetRect = getBoundingClientRect(offsetParent, true, isFixed, offsetParent);
      offsets.x = offsetRect.x + offsetParent.clientLeft;
      offsets.y = offsetRect.y + offsetParent.clientTop;
    } else if (documentElement) {
      offsets.x = getWindowScrollBarX(documentElement);
    }
  }
  const htmlOffset = documentElement && !isOffsetParentAnElement && !isFixed ? getHTMLOffset(documentElement, scroll) : createCoords(0);
  const x = rect.left + scroll.scrollLeft - offsets.x - htmlOffset.x;
  const y = rect.top + scroll.scrollTop - offsets.y - htmlOffset.y;
  return {
    x,
    y,
    width: rect.width,
    height: rect.height
  };
}
function isStaticPositioned(element) {
  return getComputedStyle2(element).position === "static";
}
function getTrueOffsetParent(element, polyfill) {
  if (!isHTMLElement2(element) || getComputedStyle2(element).position === "fixed") {
    return null;
  }
  if (polyfill) {
    return polyfill(element);
  }
  let rawOffsetParent = element.offsetParent;
  if (getDocumentElement2(element) === rawOffsetParent) {
    rawOffsetParent = rawOffsetParent.ownerDocument.body;
  }
  return rawOffsetParent;
}
function getOffsetParent(element, polyfill) {
  const win = getWindow2(element);
  if (isTopLayer(element)) {
    return win;
  }
  if (!isHTMLElement2(element)) {
    let svgOffsetParent = getParentNode2(element);
    while (svgOffsetParent && !isLastTraversableNode(svgOffsetParent)) {
      if (isElement2(svgOffsetParent) && !isStaticPositioned(svgOffsetParent)) {
        return svgOffsetParent;
      }
      svgOffsetParent = getParentNode2(svgOffsetParent);
    }
    return win;
  }
  let offsetParent = getTrueOffsetParent(element, polyfill);
  while (offsetParent && isTableElement(offsetParent) && isStaticPositioned(offsetParent)) {
    offsetParent = getTrueOffsetParent(offsetParent, polyfill);
  }
  if (offsetParent && isLastTraversableNode(offsetParent) && isStaticPositioned(offsetParent) && !isContainingBlock(offsetParent)) {
    return win;
  }
  return offsetParent || getContainingBlock(element) || win;
}
var getElementRects = async function(data) {
  const getOffsetParentFn = this.getOffsetParent || getOffsetParent;
  const getDimensionsFn = this.getDimensions;
  const floatingDimensions = await getDimensionsFn(data.floating);
  return {
    reference: getRectRelativeToOffsetParent(data.reference, await getOffsetParentFn(data.floating), data.strategy),
    floating: {
      x: 0,
      y: 0,
      width: floatingDimensions.width,
      height: floatingDimensions.height
    }
  };
};
function isRTL(element) {
  return getComputedStyle2(element).direction === "rtl";
}
var platform = {
  convertOffsetParentRelativeRectToViewportRelativeRect,
  getDocumentElement: getDocumentElement2,
  getClippingRect,
  getOffsetParent,
  getElementRects,
  getClientRects,
  getDimensions,
  getScale,
  isElement: isElement2,
  isRTL
};
function observeMove(element, onMove) {
  let io = null;
  let timeoutId;
  const root = getDocumentElement2(element);
  function cleanup() {
    var _io;
    clearTimeout(timeoutId);
    (_io = io) == null || _io.disconnect();
    io = null;
  }
  function refresh(skip, threshold) {
    if (skip === void 0) {
      skip = false;
    }
    if (threshold === void 0) {
      threshold = 1;
    }
    cleanup();
    const {
      left,
      top,
      width,
      height
    } = element.getBoundingClientRect();
    if (!skip) {
      onMove();
    }
    if (!width || !height) {
      return;
    }
    const insetTop = floor2(top);
    const insetRight = floor2(root.clientWidth - (left + width));
    const insetBottom = floor2(root.clientHeight - (top + height));
    const insetLeft = floor2(left);
    const rootMargin = -insetTop + "px " + -insetRight + "px " + -insetBottom + "px " + -insetLeft + "px";
    const options = {
      rootMargin,
      threshold: max2(0, min2(1, threshold)) || 1
    };
    let isFirstUpdate = true;
    function handleObserve(entries) {
      const ratio = entries[0].intersectionRatio;
      if (ratio !== threshold) {
        if (!isFirstUpdate) {
          return refresh();
        }
        if (!ratio) {
          timeoutId = setTimeout(() => {
            refresh(false, 1e-7);
          }, 1e3);
        } else {
          refresh(false, ratio);
        }
      }
      isFirstUpdate = false;
    }
    try {
      io = new IntersectionObserver(handleObserve, {
        ...options,
        // Handle <iframe>s
        root: root.ownerDocument
      });
    } catch (e) {
      io = new IntersectionObserver(handleObserve, options);
    }
    io.observe(element);
  }
  refresh(true);
  return cleanup;
}
function autoUpdate(reference, floating, update, options) {
  if (options === void 0) {
    options = {};
  }
  const {
    ancestorScroll = true,
    ancestorResize = true,
    elementResize = typeof ResizeObserver === "function",
    layoutShift = typeof IntersectionObserver === "function",
    animationFrame = false
  } = options;
  const referenceEl = unwrapElement(reference);
  const ancestors = ancestorScroll || ancestorResize ? [...referenceEl ? getOverflowAncestors2(referenceEl) : [], ...getOverflowAncestors2(floating)] : [];
  ancestors.forEach((ancestor) => {
    ancestorScroll && ancestor.addEventListener("scroll", update, {
      passive: true
    });
    ancestorResize && ancestor.addEventListener("resize", update);
  });
  const cleanupIo = referenceEl && layoutShift ? observeMove(referenceEl, update) : null;
  let reobserveFrame = -1;
  let resizeObserver = null;
  if (elementResize) {
    resizeObserver = new ResizeObserver((_ref) => {
      let [firstEntry] = _ref;
      if (firstEntry && firstEntry.target === referenceEl && resizeObserver) {
        resizeObserver.unobserve(floating);
        cancelAnimationFrame(reobserveFrame);
        reobserveFrame = requestAnimationFrame(() => {
          var _resizeObserver;
          (_resizeObserver = resizeObserver) == null || _resizeObserver.observe(floating);
        });
      }
      update();
    });
    if (referenceEl && !animationFrame) {
      resizeObserver.observe(referenceEl);
    }
    resizeObserver.observe(floating);
  }
  let frameId;
  let prevRefRect = animationFrame ? getBoundingClientRect(reference) : null;
  if (animationFrame) {
    frameLoop();
  }
  function frameLoop() {
    const nextRefRect = getBoundingClientRect(reference);
    if (prevRefRect && (nextRefRect.x !== prevRefRect.x || nextRefRect.y !== prevRefRect.y || nextRefRect.width !== prevRefRect.width || nextRefRect.height !== prevRefRect.height)) {
      update();
    }
    prevRefRect = nextRefRect;
    frameId = requestAnimationFrame(frameLoop);
  }
  update();
  return () => {
    var _resizeObserver2;
    ancestors.forEach((ancestor) => {
      ancestorScroll && ancestor.removeEventListener("scroll", update);
      ancestorResize && ancestor.removeEventListener("resize", update);
    });
    cleanupIo == null || cleanupIo();
    (_resizeObserver2 = resizeObserver) == null || _resizeObserver2.disconnect();
    resizeObserver = null;
    if (animationFrame) {
      cancelAnimationFrame(frameId);
    }
  };
}
var offset2 = offset;
var shift2 = shift;
var flip2 = flip;
var size2 = size;
var hide2 = hide;
var arrow2 = arrow;
var limitShift2 = limitShift;
var computePosition2 = (reference, floating, options) => {
  const cache = /* @__PURE__ */ new Map();
  const mergedOptions = {
    platform,
    ...options
  };
  const platformWithCache = {
    ...mergedOptions.platform,
    _c: cache
  };
  return computePosition(reference, floating, {
    ...mergedOptions,
    platform: platformWithCache
  });
};

// node_modules/@zag-js/popper/dist/index.mjs
function createDOMRect(x = 0, y = 0, width = 0, height = 0) {
  if (typeof DOMRect === "function") {
    return new DOMRect(x, y, width, height);
  }
  const rect = {
    x,
    y,
    width,
    height,
    top: y,
    right: x + width,
    bottom: y + height,
    left: x
  };
  return { ...rect, toJSON: () => rect };
}
function getDOMRect(anchorRect) {
  if (!anchorRect) return createDOMRect();
  const { x, y, width, height } = anchorRect;
  return createDOMRect(x, y, width, height);
}
function getAnchorElement(anchorElement, getAnchorRect) {
  return {
    contextElement: isHTMLElement(anchorElement) ? anchorElement : void 0,
    getBoundingClientRect: () => {
      const anchor = anchorElement;
      const anchorRect = getAnchorRect == null ? void 0 : getAnchorRect(anchor);
      if (anchorRect || !anchor) {
        return getDOMRect(anchorRect);
      }
      return anchor.getBoundingClientRect();
    }
  };
}
var toVar = (value) => ({ variable: value, reference: `var(${value})` });
var cssVars = {
  arrowSize: toVar("--arrow-size"),
  arrowSizeHalf: toVar("--arrow-size-half"),
  arrowBg: toVar("--arrow-background"),
  transformOrigin: toVar("--transform-origin"),
  arrowOffset: toVar("--arrow-offset")
};
var getTransformOrigin = (arrow22) => ({
  top: "bottom center",
  "top-start": arrow22 ? `${arrow22.x}px bottom` : "left bottom",
  "top-end": arrow22 ? `${arrow22.x}px bottom` : "right bottom",
  bottom: "top center",
  "bottom-start": arrow22 ? `${arrow22.x}px top` : "top left",
  "bottom-end": arrow22 ? `${arrow22.x}px top` : "top right",
  left: "right center",
  "left-start": arrow22 ? `right ${arrow22.y}px` : "right top",
  "left-end": arrow22 ? `right ${arrow22.y}px` : "right bottom",
  right: "left center",
  "right-start": arrow22 ? `left ${arrow22.y}px` : "left top",
  "right-end": arrow22 ? `left ${arrow22.y}px` : "left bottom"
});
var transformOriginMiddleware = {
  name: "transformOrigin",
  fn({ placement, elements, middlewareData }) {
    const { arrow: arrow22 } = middlewareData;
    const transformOrigin = getTransformOrigin(arrow22)[placement];
    const { floating } = elements;
    floating.style.setProperty(cssVars.transformOrigin.variable, transformOrigin);
    return {
      data: { transformOrigin }
    };
  }
};
var rectMiddleware = {
  name: "rects",
  fn({ rects }) {
    return {
      data: rects
    };
  }
};
var shiftArrowMiddleware = (arrowEl) => {
  if (!arrowEl) return;
  return {
    name: "shiftArrow",
    fn({ placement, middlewareData }) {
      if (!middlewareData.arrow) return {};
      const { x, y } = middlewareData.arrow;
      const dir = placement.split("-")[0];
      Object.assign(arrowEl.style, {
        left: x != null ? `${x}px` : "",
        top: y != null ? `${y}px` : "",
        [dir]: `calc(100% + ${cssVars.arrowOffset.reference})`
      });
      return {};
    }
  };
};
function getPlacementDetails(placement) {
  const [side, align] = placement.split("-");
  return { side, align, hasAlign: align != null };
}
function getPlacementSide(placement) {
  return placement.split("-")[0];
}
var defaultOptions = {
  strategy: "absolute",
  placement: "bottom",
  listeners: true,
  gutter: 8,
  flip: true,
  slide: true,
  overlap: false,
  sameWidth: false,
  fitViewport: false,
  overflowPadding: 8,
  arrowPadding: 4
};
function roundByDpr(win, value) {
  const dpr = win.devicePixelRatio || 1;
  return Math.round(value * dpr) / dpr;
}
function getBoundaryMiddleware(opts) {
  return runIfFn(opts.boundary);
}
function getArrowMiddleware(arrowElement, opts) {
  if (!arrowElement) return;
  return arrow2({
    element: arrowElement,
    padding: opts.arrowPadding
  });
}
function getOffsetMiddleware(arrowElement, opts) {
  if (isNull(opts.offset ?? opts.gutter)) return;
  return offset2(({ placement }) => {
    var _a8, _b7;
    const arrowOffset = ((arrowElement == null ? void 0 : arrowElement.clientHeight) || 0) / 2;
    const gutter = ((_a8 = opts.offset) == null ? void 0 : _a8.mainAxis) ?? opts.gutter;
    const mainAxis = typeof gutter === "number" ? gutter + arrowOffset : gutter ?? arrowOffset;
    const { hasAlign } = getPlacementDetails(placement);
    const shift22 = !hasAlign ? opts.shift : void 0;
    const crossAxis = ((_b7 = opts.offset) == null ? void 0 : _b7.crossAxis) ?? shift22;
    return compact2({
      crossAxis,
      mainAxis,
      alignmentAxis: opts.shift
    });
  });
}
function getFlipMiddleware(opts) {
  if (!opts.flip) return;
  return flip2({
    boundary: getBoundaryMiddleware(opts),
    padding: opts.overflowPadding,
    fallbackPlacements: opts.flip === true ? void 0 : opts.flip
  });
}
function getShiftMiddleware(opts) {
  if (!opts.slide && !opts.overlap) return;
  return shift2({
    boundary: getBoundaryMiddleware(opts),
    mainAxis: opts.slide,
    crossAxis: opts.overlap,
    padding: opts.overflowPadding,
    limiter: limitShift2()
  });
}
function getSizeMiddleware(opts) {
  return size2({
    padding: opts.overflowPadding,
    apply({ elements, rects, availableHeight, availableWidth }) {
      const floating = elements.floating;
      const referenceWidth = Math.round(rects.reference.width);
      availableWidth = Math.floor(availableWidth);
      availableHeight = Math.floor(availableHeight);
      floating.style.setProperty("--reference-width", `${referenceWidth}px`);
      floating.style.setProperty("--available-width", `${availableWidth}px`);
      floating.style.setProperty("--available-height", `${availableHeight}px`);
    }
  });
}
function hideWhenDetachedMiddleware(opts) {
  var _a8;
  if (!opts.hideWhenDetached) return;
  return hide2({ strategy: "referenceHidden", boundary: ((_a8 = opts.boundary) == null ? void 0 : _a8.call(opts)) ?? "clippingAncestors" });
}
function getAutoUpdateOptions(opts) {
  if (!opts) return {};
  if (opts === true) {
    return { ancestorResize: true, ancestorScroll: true, elementResize: true, layoutShift: true };
  }
  return opts;
}
function getPlacementImpl(referenceOrVirtual, floating, opts = {}) {
  const reference = getAnchorElement(referenceOrVirtual, opts.getAnchorRect);
  if (!floating || !reference) return;
  const options = Object.assign({}, defaultOptions, opts);
  const arrowEl = floating.querySelector("[data-part=arrow]");
  const middleware = [
    getOffsetMiddleware(arrowEl, options),
    getFlipMiddleware(options),
    getShiftMiddleware(options),
    getArrowMiddleware(arrowEl, options),
    shiftArrowMiddleware(arrowEl),
    transformOriginMiddleware,
    getSizeMiddleware(options),
    hideWhenDetachedMiddleware(options),
    rectMiddleware
  ];
  const { placement, strategy, onComplete, onPositioned } = options;
  const updatePosition = async () => {
    var _a8;
    if (!reference || !floating) return;
    const pos = await computePosition2(reference, floating, {
      placement,
      middleware,
      strategy
    });
    onComplete == null ? void 0 : onComplete(pos);
    onPositioned == null ? void 0 : onPositioned({ placed: true });
    const win = getWindow(floating);
    const x = roundByDpr(win, pos.x);
    const y = roundByDpr(win, pos.y);
    floating.style.setProperty("--x", `${x}px`);
    floating.style.setProperty("--y", `${y}px`);
    if (options.hideWhenDetached) {
      const isHidden = (_a8 = pos.middlewareData.hide) == null ? void 0 : _a8.referenceHidden;
      if (isHidden) {
        floating.style.setProperty("visibility", "hidden");
        floating.style.setProperty("pointer-events", "none");
      } else {
        floating.style.removeProperty("visibility");
        floating.style.removeProperty("pointer-events");
      }
    }
    const contentEl = floating.firstElementChild;
    if (contentEl) {
      const styles = getComputedStyle(contentEl);
      floating.style.setProperty("--z-index", styles.zIndex);
    }
  };
  const update = async () => {
    if (opts.updatePosition) {
      await opts.updatePosition({ updatePosition });
      onPositioned == null ? void 0 : onPositioned({ placed: true });
    } else {
      await updatePosition();
    }
  };
  const autoUpdateOptions = getAutoUpdateOptions(options.listeners);
  const cancelAutoUpdate = options.listeners ? autoUpdate(reference, floating, update, autoUpdateOptions) : noop2;
  update();
  return () => {
    cancelAutoUpdate == null ? void 0 : cancelAutoUpdate();
    onPositioned == null ? void 0 : onPositioned({ placed: false });
  };
}
function getPlacement(referenceOrFn, floatingOrFn, opts = {}) {
  const { defer, ...options } = opts;
  const func = defer ? raf : (v) => v();
  const cleanups2 = [];
  cleanups2.push(
    func(() => {
      const reference = typeof referenceOrFn === "function" ? referenceOrFn() : referenceOrFn;
      const floating = typeof floatingOrFn === "function" ? floatingOrFn() : floatingOrFn;
      cleanups2.push(getPlacementImpl(reference, floating, options));
    })
  );
  return () => {
    cleanups2.forEach((fn) => fn == null ? void 0 : fn());
  };
}
var ARROW_FLOATING_STYLE = {
  bottom: "rotate(45deg)",
  left: "rotate(135deg)",
  top: "rotate(225deg)",
  right: "rotate(315deg)"
};
function getPlacementStyles(options = {}) {
  const { placement, sameWidth, fitViewport, strategy = "absolute" } = options;
  return {
    arrow: {
      position: "absolute",
      width: cssVars.arrowSize.reference,
      height: cssVars.arrowSize.reference,
      [cssVars.arrowSizeHalf.variable]: `calc(${cssVars.arrowSize.reference} / 2)`,
      [cssVars.arrowOffset.variable]: `calc(${cssVars.arrowSizeHalf.reference} * -1)`
    },
    arrowTip: {
      // @ts-expect-error - Fix this
      transform: placement ? ARROW_FLOATING_STYLE[placement.split("-")[0]] : void 0,
      background: cssVars.arrowBg.reference,
      top: "0",
      left: "0",
      width: "100%",
      height: "100%",
      position: "absolute",
      zIndex: "inherit"
    },
    floating: {
      position: strategy,
      isolation: "isolate",
      minWidth: sameWidth ? void 0 : "max-content",
      width: sameWidth ? "var(--reference-width)" : void 0,
      maxWidth: fitViewport ? "var(--available-width)" : void 0,
      maxHeight: fitViewport ? "var(--available-height)" : void 0,
      top: "0px",
      left: "0px",
      // move off-screen if placement is not defined
      transform: placement ? "translate3d(var(--x), var(--y), 0)" : "translate3d(0, -100vh, 0)",
      zIndex: "var(--z-index)"
    }
  };
}

// node_modules/@zag-js/interact-outside/dist/index.mjs
function getWindowFrames(win) {
  const frames = {
    each(cb) {
      var _a8;
      for (let i = 0; i < ((_a8 = win.frames) == null ? void 0 : _a8.length); i += 1) {
        const frame = win.frames[i];
        if (frame) cb(frame);
      }
    },
    addEventListener(event, listener, options) {
      frames.each((frame) => {
        try {
          frame.document.addEventListener(event, listener, options);
        } catch {
        }
      });
      return () => {
        try {
          frames.removeEventListener(event, listener, options);
        } catch {
        }
      };
    },
    removeEventListener(event, listener, options) {
      frames.each((frame) => {
        try {
          frame.document.removeEventListener(event, listener, options);
        } catch {
        }
      });
    }
  };
  return frames;
}
function getParentWindow(win) {
  const parent = win.frameElement != null ? win.parent : null;
  return {
    addEventListener: (event, listener, options) => {
      try {
        parent == null ? void 0 : parent.addEventListener(event, listener, options);
      } catch {
      }
      return () => {
        try {
          parent == null ? void 0 : parent.removeEventListener(event, listener, options);
        } catch {
        }
      };
    },
    removeEventListener: (event, listener, options) => {
      try {
        parent == null ? void 0 : parent.removeEventListener(event, listener, options);
      } catch {
      }
    }
  };
}
var POINTER_OUTSIDE_EVENT = "pointerdown.outside";
var FOCUS_OUTSIDE_EVENT = "focus.outside";
function isComposedPathFocusable(composedPath) {
  for (const node of composedPath) {
    if (isHTMLElement(node) && isFocusable(node)) return true;
  }
  return false;
}
var isPointerEvent = (event) => "clientY" in event;
function isEventPointWithin(node, event) {
  if (!isPointerEvent(event) || !node) return false;
  const rect = node.getBoundingClientRect();
  if (rect.width === 0 || rect.height === 0) return false;
  return rect.top <= event.clientY && event.clientY <= rect.top + rect.height && rect.left <= event.clientX && event.clientX <= rect.left + rect.width;
}
function isPointInRect(rect, point) {
  return rect.y <= point.y && point.y <= rect.y + rect.height && rect.x <= point.x && point.x <= rect.x + rect.width;
}
function isEventWithinScrollbar(event, ancestor) {
  if (!ancestor || !isPointerEvent(event)) return false;
  const isScrollableY = ancestor.scrollHeight > ancestor.clientHeight;
  const onScrollbarY = isScrollableY && event.clientX > ancestor.offsetLeft + ancestor.clientWidth;
  const isScrollableX = ancestor.scrollWidth > ancestor.clientWidth;
  const onScrollbarX = isScrollableX && event.clientY > ancestor.offsetTop + ancestor.clientHeight;
  const rect = {
    x: ancestor.offsetLeft,
    y: ancestor.offsetTop,
    width: ancestor.clientWidth + (isScrollableY ? 16 : 0),
    height: ancestor.clientHeight + (isScrollableX ? 16 : 0)
  };
  const point = {
    x: event.clientX,
    y: event.clientY
  };
  if (!isPointInRect(rect, point)) return false;
  return onScrollbarY || onScrollbarX;
}
function trackInteractOutsideImpl(node, options) {
  const { exclude, onFocusOutside, onPointerDownOutside, onInteractOutside, defer } = options;
  if (!node) return;
  const doc = getDocument(node);
  const win = getWindow(node);
  const frames = getWindowFrames(win);
  const parentWin = getParentWindow(win);
  function isEventOutside(event) {
    const target = getEventTarget(event);
    if (!isHTMLElement(target)) return false;
    if (!target.isConnected) return false;
    if (contains(node, target)) return false;
    if (isEventPointWithin(node, event)) return false;
    const triggerEl = doc.querySelector(`[aria-controls="${node.id}"]`);
    if (triggerEl) {
      const triggerAncestor = getNearestOverflowAncestor(triggerEl);
      if (isEventWithinScrollbar(event, triggerAncestor)) return false;
    }
    const nodeAncestor = getNearestOverflowAncestor(node);
    if (isEventWithinScrollbar(event, nodeAncestor)) return false;
    return !(exclude == null ? void 0 : exclude(target));
  }
  const pointerdownCleanups = /* @__PURE__ */ new Set();
  function onPointerDown(event) {
    function handler() {
      var _a8;
      const func = defer ? raf : (v) => v();
      const composedPath = ((_a8 = event.composedPath) == null ? void 0 : _a8.call(event)) ?? [event.target];
      func(() => {
        if (!node || !isEventOutside(event)) return;
        if (onPointerDownOutside || onInteractOutside) {
          const handler2 = callAll(onPointerDownOutside, onInteractOutside);
          node.addEventListener(POINTER_OUTSIDE_EVENT, handler2, { once: true });
        }
        fireCustomEvent(node, POINTER_OUTSIDE_EVENT, {
          bubbles: false,
          cancelable: true,
          detail: {
            originalEvent: event,
            contextmenu: isContextMenuEvent(event),
            focusable: isComposedPathFocusable(composedPath)
          }
        });
      });
    }
    if (event.pointerType === "touch") {
      pointerdownCleanups.forEach((fn) => fn());
      pointerdownCleanups.add(addDomEvent(doc, "click", handler, { once: true }));
      pointerdownCleanups.add(parentWin.addEventListener("click", handler, { once: true }));
      pointerdownCleanups.add(frames.addEventListener("click", handler, { once: true }));
    } else {
      handler();
    }
  }
  const cleanups2 = /* @__PURE__ */ new Set();
  const timer = setTimeout(() => {
    cleanups2.add(addDomEvent(doc, "pointerdown", onPointerDown, true));
    cleanups2.add(parentWin.addEventListener("pointerdown", onPointerDown, true));
    cleanups2.add(frames.addEventListener("pointerdown", onPointerDown, true));
  }, 0);
  function onFocusin(event) {
    const func = defer ? raf : (v) => v();
    func(() => {
      if (!node || !isEventOutside(event)) return;
      if (onFocusOutside || onInteractOutside) {
        const handler = callAll(onFocusOutside, onInteractOutside);
        node.addEventListener(FOCUS_OUTSIDE_EVENT, handler, { once: true });
      }
      fireCustomEvent(node, FOCUS_OUTSIDE_EVENT, {
        bubbles: false,
        cancelable: true,
        detail: {
          originalEvent: event,
          contextmenu: false,
          focusable: isFocusable(getEventTarget(event))
        }
      });
    });
  }
  cleanups2.add(addDomEvent(doc, "focusin", onFocusin, true));
  cleanups2.add(parentWin.addEventListener("focusin", onFocusin, true));
  cleanups2.add(frames.addEventListener("focusin", onFocusin, true));
  return () => {
    clearTimeout(timer);
    pointerdownCleanups.forEach((fn) => fn());
    cleanups2.forEach((fn) => fn());
  };
}
function trackInteractOutside(nodeOrFn, options) {
  const { defer } = options;
  const func = defer ? raf : (v) => v();
  const cleanups2 = [];
  cleanups2.push(
    func(() => {
      const node = typeof nodeOrFn === "function" ? nodeOrFn() : nodeOrFn;
      cleanups2.push(trackInteractOutsideImpl(node, options));
    })
  );
  return () => {
    cleanups2.forEach((fn) => fn == null ? void 0 : fn());
  };
}
function fireCustomEvent(el, type, init) {
  const win = el.ownerDocument.defaultView || window;
  const event = new win.CustomEvent(type, init);
  return el.dispatchEvent(event);
}

// node_modules/@zag-js/dismissable/dist/index.mjs
function trackEscapeKeydown(node, fn) {
  const handleKeyDown = (event) => {
    if (event.key !== "Escape") return;
    if (event.isComposing) return;
    fn == null ? void 0 : fn(event);
  };
  return addDomEvent(getDocument(node), "keydown", handleKeyDown, { capture: true });
}
var layerStack = {
  layers: [],
  branches: [],
  count() {
    return this.layers.length;
  },
  pointerBlockingLayers() {
    return this.layers.filter((layer) => layer.pointerBlocking);
  },
  topMostPointerBlockingLayer() {
    return [...this.pointerBlockingLayers()].slice(-1)[0];
  },
  hasPointerBlockingLayer() {
    return this.pointerBlockingLayers().length > 0;
  },
  isBelowPointerBlockingLayer(node) {
    var _a8;
    const index = this.indexOf(node);
    const highestBlockingIndex = this.topMostPointerBlockingLayer() ? this.indexOf((_a8 = this.topMostPointerBlockingLayer()) == null ? void 0 : _a8.node) : -1;
    return index < highestBlockingIndex;
  },
  isTopMost(node) {
    const layer = this.layers[this.count() - 1];
    return (layer == null ? void 0 : layer.node) === node;
  },
  getNestedLayers(node) {
    return Array.from(this.layers).slice(this.indexOf(node) + 1);
  },
  isInNestedLayer(node, target) {
    return this.getNestedLayers(node).some((layer) => contains(layer.node, target));
  },
  isInBranch(target) {
    return Array.from(this.branches).some((branch) => contains(branch, target));
  },
  add(layer) {
    const num = this.layers.push(layer);
    layer.node.style.setProperty("--layer-index", `${num}`);
  },
  addBranch(node) {
    this.branches.push(node);
  },
  remove(node) {
    const index = this.indexOf(node);
    if (index < 0) return;
    if (index < this.count() - 1) {
      const _layers = this.getNestedLayers(node);
      _layers.forEach((layer) => layer.dismiss());
    }
    this.layers.splice(index, 1);
    node.style.removeProperty("--layer-index");
  },
  removeBranch(node) {
    const index = this.branches.indexOf(node);
    if (index >= 0) this.branches.splice(index, 1);
  },
  indexOf(node) {
    return this.layers.findIndex((layer) => layer.node === node);
  },
  dismiss(node) {
    var _a8;
    (_a8 = this.layers[this.indexOf(node)]) == null ? void 0 : _a8.dismiss();
  },
  clear() {
    this.remove(this.layers[0].node);
  }
};
var originalBodyPointerEvents;
function assignPointerEventToLayers() {
  layerStack.layers.forEach(({ node }) => {
    node.style.pointerEvents = layerStack.isBelowPointerBlockingLayer(node) ? "none" : "auto";
  });
}
function clearPointerEvent(node) {
  node.style.pointerEvents = "";
}
function disablePointerEventsOutside(node, persistentElements) {
  const doc = getDocument(node);
  const cleanups2 = [];
  if (layerStack.hasPointerBlockingLayer() && !doc.body.hasAttribute("data-inert")) {
    originalBodyPointerEvents = document.body.style.pointerEvents;
    queueMicrotask(() => {
      doc.body.style.pointerEvents = "none";
      doc.body.setAttribute("data-inert", "");
    });
  }
  if (persistentElements) {
    const persistedCleanup = waitForElements(persistentElements, (el) => {
      cleanups2.push(setStyle(el, { pointerEvents: "auto" }));
    });
    cleanups2.push(persistedCleanup);
  }
  return () => {
    if (layerStack.hasPointerBlockingLayer()) return;
    queueMicrotask(() => {
      doc.body.style.pointerEvents = originalBodyPointerEvents;
      doc.body.removeAttribute("data-inert");
      if (doc.body.style.length === 0) doc.body.removeAttribute("style");
    });
    cleanups2.forEach((fn) => fn());
  };
}
function trackDismissableElementImpl(node, options) {
  if (!node) {
    warn("[@zag-js/dismissable] node is `null` or `undefined`");
    return;
  }
  const { onDismiss, pointerBlocking, exclude: excludeContainers, debug } = options;
  const layer = { dismiss: onDismiss, node, pointerBlocking };
  layerStack.add(layer);
  assignPointerEventToLayers();
  function onPointerDownOutside(event) {
    var _a8, _b7;
    const target = getEventTarget(event.detail.originalEvent);
    if (layerStack.isBelowPointerBlockingLayer(node) || layerStack.isInBranch(target)) return;
    (_a8 = options.onPointerDownOutside) == null ? void 0 : _a8.call(options, event);
    (_b7 = options.onInteractOutside) == null ? void 0 : _b7.call(options, event);
    if (event.defaultPrevented) return;
    if (debug) {
      console.log("onPointerDownOutside:", event.detail.originalEvent);
    }
    onDismiss == null ? void 0 : onDismiss();
  }
  function onFocusOutside(event) {
    var _a8, _b7;
    const target = getEventTarget(event.detail.originalEvent);
    if (layerStack.isInBranch(target)) return;
    (_a8 = options.onFocusOutside) == null ? void 0 : _a8.call(options, event);
    (_b7 = options.onInteractOutside) == null ? void 0 : _b7.call(options, event);
    if (event.defaultPrevented) return;
    if (debug) {
      console.log("onFocusOutside:", event.detail.originalEvent);
    }
    onDismiss == null ? void 0 : onDismiss();
  }
  function onEscapeKeyDown(event) {
    var _a8;
    if (!layerStack.isTopMost(node)) return;
    (_a8 = options.onEscapeKeyDown) == null ? void 0 : _a8.call(options, event);
    if (!event.defaultPrevented && onDismiss) {
      event.preventDefault();
      onDismiss();
    }
  }
  function exclude(target) {
    var _a8;
    if (!node) return false;
    const containers = typeof excludeContainers === "function" ? excludeContainers() : excludeContainers;
    const _containers = Array.isArray(containers) ? containers : [containers];
    const persistentElements = (_a8 = options.persistentElements) == null ? void 0 : _a8.map((fn) => fn()).filter(isHTMLElement);
    if (persistentElements) _containers.push(...persistentElements);
    return _containers.some((node2) => contains(node2, target)) || layerStack.isInNestedLayer(node, target);
  }
  const cleanups2 = [
    pointerBlocking ? disablePointerEventsOutside(node, options.persistentElements) : void 0,
    trackEscapeKeydown(node, onEscapeKeyDown),
    trackInteractOutside(node, { exclude, onFocusOutside, onPointerDownOutside, defer: options.defer })
  ];
  return () => {
    layerStack.remove(node);
    assignPointerEventToLayers();
    clearPointerEvent(node);
    cleanups2.forEach((fn) => fn == null ? void 0 : fn());
  };
}
function trackDismissableElement(nodeOrFn, options) {
  const { defer } = options;
  const func = defer ? raf : (v) => v();
  const cleanups2 = [];
  cleanups2.push(
    func(() => {
      const node = isFunction2(nodeOrFn) ? nodeOrFn() : nodeOrFn;
      cleanups2.push(trackDismissableElementImpl(node, options));
    })
  );
  return () => {
    func(() => {
      cleanups2.forEach((fn) => fn == null ? void 0 : fn());
    });
  };
}
function trackDismissableBranch(nodeOrFn, options = {}) {
  const { defer } = options;
  const func = defer ? raf : (v) => v();
  const cleanups2 = [];
  cleanups2.push(
    func(() => {
      const node = isFunction2(nodeOrFn) ? nodeOrFn() : nodeOrFn;
      if (!node) {
        warn("[@zag-js/dismissable] branch node is `null` or `undefined`");
        return;
      }
      layerStack.addBranch(node);
      cleanups2.push(() => {
        layerStack.removeBranch(node);
      });
    })
  );
  return () => {
    func(() => {
      cleanups2.forEach((fn) => fn == null ? void 0 : fn());
    });
  };
}

// node_modules/@zag-js/color-picker/dist/index.mjs
var anatomy3 = createAnatomy("color-picker", [
  "root",
  "label",
  "control",
  "trigger",
  "positioner",
  "content",
  "area",
  "areaThumb",
  "valueText",
  "areaBackground",
  "channelSlider",
  "channelSliderLabel",
  "channelSliderTrack",
  "channelSliderThumb",
  "channelSliderValueText",
  "channelInput",
  "transparencyGrid",
  "swatchGroup",
  "swatchTrigger",
  "swatchIndicator",
  "swatch",
  "eyeDropperTrigger",
  "formatTrigger",
  "formatSelect"
]);
var parts3 = anatomy3.build();
var dom3 = createScope({
  getRootId: (ctx) => {
    var _a8;
    return ((_a8 = ctx.ids) == null ? void 0 : _a8.root) ?? `color-picker:${ctx.id}`;
  },
  getLabelId: (ctx) => {
    var _a8;
    return ((_a8 = ctx.ids) == null ? void 0 : _a8.label) ?? `color-picker:${ctx.id}:label`;
  },
  getHiddenInputId: (ctx) => {
    var _a8;
    return ((_a8 = ctx.ids) == null ? void 0 : _a8.hiddenInput) ?? `color-picker:${ctx.id}:hidden-input`;
  },
  getControlId: (ctx) => {
    var _a8;
    return ((_a8 = ctx.ids) == null ? void 0 : _a8.control) ?? `color-picker:${ctx.id}:control`;
  },
  getTriggerId: (ctx) => {
    var _a8;
    return ((_a8 = ctx.ids) == null ? void 0 : _a8.trigger) ?? `color-picker:${ctx.id}:trigger`;
  },
  getContentId: (ctx) => {
    var _a8;
    return ((_a8 = ctx.ids) == null ? void 0 : _a8.content) ?? `color-picker:${ctx.id}:content`;
  },
  getPositionerId: (ctx) => {
    var _a8;
    return ((_a8 = ctx.ids) == null ? void 0 : _a8.positioner) ?? `color-picker:${ctx.id}:positioner`;
  },
  getFormatSelectId: (ctx) => {
    var _a8;
    return ((_a8 = ctx.ids) == null ? void 0 : _a8.formatSelect) ?? `color-picker:${ctx.id}:format-select`;
  },
  getAreaId: (ctx) => {
    var _a8;
    return ((_a8 = ctx.ids) == null ? void 0 : _a8.area) ?? `color-picker:${ctx.id}:area`;
  },
  getAreaGradientId: (ctx) => {
    var _a8;
    return ((_a8 = ctx.ids) == null ? void 0 : _a8.areaGradient) ?? `color-picker:${ctx.id}:area-gradient`;
  },
  getAreaThumbId: (ctx) => {
    var _a8;
    return ((_a8 = ctx.ids) == null ? void 0 : _a8.areaThumb) ?? `color-picker:${ctx.id}:area-thumb`;
  },
  getChannelSliderTrackId: (ctx, channel) => {
    var _a8, _b7;
    return ((_b7 = (_a8 = ctx.ids) == null ? void 0 : _a8.channelSliderTrack) == null ? void 0 : _b7.call(_a8, channel)) ?? `color-picker:${ctx.id}:slider-track:${channel}`;
  },
  getChannelSliderThumbId: (ctx, channel) => {
    var _a8, _b7;
    return ((_b7 = (_a8 = ctx.ids) == null ? void 0 : _a8.channelSliderThumb) == null ? void 0 : _b7.call(_a8, channel)) ?? `color-picker:${ctx.id}:slider-thumb:${channel}`;
  },
  getContentEl: (ctx) => dom3.getById(ctx, dom3.getContentId(ctx)),
  getAreaThumbEl: (ctx) => dom3.getById(ctx, dom3.getAreaThumbId(ctx)),
  getChannelSliderThumbEl: (ctx, channel) => dom3.getById(ctx, dom3.getChannelSliderThumbId(ctx, channel)),
  getChannelInputEl: (ctx, channel) => {
    const selector = `input[data-channel="${channel}"]`;
    return [
      ...queryAll(dom3.getContentEl(ctx), selector),
      ...queryAll(dom3.getControlEl(ctx), selector)
    ];
  },
  getFormatSelectEl: (ctx) => dom3.getById(ctx, dom3.getFormatSelectId(ctx)),
  getHiddenInputEl: (ctx) => dom3.getById(ctx, dom3.getHiddenInputId(ctx)),
  getAreaEl: (ctx) => dom3.getById(ctx, dom3.getAreaId(ctx)),
  getAreaValueFromPoint(ctx, point) {
    const areaEl = dom3.getAreaEl(ctx);
    if (!areaEl) return;
    const { percent } = getRelativePoint(point, areaEl);
    return percent;
  },
  getControlEl: (ctx) => dom3.getById(ctx, dom3.getControlId(ctx)),
  getTriggerEl: (ctx) => dom3.getById(ctx, dom3.getTriggerId(ctx)),
  getPositionerEl: (ctx) => dom3.getById(ctx, dom3.getPositionerId(ctx)),
  getChannelSliderTrackEl: (ctx, channel) => {
    return dom3.getById(ctx, dom3.getChannelSliderTrackId(ctx, channel));
  },
  getChannelSliderValueFromPoint(ctx, point, channel) {
    const trackEl = dom3.getChannelSliderTrackEl(ctx, channel);
    if (!trackEl) return;
    const { percent } = getRelativePoint(point, trackEl);
    return percent;
  },
  getChannelInputEls: (ctx) => {
    return [
      ...queryAll(dom3.getContentEl(ctx), "input[data-channel]"),
      ...queryAll(dom3.getControlEl(ctx), "input[data-channel]")
    ];
  }
});
function getChannelDisplayColor(color, channel) {
  switch (channel) {
    case "hue":
      return parseColor(`hsl(${color.getChannelValue("hue")}, 100%, 50%)`);
    case "lightness":
    case "brightness":
    case "saturation":
    case "red":
    case "green":
    case "blue":
      return color.withChannelValue("alpha", 1);
    case "alpha": {
      return color;
    }
    default:
      throw new Error("Unknown color channel: " + channel);
  }
}
function getChannelValue(color, channel) {
  if (channel == null) return "";
  if (channel === "hex") {
    return color.toString("hex");
  }
  if (channel === "css") {
    return color.toString("css");
  }
  if (channel in color) {
    return color.getChannelValue(channel).toString();
  }
  const isHSL = color.getFormat() === "hsla";
  switch (channel) {
    case "hue":
      return isHSL ? color.toFormat("hsla").getChannelValue("hue").toString() : color.toFormat("hsba").getChannelValue("hue").toString();
    case "saturation":
      return isHSL ? color.toFormat("hsla").getChannelValue("saturation").toString() : color.toFormat("hsba").getChannelValue("saturation").toString();
    case "lightness":
      return color.toFormat("hsla").getChannelValue("lightness").toString();
    case "brightness":
      return color.toFormat("hsba").getChannelValue("brightness").toString();
    case "red":
    case "green":
    case "blue":
      return color.toFormat("rgba").getChannelValue(channel).toString();
    default:
      return color.getChannelValue(channel).toString();
  }
}
function getChannelRange(color, channel) {
  switch (channel) {
    case "hex":
      const minColor = parseColor("#000000");
      const maxColor = parseColor("#FFFFFF");
      return {
        minValue: minColor.toHexInt(),
        maxValue: maxColor.toHexInt(),
        pageSize: 10,
        step: 1
      };
    case "css":
      return void 0;
    case "hue":
    case "saturation":
    case "lightness":
      return color.toFormat("hsla").getChannelRange(channel);
    case "brightness":
      return color.toFormat("hsba").getChannelRange(channel);
    case "red":
    case "green":
    case "blue":
      return color.toFormat("rgba").getChannelRange(channel);
    default:
      return color.getChannelRange(channel);
  }
}
function getSliderBackgroundDirection(orientation, dir) {
  if (orientation === "vertical") {
    return "top";
  } else if (dir === "ltr") {
    return "right";
  } else {
    return "left";
  }
}
var getSliderBackground = (props21) => {
  const { channel, value, dir, orientation } = props21;
  const bgDirection = getSliderBackgroundDirection(orientation, dir);
  const { minValue, maxValue: maxValue2 } = value.getChannelRange(channel);
  switch (channel) {
    case "hue":
      return `linear-gradient(to ${bgDirection}, rgb(255, 0, 0) 0%, rgb(255, 255, 0) 17%, rgb(0, 255, 0) 33%, rgb(0, 255, 255) 50%, rgb(0, 0, 255) 67%, rgb(255, 0, 255) 83%, rgb(255, 0, 0) 100%)`;
    case "lightness": {
      let start = value.withChannelValue(channel, minValue).toString("css");
      let middle = value.withChannelValue(channel, (maxValue2 - minValue) / 2).toString("css");
      let end = value.withChannelValue(channel, maxValue2).toString("css");
      return `linear-gradient(to ${bgDirection}, ${start}, ${middle}, ${end})`;
    }
    case "saturation":
    case "brightness":
    case "red":
    case "green":
    case "blue":
    case "alpha": {
      let start = value.withChannelValue(channel, minValue).toString("css");
      let end = value.withChannelValue(channel, maxValue2).toString("css");
      return `linear-gradient(to ${bgDirection}, ${start}, ${end})`;
    }
    default:
      throw new Error("Unknown color channel: " + channel);
  }
};
function connect3(state2, send, normalize2) {
  const value = state2.context.value;
  const areaValue = state2.context.areaValue;
  const valueAsString = state2.context.valueAsString;
  const disabled = state2.context.isDisabled;
  const interactive = state2.context.isInteractive;
  const dragging = state2.hasTag("dragging");
  const open = state2.hasTag("open");
  const focused = state2.hasTag("focused");
  const getAreaChannels = (props21) => {
    const channels = areaValue.getChannels();
    return {
      xChannel: props21.xChannel ?? channels[1],
      yChannel: props21.yChannel ?? channels[2]
    };
  };
  const currentPlacement = state2.context.currentPlacement;
  const popperStyles = getPlacementStyles({
    ...state2.context.positioning,
    placement: currentPlacement
  });
  function getSwatchTriggerState(props21) {
    const color = normalizeColor(props21.value).toFormat(state2.context.format);
    return {
      value: color,
      valueAsString: color.toString("hex"),
      checked: color.isEqual(value),
      disabled: props21.disabled || !interactive
    };
  }
  return {
    dragging,
    open,
    valueAsString,
    value,
    setOpen(nextOpen) {
      if (nextOpen === open) return;
      send({ type: nextOpen ? "OPEN" : "CLOSE" });
    },
    setValue(value2) {
      send({ type: "VALUE.SET", value: normalizeColor(value2), src: "set-color" });
    },
    getChannelValue(channel) {
      return getChannelValue(value, channel);
    },
    getChannelValueText(channel, locale) {
      return value.formatChannelValue(channel, locale);
    },
    setChannelValue(channel, channelValue) {
      const color = value.withChannelValue(channel, channelValue);
      send({ type: "VALUE.SET", value: color, src: "set-channel" });
    },
    format: state2.context.format,
    setFormat(format) {
      const formatValue2 = value.toFormat(format);
      send({ type: "VALUE.SET", value: formatValue2, src: "set-format" });
    },
    alpha: value.getChannelValue("alpha"),
    setAlpha(alphaValue) {
      const color = value.withChannelValue("alpha", alphaValue);
      send({ type: "VALUE.SET", value: color, src: "set-alpha" });
    },
    getRootProps() {
      return normalize2.element({
        ...parts3.root.attrs,
        dir: state2.context.dir,
        id: dom3.getRootId(state2.context),
        "data-disabled": dataAttr(disabled),
        "data-readonly": dataAttr(state2.context.readOnly),
        "data-invalid": dataAttr(state2.context.invalid),
        style: {
          "--value": value.toString("css")
        }
      });
    },
    getLabelProps() {
      return normalize2.element({
        ...parts3.label.attrs,
        dir: state2.context.dir,
        id: dom3.getLabelId(state2.context),
        htmlFor: dom3.getHiddenInputId(state2.context),
        "data-disabled": dataAttr(disabled),
        "data-readonly": dataAttr(state2.context.readOnly),
        "data-invalid": dataAttr(state2.context.invalid),
        "data-focus": dataAttr(focused),
        onClick(event) {
          event.preventDefault();
          const inputEl = query(dom3.getControlEl(state2.context), "[data-channel=hex]");
          inputEl == null ? void 0 : inputEl.focus({ preventScroll: true });
        }
      });
    },
    getControlProps() {
      return normalize2.element({
        ...parts3.control.attrs,
        id: dom3.getControlId(state2.context),
        dir: state2.context.dir,
        "data-disabled": dataAttr(disabled),
        "data-readonly": dataAttr(state2.context.readOnly),
        "data-invalid": dataAttr(state2.context.invalid),
        "data-state": open ? "open" : "closed",
        "data-focus": dataAttr(focused)
      });
    },
    getTriggerProps() {
      return normalize2.button({
        ...parts3.trigger.attrs,
        id: dom3.getTriggerId(state2.context),
        dir: state2.context.dir,
        disabled,
        "aria-label": `select color. current color is ${valueAsString}`,
        "aria-controls": dom3.getContentId(state2.context),
        "aria-labelledby": dom3.getLabelId(state2.context),
        "data-disabled": dataAttr(disabled),
        "data-readonly": dataAttr(state2.context.readOnly),
        "data-invalid": dataAttr(state2.context.invalid),
        "data-placement": currentPlacement,
        "aria-expanded": dataAttr(open),
        "data-state": open ? "open" : "closed",
        "data-focus": dataAttr(focused),
        type: "button",
        onClick() {
          if (!interactive) return;
          send({ type: "TRIGGER.CLICK" });
        },
        onBlur() {
          if (!interactive) return;
          send({ type: "TRIGGER.BLUR" });
        },
        style: {
          position: "relative"
        }
      });
    },
    getPositionerProps() {
      return normalize2.element({
        ...parts3.positioner.attrs,
        id: dom3.getPositionerId(state2.context),
        dir: state2.context.dir,
        style: popperStyles.floating
      });
    },
    getContentProps() {
      return normalize2.element({
        ...parts3.content.attrs,
        id: dom3.getContentId(state2.context),
        dir: state2.context.dir,
        "data-placement": currentPlacement,
        "data-state": open ? "open" : "closed",
        hidden: !open
      });
    },
    getValueTextProps() {
      return normalize2.element({
        ...parts3.valueText.attrs,
        dir: state2.context.dir,
        "data-disabled": dataAttr(disabled),
        "data-focus": dataAttr(focused)
      });
    },
    getAreaProps(props21 = {}) {
      const { xChannel, yChannel } = getAreaChannels(props21);
      const { areaStyles } = getColorAreaGradient(areaValue, {
        xChannel,
        yChannel,
        dir: state2.context.dir
      });
      return normalize2.element({
        ...parts3.area.attrs,
        id: dom3.getAreaId(state2.context),
        role: "group",
        "data-invalid": dataAttr(state2.context.invalid),
        "data-disabled": dataAttr(disabled),
        "data-readonly": dataAttr(state2.context.readOnly),
        onPointerDown(event) {
          if (!interactive) return;
          if (!isLeftClick(event)) return;
          if (isModifierKey(event)) return;
          const point = getEventPoint(event);
          const channel = { xChannel, yChannel };
          send({ type: "AREA.POINTER_DOWN", point, channel, id: "area" });
          event.preventDefault();
        },
        style: {
          position: "relative",
          touchAction: "none",
          forcedColorAdjust: "none",
          ...areaStyles
        }
      });
    },
    getAreaBackgroundProps(props21 = {}) {
      const { xChannel, yChannel } = getAreaChannels(props21);
      const { areaGradientStyles } = getColorAreaGradient(areaValue, {
        xChannel,
        yChannel,
        dir: state2.context.dir
      });
      return normalize2.element({
        ...parts3.areaBackground.attrs,
        id: dom3.getAreaGradientId(state2.context),
        "data-invalid": dataAttr(state2.context.invalid),
        "data-disabled": dataAttr(disabled),
        "data-readonly": dataAttr(state2.context.readOnly),
        style: {
          position: "relative",
          touchAction: "none",
          forcedColorAdjust: "none",
          ...areaGradientStyles
        }
      });
    },
    getAreaThumbProps(props21 = {}) {
      const { xChannel, yChannel } = getAreaChannels(props21);
      const channel = { xChannel, yChannel };
      const xPercent = areaValue.getChannelValuePercent(xChannel);
      const yPercent = 1 - areaValue.getChannelValuePercent(yChannel);
      const xValue = areaValue.getChannelValue(xChannel);
      const yValue = areaValue.getChannelValue(yChannel);
      const color = areaValue.withChannelValue("alpha", 1).toString("css");
      return normalize2.element({
        ...parts3.areaThumb.attrs,
        id: dom3.getAreaThumbId(state2.context),
        dir: state2.context.dir,
        tabIndex: disabled ? void 0 : 0,
        "data-disabled": dataAttr(disabled),
        "data-invalid": dataAttr(state2.context.invalid),
        "data-readonly": dataAttr(state2.context.readOnly),
        role: "slider",
        "aria-valuemin": 0,
        "aria-valuemax": 100,
        "aria-valuenow": xValue,
        "aria-label": `${xChannel} and ${yChannel}`,
        "aria-roledescription": "2d slider",
        "aria-valuetext": `${xChannel} ${xValue}, ${yChannel} ${yValue}`,
        style: {
          position: "absolute",
          left: `${xPercent * 100}%`,
          top: `${yPercent * 100}%`,
          transform: "translate(-50%, -50%)",
          touchAction: "none",
          forcedColorAdjust: "none",
          "--color": color,
          background: color
        },
        onFocus() {
          if (!interactive) return;
          send({ type: "AREA.FOCUS", id: "area", channel });
        },
        onKeyDown(event) {
          if (event.defaultPrevented) return;
          if (!interactive) return;
          const step = getEventStep(event);
          const keyMap2 = {
            ArrowUp() {
              send({ type: "AREA.ARROW_UP", channel, step });
            },
            ArrowDown() {
              send({ type: "AREA.ARROW_DOWN", channel, step });
            },
            ArrowLeft() {
              send({ type: "AREA.ARROW_LEFT", channel, step });
            },
            ArrowRight() {
              send({ type: "AREA.ARROW_RIGHT", channel, step });
            },
            PageUp() {
              send({ type: "AREA.PAGE_UP", channel, step });
            },
            PageDown() {
              send({ type: "AREA.PAGE_DOWN", channel, step });
            },
            Escape(event2) {
              event2.stopPropagation();
            }
          };
          const exec2 = keyMap2[getEventKey(event, state2.context)];
          if (exec2) {
            exec2(event);
            event.preventDefault();
          }
        }
      });
    },
    getTransparencyGridProps(props21 = {}) {
      const { size: size3 = "12px" } = props21;
      return normalize2.element({
        ...parts3.transparencyGrid.attrs,
        style: {
          "--size": size3,
          width: "100%",
          height: "100%",
          position: "absolute",
          backgroundColor: "#fff",
          backgroundImage: "conic-gradient(#eeeeee 0 25%, transparent 0 50%, #eeeeee 0 75%, transparent 0)",
          backgroundSize: "var(--size) var(--size)",
          inset: "0px",
          zIndex: "auto",
          pointerEvents: "none"
        }
      });
    },
    getChannelSliderProps(props21) {
      const { orientation = "horizontal", channel, format } = props21;
      return normalize2.element({
        ...parts3.channelSlider.attrs,
        "data-channel": channel,
        "data-orientation": orientation,
        role: "presentation",
        onPointerDown(event) {
          if (!interactive) return;
          if (!isLeftClick(event)) return;
          if (isModifierKey(event)) return;
          const point = getEventPoint(event);
          send({ type: "CHANNEL_SLIDER.POINTER_DOWN", channel, format, point, id: channel, orientation });
          event.preventDefault();
        },
        style: {
          position: "relative",
          touchAction: "none"
        }
      });
    },
    getChannelSliderTrackProps(props21) {
      const { orientation = "horizontal", channel, format } = props21;
      const normalizedValue = format ? value.toFormat(format) : areaValue;
      return normalize2.element({
        ...parts3.channelSliderTrack.attrs,
        id: dom3.getChannelSliderTrackId(state2.context, channel),
        role: "group",
        "data-channel": channel,
        "data-orientation": orientation,
        style: {
          position: "relative",
          forcedColorAdjust: "none",
          backgroundImage: getSliderBackground({
            orientation,
            channel,
            dir: state2.context.dir,
            value: normalizedValue
          })
        }
      });
    },
    getChannelSliderLabelProps(props21) {
      const { channel } = props21;
      return normalize2.element({
        ...parts3.channelSliderLabel.attrs,
        "data-channel": channel,
        onClick(event) {
          var _a8;
          if (!interactive) return;
          event.preventDefault();
          const thumbId = dom3.getChannelSliderThumbId(state2.context, channel);
          (_a8 = dom3.getById(state2.context, thumbId)) == null ? void 0 : _a8.focus({ preventScroll: true });
        },
        style: {
          userSelect: "none",
          WebkitUserSelect: "none"
        }
      });
    },
    getChannelSliderValueTextProps(props21) {
      return normalize2.element({
        ...parts3.channelSliderValueText.attrs,
        "data-channel": props21.channel
      });
    },
    getChannelSliderThumbProps(props21) {
      const { orientation = "horizontal", channel, format } = props21;
      const normalizedValue = format ? value.toFormat(format) : areaValue;
      const channelRange = normalizedValue.getChannelRange(channel);
      const channelValue = normalizedValue.getChannelValue(channel);
      const offset3 = (channelValue - channelRange.minValue) / (channelRange.maxValue - channelRange.minValue);
      const placementStyles = orientation === "horizontal" ? { left: `${offset3 * 100}%`, top: "50%" } : { top: `${offset3 * 100}%`, left: "50%" };
      return normalize2.element({
        ...parts3.channelSliderThumb.attrs,
        id: dom3.getChannelSliderThumbId(state2.context, channel),
        role: "slider",
        "aria-label": channel,
        tabIndex: disabled ? void 0 : 0,
        "data-channel": channel,
        "data-disabled": dataAttr(disabled),
        "data-orientation": orientation,
        "aria-disabled": dataAttr(disabled),
        "aria-orientation": orientation,
        "aria-valuemax": channelRange.maxValue,
        "aria-valuemin": channelRange.minValue,
        "aria-valuenow": channelValue,
        "aria-valuetext": `${channel} ${channelValue}`,
        style: {
          forcedColorAdjust: "none",
          position: "absolute",
          background: getChannelDisplayColor(areaValue, channel).toString("css"),
          ...placementStyles
        },
        onFocus() {
          if (!interactive) return;
          send({ type: "CHANNEL_SLIDER.FOCUS", channel });
        },
        onKeyDown(event) {
          if (event.defaultPrevented) return;
          if (!interactive) return;
          const step = getEventStep(event) * channelRange.step;
          const keyMap2 = {
            ArrowUp() {
              send({ type: "CHANNEL_SLIDER.ARROW_UP", channel, step });
            },
            ArrowDown() {
              send({ type: "CHANNEL_SLIDER.ARROW_DOWN", channel, step });
            },
            ArrowLeft() {
              send({ type: "CHANNEL_SLIDER.ARROW_LEFT", channel, step });
            },
            ArrowRight() {
              send({ type: "CHANNEL_SLIDER.ARROW_RIGHT", channel, step });
            },
            PageUp() {
              send({ type: "CHANNEL_SLIDER.PAGE_UP", channel });
            },
            PageDown() {
              send({ type: "CHANNEL_SLIDER.PAGE_DOWN", channel });
            },
            Home() {
              send({ type: "CHANNEL_SLIDER.HOME", channel });
            },
            End() {
              send({ type: "CHANNEL_SLIDER.END", channel });
            },
            Escape(event2) {
              event2.stopPropagation();
            }
          };
          const exec2 = keyMap2[getEventKey(event, state2.context)];
          if (exec2) {
            exec2(event);
            event.preventDefault();
          }
        }
      });
    },
    getChannelInputProps(props21) {
      const { channel } = props21;
      const isTextField = channel === "hex" || channel === "css";
      const channelRange = getChannelRange(value, channel);
      return normalize2.input({
        ...parts3.channelInput.attrs,
        dir: state2.context.dir,
        type: isTextField ? "text" : "number",
        "data-channel": channel,
        "aria-label": channel,
        spellCheck: false,
        autoComplete: "off",
        disabled,
        "data-disabled": dataAttr(disabled),
        "data-invalid": dataAttr(state2.context.invalid),
        "data-readonly": dataAttr(state2.context.readOnly),
        readOnly: state2.context.readOnly,
        defaultValue: getChannelValue(value, channel),
        min: channelRange == null ? void 0 : channelRange.minValue,
        max: channelRange == null ? void 0 : channelRange.maxValue,
        step: channelRange == null ? void 0 : channelRange.step,
        onBeforeInput(event) {
          if (isTextField || !interactive) return;
          const value2 = event.currentTarget.value;
          if (value2.match(/[^0-9.]/g)) {
            event.preventDefault();
          }
        },
        onFocus(event) {
          if (!interactive) return;
          send({ type: "CHANNEL_INPUT.FOCUS", channel });
          event.currentTarget.select();
        },
        onBlur(event) {
          if (!interactive) return;
          const value2 = isTextField ? event.currentTarget.value : event.currentTarget.valueAsNumber;
          send({ type: "CHANNEL_INPUT.BLUR", channel, value: value2, isTextField });
        },
        onKeyDown(event) {
          if (event.defaultPrevented) return;
          if (!interactive) return;
          if (event.key === "Enter") {
            const value2 = isTextField ? event.currentTarget.value : event.currentTarget.valueAsNumber;
            send({ type: "CHANNEL_INPUT.CHANGE", channel, value: value2, isTextField });
            event.preventDefault();
          }
        },
        style: {
          appearance: "none",
          WebkitAppearance: "none",
          MozAppearance: "textfield"
        }
      });
    },
    getHiddenInputProps() {
      return normalize2.input({
        type: "text",
        disabled,
        name: state2.context.name,
        tabIndex: -1,
        readOnly: state2.context.readOnly,
        required: state2.context.required,
        id: dom3.getHiddenInputId(state2.context),
        style: visuallyHiddenStyle,
        defaultValue: valueAsString
      });
    },
    getEyeDropperTriggerProps() {
      return normalize2.button({
        ...parts3.eyeDropperTrigger.attrs,
        type: "button",
        dir: state2.context.dir,
        disabled,
        "data-disabled": dataAttr(disabled),
        "data-invalid": dataAttr(state2.context.invalid),
        "data-readonly": dataAttr(state2.context.readOnly),
        "aria-label": "Pick a color from the screen",
        onClick() {
          if (!interactive) return;
          send("EYEDROPPER.CLICK");
        }
      });
    },
    getSwatchGroupProps() {
      return normalize2.element({
        ...parts3.swatchGroup.attrs,
        role: "group"
      });
    },
    getSwatchTriggerState,
    getSwatchTriggerProps(props21) {
      const swatchState = getSwatchTriggerState(props21);
      return normalize2.button({
        ...parts3.swatchTrigger.attrs,
        disabled: swatchState.disabled,
        dir: state2.context.dir,
        type: "button",
        "aria-label": `select ${swatchState.valueAsString} as the color`,
        "data-state": swatchState.checked ? "checked" : "unchecked",
        "data-value": swatchState.valueAsString,
        "data-disabled": dataAttr(swatchState.disabled),
        onClick() {
          if (swatchState.disabled) return;
          send({ type: "SWATCH_TRIGGER.CLICK", value: swatchState.value });
        },
        style: {
          "--color": swatchState.valueAsString,
          position: "relative"
        }
      });
    },
    getSwatchIndicatorProps(props21) {
      const swatchState = getSwatchTriggerState(props21);
      return normalize2.element({
        ...parts3.swatchIndicator.attrs,
        dir: state2.context.dir,
        hidden: !swatchState.checked
      });
    },
    getSwatchProps(props21) {
      const { respectAlpha = true } = props21;
      const swatchState = getSwatchTriggerState(props21);
      const color = swatchState.value.toString(respectAlpha ? "css" : "hex");
      return normalize2.element({
        ...parts3.swatch.attrs,
        dir: state2.context.dir,
        "data-state": swatchState.checked ? "checked" : "unchecked",
        "data-value": swatchState.valueAsString,
        style: {
          "--color": color,
          position: "relative",
          background: color
        }
      });
    },
    getFormatTriggerProps() {
      return normalize2.button({
        ...parts3.formatTrigger.attrs,
        dir: state2.context.dir,
        type: "button",
        "aria-label": `change color format to ${getNextFormat(state2.context.format)}`,
        onClick(event) {
          if (event.currentTarget.disabled) return;
          const nextFormat = getNextFormat(state2.context.format);
          send({ type: "FORMAT.SET", format: nextFormat, src: "format-trigger" });
        }
      });
    },
    getFormatSelectProps() {
      return normalize2.select({
        ...parts3.formatSelect.attrs,
        "aria-label": "change color format",
        dir: state2.context.dir,
        defaultValue: state2.context.format,
        disabled,
        onChange(event) {
          const format = assertFormat(event.currentTarget.value);
          send({ type: "FORMAT.SET", format, src: "format-select" });
        }
      });
    }
  };
}
var formats = ["hsba", "hsla", "rgba"];
var formatRegex = new RegExp(`^(${formats.join("|")})$`);
function getNextFormat(format) {
  const index = formats.indexOf(format);
  return formats[index + 1] ?? formats[0];
}
function assertFormat(format) {
  if (formatRegex.test(format)) return format;
  throw new Error(`Unsupported color format: ${format}`);
}
var parse = (colorString) => {
  return parseColor(colorString);
};
var { and: and3 } = guards;
function machine3(userContext) {
  const ctx = compact2(userContext);
  return createMachine(
    {
      id: "color-picker",
      initial: ctx.open ? "open" : "idle",
      context: {
        dir: "ltr",
        value: parse("#000000"),
        format: "rgba",
        disabled: false,
        closeOnSelect: false,
        openAutoFocus: true,
        ...ctx,
        activeId: null,
        activeChannel: null,
        activeOrientation: null,
        fieldsetDisabled: false,
        restoreFocus: true,
        positioning: {
          ...ctx.positioning,
          placement: "bottom"
        }
      },
      computed: {
        isRtl: (ctx2) => ctx2.dir === "rtl",
        isDisabled: (ctx2) => !!ctx2.disabled || ctx2.fieldsetDisabled,
        isInteractive: (ctx2) => !(ctx2.isDisabled || ctx2.readOnly),
        valueAsString: (ctx2) => ctx2.value.toString(ctx2.format),
        areaValue: (ctx2) => {
          const format = ctx2.format.startsWith("hsl") ? "hsla" : "hsba";
          return ctx2.value.toFormat(format);
        }
      },
      activities: ["trackFormControl"],
      watch: {
        value: ["syncInputElements"],
        format: ["syncFormatSelectElement"],
        open: ["toggleVisibility"]
      },
      on: {
        "VALUE.SET": {
          actions: ["setValue"]
        },
        "FORMAT.SET": {
          actions: ["setFormat"]
        },
        "CHANNEL_INPUT.CHANGE": {
          actions: ["setChannelColorFromInput"]
        },
        "EYEDROPPER.CLICK": {
          actions: ["openEyeDropper"]
        },
        "SWATCH_TRIGGER.CLICK": {
          actions: ["setValue"]
        }
      },
      states: {
        idle: {
          tags: ["closed"],
          on: {
            "CONTROLLED.OPEN": {
              target: "open",
              actions: ["setInitialFocus"]
            },
            OPEN: [
              {
                guard: "isOpenControlled",
                actions: ["invokeOnOpen"]
              },
              {
                target: "open",
                actions: ["invokeOnOpen", "setInitialFocus"]
              }
            ],
            "TRIGGER.CLICK": [
              {
                guard: "isOpenControlled",
                actions: ["invokeOnOpen"]
              },
              {
                target: "open",
                actions: ["invokeOnOpen", "setInitialFocus"]
              }
            ],
            "CHANNEL_INPUT.FOCUS": {
              target: "focused",
              actions: ["setActiveChannel"]
            }
          }
        },
        focused: {
          tags: ["closed", "focused"],
          on: {
            "CONTROLLED.OPEN": {
              target: "open",
              actions: ["setInitialFocus"]
            },
            OPEN: [
              {
                guard: "isOpenControlled",
                actions: ["invokeOnOpen"]
              },
              {
                target: "open",
                actions: ["invokeOnOpen", "setInitialFocus"]
              }
            ],
            "TRIGGER.CLICK": [
              {
                guard: "isOpenControlled",
                actions: ["invokeOnOpen"]
              },
              {
                target: "open",
                actions: ["invokeOnOpen", "setInitialFocus"]
              }
            ],
            "CHANNEL_INPUT.FOCUS": {
              actions: ["setActiveChannel"]
            },
            "CHANNEL_INPUT.BLUR": {
              target: "idle",
              actions: ["setChannelColorFromInput"]
            },
            "TRIGGER.BLUR": {
              target: "idle"
            }
          }
        },
        open: {
          tags: ["open"],
          activities: ["trackPositioning", "trackDismissableElement"],
          on: {
            "CONTROLLED.CLOSE": [
              {
                guard: "shouldRestoreFocus",
                target: "focused",
                actions: ["setReturnFocus"]
              },
              {
                target: "idle"
              }
            ],
            "TRIGGER.CLICK": [
              {
                guard: "isOpenControlled",
                actions: ["invokeOnClose"]
              },
              {
                target: "idle",
                actions: ["invokeOnClose"]
              }
            ],
            "AREA.POINTER_DOWN": {
              target: "open:dragging",
              actions: ["setActiveChannel", "setAreaColorFromPoint", "focusAreaThumb"]
            },
            "AREA.FOCUS": {
              actions: ["setActiveChannel"]
            },
            "CHANNEL_SLIDER.POINTER_DOWN": {
              target: "open:dragging",
              actions: ["setActiveChannel", "setChannelColorFromPoint", "focusChannelThumb"]
            },
            "CHANNEL_SLIDER.FOCUS": {
              actions: ["setActiveChannel"]
            },
            "AREA.ARROW_LEFT": {
              actions: ["decrementAreaXChannel"]
            },
            "AREA.ARROW_RIGHT": {
              actions: ["incrementAreaXChannel"]
            },
            "AREA.ARROW_UP": {
              actions: ["incrementAreaYChannel"]
            },
            "AREA.ARROW_DOWN": {
              actions: ["decrementAreaYChannel"]
            },
            "AREA.PAGE_UP": {
              actions: ["incrementAreaXChannel"]
            },
            "AREA.PAGE_DOWN": {
              actions: ["decrementAreaXChannel"]
            },
            "CHANNEL_SLIDER.ARROW_LEFT": {
              actions: ["decrementChannel"]
            },
            "CHANNEL_SLIDER.ARROW_RIGHT": {
              actions: ["incrementChannel"]
            },
            "CHANNEL_SLIDER.ARROW_UP": {
              actions: ["incrementChannel"]
            },
            "CHANNEL_SLIDER.ARROW_DOWN": {
              actions: ["decrementChannel"]
            },
            "CHANNEL_SLIDER.PAGE_UP": {
              actions: ["incrementChannel"]
            },
            "CHANNEL_SLIDER.PAGE_DOWN": {
              actions: ["decrementChannel"]
            },
            "CHANNEL_SLIDER.HOME": {
              actions: ["setChannelToMin"]
            },
            "CHANNEL_SLIDER.END": {
              actions: ["setChannelToMax"]
            },
            "CHANNEL_INPUT.BLUR": {
              actions: ["setChannelColorFromInput"]
            },
            INTERACT_OUTSIDE: [
              {
                guard: "isOpenControlled",
                actions: ["invokeOnClose"]
              },
              {
                guard: "shouldRestoreFocus",
                target: "focused",
                actions: ["invokeOnClose", "setReturnFocus"]
              },
              {
                target: "idle",
                actions: ["invokeOnClose"]
              }
            ],
            CLOSE: [
              {
                guard: "isOpenControlled",
                actions: ["invokeOnClose"]
              },
              {
                target: "idle",
                actions: ["invokeOnClose"]
              }
            ],
            "SWATCH_TRIGGER.CLICK": [
              {
                guard: and3("isOpenControlled", "closeOnSelect"),
                actions: ["setValue", "invokeOnClose"]
              },
              {
                guard: "closeOnSelect",
                target: "focused",
                actions: ["setValue", "invokeOnClose", "setReturnFocus"]
              },
              {
                actions: ["setValue"]
              }
            ]
          }
        },
        "open:dragging": {
          tags: ["open"],
          exit: ["clearActiveChannel"],
          activities: ["trackPointerMove", "disableTextSelection", "trackPositioning", "trackDismissableElement"],
          on: {
            "CONTROLLED.CLOSE": [
              {
                guard: "shouldRestoreFocus",
                target: "focused",
                actions: ["setReturnFocus"]
              },
              {
                target: "idle"
              }
            ],
            "AREA.POINTER_MOVE": {
              actions: ["setAreaColorFromPoint", "focusAreaThumb"]
            },
            "AREA.POINTER_UP": {
              target: "open",
              actions: ["invokeOnChangeEnd"]
            },
            "CHANNEL_SLIDER.POINTER_MOVE": {
              actions: ["setChannelColorFromPoint", "focusChannelThumb"]
            },
            "CHANNEL_SLIDER.POINTER_UP": {
              target: "open",
              actions: ["invokeOnChangeEnd"]
            },
            INTERACT_OUTSIDE: [
              {
                guard: "isOpenControlled",
                actions: ["invokeOnClose"]
              },
              {
                guard: "shouldRestoreFocus",
                target: "focused",
                actions: ["invokeOnClose", "setReturnFocus"]
              },
              {
                target: "idle",
                actions: ["invokeOnClose"]
              }
            ],
            CLOSE: [
              {
                guard: "isOpenControlled",
                actions: ["invokeOnClose"]
              },
              {
                target: "idle",
                actions: ["invokeOnClose"]
              }
            ]
          }
        }
      }
    },
    {
      guards: {
        closeOnSelect: (ctx2) => !!ctx2.closeOnSelect,
        isOpenControlled: (ctx2) => !!ctx2["open.controlled"],
        shouldRestoreFocus: (ctx2) => !!ctx2.restoreFocus
      },
      activities: {
        trackPositioning(ctx2) {
          ctx2.currentPlacement || (ctx2.currentPlacement = ctx2.positioning.placement);
          const anchorEl = dom3.getTriggerEl(ctx2);
          const getPositionerEl = () => dom3.getPositionerEl(ctx2);
          return getPlacement(anchorEl, getPositionerEl, {
            ...ctx2.positioning,
            defer: true,
            onComplete(data) {
              ctx2.currentPlacement = data.placement;
            }
          });
        },
        trackDismissableElement(ctx2, _evt, { send }) {
          const getContentEl = () => dom3.getContentEl(ctx2);
          return trackDismissableElement(getContentEl, {
            exclude: dom3.getTriggerEl(ctx2),
            defer: true,
            onInteractOutside(event) {
              var _a8;
              (_a8 = ctx2.onInteractOutside) == null ? void 0 : _a8.call(ctx2, event);
              if (event.defaultPrevented) return;
              ctx2.restoreFocus = !(event.detail.focusable || event.detail.contextmenu);
            },
            onPointerDownOutside: ctx2.onPointerDownOutside,
            onFocusOutside: ctx2.onFocusOutside,
            onDismiss() {
              send({ type: "INTERACT_OUTSIDE" });
            }
          });
        },
        trackFormControl(ctx2, _evt, { send, initialContext }) {
          const inputEl = dom3.getHiddenInputEl(ctx2);
          return trackFormControl(inputEl, {
            onFieldsetDisabledChange(disabled) {
              ctx2.fieldsetDisabled = disabled;
            },
            onFormReset() {
              send({ type: "VALUE.SET", value: initialContext.value, src: "form.reset" });
            }
          });
        },
        trackPointerMove(ctx2, evt, { send }) {
          return trackPointerMove(dom3.getDoc(ctx2), {
            onPointerMove({ point }) {
              const type = ctx2.activeId === "area" ? "AREA.POINTER_MOVE" : "CHANNEL_SLIDER.POINTER_MOVE";
              send({ type, point, format: evt.format });
            },
            onPointerUp() {
              const type = ctx2.activeId === "area" ? "AREA.POINTER_UP" : "CHANNEL_SLIDER.POINTER_UP";
              send({ type });
            }
          });
        },
        disableTextSelection(ctx2) {
          return disableTextSelection({ doc: dom3.getDoc(ctx2), target: dom3.getContentEl(ctx2) });
        }
      },
      actions: {
        openEyeDropper(ctx2) {
          const isSupported = "EyeDropper" in dom3.getWin(ctx2);
          if (!isSupported) return;
          const win = dom3.getWin(ctx2);
          const picker = new win.EyeDropper();
          picker.open().then(({ sRGBHex }) => {
            var _a8;
            const format = ctx2.value.getFormat();
            const color = parseColor(sRGBHex).toFormat(format);
            set4.value(ctx2, color);
            (_a8 = ctx2.onValueChangeEnd) == null ? void 0 : _a8.call(ctx2, { value: ctx2.value, valueAsString: ctx2.valueAsString });
          }).catch(() => void 0);
        },
        setActiveChannel(ctx2, evt) {
          ctx2.activeId = evt.id;
          if (evt.channel) ctx2.activeChannel = evt.channel;
          if (evt.orientation) ctx2.activeOrientation = evt.orientation;
        },
        clearActiveChannel(ctx2) {
          ctx2.activeChannel = null;
          ctx2.activeId = null;
          ctx2.activeOrientation = null;
        },
        setAreaColorFromPoint(ctx2, evt) {
          const normalizedValue = evt.format ? ctx2.value.toFormat(evt.format) : ctx2.areaValue;
          const { xChannel, yChannel } = evt.channel || ctx2.activeChannel;
          const percent = dom3.getAreaValueFromPoint(ctx2, evt.point);
          if (!percent) return;
          const xValue = normalizedValue.getChannelPercentValue(xChannel, percent.x);
          const yValue = normalizedValue.getChannelPercentValue(yChannel, 1 - percent.y);
          const color = normalizedValue.withChannelValue(xChannel, xValue).withChannelValue(yChannel, yValue);
          set4.value(ctx2, color);
        },
        setChannelColorFromPoint(ctx2, evt) {
          const channel = evt.channel || ctx2.activeId;
          const normalizedValue = evt.format ? ctx2.value.toFormat(evt.format) : ctx2.areaValue;
          const percent = dom3.getChannelSliderValueFromPoint(ctx2, evt.point, channel);
          if (!percent) return;
          const orientation = ctx2.activeOrientation || "horizontal";
          const channelPercent = orientation === "horizontal" ? percent.x : percent.y;
          const value = normalizedValue.getChannelPercentValue(channel, channelPercent);
          const color = normalizedValue.withChannelValue(channel, value);
          set4.value(ctx2, color);
        },
        setValue(ctx2, evt) {
          set4.value(ctx2, evt.value);
        },
        setFormat(ctx2, evt) {
          set4.format(ctx2, evt.format);
        },
        syncInputElements(ctx2) {
          sync.inputs(ctx2);
        },
        invokeOnChangeEnd(ctx2) {
          invoke2.changeEnd(ctx2);
        },
        setChannelColorFromInput(ctx2, evt) {
          const { channel, isTextField, value } = evt;
          const currentAlpha = ctx2.value.getChannelValue("alpha");
          let color;
          if (channel === "alpha") {
            let valueAsNumber = parseFloat(value);
            valueAsNumber = Number.isNaN(valueAsNumber) ? currentAlpha : valueAsNumber;
            color = ctx2.value.withChannelValue("alpha", valueAsNumber);
          } else if (isTextField) {
            color = tryCatch(
              () => parse(value).withChannelValue("alpha", currentAlpha),
              () => ctx2.value
            );
          } else {
            const current = ctx2.value.toFormat(ctx2.format);
            const valueAsNumber = Number.isNaN(value) ? current.getChannelValue(channel) : value;
            color = current.withChannelValue(channel, valueAsNumber);
          }
          sync.inputs(ctx2, color);
          set4.value(ctx2, color);
        },
        incrementChannel(ctx2, evt) {
          const color = ctx2.value.incrementChannel(evt.channel, evt.step);
          set4.value(ctx2, color);
        },
        decrementChannel(ctx2, evt) {
          const color = ctx2.value.decrementChannel(evt.channel, evt.step);
          set4.value(ctx2, color);
        },
        incrementAreaXChannel(ctx2, evt) {
          const { xChannel } = evt.channel;
          const color = ctx2.areaValue.incrementChannel(xChannel, evt.step);
          set4.value(ctx2, color);
        },
        decrementAreaXChannel(ctx2, evt) {
          const { xChannel } = evt.channel;
          const color = ctx2.areaValue.decrementChannel(xChannel, evt.step);
          set4.value(ctx2, color);
        },
        incrementAreaYChannel(ctx2, evt) {
          const { yChannel } = evt.channel;
          const color = ctx2.areaValue.incrementChannel(yChannel, evt.step);
          set4.value(ctx2, color);
        },
        decrementAreaYChannel(ctx2, evt) {
          const { yChannel } = evt.channel;
          const color = ctx2.areaValue.decrementChannel(yChannel, evt.step);
          set4.value(ctx2, color);
        },
        setChannelToMax(ctx2, evt) {
          const range = ctx2.value.getChannelRange(evt.channel);
          const color = ctx2.value.withChannelValue(evt.channel, range.maxValue);
          set4.value(ctx2, color);
        },
        setChannelToMin(ctx2, evt) {
          const range = ctx2.value.getChannelRange(evt.channel);
          const color = ctx2.value.withChannelValue(evt.channel, range.minValue);
          set4.value(ctx2, color);
        },
        focusAreaThumb(ctx2) {
          raf(() => {
            var _a8;
            (_a8 = dom3.getAreaThumbEl(ctx2)) == null ? void 0 : _a8.focus({ preventScroll: true });
          });
        },
        focusChannelThumb(ctx2, evt) {
          raf(() => {
            var _a8;
            (_a8 = dom3.getChannelSliderThumbEl(ctx2, evt.channel)) == null ? void 0 : _a8.focus({ preventScroll: true });
          });
        },
        setInitialFocus(ctx2) {
          if (!ctx2.openAutoFocus) return;
          raf(() => {
            const element = getInitialFocus({
              root: dom3.getContentEl(ctx2),
              getInitialEl: ctx2.initialFocusEl
            });
            element == null ? void 0 : element.focus({ preventScroll: true });
          });
        },
        setReturnFocus(ctx2) {
          raf(() => {
            var _a8;
            (_a8 = dom3.getTriggerEl(ctx2)) == null ? void 0 : _a8.focus({ preventScroll: true });
          });
        },
        syncFormatSelectElement(ctx2) {
          sync.formatSelect(ctx2);
        },
        invokeOnOpen(ctx2) {
          var _a8;
          (_a8 = ctx2.onOpenChange) == null ? void 0 : _a8.call(ctx2, { open: true });
        },
        invokeOnClose(ctx2) {
          var _a8;
          (_a8 = ctx2.onOpenChange) == null ? void 0 : _a8.call(ctx2, { open: false });
        },
        toggleVisibility(ctx2, evt, { send }) {
          send({ type: ctx2.open ? "CONTROLLED.OPEN" : "CONTROLLED.CLOSE", previousEvent: evt });
        }
      },
      compareFns: {
        value: (a, b) => a.isEqual(b)
      }
    }
  );
}
var sync = {
  // sync channel inputs
  inputs(ctx, color) {
    const channelInputs = dom3.getChannelInputEls(ctx);
    raf(() => {
      channelInputs.forEach((inputEl) => {
        const channel = inputEl.dataset.channel;
        dom3.setValue(inputEl, getChannelValue(color || ctx.value, channel));
      });
    });
  },
  // sync format select
  formatSelect(ctx) {
    const selectEl = dom3.getFormatSelectEl(ctx);
    raf(() => {
      dom3.setValue(selectEl, ctx.format);
    });
  }
};
var invoke2 = {
  changeEnd(ctx) {
    var _a8;
    const value = ctx.value.toFormat(ctx.format);
    (_a8 = ctx.onValueChangeEnd) == null ? void 0 : _a8.call(ctx, {
      value,
      valueAsString: ctx.valueAsString
    });
  },
  change(ctx) {
    var _a8;
    const value = ctx.value.toFormat(ctx.format);
    (_a8 = ctx.onValueChange) == null ? void 0 : _a8.call(ctx, {
      value,
      valueAsString: ctx.valueAsString
    });
    dispatchInputValueEvent(dom3.getHiddenInputEl(ctx), { value: ctx.valueAsString });
  },
  formatChange(ctx) {
    var _a8;
    (_a8 = ctx.onFormatChange) == null ? void 0 : _a8.call(ctx, { format: ctx.format });
  }
};
var set4 = {
  value(ctx, color) {
    if (!color || ctx.value.isEqual(color)) return;
    ctx.value = color;
    invoke2.change(ctx);
  },
  format(ctx, format) {
    if (ctx.format === format) return;
    ctx.format = format;
    invoke2.formatChange(ctx);
  }
};

// node_modules/@internationalized/date/dist/utils.mjs
function $2b4dce13dd5a17fa$export$842a2cf37af977e1(amount, numerator) {
  return amount - numerator * Math.floor(amount / numerator);
}

// node_modules/@internationalized/date/dist/GregorianCalendar.mjs
var $3b62074eb05584b2$var$EPOCH = 1721426;
function $3b62074eb05584b2$export$f297eb839006d339(era, year, month, day) {
  year = $3b62074eb05584b2$export$c36e0ecb2d4fa69d(era, year);
  let y1 = year - 1;
  let monthOffset = -2;
  if (month <= 2) monthOffset = 0;
  else if ($3b62074eb05584b2$export$553d7fa8e3805fc0(year)) monthOffset = -1;
  return $3b62074eb05584b2$var$EPOCH - 1 + 365 * y1 + Math.floor(y1 / 4) - Math.floor(y1 / 100) + Math.floor(y1 / 400) + Math.floor((367 * month - 362) / 12 + monthOffset + day);
}
function $3b62074eb05584b2$export$553d7fa8e3805fc0(year) {
  return year % 4 === 0 && (year % 100 !== 0 || year % 400 === 0);
}
function $3b62074eb05584b2$export$c36e0ecb2d4fa69d(era, year) {
  return era === "BC" ? 1 - year : year;
}
function $3b62074eb05584b2$export$4475b7e617eb123c(year) {
  let era = "AD";
  if (year <= 0) {
    era = "BC";
    year = 1 - year;
  }
  return [
    era,
    year
  ];
}
var $3b62074eb05584b2$var$daysInMonth = {
  standard: [
    31,
    28,
    31,
    30,
    31,
    30,
    31,
    31,
    30,
    31,
    30,
    31
  ],
  leapyear: [
    31,
    29,
    31,
    30,
    31,
    30,
    31,
    31,
    30,
    31,
    30,
    31
  ]
};
var $3b62074eb05584b2$export$80ee6245ec4f29ec = class {
  fromJulianDay(jd) {
    let jd0 = jd;
    let depoch = jd0 - $3b62074eb05584b2$var$EPOCH;
    let quadricent = Math.floor(depoch / 146097);
    let dqc = (0, $2b4dce13dd5a17fa$export$842a2cf37af977e1)(depoch, 146097);
    let cent = Math.floor(dqc / 36524);
    let dcent = (0, $2b4dce13dd5a17fa$export$842a2cf37af977e1)(dqc, 36524);
    let quad = Math.floor(dcent / 1461);
    let dquad = (0, $2b4dce13dd5a17fa$export$842a2cf37af977e1)(dcent, 1461);
    let yindex = Math.floor(dquad / 365);
    let extendedYear = quadricent * 400 + cent * 100 + quad * 4 + yindex + (cent !== 4 && yindex !== 4 ? 1 : 0);
    let [era, year] = $3b62074eb05584b2$export$4475b7e617eb123c(extendedYear);
    let yearDay = jd0 - $3b62074eb05584b2$export$f297eb839006d339(era, year, 1, 1);
    let leapAdj = 2;
    if (jd0 < $3b62074eb05584b2$export$f297eb839006d339(era, year, 3, 1)) leapAdj = 0;
    else if ($3b62074eb05584b2$export$553d7fa8e3805fc0(year)) leapAdj = 1;
    let month = Math.floor(((yearDay + leapAdj) * 12 + 373) / 367);
    let day = jd0 - $3b62074eb05584b2$export$f297eb839006d339(era, year, month, 1) + 1;
    return new (0, $35ea8db9cb2ccb90$export$99faa760c7908e4f)(era, year, month, day);
  }
  toJulianDay(date) {
    return $3b62074eb05584b2$export$f297eb839006d339(date.era, date.year, date.month, date.day);
  }
  getDaysInMonth(date) {
    return $3b62074eb05584b2$var$daysInMonth[$3b62074eb05584b2$export$553d7fa8e3805fc0(date.year) ? "leapyear" : "standard"][date.month - 1];
  }
  // eslint-disable-next-line @typescript-eslint/no-unused-vars
  getMonthsInYear(date) {
    return 12;
  }
  getDaysInYear(date) {
    return $3b62074eb05584b2$export$553d7fa8e3805fc0(date.year) ? 366 : 365;
  }
  // eslint-disable-next-line @typescript-eslint/no-unused-vars
  getYearsInEra(date) {
    return 9999;
  }
  getEras() {
    return [
      "BC",
      "AD"
    ];
  }
  isInverseEra(date) {
    return date.era === "BC";
  }
  balanceDate(date) {
    if (date.year <= 0) {
      date.era = date.era === "BC" ? "AD" : "BC";
      date.year = 1 - date.year;
    }
  }
  constructor() {
    this.identifier = "gregory";
  }
};

// node_modules/@internationalized/date/dist/weekStartData.mjs
var $2fe286d2fb449abb$export$7a5acbd77d414bd9 = {
  "001": 1,
  AD: 1,
  AE: 6,
  AF: 6,
  AI: 1,
  AL: 1,
  AM: 1,
  AN: 1,
  AR: 1,
  AT: 1,
  AU: 1,
  AX: 1,
  AZ: 1,
  BA: 1,
  BE: 1,
  BG: 1,
  BH: 6,
  BM: 1,
  BN: 1,
  BY: 1,
  CH: 1,
  CL: 1,
  CM: 1,
  CN: 1,
  CR: 1,
  CY: 1,
  CZ: 1,
  DE: 1,
  DJ: 6,
  DK: 1,
  DZ: 6,
  EC: 1,
  EE: 1,
  EG: 6,
  ES: 1,
  FI: 1,
  FJ: 1,
  FO: 1,
  FR: 1,
  GB: 1,
  GE: 1,
  GF: 1,
  GP: 1,
  GR: 1,
  HR: 1,
  HU: 1,
  IE: 1,
  IQ: 6,
  IR: 6,
  IS: 1,
  IT: 1,
  JO: 6,
  KG: 1,
  KW: 6,
  KZ: 1,
  LB: 1,
  LI: 1,
  LK: 1,
  LT: 1,
  LU: 1,
  LV: 1,
  LY: 6,
  MC: 1,
  MD: 1,
  ME: 1,
  MK: 1,
  MN: 1,
  MQ: 1,
  MV: 5,
  MY: 1,
  NL: 1,
  NO: 1,
  NZ: 1,
  OM: 6,
  PL: 1,
  QA: 6,
  RE: 1,
  RO: 1,
  RS: 1,
  RU: 1,
  SD: 6,
  SE: 1,
  SI: 1,
  SK: 1,
  SM: 1,
  SY: 6,
  TJ: 1,
  TM: 1,
  TR: 1,
  UA: 1,
  UY: 1,
  UZ: 1,
  VA: 1,
  VN: 1,
  XK: 1
};

// node_modules/@internationalized/date/dist/queries.mjs
function $14e0f24ef4ac5c92$export$ea39ec197993aef0(a, b) {
  b = (0, $11d87f3f76e88657$export$b4a036af3fc0b032)(b, a.calendar);
  return a.era === b.era && a.year === b.year && a.month === b.month && a.day === b.day;
}
function $14e0f24ef4ac5c92$export$91b62ebf2ba703ee(a, b) {
  return a.calendar.identifier === b.calendar.identifier && a.era === b.era && a.year === b.year && a.month === b.month && a.day === b.day;
}
function $14e0f24ef4ac5c92$export$629b0a497aa65267(date, timeZone) {
  return $14e0f24ef4ac5c92$export$ea39ec197993aef0(date, $14e0f24ef4ac5c92$export$d0bdf45af03a6ea3(timeZone));
}
var $14e0f24ef4ac5c92$var$DAY_MAP = {
  sun: 0,
  mon: 1,
  tue: 2,
  wed: 3,
  thu: 4,
  fri: 5,
  sat: 6
};
function $14e0f24ef4ac5c92$export$2061056d06d7cdf7(date, locale, firstDayOfWeek) {
  let julian = date.calendar.toJulianDay(date);
  let weekStart = firstDayOfWeek ? $14e0f24ef4ac5c92$var$DAY_MAP[firstDayOfWeek] : $14e0f24ef4ac5c92$var$getWeekStart(locale);
  let dayOfWeek = Math.ceil(julian + 1 - weekStart) % 7;
  if (dayOfWeek < 0) dayOfWeek += 7;
  return dayOfWeek;
}
function $14e0f24ef4ac5c92$export$461939dd4422153(timeZone) {
  return (0, $11d87f3f76e88657$export$1b96692a1ba042ac)(Date.now(), timeZone);
}
function $14e0f24ef4ac5c92$export$d0bdf45af03a6ea3(timeZone) {
  return (0, $11d87f3f76e88657$export$93522d1a439f3617)($14e0f24ef4ac5c92$export$461939dd4422153(timeZone));
}
function $14e0f24ef4ac5c92$export$68781ddf31c0090f(a, b) {
  return a.calendar.toJulianDay(a) - b.calendar.toJulianDay(b);
}
function $14e0f24ef4ac5c92$export$c19a80a9721b80f6(a, b) {
  return $14e0f24ef4ac5c92$var$timeToMs(a) - $14e0f24ef4ac5c92$var$timeToMs(b);
}
function $14e0f24ef4ac5c92$var$timeToMs(a) {
  return a.hour * 36e5 + a.minute * 6e4 + a.second * 1e3 + a.millisecond;
}
var $14e0f24ef4ac5c92$var$localTimeZone = null;
function $14e0f24ef4ac5c92$export$aa8b41735afcabd2() {
  if ($14e0f24ef4ac5c92$var$localTimeZone == null) $14e0f24ef4ac5c92$var$localTimeZone = new Intl.DateTimeFormat().resolvedOptions().timeZone;
  return $14e0f24ef4ac5c92$var$localTimeZone;
}
function $14e0f24ef4ac5c92$export$a5a3b454ada2268e(date) {
  return date.subtract({
    days: date.day - 1
  });
}
function $14e0f24ef4ac5c92$export$a2258d9c4118825c(date) {
  return date.add({
    days: date.calendar.getDaysInMonth(date) - date.day
  });
}
function $14e0f24ef4ac5c92$export$f91e89d3d0406102(date) {
  return $14e0f24ef4ac5c92$export$a5a3b454ada2268e(date.subtract({
    months: date.month - 1
  }));
}
function $14e0f24ef4ac5c92$export$8b7aa55c66d5569e(date) {
  return $14e0f24ef4ac5c92$export$a2258d9c4118825c(date.add({
    months: date.calendar.getMonthsInYear(date) - date.month
  }));
}
function $14e0f24ef4ac5c92$export$42c81a444fbfb5d4(date, locale, firstDayOfWeek) {
  let dayOfWeek = $14e0f24ef4ac5c92$export$2061056d06d7cdf7(date, locale, firstDayOfWeek);
  return date.subtract({
    days: dayOfWeek
  });
}
function $14e0f24ef4ac5c92$export$ef8b6d9133084f4e(date, locale, firstDayOfWeek) {
  return $14e0f24ef4ac5c92$export$42c81a444fbfb5d4(date, locale, firstDayOfWeek).add({
    days: 6
  });
}
var $14e0f24ef4ac5c92$var$cachedRegions = /* @__PURE__ */ new Map();
function $14e0f24ef4ac5c92$var$getRegion(locale) {
  if (Intl.Locale) {
    let region = $14e0f24ef4ac5c92$var$cachedRegions.get(locale);
    if (!region) {
      region = new Intl.Locale(locale).maximize().region;
      if (region) $14e0f24ef4ac5c92$var$cachedRegions.set(locale, region);
    }
    return region;
  }
  let part = locale.split("-")[1];
  return part === "u" ? void 0 : part;
}
function $14e0f24ef4ac5c92$var$getWeekStart(locale) {
  let region = $14e0f24ef4ac5c92$var$getRegion(locale);
  return region ? (0, $2fe286d2fb449abb$export$7a5acbd77d414bd9)[region] || 0 : 0;
}
function $14e0f24ef4ac5c92$export$ccc1b2479e7dd654(date, locale, firstDayOfWeek) {
  let days = date.calendar.getDaysInMonth(date);
  return Math.ceil(($14e0f24ef4ac5c92$export$2061056d06d7cdf7($14e0f24ef4ac5c92$export$a5a3b454ada2268e(date), locale, firstDayOfWeek) + days) / 7);
}
function $14e0f24ef4ac5c92$export$5c333a116e949cdd(a, b) {
  if (a && b) return a.compare(b) <= 0 ? a : b;
  return a || b;
}
function $14e0f24ef4ac5c92$export$a75f2bff57811055(a, b) {
  if (a && b) return a.compare(b) >= 0 ? a : b;
  return a || b;
}
var $14e0f24ef4ac5c92$var$WEEKEND_DATA = {
  AF: [
    4,
    5
  ],
  AE: [
    5,
    6
  ],
  BH: [
    5,
    6
  ],
  DZ: [
    5,
    6
  ],
  EG: [
    5,
    6
  ],
  IL: [
    5,
    6
  ],
  IQ: [
    5,
    6
  ],
  IR: [
    5,
    5
  ],
  JO: [
    5,
    6
  ],
  KW: [
    5,
    6
  ],
  LY: [
    5,
    6
  ],
  OM: [
    5,
    6
  ],
  QA: [
    5,
    6
  ],
  SA: [
    5,
    6
  ],
  SD: [
    5,
    6
  ],
  SY: [
    5,
    6
  ],
  YE: [
    5,
    6
  ]
};
function $14e0f24ef4ac5c92$export$618d60ea299da42(date, locale) {
  let julian = date.calendar.toJulianDay(date);
  let dayOfWeek = Math.ceil(julian + 1) % 7;
  if (dayOfWeek < 0) dayOfWeek += 7;
  let region = $14e0f24ef4ac5c92$var$getRegion(locale);
  let [start, end] = $14e0f24ef4ac5c92$var$WEEKEND_DATA[region] || [
    6,
    0
  ];
  return dayOfWeek === start || dayOfWeek === end;
}

// node_modules/@internationalized/date/dist/conversion.mjs
function $11d87f3f76e88657$export$bd4fb2bc8bb06fb(date) {
  date = $11d87f3f76e88657$export$b4a036af3fc0b032(date, new (0, $3b62074eb05584b2$export$80ee6245ec4f29ec)());
  let year = (0, $3b62074eb05584b2$export$c36e0ecb2d4fa69d)(date.era, date.year);
  return $11d87f3f76e88657$var$epochFromParts(year, date.month, date.day, date.hour, date.minute, date.second, date.millisecond);
}
function $11d87f3f76e88657$var$epochFromParts(year, month, day, hour, minute, second, millisecond) {
  let date = /* @__PURE__ */ new Date();
  date.setUTCHours(hour, minute, second, millisecond);
  date.setUTCFullYear(year, month - 1, day);
  return date.getTime();
}
function $11d87f3f76e88657$export$59c99f3515d3493f(ms, timeZone) {
  if (timeZone === "UTC") return 0;
  if (ms > 0 && timeZone === (0, $14e0f24ef4ac5c92$export$aa8b41735afcabd2)()) return new Date(ms).getTimezoneOffset() * -6e4;
  let { year, month, day, hour, minute, second } = $11d87f3f76e88657$var$getTimeZoneParts(ms, timeZone);
  let utc = $11d87f3f76e88657$var$epochFromParts(year, month, day, hour, minute, second, 0);
  return utc - Math.floor(ms / 1e3) * 1e3;
}
var $11d87f3f76e88657$var$formattersByTimeZone = /* @__PURE__ */ new Map();
function $11d87f3f76e88657$var$getTimeZoneParts(ms, timeZone) {
  let formatter = $11d87f3f76e88657$var$formattersByTimeZone.get(timeZone);
  if (!formatter) {
    formatter = new Intl.DateTimeFormat("en-US", {
      timeZone,
      hour12: false,
      era: "short",
      year: "numeric",
      month: "numeric",
      day: "numeric",
      hour: "numeric",
      minute: "numeric",
      second: "numeric"
    });
    $11d87f3f76e88657$var$formattersByTimeZone.set(timeZone, formatter);
  }
  let parts26 = formatter.formatToParts(new Date(ms));
  let namedParts = {};
  for (let part of parts26) if (part.type !== "literal") namedParts[part.type] = part.value;
  return {
    // Firefox returns B instead of BC... https://bugzilla.mozilla.org/show_bug.cgi?id=1752253
    year: namedParts.era === "BC" || namedParts.era === "B" ? -namedParts.year + 1 : +namedParts.year,
    month: +namedParts.month,
    day: +namedParts.day,
    hour: namedParts.hour === "24" ? 0 : +namedParts.hour,
    minute: +namedParts.minute,
    second: +namedParts.second
  };
}
var $11d87f3f76e88657$var$DAYMILLIS = 864e5;
function $11d87f3f76e88657$var$getValidWallTimes(date, timeZone, earlier, later) {
  let found = earlier === later ? [
    earlier
  ] : [
    earlier,
    later
  ];
  return found.filter((absolute) => $11d87f3f76e88657$var$isValidWallTime(date, timeZone, absolute));
}
function $11d87f3f76e88657$var$isValidWallTime(date, timeZone, absolute) {
  let parts26 = $11d87f3f76e88657$var$getTimeZoneParts(absolute, timeZone);
  return date.year === parts26.year && date.month === parts26.month && date.day === parts26.day && date.hour === parts26.hour && date.minute === parts26.minute && date.second === parts26.second;
}
function $11d87f3f76e88657$export$5107c82f94518f5c(date, timeZone, disambiguation = "compatible") {
  let dateTime = $11d87f3f76e88657$export$b21e0b124e224484(date);
  if (timeZone === "UTC") return $11d87f3f76e88657$export$bd4fb2bc8bb06fb(dateTime);
  if (timeZone === (0, $14e0f24ef4ac5c92$export$aa8b41735afcabd2)() && disambiguation === "compatible") {
    dateTime = $11d87f3f76e88657$export$b4a036af3fc0b032(dateTime, new (0, $3b62074eb05584b2$export$80ee6245ec4f29ec)());
    let date2 = /* @__PURE__ */ new Date();
    let year = (0, $3b62074eb05584b2$export$c36e0ecb2d4fa69d)(dateTime.era, dateTime.year);
    date2.setFullYear(year, dateTime.month - 1, dateTime.day);
    date2.setHours(dateTime.hour, dateTime.minute, dateTime.second, dateTime.millisecond);
    return date2.getTime();
  }
  let ms = $11d87f3f76e88657$export$bd4fb2bc8bb06fb(dateTime);
  let offsetBefore = $11d87f3f76e88657$export$59c99f3515d3493f(ms - $11d87f3f76e88657$var$DAYMILLIS, timeZone);
  let offsetAfter = $11d87f3f76e88657$export$59c99f3515d3493f(ms + $11d87f3f76e88657$var$DAYMILLIS, timeZone);
  let valid = $11d87f3f76e88657$var$getValidWallTimes(dateTime, timeZone, ms - offsetBefore, ms - offsetAfter);
  if (valid.length === 1) return valid[0];
  if (valid.length > 1) switch (disambiguation) {
    // 'compatible' means 'earlier' for "fall back" transitions
    case "compatible":
    case "earlier":
      return valid[0];
    case "later":
      return valid[valid.length - 1];
    case "reject":
      throw new RangeError("Multiple possible absolute times found");
  }
  switch (disambiguation) {
    case "earlier":
      return Math.min(ms - offsetBefore, ms - offsetAfter);
    // 'compatible' means 'later' for "spring forward" transitions
    case "compatible":
    case "later":
      return Math.max(ms - offsetBefore, ms - offsetAfter);
    case "reject":
      throw new RangeError("No such absolute time found");
  }
}
function $11d87f3f76e88657$export$e67a095c620b86fe(dateTime, timeZone, disambiguation = "compatible") {
  return new Date($11d87f3f76e88657$export$5107c82f94518f5c(dateTime, timeZone, disambiguation));
}
function $11d87f3f76e88657$export$1b96692a1ba042ac(ms, timeZone) {
  let offset3 = $11d87f3f76e88657$export$59c99f3515d3493f(ms, timeZone);
  let date = new Date(ms + offset3);
  let year = date.getUTCFullYear();
  let month = date.getUTCMonth() + 1;
  let day = date.getUTCDate();
  let hour = date.getUTCHours();
  let minute = date.getUTCMinutes();
  let second = date.getUTCSeconds();
  let millisecond = date.getUTCMilliseconds();
  return new (0, $35ea8db9cb2ccb90$export$d3b7288e7994edea)(year < 1 ? "BC" : "AD", year < 1 ? -year + 1 : year, month, day, timeZone, offset3, hour, minute, second, millisecond);
}
function $11d87f3f76e88657$export$93522d1a439f3617(dateTime) {
  return new (0, $35ea8db9cb2ccb90$export$99faa760c7908e4f)(dateTime.calendar, dateTime.era, dateTime.year, dateTime.month, dateTime.day);
}
function $11d87f3f76e88657$export$b21e0b124e224484(date, time) {
  let hour = 0, minute = 0, second = 0, millisecond = 0;
  if ("timeZone" in date) ({ hour, minute, second, millisecond } = date);
  else if ("hour" in date && !time) return date;
  if (time) ({ hour, minute, second, millisecond } = time);
  return new (0, $35ea8db9cb2ccb90$export$ca871e8dbb80966f)(date.calendar, date.era, date.year, date.month, date.day, hour, minute, second, millisecond);
}
function $11d87f3f76e88657$export$b4a036af3fc0b032(date, calendar) {
  if (date.calendar.identifier === calendar.identifier) return date;
  let calendarDate = calendar.fromJulianDay(date.calendar.toJulianDay(date));
  let copy = date.copy();
  copy.calendar = calendar;
  copy.era = calendarDate.era;
  copy.year = calendarDate.year;
  copy.month = calendarDate.month;
  copy.day = calendarDate.day;
  (0, $735220c2d4774dd3$export$c4e2ecac49351ef2)(copy);
  return copy;
}
function $11d87f3f76e88657$export$84c95a83c799e074(date, timeZone, disambiguation) {
  if (date instanceof (0, $35ea8db9cb2ccb90$export$d3b7288e7994edea)) {
    if (date.timeZone === timeZone) return date;
    return $11d87f3f76e88657$export$538b00033cc11c75(date, timeZone);
  }
  let ms = $11d87f3f76e88657$export$5107c82f94518f5c(date, timeZone, disambiguation);
  return $11d87f3f76e88657$export$1b96692a1ba042ac(ms, timeZone);
}
function $11d87f3f76e88657$export$83aac07b4c37b25(date) {
  let ms = $11d87f3f76e88657$export$bd4fb2bc8bb06fb(date) - date.offset;
  return new Date(ms);
}
function $11d87f3f76e88657$export$538b00033cc11c75(date, timeZone) {
  let ms = $11d87f3f76e88657$export$bd4fb2bc8bb06fb(date) - date.offset;
  return $11d87f3f76e88657$export$b4a036af3fc0b032($11d87f3f76e88657$export$1b96692a1ba042ac(ms, timeZone), date.calendar);
}

// node_modules/@internationalized/date/dist/manipulation.mjs
var $735220c2d4774dd3$var$ONE_HOUR = 36e5;
function $735220c2d4774dd3$export$e16d8520af44a096(date, duration) {
  let mutableDate = date.copy();
  let days = "hour" in mutableDate ? $735220c2d4774dd3$var$addTimeFields(mutableDate, duration) : 0;
  $735220c2d4774dd3$var$addYears(mutableDate, duration.years || 0);
  if (mutableDate.calendar.balanceYearMonth) mutableDate.calendar.balanceYearMonth(mutableDate, date);
  mutableDate.month += duration.months || 0;
  $735220c2d4774dd3$var$balanceYearMonth(mutableDate);
  $735220c2d4774dd3$var$constrainMonthDay(mutableDate);
  mutableDate.day += (duration.weeks || 0) * 7;
  mutableDate.day += duration.days || 0;
  mutableDate.day += days;
  $735220c2d4774dd3$var$balanceDay(mutableDate);
  if (mutableDate.calendar.balanceDate) mutableDate.calendar.balanceDate(mutableDate);
  if (mutableDate.year < 1) {
    mutableDate.year = 1;
    mutableDate.month = 1;
    mutableDate.day = 1;
  }
  let maxYear = mutableDate.calendar.getYearsInEra(mutableDate);
  if (mutableDate.year > maxYear) {
    var _mutableDate_calendar_isInverseEra, _mutableDate_calendar;
    let isInverseEra = (_mutableDate_calendar_isInverseEra = (_mutableDate_calendar = mutableDate.calendar).isInverseEra) === null || _mutableDate_calendar_isInverseEra === void 0 ? void 0 : _mutableDate_calendar_isInverseEra.call(_mutableDate_calendar, mutableDate);
    mutableDate.year = maxYear;
    mutableDate.month = isInverseEra ? 1 : mutableDate.calendar.getMonthsInYear(mutableDate);
    mutableDate.day = isInverseEra ? 1 : mutableDate.calendar.getDaysInMonth(mutableDate);
  }
  if (mutableDate.month < 1) {
    mutableDate.month = 1;
    mutableDate.day = 1;
  }
  let maxMonth = mutableDate.calendar.getMonthsInYear(mutableDate);
  if (mutableDate.month > maxMonth) {
    mutableDate.month = maxMonth;
    mutableDate.day = mutableDate.calendar.getDaysInMonth(mutableDate);
  }
  mutableDate.day = Math.max(1, Math.min(mutableDate.calendar.getDaysInMonth(mutableDate), mutableDate.day));
  return mutableDate;
}
function $735220c2d4774dd3$var$addYears(date, years) {
  var _date_calendar_isInverseEra, _date_calendar;
  if ((_date_calendar_isInverseEra = (_date_calendar = date.calendar).isInverseEra) === null || _date_calendar_isInverseEra === void 0 ? void 0 : _date_calendar_isInverseEra.call(_date_calendar, date)) years = -years;
  date.year += years;
}
function $735220c2d4774dd3$var$balanceYearMonth(date) {
  while (date.month < 1) {
    $735220c2d4774dd3$var$addYears(date, -1);
    date.month += date.calendar.getMonthsInYear(date);
  }
  let monthsInYear = 0;
  while (date.month > (monthsInYear = date.calendar.getMonthsInYear(date))) {
    date.month -= monthsInYear;
    $735220c2d4774dd3$var$addYears(date, 1);
  }
}
function $735220c2d4774dd3$var$balanceDay(date) {
  while (date.day < 1) {
    date.month--;
    $735220c2d4774dd3$var$balanceYearMonth(date);
    date.day += date.calendar.getDaysInMonth(date);
  }
  while (date.day > date.calendar.getDaysInMonth(date)) {
    date.day -= date.calendar.getDaysInMonth(date);
    date.month++;
    $735220c2d4774dd3$var$balanceYearMonth(date);
  }
}
function $735220c2d4774dd3$var$constrainMonthDay(date) {
  date.month = Math.max(1, Math.min(date.calendar.getMonthsInYear(date), date.month));
  date.day = Math.max(1, Math.min(date.calendar.getDaysInMonth(date), date.day));
}
function $735220c2d4774dd3$export$c4e2ecac49351ef2(date) {
  if (date.calendar.constrainDate) date.calendar.constrainDate(date);
  date.year = Math.max(1, Math.min(date.calendar.getYearsInEra(date), date.year));
  $735220c2d4774dd3$var$constrainMonthDay(date);
}
function $735220c2d4774dd3$export$3e2544e88a25bff8(duration) {
  let inverseDuration = {};
  for (let key in duration) if (typeof duration[key] === "number") inverseDuration[key] = -duration[key];
  return inverseDuration;
}
function $735220c2d4774dd3$export$4e2d2ead65e5f7e3(date, duration) {
  return $735220c2d4774dd3$export$e16d8520af44a096(date, $735220c2d4774dd3$export$3e2544e88a25bff8(duration));
}
function $735220c2d4774dd3$export$adaa4cf7ef1b65be(date, fields) {
  let mutableDate = date.copy();
  if (fields.era != null) mutableDate.era = fields.era;
  if (fields.year != null) mutableDate.year = fields.year;
  if (fields.month != null) mutableDate.month = fields.month;
  if (fields.day != null) mutableDate.day = fields.day;
  $735220c2d4774dd3$export$c4e2ecac49351ef2(mutableDate);
  return mutableDate;
}
function $735220c2d4774dd3$export$e5d5e1c1822b6e56(value, fields) {
  let mutableValue = value.copy();
  if (fields.hour != null) mutableValue.hour = fields.hour;
  if (fields.minute != null) mutableValue.minute = fields.minute;
  if (fields.second != null) mutableValue.second = fields.second;
  if (fields.millisecond != null) mutableValue.millisecond = fields.millisecond;
  $735220c2d4774dd3$export$7555de1e070510cb(mutableValue);
  return mutableValue;
}
function $735220c2d4774dd3$var$balanceTime(time) {
  time.second += Math.floor(time.millisecond / 1e3);
  time.millisecond = $735220c2d4774dd3$var$nonNegativeMod(time.millisecond, 1e3);
  time.minute += Math.floor(time.second / 60);
  time.second = $735220c2d4774dd3$var$nonNegativeMod(time.second, 60);
  time.hour += Math.floor(time.minute / 60);
  time.minute = $735220c2d4774dd3$var$nonNegativeMod(time.minute, 60);
  let days = Math.floor(time.hour / 24);
  time.hour = $735220c2d4774dd3$var$nonNegativeMod(time.hour, 24);
  return days;
}
function $735220c2d4774dd3$export$7555de1e070510cb(time) {
  time.millisecond = Math.max(0, Math.min(time.millisecond, 1e3));
  time.second = Math.max(0, Math.min(time.second, 59));
  time.minute = Math.max(0, Math.min(time.minute, 59));
  time.hour = Math.max(0, Math.min(time.hour, 23));
}
function $735220c2d4774dd3$var$nonNegativeMod(a, b) {
  let result = a % b;
  if (result < 0) result += b;
  return result;
}
function $735220c2d4774dd3$var$addTimeFields(time, duration) {
  time.hour += duration.hours || 0;
  time.minute += duration.minutes || 0;
  time.second += duration.seconds || 0;
  time.millisecond += duration.milliseconds || 0;
  return $735220c2d4774dd3$var$balanceTime(time);
}
function $735220c2d4774dd3$export$7ed87b6bc2506470(time, duration) {
  let res = time.copy();
  $735220c2d4774dd3$var$addTimeFields(res, duration);
  return res;
}
function $735220c2d4774dd3$export$fe34d3a381cd7501(time, duration) {
  return $735220c2d4774dd3$export$7ed87b6bc2506470(time, $735220c2d4774dd3$export$3e2544e88a25bff8(duration));
}
function $735220c2d4774dd3$export$d52ced6badfb9a4c(value, field, amount, options) {
  let mutable = value.copy();
  switch (field) {
    case "era": {
      let eras = value.calendar.getEras();
      let eraIndex = eras.indexOf(value.era);
      if (eraIndex < 0) throw new Error("Invalid era: " + value.era);
      eraIndex = $735220c2d4774dd3$var$cycleValue(eraIndex, amount, 0, eras.length - 1, options === null || options === void 0 ? void 0 : options.round);
      mutable.era = eras[eraIndex];
      $735220c2d4774dd3$export$c4e2ecac49351ef2(mutable);
      break;
    }
    case "year":
      var _mutable_calendar_isInverseEra, _mutable_calendar;
      if ((_mutable_calendar_isInverseEra = (_mutable_calendar = mutable.calendar).isInverseEra) === null || _mutable_calendar_isInverseEra === void 0 ? void 0 : _mutable_calendar_isInverseEra.call(_mutable_calendar, mutable)) amount = -amount;
      mutable.year = $735220c2d4774dd3$var$cycleValue(value.year, amount, -Infinity, 9999, options === null || options === void 0 ? void 0 : options.round);
      if (mutable.year === -Infinity) mutable.year = 1;
      if (mutable.calendar.balanceYearMonth) mutable.calendar.balanceYearMonth(mutable, value);
      break;
    case "month":
      mutable.month = $735220c2d4774dd3$var$cycleValue(value.month, amount, 1, value.calendar.getMonthsInYear(value), options === null || options === void 0 ? void 0 : options.round);
      break;
    case "day":
      mutable.day = $735220c2d4774dd3$var$cycleValue(value.day, amount, 1, value.calendar.getDaysInMonth(value), options === null || options === void 0 ? void 0 : options.round);
      break;
    default:
      throw new Error("Unsupported field " + field);
  }
  if (value.calendar.balanceDate) value.calendar.balanceDate(mutable);
  $735220c2d4774dd3$export$c4e2ecac49351ef2(mutable);
  return mutable;
}
function $735220c2d4774dd3$export$dd02b3e0007dfe28(value, field, amount, options) {
  let mutable = value.copy();
  switch (field) {
    case "hour": {
      let hours = value.hour;
      let min4 = 0;
      let max4 = 23;
      if ((options === null || options === void 0 ? void 0 : options.hourCycle) === 12) {
        let isPM = hours >= 12;
        min4 = isPM ? 12 : 0;
        max4 = isPM ? 23 : 11;
      }
      mutable.hour = $735220c2d4774dd3$var$cycleValue(hours, amount, min4, max4, options === null || options === void 0 ? void 0 : options.round);
      break;
    }
    case "minute":
      mutable.minute = $735220c2d4774dd3$var$cycleValue(value.minute, amount, 0, 59, options === null || options === void 0 ? void 0 : options.round);
      break;
    case "second":
      mutable.second = $735220c2d4774dd3$var$cycleValue(value.second, amount, 0, 59, options === null || options === void 0 ? void 0 : options.round);
      break;
    case "millisecond":
      mutable.millisecond = $735220c2d4774dd3$var$cycleValue(value.millisecond, amount, 0, 999, options === null || options === void 0 ? void 0 : options.round);
      break;
    default:
      throw new Error("Unsupported field " + field);
  }
  return mutable;
}
function $735220c2d4774dd3$var$cycleValue(value, amount, min4, max4, round3 = false) {
  if (round3) {
    value += Math.sign(amount);
    if (value < min4) value = max4;
    let div = Math.abs(amount);
    if (amount > 0) value = Math.ceil(value / div) * div;
    else value = Math.floor(value / div) * div;
    if (value > max4) value = min4;
  } else {
    value += amount;
    if (value < min4) value = max4 - (min4 - value - 1);
    else if (value > max4) value = min4 + (value - max4 - 1);
  }
  return value;
}
function $735220c2d4774dd3$export$96b1d28349274637(dateTime, duration) {
  let ms;
  if (duration.years != null && duration.years !== 0 || duration.months != null && duration.months !== 0 || duration.weeks != null && duration.weeks !== 0 || duration.days != null && duration.days !== 0) {
    let res2 = $735220c2d4774dd3$export$e16d8520af44a096((0, $11d87f3f76e88657$export$b21e0b124e224484)(dateTime), {
      years: duration.years,
      months: duration.months,
      weeks: duration.weeks,
      days: duration.days
    });
    ms = (0, $11d87f3f76e88657$export$5107c82f94518f5c)(res2, dateTime.timeZone);
  } else
    ms = (0, $11d87f3f76e88657$export$bd4fb2bc8bb06fb)(dateTime) - dateTime.offset;
  ms += duration.milliseconds || 0;
  ms += (duration.seconds || 0) * 1e3;
  ms += (duration.minutes || 0) * 6e4;
  ms += (duration.hours || 0) * 36e5;
  let res = (0, $11d87f3f76e88657$export$1b96692a1ba042ac)(ms, dateTime.timeZone);
  return (0, $11d87f3f76e88657$export$b4a036af3fc0b032)(res, dateTime.calendar);
}
function $735220c2d4774dd3$export$6814caac34ca03c7(dateTime, duration) {
  return $735220c2d4774dd3$export$96b1d28349274637(dateTime, $735220c2d4774dd3$export$3e2544e88a25bff8(duration));
}
function $735220c2d4774dd3$export$9a297d111fc86b79(dateTime, field, amount, options) {
  switch (field) {
    case "hour": {
      let min4 = 0;
      let max4 = 23;
      if ((options === null || options === void 0 ? void 0 : options.hourCycle) === 12) {
        let isPM = dateTime.hour >= 12;
        min4 = isPM ? 12 : 0;
        max4 = isPM ? 23 : 11;
      }
      let plainDateTime = (0, $11d87f3f76e88657$export$b21e0b124e224484)(dateTime);
      let minDate = (0, $11d87f3f76e88657$export$b4a036af3fc0b032)($735220c2d4774dd3$export$e5d5e1c1822b6e56(plainDateTime, {
        hour: min4
      }), new (0, $3b62074eb05584b2$export$80ee6245ec4f29ec)());
      let minAbsolute = [
        (0, $11d87f3f76e88657$export$5107c82f94518f5c)(minDate, dateTime.timeZone, "earlier"),
        (0, $11d87f3f76e88657$export$5107c82f94518f5c)(minDate, dateTime.timeZone, "later")
      ].filter((ms2) => (0, $11d87f3f76e88657$export$1b96692a1ba042ac)(ms2, dateTime.timeZone).day === minDate.day)[0];
      let maxDate = (0, $11d87f3f76e88657$export$b4a036af3fc0b032)($735220c2d4774dd3$export$e5d5e1c1822b6e56(plainDateTime, {
        hour: max4
      }), new (0, $3b62074eb05584b2$export$80ee6245ec4f29ec)());
      let maxAbsolute = [
        (0, $11d87f3f76e88657$export$5107c82f94518f5c)(maxDate, dateTime.timeZone, "earlier"),
        (0, $11d87f3f76e88657$export$5107c82f94518f5c)(maxDate, dateTime.timeZone, "later")
      ].filter((ms2) => (0, $11d87f3f76e88657$export$1b96692a1ba042ac)(ms2, dateTime.timeZone).day === maxDate.day).pop();
      let ms = (0, $11d87f3f76e88657$export$bd4fb2bc8bb06fb)(dateTime) - dateTime.offset;
      let hours = Math.floor(ms / $735220c2d4774dd3$var$ONE_HOUR);
      let remainder = ms % $735220c2d4774dd3$var$ONE_HOUR;
      ms = $735220c2d4774dd3$var$cycleValue(hours, amount, Math.floor(minAbsolute / $735220c2d4774dd3$var$ONE_HOUR), Math.floor(maxAbsolute / $735220c2d4774dd3$var$ONE_HOUR), options === null || options === void 0 ? void 0 : options.round) * $735220c2d4774dd3$var$ONE_HOUR + remainder;
      return (0, $11d87f3f76e88657$export$b4a036af3fc0b032)((0, $11d87f3f76e88657$export$1b96692a1ba042ac)(ms, dateTime.timeZone), dateTime.calendar);
    }
    case "minute":
    case "second":
    case "millisecond":
      return $735220c2d4774dd3$export$dd02b3e0007dfe28(dateTime, field, amount, options);
    case "era":
    case "year":
    case "month":
    case "day": {
      let res = $735220c2d4774dd3$export$d52ced6badfb9a4c((0, $11d87f3f76e88657$export$b21e0b124e224484)(dateTime), field, amount, options);
      let ms = (0, $11d87f3f76e88657$export$5107c82f94518f5c)(res, dateTime.timeZone);
      return (0, $11d87f3f76e88657$export$b4a036af3fc0b032)((0, $11d87f3f76e88657$export$1b96692a1ba042ac)(ms, dateTime.timeZone), dateTime.calendar);
    }
    default:
      throw new Error("Unsupported field " + field);
  }
}
function $735220c2d4774dd3$export$31b5430eb18be4f8(dateTime, fields, disambiguation) {
  let plainDateTime = (0, $11d87f3f76e88657$export$b21e0b124e224484)(dateTime);
  let res = $735220c2d4774dd3$export$e5d5e1c1822b6e56($735220c2d4774dd3$export$adaa4cf7ef1b65be(plainDateTime, fields), fields);
  if (res.compare(plainDateTime) === 0) return dateTime;
  let ms = (0, $11d87f3f76e88657$export$5107c82f94518f5c)(res, dateTime.timeZone, disambiguation);
  return (0, $11d87f3f76e88657$export$b4a036af3fc0b032)((0, $11d87f3f76e88657$export$1b96692a1ba042ac)(ms, dateTime.timeZone), dateTime.calendar);
}

// node_modules/@internationalized/date/dist/string.mjs
var $fae977aafc393c5c$var$requiredDurationTimeGroups = [
  "hours",
  "minutes",
  "seconds"
];
var $fae977aafc393c5c$var$requiredDurationGroups = [
  "years",
  "months",
  "weeks",
  "days",
  ...$fae977aafc393c5c$var$requiredDurationTimeGroups
];
function $fae977aafc393c5c$export$f59dee82248f5ad4(time) {
  return `${String(time.hour).padStart(2, "0")}:${String(time.minute).padStart(2, "0")}:${String(time.second).padStart(2, "0")}${time.millisecond ? String(time.millisecond / 1e3).slice(1) : ""}`;
}
function $fae977aafc393c5c$export$60dfd74aa96791bd(date) {
  let gregorianDate = (0, $11d87f3f76e88657$export$b4a036af3fc0b032)(date, new (0, $3b62074eb05584b2$export$80ee6245ec4f29ec)());
  let year;
  if (gregorianDate.era === "BC") year = gregorianDate.year === 1 ? "0000" : "-" + String(Math.abs(1 - gregorianDate.year)).padStart(6, "00");
  else year = String(gregorianDate.year).padStart(4, "0");
  return `${year}-${String(gregorianDate.month).padStart(2, "0")}-${String(gregorianDate.day).padStart(2, "0")}`;
}
function $fae977aafc393c5c$export$4223de14708adc63(date) {
  return `${$fae977aafc393c5c$export$60dfd74aa96791bd(date)}T${$fae977aafc393c5c$export$f59dee82248f5ad4(date)}`;
}
function $fae977aafc393c5c$var$offsetToString(offset3) {
  let sign3 = Math.sign(offset3) < 0 ? "-" : "+";
  offset3 = Math.abs(offset3);
  let offsetHours = Math.floor(offset3 / 36e5);
  let offsetMinutes = offset3 % 36e5 / 6e4;
  return `${sign3}${String(offsetHours).padStart(2, "0")}:${String(offsetMinutes).padStart(2, "0")}`;
}
function $fae977aafc393c5c$export$bf79f1ebf4b18792(date) {
  return `${$fae977aafc393c5c$export$4223de14708adc63(date)}${$fae977aafc393c5c$var$offsetToString(date.offset)}[${date.timeZone}]`;
}

// node_modules/@swc/helpers/esm/_check_private_redeclaration.js
function _check_private_redeclaration(obj, privateCollection) {
  if (privateCollection.has(obj)) {
    throw new TypeError("Cannot initialize the same private elements twice on an object");
  }
}

// node_modules/@swc/helpers/esm/_class_private_field_init.js
function _class_private_field_init(obj, privateMap, value) {
  _check_private_redeclaration(obj, privateMap);
  privateMap.set(obj, value);
}

// node_modules/@internationalized/date/dist/CalendarDate.mjs
function $35ea8db9cb2ccb90$var$shiftArgs(args) {
  let calendar = typeof args[0] === "object" ? args.shift() : new (0, $3b62074eb05584b2$export$80ee6245ec4f29ec)();
  let era;
  if (typeof args[0] === "string") era = args.shift();
  else {
    let eras = calendar.getEras();
    era = eras[eras.length - 1];
  }
  let year = args.shift();
  let month = args.shift();
  let day = args.shift();
  return [
    calendar,
    era,
    year,
    month,
    day
  ];
}
var $35ea8db9cb2ccb90$var$_type = /* @__PURE__ */ new WeakMap();
var $35ea8db9cb2ccb90$export$99faa760c7908e4f = class _$35ea8db9cb2ccb90$export$99faa760c7908e4f {
  /** Returns a copy of this date. */
  copy() {
    if (this.era) return new _$35ea8db9cb2ccb90$export$99faa760c7908e4f(this.calendar, this.era, this.year, this.month, this.day);
    else return new _$35ea8db9cb2ccb90$export$99faa760c7908e4f(this.calendar, this.year, this.month, this.day);
  }
  /** Returns a new `CalendarDate` with the given duration added to it. */
  add(duration) {
    return (0, $735220c2d4774dd3$export$e16d8520af44a096)(this, duration);
  }
  /** Returns a new `CalendarDate` with the given duration subtracted from it. */
  subtract(duration) {
    return (0, $735220c2d4774dd3$export$4e2d2ead65e5f7e3)(this, duration);
  }
  /** Returns a new `CalendarDate` with the given fields set to the provided values. Other fields will be constrained accordingly. */
  set(fields) {
    return (0, $735220c2d4774dd3$export$adaa4cf7ef1b65be)(this, fields);
  }
  /**
  * Returns a new `CalendarDate` with the given field adjusted by a specified amount.
  * When the resulting value reaches the limits of the field, it wraps around.
  */
  cycle(field, amount, options) {
    return (0, $735220c2d4774dd3$export$d52ced6badfb9a4c)(this, field, amount, options);
  }
  /** Converts the date to a native JavaScript Date object, with the time set to midnight in the given time zone. */
  toDate(timeZone) {
    return (0, $11d87f3f76e88657$export$e67a095c620b86fe)(this, timeZone);
  }
  /** Converts the date to an ISO 8601 formatted string. */
  toString() {
    return (0, $fae977aafc393c5c$export$60dfd74aa96791bd)(this);
  }
  /** Compares this date with another. A negative result indicates that this date is before the given one, and a positive date indicates that it is after. */
  compare(b) {
    return (0, $14e0f24ef4ac5c92$export$68781ddf31c0090f)(this, b);
  }
  constructor(...args) {
    (0, _class_private_field_init)(this, $35ea8db9cb2ccb90$var$_type, {
      writable: true,
      value: void 0
    });
    let [calendar, era, year, month, day] = $35ea8db9cb2ccb90$var$shiftArgs(args);
    this.calendar = calendar;
    this.era = era;
    this.year = year;
    this.month = month;
    this.day = day;
    (0, $735220c2d4774dd3$export$c4e2ecac49351ef2)(this);
  }
};
var $35ea8db9cb2ccb90$var$_type1 = /* @__PURE__ */ new WeakMap();
var $35ea8db9cb2ccb90$export$680ea196effce5f = class _$35ea8db9cb2ccb90$export$680ea196effce5f {
  /** Returns a copy of this time. */
  copy() {
    return new _$35ea8db9cb2ccb90$export$680ea196effce5f(this.hour, this.minute, this.second, this.millisecond);
  }
  /** Returns a new `Time` with the given duration added to it. */
  add(duration) {
    return (0, $735220c2d4774dd3$export$7ed87b6bc2506470)(this, duration);
  }
  /** Returns a new `Time` with the given duration subtracted from it. */
  subtract(duration) {
    return (0, $735220c2d4774dd3$export$fe34d3a381cd7501)(this, duration);
  }
  /** Returns a new `Time` with the given fields set to the provided values. Other fields will be constrained accordingly. */
  set(fields) {
    return (0, $735220c2d4774dd3$export$e5d5e1c1822b6e56)(this, fields);
  }
  /**
  * Returns a new `Time` with the given field adjusted by a specified amount.
  * When the resulting value reaches the limits of the field, it wraps around.
  */
  cycle(field, amount, options) {
    return (0, $735220c2d4774dd3$export$dd02b3e0007dfe28)(this, field, amount, options);
  }
  /** Converts the time to an ISO 8601 formatted string. */
  toString() {
    return (0, $fae977aafc393c5c$export$f59dee82248f5ad4)(this);
  }
  /** Compares this time with another. A negative result indicates that this time is before the given one, and a positive time indicates that it is after. */
  compare(b) {
    return (0, $14e0f24ef4ac5c92$export$c19a80a9721b80f6)(this, b);
  }
  constructor(hour = 0, minute = 0, second = 0, millisecond = 0) {
    (0, _class_private_field_init)(this, $35ea8db9cb2ccb90$var$_type1, {
      writable: true,
      value: void 0
    });
    this.hour = hour;
    this.minute = minute;
    this.second = second;
    this.millisecond = millisecond;
    (0, $735220c2d4774dd3$export$7555de1e070510cb)(this);
  }
};
var $35ea8db9cb2ccb90$var$_type2 = /* @__PURE__ */ new WeakMap();
var $35ea8db9cb2ccb90$export$ca871e8dbb80966f = class _$35ea8db9cb2ccb90$export$ca871e8dbb80966f {
  /** Returns a copy of this date. */
  copy() {
    if (this.era) return new _$35ea8db9cb2ccb90$export$ca871e8dbb80966f(this.calendar, this.era, this.year, this.month, this.day, this.hour, this.minute, this.second, this.millisecond);
    else return new _$35ea8db9cb2ccb90$export$ca871e8dbb80966f(this.calendar, this.year, this.month, this.day, this.hour, this.minute, this.second, this.millisecond);
  }
  /** Returns a new `CalendarDateTime` with the given duration added to it. */
  add(duration) {
    return (0, $735220c2d4774dd3$export$e16d8520af44a096)(this, duration);
  }
  /** Returns a new `CalendarDateTime` with the given duration subtracted from it. */
  subtract(duration) {
    return (0, $735220c2d4774dd3$export$4e2d2ead65e5f7e3)(this, duration);
  }
  /** Returns a new `CalendarDateTime` with the given fields set to the provided values. Other fields will be constrained accordingly. */
  set(fields) {
    return (0, $735220c2d4774dd3$export$adaa4cf7ef1b65be)((0, $735220c2d4774dd3$export$e5d5e1c1822b6e56)(this, fields), fields);
  }
  /**
  * Returns a new `CalendarDateTime` with the given field adjusted by a specified amount.
  * When the resulting value reaches the limits of the field, it wraps around.
  */
  cycle(field, amount, options) {
    switch (field) {
      case "era":
      case "year":
      case "month":
      case "day":
        return (0, $735220c2d4774dd3$export$d52ced6badfb9a4c)(this, field, amount, options);
      default:
        return (0, $735220c2d4774dd3$export$dd02b3e0007dfe28)(this, field, amount, options);
    }
  }
  /** Converts the date to a native JavaScript Date object in the given time zone. */
  toDate(timeZone, disambiguation) {
    return (0, $11d87f3f76e88657$export$e67a095c620b86fe)(this, timeZone, disambiguation);
  }
  /** Converts the date to an ISO 8601 formatted string. */
  toString() {
    return (0, $fae977aafc393c5c$export$4223de14708adc63)(this);
  }
  /** Compares this date with another. A negative result indicates that this date is before the given one, and a positive date indicates that it is after. */
  compare(b) {
    let res = (0, $14e0f24ef4ac5c92$export$68781ddf31c0090f)(this, b);
    if (res === 0) return (0, $14e0f24ef4ac5c92$export$c19a80a9721b80f6)(this, (0, $11d87f3f76e88657$export$b21e0b124e224484)(b));
    return res;
  }
  constructor(...args) {
    (0, _class_private_field_init)(this, $35ea8db9cb2ccb90$var$_type2, {
      writable: true,
      value: void 0
    });
    let [calendar, era, year, month, day] = $35ea8db9cb2ccb90$var$shiftArgs(args);
    this.calendar = calendar;
    this.era = era;
    this.year = year;
    this.month = month;
    this.day = day;
    this.hour = args.shift() || 0;
    this.minute = args.shift() || 0;
    this.second = args.shift() || 0;
    this.millisecond = args.shift() || 0;
    (0, $735220c2d4774dd3$export$c4e2ecac49351ef2)(this);
  }
};
var $35ea8db9cb2ccb90$var$_type3 = /* @__PURE__ */ new WeakMap();
var $35ea8db9cb2ccb90$export$d3b7288e7994edea = class _$35ea8db9cb2ccb90$export$d3b7288e7994edea {
  /** Returns a copy of this date. */
  copy() {
    if (this.era) return new _$35ea8db9cb2ccb90$export$d3b7288e7994edea(this.calendar, this.era, this.year, this.month, this.day, this.timeZone, this.offset, this.hour, this.minute, this.second, this.millisecond);
    else return new _$35ea8db9cb2ccb90$export$d3b7288e7994edea(this.calendar, this.year, this.month, this.day, this.timeZone, this.offset, this.hour, this.minute, this.second, this.millisecond);
  }
  /** Returns a new `ZonedDateTime` with the given duration added to it. */
  add(duration) {
    return (0, $735220c2d4774dd3$export$96b1d28349274637)(this, duration);
  }
  /** Returns a new `ZonedDateTime` with the given duration subtracted from it. */
  subtract(duration) {
    return (0, $735220c2d4774dd3$export$6814caac34ca03c7)(this, duration);
  }
  /** Returns a new `ZonedDateTime` with the given fields set to the provided values. Other fields will be constrained accordingly. */
  set(fields, disambiguation) {
    return (0, $735220c2d4774dd3$export$31b5430eb18be4f8)(this, fields, disambiguation);
  }
  /**
  * Returns a new `ZonedDateTime` with the given field adjusted by a specified amount.
  * When the resulting value reaches the limits of the field, it wraps around.
  */
  cycle(field, amount, options) {
    return (0, $735220c2d4774dd3$export$9a297d111fc86b79)(this, field, amount, options);
  }
  /** Converts the date to a native JavaScript Date object. */
  toDate() {
    return (0, $11d87f3f76e88657$export$83aac07b4c37b25)(this);
  }
  /** Converts the date to an ISO 8601 formatted string, including the UTC offset and time zone identifier. */
  toString() {
    return (0, $fae977aafc393c5c$export$bf79f1ebf4b18792)(this);
  }
  /** Converts the date to an ISO 8601 formatted string in UTC. */
  toAbsoluteString() {
    return this.toDate().toISOString();
  }
  /** Compares this date with another. A negative result indicates that this date is before the given one, and a positive date indicates that it is after. */
  compare(b) {
    return this.toDate().getTime() - (0, $11d87f3f76e88657$export$84c95a83c799e074)(b, this.timeZone).toDate().getTime();
  }
  constructor(...args) {
    (0, _class_private_field_init)(this, $35ea8db9cb2ccb90$var$_type3, {
      writable: true,
      value: void 0
    });
    let [calendar, era, year, month, day] = $35ea8db9cb2ccb90$var$shiftArgs(args);
    let timeZone = args.shift();
    let offset3 = args.shift();
    this.calendar = calendar;
    this.era = era;
    this.year = year;
    this.month = month;
    this.day = day;
    this.timeZone = timeZone;
    this.offset = offset3;
    this.hour = args.shift() || 0;
    this.minute = args.shift() || 0;
    this.second = args.shift() || 0;
    this.millisecond = args.shift() || 0;
    (0, $735220c2d4774dd3$export$c4e2ecac49351ef2)(this);
  }
};

// node_modules/@internationalized/date/dist/HebrewCalendar.mjs
var $7c5f6fbf42389787$var$HOUR_PARTS = 1080;
var $7c5f6fbf42389787$var$DAY_PARTS = 24 * $7c5f6fbf42389787$var$HOUR_PARTS;
var $7c5f6fbf42389787$var$MONTH_DAYS = 29;
var $7c5f6fbf42389787$var$MONTH_FRACT = 12 * $7c5f6fbf42389787$var$HOUR_PARTS + 793;
var $7c5f6fbf42389787$var$MONTH_PARTS = $7c5f6fbf42389787$var$MONTH_DAYS * $7c5f6fbf42389787$var$DAY_PARTS + $7c5f6fbf42389787$var$MONTH_FRACT;

// node_modules/@internationalized/date/dist/DateFormatter.mjs
var $fb18d541ea1ad717$var$formatterCache = /* @__PURE__ */ new Map();
var $fb18d541ea1ad717$export$ad991b66133851cf = class {
  /** Formats a date as a string according to the locale and format options passed to the constructor. */
  format(value) {
    return this.formatter.format(value);
  }
  /** Formats a date to an array of parts such as separators, numbers, punctuation, and more. */
  formatToParts(value) {
    return this.formatter.formatToParts(value);
  }
  /** Formats a date range as a string. */
  formatRange(start, end) {
    if (typeof this.formatter.formatRange === "function")
      return this.formatter.formatRange(start, end);
    if (end < start) throw new RangeError("End date must be >= start date");
    return `${this.formatter.format(start)} – ${this.formatter.format(end)}`;
  }
  /** Formats a date range as an array of parts. */
  formatRangeToParts(start, end) {
    if (typeof this.formatter.formatRangeToParts === "function")
      return this.formatter.formatRangeToParts(start, end);
    if (end < start) throw new RangeError("End date must be >= start date");
    let startParts = this.formatter.formatToParts(start);
    let endParts = this.formatter.formatToParts(end);
    return [
      ...startParts.map((p) => ({
        ...p,
        source: "startRange"
      })),
      {
        type: "literal",
        value: " – ",
        source: "shared"
      },
      ...endParts.map((p) => ({
        ...p,
        source: "endRange"
      }))
    ];
  }
  /** Returns the resolved formatting options based on the values passed to the constructor. */
  resolvedOptions() {
    let resolvedOptions = this.formatter.resolvedOptions();
    if ($fb18d541ea1ad717$var$hasBuggyResolvedHourCycle()) {
      if (!this.resolvedHourCycle) this.resolvedHourCycle = $fb18d541ea1ad717$var$getResolvedHourCycle(resolvedOptions.locale, this.options);
      resolvedOptions.hourCycle = this.resolvedHourCycle;
      resolvedOptions.hour12 = this.resolvedHourCycle === "h11" || this.resolvedHourCycle === "h12";
    }
    if (resolvedOptions.calendar === "ethiopic-amete-alem") resolvedOptions.calendar = "ethioaa";
    return resolvedOptions;
  }
  constructor(locale, options = {}) {
    this.formatter = $fb18d541ea1ad717$var$getCachedDateFormatter(locale, options);
    this.options = options;
  }
};
var $fb18d541ea1ad717$var$hour12Preferences = {
  true: {
    // Only Japanese uses the h11 style for 12 hour time. All others use h12.
    ja: "h11"
  },
  false: {}
};
function $fb18d541ea1ad717$var$getCachedDateFormatter(locale, options = {}) {
  if (typeof options.hour12 === "boolean" && $fb18d541ea1ad717$var$hasBuggyHour12Behavior()) {
    options = {
      ...options
    };
    let pref = $fb18d541ea1ad717$var$hour12Preferences[String(options.hour12)][locale.split("-")[0]];
    let defaultHourCycle = options.hour12 ? "h12" : "h23";
    options.hourCycle = pref !== null && pref !== void 0 ? pref : defaultHourCycle;
    delete options.hour12;
  }
  let cacheKey = locale + (options ? Object.entries(options).sort((a, b) => a[0] < b[0] ? -1 : 1).join() : "");
  if ($fb18d541ea1ad717$var$formatterCache.has(cacheKey)) return $fb18d541ea1ad717$var$formatterCache.get(cacheKey);
  let numberFormatter = new Intl.DateTimeFormat(locale, options);
  $fb18d541ea1ad717$var$formatterCache.set(cacheKey, numberFormatter);
  return numberFormatter;
}
var $fb18d541ea1ad717$var$_hasBuggyHour12Behavior = null;
function $fb18d541ea1ad717$var$hasBuggyHour12Behavior() {
  if ($fb18d541ea1ad717$var$_hasBuggyHour12Behavior == null) $fb18d541ea1ad717$var$_hasBuggyHour12Behavior = new Intl.DateTimeFormat("en-US", {
    hour: "numeric",
    hour12: false
  }).format(new Date(2020, 2, 3, 0)) === "24";
  return $fb18d541ea1ad717$var$_hasBuggyHour12Behavior;
}
var $fb18d541ea1ad717$var$_hasBuggyResolvedHourCycle = null;
function $fb18d541ea1ad717$var$hasBuggyResolvedHourCycle() {
  if ($fb18d541ea1ad717$var$_hasBuggyResolvedHourCycle == null) $fb18d541ea1ad717$var$_hasBuggyResolvedHourCycle = new Intl.DateTimeFormat("fr", {
    hour: "numeric",
    hour12: false
  }).resolvedOptions().hourCycle === "h12";
  return $fb18d541ea1ad717$var$_hasBuggyResolvedHourCycle;
}
function $fb18d541ea1ad717$var$getResolvedHourCycle(locale, options) {
  if (!options.timeStyle && !options.hour) return void 0;
  locale = locale.replace(/(-u-)?-nu-[a-zA-Z0-9]+/, "");
  locale += (locale.includes("-u-") ? "" : "-u") + "-nu-latn";
  let formatter = $fb18d541ea1ad717$var$getCachedDateFormatter(locale, {
    ...options,
    timeZone: void 0
    // use local timezone
  });
  let min4 = parseInt(formatter.formatToParts(new Date(2020, 2, 3, 0)).find((p) => p.type === "hour").value, 10);
  let max4 = parseInt(formatter.formatToParts(new Date(2020, 2, 3, 23)).find((p) => p.type === "hour").value, 10);
  if (min4 === 0 && max4 === 23) return "h23";
  if (min4 === 24 && max4 === 23) return "h24";
  if (min4 === 0 && max4 === 11) return "h11";
  if (min4 === 12 && max4 === 11) return "h12";
  throw new Error("Unexpected hour cycle result");
}

// node_modules/@zag-js/date-utils/dist/index.mjs
function alignCenter(date, duration, locale, min4, max4) {
  const halfDuration = {};
  for (let prop in duration) {
    const key = prop;
    const value = duration[key];
    if (value == null) continue;
    halfDuration[key] = Math.floor(value / 2);
    if (halfDuration[key] > 0 && value % 2 === 0) {
      halfDuration[key]--;
    }
  }
  const aligned = alignStart(date, duration, locale).subtract(halfDuration);
  return constrainStart(date, aligned, duration, locale, min4, max4);
}
function alignStart(date, duration, locale, min4, max4) {
  let aligned = date;
  if (duration.years) {
    aligned = $14e0f24ef4ac5c92$export$f91e89d3d0406102(date);
  } else if (duration.months) {
    aligned = $14e0f24ef4ac5c92$export$a5a3b454ada2268e(date);
  } else if (duration.weeks) {
    aligned = $14e0f24ef4ac5c92$export$42c81a444fbfb5d4(date, locale);
  }
  return constrainStart(date, aligned, duration, locale, min4, max4);
}
function alignEnd(date, duration, locale, min4, max4) {
  let d = { ...duration };
  if (d.days) {
    d.days--;
  } else if (d.weeks) {
    d.weeks--;
  } else if (d.months) {
    d.months--;
  } else if (d.years) {
    d.years--;
  }
  let aligned = alignStart(date, duration, locale).subtract(d);
  return constrainStart(date, aligned, duration, locale, min4, max4);
}
function constrainStart(date, aligned, duration, locale, min4, max4) {
  if (min4 && date.compare(min4) >= 0) {
    aligned = $14e0f24ef4ac5c92$export$a75f2bff57811055(aligned, alignStart($11d87f3f76e88657$export$93522d1a439f3617(min4), duration, locale));
  }
  if (max4 && date.compare(max4) <= 0) {
    aligned = $14e0f24ef4ac5c92$export$5c333a116e949cdd(aligned, alignEnd($11d87f3f76e88657$export$93522d1a439f3617(max4), duration, locale));
  }
  return aligned;
}
function constrainValue(date, minValue, maxValue2) {
  if (minValue) {
    date = $14e0f24ef4ac5c92$export$a75f2bff57811055(date, $11d87f3f76e88657$export$93522d1a439f3617(minValue));
  }
  if (maxValue2) {
    date = $14e0f24ef4ac5c92$export$5c333a116e949cdd(date, $11d87f3f76e88657$export$93522d1a439f3617(maxValue2));
  }
  return date;
}
function alignDate(date, alignment, duration, locale, min4, max4) {
  switch (alignment) {
    case "start":
      return alignStart(date, duration, locale, min4, max4);
    case "end":
      return alignEnd(date, duration, locale, min4, max4);
    case "center":
    default:
      return alignCenter(date, duration, locale, min4, max4);
  }
}
function isDateEqual(dateA, dateB) {
  return dateB != null && $14e0f24ef4ac5c92$export$ea39ec197993aef0(dateA, dateB);
}
function isDateInvalid(date, minValue, maxValue2) {
  return minValue != null && date.compare(minValue) < 0 || maxValue2 != null && date.compare(maxValue2) > 0;
}
function isDateDisabled(date, startDate, endDate, minValue, maxValue2) {
  return isDateOutsideVisibleRange(date, startDate, endDate) || isDateInvalid(date, minValue, maxValue2);
}
function isDateUnavailable(date, isUnavailable, locale, minValue, maxValue2) {
  if (!date) {
    return false;
  }
  if (isUnavailable == null ? void 0 : isUnavailable(date, locale)) {
    return true;
  }
  return isDateInvalid(date, minValue, maxValue2);
}
function isDateOutsideVisibleRange(date, startDate, endDate) {
  return date.compare(startDate) < 0 || date.compare(endDate) > 0;
}
function isPreviousVisibleRangeInvalid(startDate, minValue, maxValue2) {
  const prevDate = startDate.subtract({ days: 1 });
  return $14e0f24ef4ac5c92$export$ea39ec197993aef0(prevDate, startDate) || isDateInvalid(prevDate, minValue, maxValue2);
}
function isNextVisibleRangeInvalid(endDate, minValue, maxValue2) {
  const nextDate = endDate.add({ days: 1 });
  return $14e0f24ef4ac5c92$export$ea39ec197993aef0(nextDate, endDate) || isDateInvalid(nextDate, minValue, maxValue2);
}
function getUnitDuration(duration) {
  let clone3 = { ...duration };
  for (let key in clone3) clone3[key] = 1;
  return clone3;
}
function getEndDate(startDate, duration) {
  let clone3 = { ...duration };
  if (clone3.days) clone3.days--;
  else clone3.days = -1;
  return startDate.add(clone3);
}
function getEraFormat(date) {
  return (date == null ? void 0 : date.calendar.identifier) === "gregory" && date.era === "BC" ? "short" : void 0;
}
function getDayFormatter(locale, timeZone) {
  const date = $11d87f3f76e88657$export$b21e0b124e224484($14e0f24ef4ac5c92$export$d0bdf45af03a6ea3(timeZone));
  return new $fb18d541ea1ad717$export$ad991b66133851cf(locale, {
    weekday: "long",
    month: "long",
    year: "numeric",
    day: "numeric",
    era: getEraFormat(date),
    timeZone
  });
}
function getMonthFormatter(locale, timeZone) {
  const date = $11d87f3f76e88657$export$93522d1a439f3617($14e0f24ef4ac5c92$export$d0bdf45af03a6ea3(timeZone));
  return new $fb18d541ea1ad717$export$ad991b66133851cf(locale, {
    month: "long",
    year: "numeric",
    era: getEraFormat(date),
    calendar: date == null ? void 0 : date.calendar.identifier,
    timeZone
  });
}
function formatRange(startDate, endDate, formatter, toString, timeZone) {
  let parts26 = formatter.formatRangeToParts(startDate.toDate(timeZone), endDate.toDate(timeZone));
  let separatorIndex = -1;
  for (let i = 0; i < parts26.length; i++) {
    let part = parts26[i];
    if (part.source === "shared" && part.type === "literal") {
      separatorIndex = i;
    } else if (part.source === "endRange") {
      break;
    }
  }
  let start = "";
  let end = "";
  for (let i = 0; i < parts26.length; i++) {
    if (i < separatorIndex) {
      start += parts26[i].value;
    } else if (i > separatorIndex) {
      end += parts26[i].value;
    }
  }
  return toString(start, end);
}
function formatSelectedDate(startDate, endDate, locale, timeZone) {
  let start = startDate;
  let end = endDate ?? startDate;
  let formatter = getDayFormatter(locale, timeZone);
  if ($14e0f24ef4ac5c92$export$ea39ec197993aef0(start, end)) {
    return formatter.format(start.toDate(timeZone));
  }
  return formatRange(start, end, formatter, (start2, end2) => `${start2} – ${end2}`, timeZone);
}
var daysOfTheWeek = ["sun", "mon", "tue", "wed", "thu", "fri", "sat"];
function normalizeFirstDayOfWeek(firstDayOfWeek) {
  return firstDayOfWeek != null ? daysOfTheWeek[firstDayOfWeek] : void 0;
}
function getStartOfWeek(date, locale, firstDayOfWeek) {
  const firstDay = normalizeFirstDayOfWeek(firstDayOfWeek);
  return $14e0f24ef4ac5c92$export$42c81a444fbfb5d4(date, locale, firstDay);
}
function getDaysInWeek(weekIndex, from, locale, firstDayOfWeek) {
  const weekDate = from.add({ weeks: weekIndex });
  const dates = [];
  let date = getStartOfWeek(weekDate, locale, firstDayOfWeek);
  while (dates.length < 7) {
    dates.push(date);
    let nextDate = date.add({ days: 1 });
    if ($14e0f24ef4ac5c92$export$ea39ec197993aef0(date, nextDate)) break;
    date = nextDate;
  }
  return dates;
}
function getMonthDays(from, locale, numOfWeeks, firstDayOfWeek) {
  const firstDay = normalizeFirstDayOfWeek(firstDayOfWeek);
  const monthWeeks = numOfWeeks ?? $14e0f24ef4ac5c92$export$ccc1b2479e7dd654(from, locale, firstDay);
  const weeks = [...new Array(monthWeeks).keys()];
  return weeks.map((week) => getDaysInWeek(week, from, locale, firstDayOfWeek));
}
function getWeekdayFormats(locale, timeZone) {
  const longFormat = new $fb18d541ea1ad717$export$ad991b66133851cf(locale, { weekday: "long", timeZone });
  const shortFormat = new $fb18d541ea1ad717$export$ad991b66133851cf(locale, { weekday: "short", timeZone });
  const narrowFormat = new $fb18d541ea1ad717$export$ad991b66133851cf(locale, { weekday: "narrow", timeZone });
  return (value) => {
    const date = value instanceof Date ? value : value.toDate(timeZone);
    return {
      value,
      short: shortFormat.format(date),
      long: longFormat.format(date),
      narrow: narrowFormat.format(date)
    };
  };
}
function getWeekDays(date, startOfWeekProp, timeZone, locale) {
  const firstDayOfWeek = getStartOfWeek(date, locale, startOfWeekProp);
  const weeks = [...new Array(7).keys()];
  const format = getWeekdayFormats(locale, timeZone);
  return weeks.map((index) => format(firstDayOfWeek.add({ days: index })));
}
function getMonthNames(locale, format = "long") {
  const date = new Date(2021, 0, 1);
  const monthNames = [];
  for (let i = 0; i < 12; i++) {
    monthNames.push(date.toLocaleString(locale, { month: format }));
    date.setMonth(date.getMonth() + 1);
  }
  return monthNames;
}
function getYearsRange(range) {
  const years = [];
  for (let year = range.from; year <= range.to; year += 1) years.push(year);
  return years;
}
var FUTURE_YEAR_COERCION = 10;
function normalizeYear(year) {
  if (!year) return;
  if (year.length === 3) return year.padEnd(4, "0");
  if (year.length === 2) {
    const currentYear = (/* @__PURE__ */ new Date()).getFullYear();
    const currentCentury = Math.floor(currentYear / 100) * 100;
    const twoDigitYear = parseInt(year.slice(-2), 10);
    const fullYear = currentCentury + twoDigitYear;
    return fullYear > currentYear + FUTURE_YEAR_COERCION ? (fullYear - 100).toString() : fullYear.toString();
  }
  return year;
}
function getDecadeRange(year) {
  const computedYear = year - year % 10 - 1;
  const years = [];
  for (let i = 0; i < 12; i += 1) {
    const value = computedYear + i;
    years.push(value);
  }
  return years;
}
function getTodayDate(timeZone) {
  return $14e0f24ef4ac5c92$export$d0bdf45af03a6ea3(timeZone ?? $14e0f24ef4ac5c92$export$aa8b41735afcabd2());
}
function getAdjustedDateFn(visibleDuration, locale, minValue, maxValue2) {
  return function getDate(options) {
    const { startDate, focusedDate } = options;
    const endDate = getEndDate(startDate, visibleDuration);
    if (isDateInvalid(focusedDate, minValue, maxValue2)) {
      return {
        startDate,
        focusedDate: constrainValue(focusedDate, minValue, maxValue2),
        endDate
      };
    }
    if (focusedDate.compare(startDate) < 0) {
      return {
        startDate: alignEnd(focusedDate, visibleDuration, locale, minValue, maxValue2),
        focusedDate: constrainValue(focusedDate, minValue, maxValue2),
        endDate
      };
    }
    if (focusedDate.compare(endDate) > 0) {
      return {
        startDate: alignStart(focusedDate, visibleDuration, locale, minValue, maxValue2),
        endDate,
        focusedDate: constrainValue(focusedDate, minValue, maxValue2)
      };
    }
    return {
      startDate,
      endDate,
      focusedDate: constrainValue(focusedDate, minValue, maxValue2)
    };
  };
}
function getNextPage(focusedDate, startDate, visibleDuration, locale, minValue, maxValue2) {
  const adjust2 = getAdjustedDateFn(visibleDuration, locale, minValue, maxValue2);
  const start = startDate.add(visibleDuration);
  return adjust2({
    focusedDate: focusedDate.add(visibleDuration),
    startDate: alignStart(
      constrainStart(focusedDate, start, visibleDuration, locale, minValue, maxValue2),
      visibleDuration,
      locale
    )
  });
}
function getPreviousPage(focusedDate, startDate, visibleDuration, locale, minValue, maxValue2) {
  const adjust2 = getAdjustedDateFn(visibleDuration, locale, minValue, maxValue2);
  let start = startDate.subtract(visibleDuration);
  return adjust2({
    focusedDate: focusedDate.subtract(visibleDuration),
    startDate: alignStart(
      constrainStart(focusedDate, start, visibleDuration, locale, minValue, maxValue2),
      visibleDuration,
      locale
    )
  });
}
function getNextSection(focusedDate, startDate, larger, visibleDuration, locale, minValue, maxValue2) {
  const adjust2 = getAdjustedDateFn(visibleDuration, locale, minValue, maxValue2);
  if (!larger && !visibleDuration.days) {
    return adjust2({
      focusedDate: focusedDate.add(getUnitDuration(visibleDuration)),
      startDate
    });
  }
  if (visibleDuration.days) {
    return getNextPage(focusedDate, startDate, visibleDuration, locale, minValue, maxValue2);
  }
  if (visibleDuration.weeks) {
    return adjust2({
      focusedDate: focusedDate.add({ months: 1 }),
      startDate
    });
  }
  if (visibleDuration.months || visibleDuration.years) {
    return adjust2({
      focusedDate: focusedDate.add({ years: 1 }),
      startDate
    });
  }
}
function getPreviousSection(focusedDate, startDate, larger, visibleDuration, locale, minValue, maxValue2) {
  const adjust2 = getAdjustedDateFn(visibleDuration, locale, minValue, maxValue2);
  if (!larger && !visibleDuration.days) {
    return adjust2({
      focusedDate: focusedDate.subtract(getUnitDuration(visibleDuration)),
      startDate
    });
  }
  if (visibleDuration.days) {
    return getPreviousPage(focusedDate, startDate, visibleDuration, locale, minValue, maxValue2);
  }
  if (visibleDuration.weeks) {
    return adjust2({
      focusedDate: focusedDate.subtract({ months: 1 }),
      startDate
    });
  }
  if (visibleDuration.months || visibleDuration.years) {
    return adjust2({
      focusedDate: focusedDate.subtract({ years: 1 }),
      startDate
    });
  }
}
var isValidYear = (year) => year != null && year.length === 4;
var isValidMonth = (month) => month != null && parseFloat(month) <= 12;
var isValidDay = (day) => day != null && parseFloat(day) <= 31;
function parseDateString(date, locale, timeZone) {
  const regex = createRegex(locale, timeZone);
  let { year, month, day } = extract(regex, date) ?? {};
  const hasMatch = year != null || month != null || day != null;
  if (hasMatch) {
    const curr = /* @__PURE__ */ new Date();
    year || (year = curr.getFullYear().toString());
    month || (month = (curr.getMonth() + 1).toString());
    day || (day = curr.getDate().toString());
  }
  if (!isValidYear(year)) {
    year = normalizeYear(year);
  }
  if (isValidYear(year) && isValidMonth(month) && isValidDay(day)) {
    return new $35ea8db9cb2ccb90$export$99faa760c7908e4f(+year, +month, +day);
  }
  const time = Date.parse(date);
  if (!isNaN(time)) {
    const date2 = new Date(time);
    return new $35ea8db9cb2ccb90$export$99faa760c7908e4f(date2.getFullYear(), date2.getMonth() + 1, date2.getDate());
  }
}
function createRegex(locale, timeZone) {
  const formatter = new $fb18d541ea1ad717$export$ad991b66133851cf(locale, { day: "numeric", month: "numeric", year: "numeric", timeZone });
  const parts26 = formatter.formatToParts(new Date(2e3, 11, 25));
  return parts26.map(({ type, value }) => type === "literal" ? `${value}?` : `((?!=<${type}>)\\d+)?`).join("");
}
function extract(pattern, str) {
  var _a8;
  const matches = str.match(pattern);
  return (_a8 = pattern.toString().match(/<(.+?)>/g)) == null ? void 0 : _a8.map((group) => {
    var _a9;
    const groupMatches = group.match(/<(.+)>/);
    if (!groupMatches || groupMatches.length <= 0) {
      return null;
    }
    return (_a9 = group.match(/<(.+)>/)) == null ? void 0 : _a9[1];
  }).reduce((acc, curr, index) => {
    if (!curr) return acc;
    if (matches && matches.length > index) {
      acc[curr] = matches[index + 1];
    } else {
      acc[curr] = null;
    }
    return acc;
  }, {});
}
function getDateRangePreset(preset, locale, timeZone) {
  const today3 = $14e0f24ef4ac5c92$export$461939dd4422153(timeZone);
  switch (preset) {
    case "thisWeek":
      return [$14e0f24ef4ac5c92$export$42c81a444fbfb5d4(today3, locale), $14e0f24ef4ac5c92$export$ef8b6d9133084f4e(today3, locale)];
    case "thisMonth":
      return [$14e0f24ef4ac5c92$export$a5a3b454ada2268e(today3), today3];
    case "thisQuarter":
      return [$14e0f24ef4ac5c92$export$a5a3b454ada2268e(today3).add({ months: -today3.month % 3 }), today3];
    case "thisYear":
      return [$14e0f24ef4ac5c92$export$f91e89d3d0406102(today3), today3];
    case "last3Days":
      return [today3.add({ days: -2 }), today3];
    case "last7Days":
      return [today3.add({ days: -6 }), today3];
    case "last14Days":
      return [today3.add({ days: -13 }), today3];
    case "last30Days":
      return [today3.add({ days: -29 }), today3];
    case "last90Days":
      return [today3.add({ days: -89 }), today3];
    case "lastMonth":
      return [$14e0f24ef4ac5c92$export$a5a3b454ada2268e(today3.add({ months: -1 })), $14e0f24ef4ac5c92$export$a2258d9c4118825c(today3.add({ months: -1 }))];
    case "lastQuarter":
      return [
        $14e0f24ef4ac5c92$export$a5a3b454ada2268e(today3.add({ months: -today3.month % 3 - 3 })),
        $14e0f24ef4ac5c92$export$a2258d9c4118825c(today3.add({ months: -today3.month % 3 - 1 }))
      ];
    case "lastWeek":
      return [$14e0f24ef4ac5c92$export$42c81a444fbfb5d4(today3, locale).add({ weeks: -1 }), $14e0f24ef4ac5c92$export$ef8b6d9133084f4e(today3, locale).add({ weeks: -1 })];
    case "lastYear":
      return [$14e0f24ef4ac5c92$export$f91e89d3d0406102(today3.add({ years: -1 })), $14e0f24ef4ac5c92$export$8b7aa55c66d5569e(today3.add({ years: -1 }))];
    default:
      throw new Error(`Invalid date range preset: ${preset}`);
  }
}

// node_modules/@zag-js/live-region/dist/index.mjs
var ID = "__live-region__";
function createLiveRegion(opts = {}) {
  const { level = "polite", document: doc = document, root, delay: _delay = 0 } = opts;
  const win = doc.defaultView ?? window;
  const parent = root ?? doc.body;
  function announce(message, delay2) {
    const oldRegion = doc.getElementById(ID);
    oldRegion == null ? void 0 : oldRegion.remove();
    delay2 = delay2 ?? _delay;
    const region = doc.createElement("span");
    region.id = ID;
    region.dataset.liveAnnouncer = "true";
    const role = level !== "assertive" ? "status" : "alert";
    region.setAttribute("aria-live", level);
    region.setAttribute("role", role);
    Object.assign(region.style, {
      border: "0",
      clip: "rect(0 0 0 0)",
      height: "1px",
      margin: "-1px",
      overflow: "hidden",
      padding: "0",
      position: "absolute",
      width: "1px",
      whiteSpace: "nowrap",
      wordWrap: "normal"
    });
    parent.appendChild(region);
    win.setTimeout(() => {
      region.textContent = message;
    }, delay2);
  }
  function destroy() {
    const oldRegion = doc.getElementById(ID);
    oldRegion == null ? void 0 : oldRegion.remove();
  }
  return {
    announce,
    destroy,
    toJSON() {
      return ID;
    }
  };
}

// node_modules/@zag-js/date-picker/dist/index.mjs
var anatomy4 = createAnatomy("date-picker").parts(
  "root",
  "label",
  "clearTrigger",
  "content",
  "control",
  "input",
  "monthSelect",
  "nextTrigger",
  "positioner",
  "prevTrigger",
  "rangeText",
  "table",
  "tableBody",
  "tableCell",
  "tableCellTrigger",
  "tableHead",
  "tableHeader",
  "tableRow",
  "trigger",
  "viewTrigger",
  "viewControl",
  "yearSelect",
  "presetTrigger"
);
var parts4 = anatomy4.build();
var dom4 = createScope({
  getLabelId: (ctx, index) => {
    var _a8, _b7;
    return ((_b7 = (_a8 = ctx.ids) == null ? void 0 : _a8.label) == null ? void 0 : _b7.call(_a8, index)) ?? `datepicker:${ctx.id}:label:${index}`;
  },
  getRootId: (ctx) => {
    var _a8;
    return ((_a8 = ctx.ids) == null ? void 0 : _a8.root) ?? `datepicker:${ctx.id}`;
  },
  getTableId: (ctx, id) => {
    var _a8, _b7;
    return ((_b7 = (_a8 = ctx.ids) == null ? void 0 : _a8.table) == null ? void 0 : _b7.call(_a8, id)) ?? `datepicker:${ctx.id}:table:${id}`;
  },
  getTableHeaderId: (ctx, id) => {
    var _a8, _b7;
    return ((_b7 = (_a8 = ctx.ids) == null ? void 0 : _a8.tableHeader) == null ? void 0 : _b7.call(_a8, id)) ?? `datepicker:${ctx.id}:thead`;
  },
  getTableBodyId: (ctx, id) => {
    var _a8, _b7;
    return ((_b7 = (_a8 = ctx.ids) == null ? void 0 : _a8.tableBody) == null ? void 0 : _b7.call(_a8, id)) ?? `datepicker:${ctx.id}:tbody`;
  },
  getTableRowId: (ctx, id) => {
    var _a8, _b7;
    return ((_b7 = (_a8 = ctx.ids) == null ? void 0 : _a8.tableRow) == null ? void 0 : _b7.call(_a8, id)) ?? `datepicker:${ctx.id}:tr:${id}`;
  },
  getContentId: (ctx) => {
    var _a8;
    return ((_a8 = ctx.ids) == null ? void 0 : _a8.content) ?? `datepicker:${ctx.id}:content`;
  },
  getCellTriggerId: (ctx, id) => {
    var _a8, _b7;
    return ((_b7 = (_a8 = ctx.ids) == null ? void 0 : _a8.cellTrigger) == null ? void 0 : _b7.call(_a8, id)) ?? `datepicker:${ctx.id}:cell-trigger:${id}`;
  },
  getPrevTriggerId: (ctx, view) => {
    var _a8, _b7;
    return ((_b7 = (_a8 = ctx.ids) == null ? void 0 : _a8.prevTrigger) == null ? void 0 : _b7.call(_a8, view)) ?? `datepicker:${ctx.id}:prev:${view}`;
  },
  getNextTriggerId: (ctx, view) => {
    var _a8, _b7;
    return ((_b7 = (_a8 = ctx.ids) == null ? void 0 : _a8.nextTrigger) == null ? void 0 : _b7.call(_a8, view)) ?? `datepicker:${ctx.id}:next:${view}`;
  },
  getViewTriggerId: (ctx, view) => {
    var _a8, _b7;
    return ((_b7 = (_a8 = ctx.ids) == null ? void 0 : _a8.viewTrigger) == null ? void 0 : _b7.call(_a8, view)) ?? `datepicker:${ctx.id}:view:${view}`;
  },
  getClearTriggerId: (ctx) => {
    var _a8;
    return ((_a8 = ctx.ids) == null ? void 0 : _a8.clearTrigger) ?? `datepicker:${ctx.id}:clear`;
  },
  getControlId: (ctx) => {
    var _a8;
    return ((_a8 = ctx.ids) == null ? void 0 : _a8.control) ?? `datepicker:${ctx.id}:control`;
  },
  getInputId: (ctx, index) => {
    var _a8, _b7;
    return ((_b7 = (_a8 = ctx.ids) == null ? void 0 : _a8.input) == null ? void 0 : _b7.call(_a8, index)) ?? `datepicker:${ctx.id}:input:${index}`;
  },
  getTriggerId: (ctx) => {
    var _a8;
    return ((_a8 = ctx.ids) == null ? void 0 : _a8.trigger) ?? `datepicker:${ctx.id}:trigger`;
  },
  getPositionerId: (ctx) => {
    var _a8;
    return ((_a8 = ctx.ids) == null ? void 0 : _a8.positioner) ?? `datepicker:${ctx.id}:positioner`;
  },
  getMonthSelectId: (ctx) => {
    var _a8;
    return ((_a8 = ctx.ids) == null ? void 0 : _a8.monthSelect) ?? `datepicker:${ctx.id}:month-select`;
  },
  getYearSelectId: (ctx) => {
    var _a8;
    return ((_a8 = ctx.ids) == null ? void 0 : _a8.yearSelect) ?? `datepicker:${ctx.id}:year-select`;
  },
  getFocusedCell: (ctx, view = ctx.view) => query(
    dom4.getContentEl(ctx),
    `[data-part=table-cell-trigger][data-view=${view}][data-focus]:not([data-outside-range])`
  ),
  getTriggerEl: (ctx) => dom4.getById(ctx, dom4.getTriggerId(ctx)),
  getContentEl: (ctx) => dom4.getById(ctx, dom4.getContentId(ctx)),
  getInputEls: (ctx) => queryAll(dom4.getControlEl(ctx), `[data-part=input]`),
  getYearSelectEl: (ctx) => dom4.getById(ctx, dom4.getYearSelectId(ctx)),
  getMonthSelectEl: (ctx) => dom4.getById(ctx, dom4.getMonthSelectId(ctx)),
  getClearTriggerEl: (ctx) => dom4.getById(ctx, dom4.getClearTriggerId(ctx)),
  getPositionerEl: (ctx) => dom4.getById(ctx, dom4.getPositionerId(ctx)),
  getControlEl: (ctx) => dom4.getById(ctx, dom4.getControlId(ctx))
});
function adjustStartAndEndDate(value) {
  const [startDate, endDate] = value;
  if (!startDate || !endDate) return value;
  return startDate.compare(endDate) <= 0 ? value : [endDate, startDate];
}
function isDateWithinRange(date, value) {
  const [startDate, endDate] = value;
  if (!startDate || !endDate) return false;
  return startDate.compare(date) <= 0 && endDate.compare(date) >= 0;
}
function sortDates(values) {
  return values.sort((a, b) => a.compare(b));
}
function getRoleDescription(view) {
  return match2(view, {
    year: "calendar decade",
    month: "calendar year",
    day: "calendar month"
  });
}
var PLACEHOLDERS = {
  day: "dd",
  month: "mm",
  year: "yyyy"
};
function getInputPlaceholder(locale) {
  return new $fb18d541ea1ad717$export$ad991b66133851cf(locale).formatToParts(/* @__PURE__ */ new Date()).map((item) => PLACEHOLDERS[item.type] ?? item.value).join("");
}
var isValidCharacter = (char, separator) => {
  if (!char) return true;
  return /\d/.test(char) || char === separator || char.length !== 1;
};
var isValidDate = (value) => {
  return !Number.isNaN(value.day) && !Number.isNaN(value.month) && !Number.isNaN(value.year);
};
var ensureValidCharacters = (value, separator) => {
  return value.split("").filter((char) => isValidCharacter(char, separator)).join("");
};
function getLocaleSeparator(locale) {
  const dateFormatter = new Intl.DateTimeFormat(locale);
  const parts26 = dateFormatter.formatToParts(/* @__PURE__ */ new Date());
  const literalPart = parts26.find((part) => part.type === "literal");
  return literalPart ? literalPart.value : "/";
}
var defaultTranslations = {
  dayCell(state2) {
    if (state2.unavailable) return `Not available. ${state2.formattedDate}`;
    if (state2.selected) return `Selected date. ${state2.formattedDate}`;
    return `Choose ${state2.formattedDate}`;
  },
  trigger(open) {
    return open ? "Close calendar" : "Open calendar";
  },
  viewTrigger(view) {
    return match2(view, {
      year: "Switch to month view",
      month: "Switch to day view",
      day: "Switch to year view"
    });
  },
  presetTrigger(value) {
    return Array.isArray(value) ? `select ${value[0].toString()} to ${value[1].toString()}` : `select ${value}`;
  },
  prevTrigger(view) {
    return match2(view, {
      year: "Switch to previous decade",
      month: "Switch to previous year",
      day: "Switch to previous month"
    });
  },
  nextTrigger(view) {
    return match2(view, {
      year: "Switch to next decade",
      month: "Switch to next year",
      day: "Switch to next month"
    });
  },
  // TODO: Revisit this
  placeholder() {
    return { day: "dd", month: "mm", year: "yyyy" };
  },
  content: "calendar",
  monthSelect: "Select month",
  yearSelect: "Select year",
  clearTrigger: "Clear selected dates"
};
function viewToNumber(view, fallback4) {
  if (!view) return fallback4 || 0;
  return view === "day" ? 0 : view === "month" ? 1 : 2;
}
function viewNumberToView(viewNumber) {
  return viewNumber === 0 ? "day" : viewNumber === 1 ? "month" : "year";
}
function clampView(view, minView, maxView) {
  return viewNumberToView(
    clampValue(viewToNumber(view, 0), viewToNumber(minView, 0), viewToNumber(maxView, 2))
  );
}
function isAboveMinView(view, minView) {
  return viewToNumber(view, 0) > viewToNumber(minView, 0);
}
function isBelowMinView(view, minView) {
  return viewToNumber(view, 0) < viewToNumber(minView, 0);
}
function getNextView(view, minView, maxView) {
  const nextViewNumber = viewToNumber(view, 0) + 1;
  return clampView(viewNumberToView(nextViewNumber), minView, maxView);
}
function getPreviousView(view, minView, maxView) {
  const prevViewNumber = viewToNumber(view, 0) - 1;
  return clampView(viewNumberToView(prevViewNumber), minView, maxView);
}
var views = ["day", "month", "year"];
function eachView(cb) {
  views.forEach((view) => cb(view));
}
function connect4(state2, send, normalize2) {
  const startValue = state2.context.startValue;
  const endValue = state2.context.endValue;
  const selectedValue = state2.context.value;
  const focusedValue = state2.context.focusedValue;
  const hoveredValue = state2.context.hoveredValue;
  const hoveredRangeValue = hoveredValue ? adjustStartAndEndDate([selectedValue[0], hoveredValue]) : [];
  const disabled = state2.context.disabled;
  const readOnly = state2.context.readOnly;
  const interactive = state2.context.isInteractive;
  const min4 = state2.context.min;
  const max4 = state2.context.max;
  const locale = state2.context.locale;
  const timeZone = state2.context.timeZone;
  const startOfWeek = state2.context.startOfWeek;
  const focused = state2.matches("focused");
  const open = state2.matches("open");
  const isRangePicker = state2.context.selectionMode === "range";
  const isDateUnavailableFn = state2.context.isDateUnavailable;
  const currentPlacement = state2.context.currentPlacement;
  const popperStyles = getPlacementStyles({
    ...state2.context.positioning,
    placement: currentPlacement
  });
  const separator = getLocaleSeparator(locale);
  function getMonthWeeks(from = startValue) {
    const numOfWeeks = state2.context.fixedWeeks ? 6 : void 0;
    return getMonthDays(from, locale, numOfWeeks, startOfWeek);
  }
  function getMonths(props22 = {}) {
    const { format } = props22;
    return getMonthNames(locale, format).map((label, index) => ({ label, value: index + 1 }));
  }
  function getYears() {
    const range = getYearsRange({ from: (min4 == null ? void 0 : min4.year) ?? 1900, to: (max4 == null ? void 0 : max4.year) ?? 2100 });
    return range.map((year) => ({ label: year.toString(), value: year }));
  }
  function getDecadeYears(year) {
    const range = getDecadeRange(focusedValue.year);
    return range.map((year2) => ({ label: year2.toString(), value: year2 }));
  }
  function isUnavailable(date) {
    return isDateUnavailable(date, isDateUnavailableFn, locale, min4, max4);
  }
  function focusMonth(month) {
    const date = startValue ?? getTodayDate(timeZone);
    send({ type: "FOCUS.SET", value: date.set({ month }) });
  }
  function focusYear(year) {
    const date = startValue ?? getTodayDate(timeZone);
    send({ type: "FOCUS.SET", value: date.set({ year }) });
  }
  function getYearTableCellState(props22) {
    const { value, disabled: disabled2 } = props22;
    const cellState = {
      focused: focusedValue.year === props22.value,
      selectable: isValueWithinRange(value, (min4 == null ? void 0 : min4.year) ?? 0, (max4 == null ? void 0 : max4.year) ?? 9999),
      selected: !!selectedValue.find((date) => date.year === value),
      valueText: value.toString(),
      get disabled() {
        return disabled2 || !cellState.selectable;
      }
    };
    return cellState;
  }
  function getMonthTableCellState(props22) {
    const { value, disabled: disabled2 } = props22;
    const normalized = focusedValue.set({ month: value });
    const formatter = getMonthFormatter(locale, timeZone);
    const cellState = {
      focused: focusedValue.month === props22.value,
      selectable: !isDateInvalid(normalized, min4, max4),
      selected: !!selectedValue.find((date) => date.month === value && date.year === focusedValue.year),
      valueText: formatter.format(normalized.toDate(timeZone)),
      get disabled() {
        return disabled2 || !cellState.selectable;
      }
    };
    return cellState;
  }
  const translations = state2.context.translations || defaultTranslations;
  function getDayTableCellState(props22) {
    const { value, disabled: disabled2, visibleRange = state2.context.visibleRange } = props22;
    const formatter = getDayFormatter(locale, timeZone);
    const unitDuration = getUnitDuration(state2.context.visibleDuration);
    const end = visibleRange.start.add(unitDuration).subtract({ days: 1 });
    const cellState = {
      invalid: isDateInvalid(value, min4, max4),
      disabled: disabled2 || isDateDisabled(value, visibleRange.start, end, min4, max4),
      selected: selectedValue.some((date) => isDateEqual(value, date)),
      unavailable: isDateUnavailable(value, isDateUnavailableFn, locale, min4, max4) && !disabled2,
      outsideRange: isDateOutsideVisibleRange(value, visibleRange.start, end),
      inRange: isRangePicker && (isDateWithinRange(value, selectedValue) || isDateWithinRange(value, hoveredRangeValue)),
      firstInRange: isRangePicker && isDateEqual(value, selectedValue[0]),
      lastInRange: isRangePicker && isDateEqual(value, selectedValue[1]),
      today: $14e0f24ef4ac5c92$export$629b0a497aa65267(value, timeZone),
      weekend: $14e0f24ef4ac5c92$export$618d60ea299da42(value, locale),
      formattedDate: formatter.format(value.toDate(timeZone)),
      get focused() {
        return isDateEqual(value, focusedValue) && !cellState.outsideRange;
      },
      get ariaLabel() {
        return translations.dayCell(cellState);
      },
      get selectable() {
        return !cellState.disabled && !cellState.unavailable;
      }
    };
    return cellState;
  }
  function getTableId(props22) {
    const { view = "day", id } = props22;
    return [view, id].filter(Boolean).join(" ");
  }
  return {
    focused,
    open,
    view: state2.context.view,
    getRangePresetValue(preset) {
      return getDateRangePreset(preset, locale, timeZone);
    },
    getDaysInWeek(week, from = startValue) {
      return getDaysInWeek(week, from, locale, startOfWeek);
    },
    getOffset(duration) {
      const from = startValue.add(duration);
      return {
        visibleRange: { start: from, end: endValue.add(duration) },
        weeks: getMonthWeeks(from)
      };
    },
    getMonthWeeks,
    isUnavailable,
    weeks: getMonthWeeks(),
    weekDays: getWeekDays(getTodayDate(timeZone), startOfWeek, timeZone, locale),
    visibleRangeText: state2.context.visibleRangeText,
    value: selectedValue,
    valueAsDate: selectedValue.map((date) => date.toDate(timeZone)),
    valueAsString: state2.context.valueAsString,
    focusedValue,
    focusedValueAsDate: focusedValue == null ? void 0 : focusedValue.toDate(timeZone),
    focusedValueAsString: state2.context.format(focusedValue, { locale, timeZone }),
    visibleRange: state2.context.visibleRange,
    selectToday() {
      const value = constrainValue(getTodayDate(timeZone), min4, max4);
      send({ type: "VALUE.SET", value });
    },
    setValue(values) {
      const computedValue = values.map((date) => constrainValue(date, min4, max4));
      send({ type: "VALUE.SET", value: computedValue });
    },
    clearValue() {
      send("VALUE.CLEAR");
    },
    setFocusedValue(value) {
      send({ type: "FOCUS.SET", value });
    },
    setOpen(nextOpen) {
      if (nextOpen === open) return;
      send(nextOpen ? "OPEN" : "CLOSE");
    },
    focusMonth,
    focusYear,
    getYears,
    getMonths,
    getYearsGrid(props22 = {}) {
      const { columns = 1 } = props22;
      return chunk(getDecadeYears(), columns);
    },
    getDecade() {
      const years = getDecadeRange(focusedValue.year);
      return { start: years.at(0), end: years.at(-1) };
    },
    getMonthsGrid(props22 = {}) {
      const { columns = 1, format } = props22;
      return chunk(getMonths({ format }), columns);
    },
    format(value, opts = { month: "long", year: "numeric" }) {
      return new $fb18d541ea1ad717$export$ad991b66133851cf(locale, opts).format(value.toDate(timeZone));
    },
    setView(view) {
      send({ type: "VIEW.SET", view });
    },
    goToNext() {
      send({ type: "GOTO.NEXT", view: state2.context.view });
    },
    goToPrev() {
      send({ type: "GOTO.PREV", view: state2.context.view });
    },
    getRootProps() {
      return normalize2.element({
        ...parts4.root.attrs,
        dir: state2.context.dir,
        id: dom4.getRootId(state2.context),
        "data-state": open ? "open" : "closed",
        "data-disabled": dataAttr(disabled),
        "data-readonly": dataAttr(readOnly)
      });
    },
    getLabelProps(props22 = {}) {
      const { index = 0 } = props22;
      return normalize2.label({
        ...parts4.label.attrs,
        id: dom4.getLabelId(state2.context, index),
        dir: state2.context.dir,
        htmlFor: dom4.getInputId(state2.context, index),
        "data-state": open ? "open" : "closed",
        "data-index": index,
        "data-disabled": dataAttr(disabled),
        "data-readonly": dataAttr(readOnly)
      });
    },
    getControlProps() {
      return normalize2.element({
        ...parts4.control.attrs,
        dir: state2.context.dir,
        id: dom4.getControlId(state2.context),
        "data-disabled": dataAttr(disabled)
      });
    },
    getRangeTextProps() {
      return normalize2.element({
        ...parts4.rangeText.attrs,
        dir: state2.context.dir
      });
    },
    getContentProps() {
      return normalize2.element({
        ...parts4.content.attrs,
        hidden: !open,
        dir: state2.context.dir,
        "data-state": open ? "open" : "closed",
        "data-placement": currentPlacement,
        id: dom4.getContentId(state2.context),
        tabIndex: -1,
        role: "application",
        "aria-roledescription": "datepicker",
        "aria-label": translations.content
      });
    },
    getTableProps(props22 = {}) {
      const { view = "day", columns = view === "day" ? 7 : 4 } = props22;
      const uid = getTableId(props22);
      return normalize2.element({
        ...parts4.table.attrs,
        role: "grid",
        "data-columns": columns,
        "aria-roledescription": getRoleDescription(view),
        id: dom4.getTableId(state2.context, uid),
        "aria-readonly": ariaAttr(readOnly),
        "aria-disabled": ariaAttr(disabled),
        "aria-multiselectable": ariaAttr(state2.context.selectionMode !== "single"),
        "data-view": view,
        dir: state2.context.dir,
        tabIndex: -1,
        onKeyDown(event) {
          if (event.defaultPrevented) return;
          const keyMap2 = {
            Enter() {
              if (isUnavailable(focusedValue)) return;
              send({ type: "TABLE.ENTER", view, columns, focus: true });
            },
            ArrowLeft() {
              send({ type: "TABLE.ARROW_LEFT", view, columns, focus: true });
            },
            ArrowRight() {
              send({ type: "TABLE.ARROW_RIGHT", view, columns, focus: true });
            },
            ArrowUp() {
              send({ type: "TABLE.ARROW_UP", view, columns, focus: true });
            },
            ArrowDown() {
              send({ type: "TABLE.ARROW_DOWN", view, columns, focus: true });
            },
            PageUp(event2) {
              send({ type: "TABLE.PAGE_UP", larger: event2.shiftKey, view, columns, focus: true });
            },
            PageDown(event2) {
              send({ type: "TABLE.PAGE_DOWN", larger: event2.shiftKey, view, columns, focus: true });
            },
            Home() {
              send({ type: "TABLE.HOME", view, columns, focus: true });
            },
            End() {
              send({ type: "TABLE.END", view, columns, focus: true });
            }
          };
          const exec2 = keyMap2[getEventKey(event, state2.context)];
          if (exec2) {
            exec2(event);
            event.preventDefault();
            event.stopPropagation();
          }
        },
        onPointerLeave() {
          send({ type: "TABLE.POINTER_LEAVE" });
        },
        onPointerDown() {
          send({ type: "TABLE.POINTER_DOWN", view });
        },
        onPointerUp() {
          send({ type: "TABLE.POINTER_UP", view });
        }
      });
    },
    getTableHeadProps(props22 = {}) {
      const { view = "day" } = props22;
      return normalize2.element({
        ...parts4.tableHead.attrs,
        "aria-hidden": true,
        dir: state2.context.dir,
        "data-view": view,
        "data-disabled": dataAttr(disabled)
      });
    },
    getTableHeaderProps(props22 = {}) {
      const { view = "day" } = props22;
      return normalize2.element({
        ...parts4.tableHeader.attrs,
        dir: state2.context.dir,
        "data-view": view,
        "data-disabled": dataAttr(disabled)
      });
    },
    getTableBodyProps(props22 = {}) {
      const { view = "day" } = props22;
      return normalize2.element({
        ...parts4.tableBody.attrs,
        "data-view": view,
        "data-disabled": dataAttr(disabled)
      });
    },
    getTableRowProps(props22 = {}) {
      const { view = "day" } = props22;
      return normalize2.element({
        ...parts4.tableRow.attrs,
        "aria-disabled": ariaAttr(disabled),
        "data-disabled": dataAttr(disabled),
        "data-view": view
      });
    },
    getDayTableCellState,
    getDayTableCellProps(props22) {
      const { value } = props22;
      const cellState = getDayTableCellState(props22);
      return normalize2.element({
        ...parts4.tableCell.attrs,
        role: "gridcell",
        "aria-disabled": ariaAttr(!cellState.selectable),
        "aria-selected": cellState.selected || cellState.inRange,
        "aria-invalid": ariaAttr(cellState.invalid),
        "aria-current": cellState.today ? "date" : void 0,
        "data-value": value.toString()
      });
    },
    getDayTableCellTriggerProps(props22) {
      const { value } = props22;
      const cellState = getDayTableCellState(props22);
      return normalize2.element({
        ...parts4.tableCellTrigger.attrs,
        id: dom4.getCellTriggerId(state2.context, value.toString()),
        role: "button",
        dir: state2.context.dir,
        tabIndex: cellState.focused ? 0 : -1,
        "aria-label": cellState.ariaLabel,
        "aria-disabled": ariaAttr(!cellState.selectable),
        "aria-invalid": ariaAttr(cellState.invalid),
        "data-disabled": dataAttr(!cellState.selectable),
        "data-selected": dataAttr(cellState.selected),
        "data-value": value.toString(),
        "data-view": "day",
        "data-today": dataAttr(cellState.today),
        "data-focus": dataAttr(cellState.focused),
        "data-unavailable": dataAttr(cellState.unavailable),
        "data-range-start": dataAttr(cellState.firstInRange),
        "data-range-end": dataAttr(cellState.lastInRange),
        "data-in-range": dataAttr(cellState.inRange),
        "data-outside-range": dataAttr(cellState.outsideRange),
        "data-weekend": dataAttr(cellState.weekend),
        onClick(event) {
          if (event.defaultPrevented) return;
          if (!cellState.selectable) return;
          send({ type: "CELL.CLICK", cell: "day", value });
        },
        onPointerMove(event) {
          if (event.pointerType === "touch" || !cellState.selectable) return;
          const focus = event.currentTarget.ownerDocument.activeElement !== event.currentTarget;
          if (hoveredValue && $14e0f24ef4ac5c92$export$91b62ebf2ba703ee(value, hoveredValue)) return;
          send({ type: "CELL.POINTER_MOVE", cell: "day", value, focus });
        }
      });
    },
    getMonthTableCellState,
    getMonthTableCellProps(props22) {
      const { value, columns } = props22;
      const cellState = getMonthTableCellState(props22);
      return normalize2.element({
        ...parts4.tableCell.attrs,
        dir: state2.context.dir,
        colSpan: columns,
        role: "gridcell",
        "aria-selected": ariaAttr(cellState.selected),
        "data-selected": dataAttr(cellState.selected),
        "aria-disabled": ariaAttr(!cellState.selectable),
        "data-value": value
      });
    },
    getMonthTableCellTriggerProps(props22) {
      const { value } = props22;
      const cellState = getMonthTableCellState(props22);
      return normalize2.element({
        ...parts4.tableCellTrigger.attrs,
        dir: state2.context.dir,
        role: "button",
        id: dom4.getCellTriggerId(state2.context, value.toString()),
        "data-selected": dataAttr(cellState.selected),
        "aria-disabled": ariaAttr(!cellState.selectable),
        "data-disabled": dataAttr(!cellState.selectable),
        "data-focus": dataAttr(cellState.focused),
        "aria-label": cellState.valueText,
        "data-view": "month",
        "data-value": value,
        tabIndex: cellState.focused ? 0 : -1,
        onClick(event) {
          if (event.defaultPrevented) return;
          if (!cellState.selectable) return;
          send({ type: "CELL.CLICK", cell: "month", value });
        }
      });
    },
    getYearTableCellState,
    getYearTableCellProps(props22) {
      const { value, columns } = props22;
      const cellState = getYearTableCellState(props22);
      return normalize2.element({
        ...parts4.tableCell.attrs,
        dir: state2.context.dir,
        colSpan: columns,
        role: "gridcell",
        "aria-selected": ariaAttr(cellState.selected),
        "data-selected": dataAttr(cellState.selected),
        "aria-disabled": ariaAttr(!cellState.selectable),
        "data-value": value
      });
    },
    getYearTableCellTriggerProps(props22) {
      const { value } = props22;
      const cellState = getYearTableCellState(props22);
      return normalize2.element({
        ...parts4.tableCellTrigger.attrs,
        dir: state2.context.dir,
        role: "button",
        id: dom4.getCellTriggerId(state2.context, value.toString()),
        "data-selected": dataAttr(cellState.selected),
        "data-focus": dataAttr(cellState.focused),
        "aria-disabled": ariaAttr(!cellState.selectable),
        "data-disabled": dataAttr(!cellState.selectable),
        "aria-label": cellState.valueText,
        "data-value": value,
        "data-view": "year",
        tabIndex: cellState.focused ? 0 : -1,
        onClick(event) {
          if (event.defaultPrevented) return;
          if (!cellState.selectable) return;
          send({ type: "CELL.CLICK", cell: "year", value });
        }
      });
    },
    getNextTriggerProps(props22 = {}) {
      const { view = "day" } = props22;
      const isDisabled = disabled || !state2.context.isNextVisibleRangeValid;
      return normalize2.button({
        ...parts4.nextTrigger.attrs,
        dir: state2.context.dir,
        id: dom4.getNextTriggerId(state2.context, view),
        type: "button",
        "aria-label": translations.nextTrigger(view),
        disabled: isDisabled,
        "data-disabled": dataAttr(isDisabled),
        onClick(event) {
          if (event.defaultPrevented) return;
          send({ type: "GOTO.NEXT", view });
        }
      });
    },
    getPrevTriggerProps(props22 = {}) {
      const { view = "day" } = props22;
      const isDisabled = disabled || !state2.context.isPrevVisibleRangeValid;
      return normalize2.button({
        ...parts4.prevTrigger.attrs,
        dir: state2.context.dir,
        id: dom4.getPrevTriggerId(state2.context, view),
        type: "button",
        "aria-label": translations.prevTrigger(view),
        disabled: isDisabled,
        "data-disabled": dataAttr(isDisabled),
        onClick(event) {
          if (event.defaultPrevented) return;
          send({ type: "GOTO.PREV", view });
        }
      });
    },
    getClearTriggerProps() {
      return normalize2.button({
        ...parts4.clearTrigger.attrs,
        id: dom4.getClearTriggerId(state2.context),
        dir: state2.context.dir,
        type: "button",
        "aria-label": translations.clearTrigger,
        hidden: !state2.context.value.length,
        onClick(event) {
          if (event.defaultPrevented) return;
          send("VALUE.CLEAR");
        }
      });
    },
    getTriggerProps() {
      return normalize2.button({
        ...parts4.trigger.attrs,
        id: dom4.getTriggerId(state2.context),
        dir: state2.context.dir,
        type: "button",
        "data-placement": currentPlacement,
        "aria-label": translations.trigger(open),
        "aria-controls": dom4.getContentId(state2.context),
        "data-state": open ? "open" : "closed",
        "aria-haspopup": "grid",
        disabled,
        onClick(event) {
          if (event.defaultPrevented) return;
          if (!interactive) return;
          send("TRIGGER.CLICK");
        }
      });
    },
    getViewTriggerProps(props22 = {}) {
      const { view = "day" } = props22;
      return normalize2.button({
        ...parts4.viewTrigger.attrs,
        "data-view": view,
        dir: state2.context.dir,
        id: dom4.getViewTriggerId(state2.context, view),
        type: "button",
        disabled,
        "aria-label": translations.viewTrigger(view),
        onClick(event) {
          if (event.defaultPrevented) return;
          if (!interactive) return;
          send({ type: "VIEW.TOGGLE", src: "viewTrigger" });
        }
      });
    },
    getViewControlProps(props22 = {}) {
      const { view = "day" } = props22;
      return normalize2.element({
        ...parts4.viewControl.attrs,
        "data-view": view,
        dir: state2.context.dir
      });
    },
    getInputProps(props22 = {}) {
      const { index = 0, fixOnBlur = true } = props22;
      return normalize2.input({
        ...parts4.input.attrs,
        id: dom4.getInputId(state2.context, index),
        autoComplete: "off",
        autoCorrect: "off",
        spellCheck: "false",
        dir: state2.context.dir,
        name: state2.context.name,
        "data-index": index,
        "data-state": open ? "open" : "closed",
        readOnly,
        disabled,
        placeholder: state2.context.placeholder || getInputPlaceholder(locale),
        defaultValue: state2.context.valueAsString[index],
        onBeforeInput(event) {
          const { data } = getNativeEvent(event);
          if (!isValidCharacter(data, separator)) {
            event.preventDefault();
          }
        },
        onFocus() {
          send({ type: "INPUT.FOCUS", index });
        },
        onBlur(event) {
          const value = event.currentTarget.value.trim();
          send({ type: "INPUT.BLUR", value, index, fixOnBlur });
        },
        onKeyDown(event) {
          if (event.defaultPrevented) return;
          if (!interactive) return;
          const keyMap2 = {
            Enter(event2) {
              if (isComposingEvent(event2)) return;
              if (isUnavailable(state2.context.focusedValue)) return;
              if (event2.currentTarget.value.trim() === "") return;
              send({ type: "INPUT.ENTER", value: event2.currentTarget.value, index });
            }
          };
          const exec2 = keyMap2[event.key];
          if (exec2) {
            exec2(event);
            event.preventDefault();
          }
        },
        onInput(event) {
          const value = event.currentTarget.value;
          send({ type: "INPUT.CHANGE", value: ensureValidCharacters(value, separator), index });
        }
      });
    },
    getMonthSelectProps() {
      return normalize2.select({
        ...parts4.monthSelect.attrs,
        id: dom4.getMonthSelectId(state2.context),
        "aria-label": translations.monthSelect,
        disabled,
        dir: state2.context.dir,
        defaultValue: startValue.month,
        onChange(event) {
          focusMonth(Number(event.currentTarget.value));
        }
      });
    },
    getYearSelectProps() {
      return normalize2.select({
        ...parts4.yearSelect.attrs,
        id: dom4.getYearSelectId(state2.context),
        disabled,
        "aria-label": translations.yearSelect,
        dir: state2.context.dir,
        defaultValue: startValue.year,
        onChange(event) {
          focusYear(Number(event.currentTarget.value));
        }
      });
    },
    getPositionerProps() {
      return normalize2.element({
        id: dom4.getPositionerId(state2.context),
        ...parts4.positioner.attrs,
        dir: state2.context.dir,
        style: popperStyles.floating
      });
    },
    getPresetTriggerProps(props22) {
      const value = Array.isArray(props22.value) ? props22.value : getDateRangePreset(props22.value, locale, timeZone);
      const valueAsString = value.map((item) => item.toDate(timeZone).toDateString());
      return normalize2.button({
        ...parts4.presetTrigger.attrs,
        "aria-label": translations.presetTrigger(valueAsString),
        type: "button",
        onClick(event) {
          if (event.defaultPrevented) return;
          send({ type: "PRESET.CLICK", value });
        }
      });
    }
  };
}
var { and: and4 } = guards;
var transformContext = (ctx) => {
  const locale = ctx.locale || "en-US";
  const timeZone = ctx.timeZone || "UTC";
  const selectionMode = ctx.selectionMode || "single";
  const numOfMonths = ctx.numOfMonths || 1;
  const value = sortDates(ctx.value || []).map((date) => constrainValue(date, ctx.min, ctx.max));
  let focusedValue = value[0] || ctx.focusedValue || getTodayDate(timeZone);
  focusedValue = constrainValue(focusedValue, ctx.min, ctx.max);
  const startValue = alignDate(focusedValue, "start", { months: numOfMonths }, locale);
  const minView = "day";
  const maxView = "year";
  const view = clampView(ctx.view || minView, minView, maxView);
  return {
    locale,
    numOfMonths,
    focusedValue,
    startValue,
    inputValue: "",
    timeZone,
    value,
    selectionMode,
    view,
    minView,
    maxView,
    activeIndex: 0,
    hoveredValue: null,
    closeOnSelect: true,
    disabled: false,
    readOnly: false,
    min: void 0,
    max: void 0,
    format(date, { locale: locale2, timeZone: timeZone2 }) {
      const formatter = new $fb18d541ea1ad717$export$ad991b66133851cf(locale2, { timeZone: timeZone2, day: "2-digit", month: "2-digit", year: "numeric" });
      return formatter.format(date.toDate(timeZone2));
    },
    parse(value2, { locale: locale2, timeZone: timeZone2 }) {
      return parseDateString(value2, locale2, timeZone2);
    },
    ...ctx,
    positioning: {
      placement: "bottom",
      ...ctx.positioning
    }
  };
};
function machine4(userContext) {
  const ctx = compact2(userContext);
  return createMachine(
    {
      id: "datepicker",
      initial: ctx.open ? "open" : "idle",
      context: transformContext(ctx),
      computed: {
        isInteractive: (ctx2) => !ctx2.disabled && !ctx2.readOnly,
        visibleDuration: (ctx2) => ({ months: ctx2.numOfMonths }),
        endValue: (ctx2) => getEndDate(ctx2.startValue, ctx2.visibleDuration),
        visibleRange: (ctx2) => ({ start: ctx2.startValue, end: ctx2.endValue }),
        visibleRangeText(ctx2) {
          const formatter = new $fb18d541ea1ad717$export$ad991b66133851cf(ctx2.locale, { month: "long", year: "numeric", timeZone: ctx2.timeZone });
          const start = formatter.format(ctx2.startValue.toDate(ctx2.timeZone));
          const end = formatter.format(ctx2.endValue.toDate(ctx2.timeZone));
          const formatted = ctx2.selectionMode === "range" ? `${start} - ${end}` : start;
          return { start, end, formatted };
        },
        isPrevVisibleRangeValid: (ctx2) => !isPreviousVisibleRangeInvalid(ctx2.startValue, ctx2.min, ctx2.max),
        isNextVisibleRangeValid: (ctx2) => !isNextVisibleRangeInvalid(ctx2.endValue, ctx2.min, ctx2.max),
        valueAsString(ctx2) {
          return ctx2.value.map((date) => ctx2.format(date, { locale: ctx2.locale, timeZone: ctx2.timeZone }));
        }
      },
      activities: ["setupLiveRegion"],
      created: ["setStartValue"],
      watch: {
        locale: ["setStartValue"],
        focusedValue: [
          "setStartValue",
          "syncMonthSelectElement",
          "syncYearSelectElement",
          "focusActiveCellIfNeeded",
          "setHoveredValueIfKeyboard"
        ],
        inputValue: ["syncInputValue"],
        value: ["syncInputElement"],
        valueAsString: ["announceValueText"],
        view: ["focusActiveCell"],
        open: ["toggleVisibility"]
      },
      on: {
        "VALUE.SET": {
          actions: ["setDateValue", "setFocusedDate"]
        },
        "VIEW.SET": {
          actions: ["setView"]
        },
        "FOCUS.SET": {
          actions: ["setFocusedDate"]
        },
        "VALUE.CLEAR": {
          actions: ["clearDateValue", "clearFocusedDate", "focusFirstInputElement"]
        },
        "INPUT.CHANGE": [
          {
            guard: "isInputValueEmpty",
            actions: ["setInputValue", "clearDateValue", "clearFocusedDate"]
          },
          {
            actions: ["setInputValue", "focusParsedDate"]
          }
        ],
        "INPUT.ENTER": {
          actions: ["focusParsedDate", "selectFocusedDate"]
        },
        "INPUT.FOCUS": {
          actions: ["setActiveIndex"]
        },
        "INPUT.BLUR": [
          {
            guard: "shouldFixOnBlur",
            actions: ["setActiveIndexToStart", "selectParsedDate"]
          },
          {
            actions: ["setActiveIndexToStart"]
          }
        ],
        "PRESET.CLICK": [
          {
            guard: "isOpenControlled",
            actions: ["setDateValue", "setFocusedDate", "invokeOnClose"]
          },
          {
            target: "focused",
            actions: ["setDateValue", "setFocusedDate", "focusInputElement"]
          }
        ],
        "GOTO.NEXT": [
          {
            guard: "isYearView",
            actions: ["focusNextDecade", "announceVisibleRange"]
          },
          {
            guard: "isMonthView",
            actions: ["focusNextYear", "announceVisibleRange"]
          },
          {
            actions: ["focusNextPage"]
          }
        ],
        "GOTO.PREV": [
          {
            guard: "isYearView",
            actions: ["focusPreviousDecade", "announceVisibleRange"]
          },
          {
            guard: "isMonthView",
            actions: ["focusPreviousYear", "announceVisibleRange"]
          },
          {
            actions: ["focusPreviousPage"]
          }
        ]
      },
      states: {
        idle: {
          tags: "closed",
          on: {
            "CONTROLLED.OPEN": {
              target: "open",
              actions: ["focusFirstSelectedDate", "focusActiveCell"]
            },
            "TRIGGER.CLICK": [
              {
                guard: "isOpenControlled",
                actions: ["invokeOnOpen"]
              },
              {
                target: "open",
                actions: ["focusFirstSelectedDate", "focusActiveCell", "invokeOnOpen"]
              }
            ],
            OPEN: [
              {
                guard: "isOpenControlled",
                actions: ["invokeOnOpen"]
              },
              {
                target: "open",
                actions: ["focusFirstSelectedDate", "focusActiveCell", "invokeOnOpen"]
              }
            ]
          }
        },
        focused: {
          tags: "closed",
          on: {
            "CONTROLLED.OPEN": {
              target: "open",
              actions: ["focusFirstSelectedDate", "focusActiveCell"]
            },
            "TRIGGER.CLICK": [
              {
                guard: "isOpenControlled",
                actions: ["invokeOnOpen"]
              },
              {
                target: "open",
                actions: ["focusFirstSelectedDate", "focusActiveCell", "invokeOnOpen"]
              }
            ],
            OPEN: [
              {
                guard: "isOpenControlled",
                actions: ["invokeOnOpen"]
              },
              {
                target: "open",
                actions: ["focusFirstSelectedDate", "focusActiveCell", "invokeOnOpen"]
              }
            ]
          }
        },
        open: {
          tags: "open",
          activities: ["trackDismissableElement", "trackPositioning"],
          exit: ["clearHoveredDate", "resetView"],
          on: {
            "CONTROLLED.CLOSE": [
              {
                guard: and4("shouldRestoreFocus", "isInteractOutsideEvent"),
                target: "focused",
                actions: ["focusTriggerElement"]
              },
              {
                guard: "shouldRestoreFocus",
                target: "focused",
                actions: ["focusInputElement"]
              },
              {
                target: "idle"
              }
            ],
            "CELL.CLICK": [
              {
                guard: "isAboveMinView",
                actions: ["setFocusedValueForView", "setPreviousView"]
              },
              {
                guard: and4("isRangePicker", "hasSelectedRange"),
                actions: [
                  "setActiveIndexToStart",
                  "clearDateValue",
                  "setFocusedDate",
                  "setSelectedDate",
                  "setActiveIndexToEnd"
                ]
              },
              // === Grouped transitions (based on `closeOnSelect` and `isOpenControlled`) ===
              {
                guard: and4("isRangePicker", "isSelectingEndDate", "closeOnSelect", "isOpenControlled"),
                actions: [
                  "setFocusedDate",
                  "setSelectedDate",
                  "setActiveIndexToStart",
                  "invokeOnClose",
                  "setRestoreFocus"
                ]
              },
              {
                guard: and4("isRangePicker", "isSelectingEndDate", "closeOnSelect"),
                target: "focused",
                actions: [
                  "setFocusedDate",
                  "setSelectedDate",
                  "setActiveIndexToStart",
                  "invokeOnClose",
                  "focusInputElement"
                ]
              },
              {
                guard: and4("isRangePicker", "isSelectingEndDate"),
                actions: ["setFocusedDate", "setSelectedDate", "setActiveIndexToStart", "clearHoveredDate"]
              },
              // ===
              {
                guard: "isRangePicker",
                actions: ["setFocusedDate", "setSelectedDate", "setActiveIndexToEnd"]
              },
              {
                guard: "isMultiPicker",
                actions: ["setFocusedDate", "toggleSelectedDate"]
              },
              // === Grouped transitions (based on `closeOnSelect` and `isOpenControlled`) ===
              {
                guard: and4("closeOnSelect", "isOpenControlled"),
                actions: ["setFocusedDate", "setSelectedDate", "invokeOnClose"]
              },
              {
                guard: "closeOnSelect",
                target: "focused",
                actions: ["setFocusedDate", "setSelectedDate", "invokeOnClose", "focusInputElement"]
              },
              {
                actions: ["setFocusedDate", "setSelectedDate"]
              }
              // ===
            ],
            "CELL.POINTER_MOVE": {
              guard: and4("isRangePicker", "isSelectingEndDate"),
              actions: ["setHoveredDate", "setFocusedDate"]
            },
            "TABLE.POINTER_LEAVE": {
              guard: "isRangePicker",
              actions: ["clearHoveredDate"]
            },
            "TABLE.POINTER_DOWN": {
              actions: ["disableTextSelection"]
            },
            "TABLE.POINTER_UP": {
              actions: ["enableTextSelection"]
            },
            "TABLE.ESCAPE": [
              {
                guard: "isOpenControlled",
                actions: ["focusFirstSelectedDate", "invokeOnClose"]
              },
              {
                target: "focused",
                actions: ["focusFirstSelectedDate", "invokeOnClose", "focusTriggerElement"]
              }
            ],
            "TABLE.ENTER": [
              {
                guard: "isAboveMinView",
                actions: ["setPreviousView"]
              },
              {
                guard: and4("isRangePicker", "hasSelectedRange"),
                actions: ["setActiveIndexToStart", "clearDateValue", "setSelectedDate", "setActiveIndexToEnd"]
              },
              // === Grouped transitions (based on `closeOnSelect` and `isOpenControlled`) ===
              {
                guard: and4("isRangePicker", "isSelectingEndDate", "closeOnSelect", "isOpenControlled"),
                actions: ["setSelectedDate", "setActiveIndexToStart", "invokeOnClose"]
              },
              {
                guard: and4("isRangePicker", "isSelectingEndDate", "closeOnSelect"),
                target: "focused",
                actions: ["setSelectedDate", "setActiveIndexToStart", "invokeOnClose", "focusInputElement"]
              },
              {
                guard: and4("isRangePicker", "isSelectingEndDate"),
                actions: ["setSelectedDate", "setActiveIndexToStart"]
              },
              // ===
              {
                guard: "isRangePicker",
                actions: ["setSelectedDate", "setActiveIndexToEnd", "focusNextDay"]
              },
              {
                guard: "isMultiPicker",
                actions: ["toggleSelectedDate"]
              },
              // === Grouped transitions (based on `closeOnSelect` and `isOpenControlled`) ===
              {
                guard: and4("closeOnSelect", "isOpenControlled"),
                actions: ["selectFocusedDate", "invokeOnClose"]
              },
              {
                guard: "closeOnSelect",
                target: "focused",
                actions: ["selectFocusedDate", "invokeOnClose", "focusInputElement"]
              },
              {
                actions: ["selectFocusedDate"]
              }
              // ===
            ],
            "TABLE.ARROW_RIGHT": [
              {
                guard: "isMonthView",
                actions: "focusNextMonth"
              },
              {
                guard: "isYearView",
                actions: "focusNextYear"
              },
              {
                actions: ["focusNextDay", "setHoveredDate"]
              }
            ],
            "TABLE.ARROW_LEFT": [
              {
                guard: "isMonthView",
                actions: "focusPreviousMonth"
              },
              {
                guard: "isYearView",
                actions: "focusPreviousYear"
              },
              {
                actions: ["focusPreviousDay"]
              }
            ],
            "TABLE.ARROW_UP": [
              {
                guard: "isMonthView",
                actions: "focusPreviousMonthColumn"
              },
              {
                guard: "isYearView",
                actions: "focusPreviousYearColumn"
              },
              {
                actions: ["focusPreviousWeek"]
              }
            ],
            "TABLE.ARROW_DOWN": [
              {
                guard: "isMonthView",
                actions: "focusNextMonthColumn"
              },
              {
                guard: "isYearView",
                actions: "focusNextYearColumn"
              },
              {
                actions: ["focusNextWeek"]
              }
            ],
            "TABLE.PAGE_UP": {
              actions: ["focusPreviousSection"]
            },
            "TABLE.PAGE_DOWN": {
              actions: ["focusNextSection"]
            },
            "TABLE.HOME": [
              {
                guard: "isMonthView",
                actions: ["focusFirstMonth"]
              },
              {
                guard: "isYearView",
                actions: ["focusFirstYear"]
              },
              {
                actions: ["focusSectionStart"]
              }
            ],
            "TABLE.END": [
              {
                guard: "isMonthView",
                actions: ["focusLastMonth"]
              },
              {
                guard: "isYearView",
                actions: ["focusLastYear"]
              },
              {
                actions: ["focusSectionEnd"]
              }
            ],
            "TRIGGER.CLICK": [
              {
                guard: "isOpenControlled",
                actions: ["invokeOnClose"]
              },
              {
                target: "focused",
                actions: ["invokeOnClose"]
              }
            ],
            "VIEW.TOGGLE": {
              actions: ["setNextView"]
            },
            INTERACT_OUTSIDE: [
              {
                guard: "isOpenControlled",
                actions: ["setActiveIndexToStart", "invokeOnClose"]
              },
              {
                guard: "shouldRestoreFocus",
                target: "focused",
                actions: ["setActiveIndexToStart", "invokeOnClose", "focusTriggerElement"]
              },
              {
                target: "idle",
                actions: ["setActiveIndexToStart", "invokeOnClose"]
              }
            ],
            CLOSE: [
              {
                guard: "isOpenControlled",
                actions: ["setActiveIndexToStart", "invokeOnClose"]
              },
              {
                target: "idle",
                actions: ["setActiveIndexToStart", "invokeOnClose"]
              }
            ]
          }
        }
      }
    },
    {
      guards: {
        isAboveMinView: (ctx2) => isAboveMinView(ctx2.view, ctx2.minView),
        isDayView: (ctx2, evt) => (evt.view || ctx2.view) === "day",
        isMonthView: (ctx2, evt) => (evt.view || ctx2.view) === "month",
        isYearView: (ctx2, evt) => (evt.view || ctx2.view) === "year",
        isRangePicker: (ctx2) => ctx2.selectionMode === "range",
        hasSelectedRange: (ctx2) => ctx2.value.length === 2,
        isMultiPicker: (ctx2) => ctx2.selectionMode === "multiple",
        shouldRestoreFocus: (ctx2) => !!ctx2.restoreFocus,
        isSelectingEndDate: (ctx2) => ctx2.activeIndex === 1,
        closeOnSelect: (ctx2) => !!ctx2.closeOnSelect,
        isOpenControlled: (ctx2) => !!ctx2["open.controlled"],
        isInteractOutsideEvent: (_ctx, evt) => {
          var _a8;
          return ((_a8 = evt.previousEvent) == null ? void 0 : _a8.type) === "INTERACT_OUTSIDE";
        },
        isInputValueEmpty: (_ctx, evt) => evt.value.trim() === "",
        shouldFixOnBlur: (_ctx, evt) => !!evt.fixOnBlur
      },
      activities: {
        trackPositioning(ctx2) {
          ctx2.currentPlacement || (ctx2.currentPlacement = ctx2.positioning.placement);
          const anchorEl = dom4.getControlEl(ctx2);
          const getPositionerEl = () => dom4.getPositionerEl(ctx2);
          return getPlacement(anchorEl, getPositionerEl, {
            ...ctx2.positioning,
            defer: true,
            onComplete(data) {
              ctx2.currentPlacement = data.placement;
            }
          });
        },
        setupLiveRegion(ctx2) {
          const doc = dom4.getDoc(ctx2);
          ctx2.announcer = createLiveRegion({ level: "assertive", document: doc });
          return () => {
            var _a8, _b7;
            return (_b7 = (_a8 = ctx2.announcer) == null ? void 0 : _a8.destroy) == null ? void 0 : _b7.call(_a8);
          };
        },
        trackDismissableElement(ctx2, _evt, { send }) {
          const getContentEl = () => dom4.getContentEl(ctx2);
          return trackDismissableElement(getContentEl, {
            defer: true,
            exclude: [...dom4.getInputEls(ctx2), dom4.getTriggerEl(ctx2), dom4.getClearTriggerEl(ctx2)],
            onInteractOutside(event) {
              ctx2.restoreFocus = !event.detail.focusable;
            },
            onDismiss() {
              send({ type: "INTERACT_OUTSIDE" });
            },
            onEscapeKeyDown(event) {
              event.preventDefault();
              send({ type: "TABLE.ESCAPE", src: "dismissable" });
            }
          });
        }
      },
      actions: {
        setNextView(ctx2) {
          const nextView = getNextView(ctx2.view, ctx2.minView, ctx2.maxView);
          set5.view(ctx2, nextView);
        },
        setPreviousView(ctx2) {
          const prevView = getPreviousView(ctx2.view, ctx2.minView, ctx2.maxView);
          set5.view(ctx2, prevView);
        },
        setView(ctx2, evt) {
          set5.view(ctx2, evt.view);
        },
        setRestoreFocus(ctx2) {
          ctx2.restoreFocus = true;
        },
        announceValueText(ctx2) {
          var _a8;
          const announceText = ctx2.value.map((date) => formatSelectedDate(date, null, ctx2.locale, ctx2.timeZone));
          (_a8 = ctx2.announcer) == null ? void 0 : _a8.announce(announceText.join(","), 3e3);
        },
        announceVisibleRange(ctx2) {
          var _a8;
          const { formatted } = ctx2.visibleRangeText;
          (_a8 = ctx2.announcer) == null ? void 0 : _a8.announce(formatted);
        },
        disableTextSelection(ctx2) {
          disableTextSelection({ target: dom4.getContentEl(ctx2), doc: dom4.getDoc(ctx2) });
        },
        enableTextSelection(ctx2) {
          restoreTextSelection({ doc: dom4.getDoc(ctx2), target: dom4.getContentEl(ctx2) });
        },
        focusFirstSelectedDate(ctx2) {
          if (!ctx2.value.length) return;
          set5.focusedValue(ctx2, ctx2.value[0]);
        },
        syncInputElement(ctx2) {
          raf(() => {
            const inputEls = dom4.getInputEls(ctx2);
            inputEls.forEach((inputEl, index) => {
              dom4.setValue(inputEl, ctx2.valueAsString[index] || "");
            });
          });
        },
        setFocusedDate(ctx2, evt) {
          const value = Array.isArray(evt.value) ? evt.value[0] : evt.value;
          set5.focusedValue(ctx2, value);
        },
        setFocusedValueForView(ctx2, evt) {
          set5.focusedValue(ctx2, ctx2.focusedValue.set({ [ctx2.view]: evt.value }));
        },
        focusNextMonth(ctx2) {
          set5.focusedValue(ctx2, ctx2.focusedValue.add({ months: 1 }));
        },
        focusPreviousMonth(ctx2) {
          set5.focusedValue(ctx2, ctx2.focusedValue.subtract({ months: 1 }));
        },
        setDateValue(ctx2, evt) {
          if (!Array.isArray(evt.value)) return;
          const value = evt.value.map((date) => constrainValue(date, ctx2.min, ctx2.max));
          set5.value(ctx2, value);
        },
        clearDateValue(ctx2) {
          set5.value(ctx2, []);
        },
        setSelectedDate(ctx2, evt) {
          const values = Array.from(ctx2.value);
          values[ctx2.activeIndex] = normalizeValue(ctx2, evt.value ?? ctx2.focusedValue);
          set5.value(ctx2, adjustStartAndEndDate(values));
        },
        toggleSelectedDate(ctx2, evt) {
          const currentValue = normalizeValue(ctx2, evt.value ?? ctx2.focusedValue);
          const index = ctx2.value.findIndex((date) => isDateEqual(date, currentValue));
          if (index === -1) {
            const values = [...ctx2.value, currentValue];
            set5.value(ctx2, sortDates(values));
          } else {
            const values = Array.from(ctx2.value);
            values.splice(index, 1);
            set5.value(ctx2, sortDates(values));
          }
        },
        setHoveredDate(ctx2, evt) {
          ctx2.hoveredValue = evt.value;
        },
        clearHoveredDate(ctx2) {
          ctx2.hoveredValue = null;
        },
        selectFocusedDate(ctx2) {
          const values = Array.from(ctx2.value);
          values[ctx2.activeIndex] = ctx2.focusedValue.copy();
          set5.value(ctx2, adjustStartAndEndDate(values));
          set5.inputValue(ctx2, ctx2.activeIndex);
        },
        focusPreviousDay(ctx2) {
          set5.focusedValue(ctx2, ctx2.focusedValue.subtract({ days: 1 }));
        },
        focusNextDay(ctx2) {
          set5.focusedValue(ctx2, ctx2.focusedValue.add({ days: 1 }));
        },
        focusPreviousWeek(ctx2) {
          set5.focusedValue(ctx2, ctx2.focusedValue.subtract({ weeks: 1 }));
        },
        focusNextWeek(ctx2) {
          set5.focusedValue(ctx2, ctx2.focusedValue.add({ weeks: 1 }));
        },
        focusNextPage(ctx2) {
          const nextPage = getNextPage(
            ctx2.focusedValue,
            ctx2.startValue,
            ctx2.visibleDuration,
            ctx2.locale,
            ctx2.min,
            ctx2.max
          );
          set5.adjustedValue(ctx2, nextPage);
        },
        focusPreviousPage(ctx2) {
          const previousPage = getPreviousPage(
            ctx2.focusedValue,
            ctx2.startValue,
            ctx2.visibleDuration,
            ctx2.locale,
            ctx2.min,
            ctx2.max
          );
          set5.adjustedValue(ctx2, previousPage);
        },
        focusSectionStart(ctx2) {
          set5.focusedValue(ctx2, ctx2.startValue.copy());
        },
        focusSectionEnd(ctx2) {
          set5.focusedValue(ctx2, ctx2.endValue.copy());
        },
        focusNextSection(ctx2, evt) {
          const nextSection = getNextSection(
            ctx2.focusedValue,
            ctx2.startValue,
            evt.larger,
            ctx2.visibleDuration,
            ctx2.locale,
            ctx2.min,
            ctx2.max
          );
          if (!nextSection) return;
          set5.adjustedValue(ctx2, nextSection);
        },
        focusPreviousSection(ctx2, evt) {
          const previousSection = getPreviousSection(
            ctx2.focusedValue,
            ctx2.startValue,
            evt.larger,
            ctx2.visibleDuration,
            ctx2.locale,
            ctx2.min,
            ctx2.max
          );
          if (!previousSection) return;
          set5.adjustedValue(ctx2, previousSection);
        },
        focusNextYear(ctx2) {
          set5.focusedValue(ctx2, ctx2.focusedValue.add({ years: 1 }));
        },
        focusPreviousYear(ctx2) {
          set5.focusedValue(ctx2, ctx2.focusedValue.subtract({ years: 1 }));
        },
        focusNextDecade(ctx2) {
          set5.focusedValue(ctx2, ctx2.focusedValue.add({ years: 10 }));
        },
        focusPreviousDecade(ctx2) {
          set5.focusedValue(ctx2, ctx2.focusedValue.subtract({ years: 10 }));
        },
        clearFocusedDate(ctx2) {
          set5.focusedValue(ctx2, getTodayDate(ctx2.timeZone));
        },
        focusPreviousMonthColumn(ctx2, evt) {
          set5.focusedValue(ctx2, ctx2.focusedValue.subtract({ months: evt.columns }));
        },
        focusNextMonthColumn(ctx2, evt) {
          set5.focusedValue(ctx2, ctx2.focusedValue.add({ months: evt.columns }));
        },
        focusPreviousYearColumn(ctx2, evt) {
          set5.focusedValue(ctx2, ctx2.focusedValue.subtract({ years: evt.columns }));
        },
        focusNextYearColumn(ctx2, evt) {
          set5.focusedValue(ctx2, ctx2.focusedValue.add({ years: evt.columns }));
        },
        focusFirstMonth(ctx2) {
          set5.focusedValue(ctx2, ctx2.focusedValue.set({ month: 0 }));
        },
        focusLastMonth(ctx2) {
          set5.focusedValue(ctx2, ctx2.focusedValue.set({ month: 12 }));
        },
        focusFirstYear(ctx2) {
          const range = getDecadeRange(ctx2.focusedValue.year);
          set5.focusedValue(ctx2, ctx2.focusedValue.set({ year: range[0] }));
        },
        focusLastYear(ctx2) {
          const range = getDecadeRange(ctx2.focusedValue.year);
          set5.focusedValue(ctx2, ctx2.focusedValue.set({ year: range[range.length - 1] }));
        },
        setActiveIndex(ctx2, evt) {
          ctx2.activeIndex = evt.index;
        },
        setActiveIndexToEnd(ctx2) {
          ctx2.activeIndex = 1;
        },
        setActiveIndexToStart(ctx2) {
          ctx2.activeIndex = 0;
        },
        focusActiveCell(ctx2) {
          raf(() => {
            var _a8;
            (_a8 = dom4.getFocusedCell(ctx2)) == null ? void 0 : _a8.focus({ preventScroll: true });
          });
        },
        focusActiveCellIfNeeded(ctx2, evt) {
          if (!evt.focus) return;
          raf(() => {
            var _a8;
            (_a8 = dom4.getFocusedCell(ctx2)) == null ? void 0 : _a8.focus({ preventScroll: true });
          });
        },
        setHoveredValueIfKeyboard(ctx2, evt) {
          if (!evt.type.startsWith("TABLE.ARROW") || ctx2.selectionMode !== "range" || ctx2.activeIndex === 0) return;
          ctx2.hoveredValue = ctx2.focusedValue.copy();
        },
        focusTriggerElement(ctx2) {
          raf(() => {
            var _a8;
            (_a8 = dom4.getTriggerEl(ctx2)) == null ? void 0 : _a8.focus({ preventScroll: true });
          });
        },
        focusFirstInputElement(ctx2) {
          raf(() => {
            const [inputEl] = dom4.getInputEls(ctx2);
            inputEl == null ? void 0 : inputEl.focus({ preventScroll: true });
          });
        },
        focusInputElement(ctx2) {
          raf(() => {
            const inputEls = dom4.getInputEls(ctx2);
            const lastIndexWithValue = inputEls.findLastIndex((inputEl2) => inputEl2.value !== "");
            const indexToFocus = Math.max(lastIndexWithValue, 0);
            const inputEl = inputEls[indexToFocus];
            inputEl == null ? void 0 : inputEl.focus({ preventScroll: true });
            inputEl == null ? void 0 : inputEl.setSelectionRange(inputEl.value.length, inputEl.value.length);
          });
        },
        syncMonthSelectElement(ctx2) {
          const monthSelectEl = dom4.getMonthSelectEl(ctx2);
          dom4.setValue(monthSelectEl, ctx2.startValue.month.toString());
        },
        syncYearSelectElement(ctx2) {
          const yearSelectEl = dom4.getYearSelectEl(ctx2);
          dom4.setValue(yearSelectEl, ctx2.startValue.year.toString());
        },
        setInputValue(ctx2, evt) {
          if (ctx2.activeIndex !== evt.index) return;
          ctx2.inputValue = evt.value;
        },
        syncInputValue(ctx2, evt) {
          queueMicrotask(() => {
            const inputEls = dom4.getInputEls(ctx2);
            const idx = evt.index ?? ctx2.activeIndex;
            dom4.setValue(inputEls[idx], ctx2.inputValue);
          });
        },
        focusParsedDate(ctx2, evt) {
          if (evt.index == null) return;
          const date = ctx2.parse(evt.value, { locale: ctx2.locale, timeZone: ctx2.timeZone });
          if (!date || !isValidDate(date)) return;
          set5.focusedValue(ctx2, date);
        },
        selectParsedDate(ctx2, evt) {
          if (evt.index == null) return;
          let date = ctx2.parse(evt.value, { locale: ctx2.locale, timeZone: ctx2.timeZone });
          if (!date || !isValidDate(date)) {
            if (evt.value) {
              date = ctx2.focusedValue.copy();
            }
          }
          if (!date) return;
          const values = Array.from(ctx2.value);
          values[evt.index] = date;
          set5.value(ctx2, values);
          set5.inputValue(ctx2, evt.index);
        },
        resetView(ctx2, _evt, { initialContext }) {
          set5.view(ctx2, initialContext.view);
        },
        setStartValue(ctx2) {
          const outside = isDateOutsideVisibleRange(ctx2.focusedValue, ctx2.startValue, ctx2.endValue);
          if (!outside) return;
          const startValue = alignDate(ctx2.focusedValue, "start", { months: ctx2.numOfMonths }, ctx2.locale);
          ctx2.startValue = startValue;
        },
        invokeOnOpen(ctx2) {
          var _a8;
          (_a8 = ctx2.onOpenChange) == null ? void 0 : _a8.call(ctx2, { open: true });
        },
        invokeOnClose(ctx2) {
          var _a8;
          (_a8 = ctx2.onOpenChange) == null ? void 0 : _a8.call(ctx2, { open: false });
        },
        toggleVisibility(ctx2, evt, { send }) {
          send({ type: ctx2.open ? "CONTROLLED.OPEN" : "CONTROLLED.CLOSE", previousEvent: evt });
        }
      },
      compareFns: {
        startValue: isDateEqual,
        endValue: isDateEqual,
        focusedValue: isDateEqual,
        value: isDateEqualFn
      }
    }
  );
}
var invoke3 = {
  change(ctx) {
    var _a8;
    (_a8 = ctx.onValueChange) == null ? void 0 : _a8.call(ctx, {
      value: Array.from(ctx.value),
      valueAsString: Array.from(ctx.valueAsString),
      view: ctx.view
    });
  },
  focusChange(ctx) {
    var _a8;
    (_a8 = ctx.onFocusChange) == null ? void 0 : _a8.call(ctx, {
      focusedValue: ctx.focusedValue,
      value: Array.from(ctx.value),
      valueAsString: Array.from(ctx.valueAsString),
      view: ctx.view
    });
  },
  viewChange(ctx) {
    var _a8;
    (_a8 = ctx.onViewChange) == null ? void 0 : _a8.call(ctx, { view: ctx.view });
  }
};
var isDateEqualFn = (a, b) => {
  if (a.length !== b.length) return false;
  return a.every((date, index) => isDateEqual(date, b[index]));
};
var normalizeValue = (ctx, value) => {
  let dateValue = typeof value === "number" ? ctx.focusedValue.set({ [ctx.view]: value }) : value;
  eachView((view) => {
    if (isBelowMinView(view, ctx.minView)) {
      dateValue = dateValue.set({ [view]: view === "day" ? 1 : 0 });
    }
  });
  return dateValue;
};
var set5 = {
  value(ctx, value) {
    if (isDateEqualFn(ctx.value, value)) return;
    ctx.value = value;
    invoke3.change(ctx);
  },
  focusedValue(ctx, mixedValue) {
    if (!mixedValue) return;
    const value = normalizeValue(ctx, mixedValue);
    if (isDateEqual(ctx.focusedValue, value)) return;
    const adjustFn = getAdjustedDateFn(ctx.visibleDuration, ctx.locale, ctx.min, ctx.max);
    const adjustedValue = adjustFn({
      focusedDate: value,
      startDate: ctx.startValue
    });
    ctx.startValue = adjustedValue.startDate;
    ctx.focusedValue = adjustedValue.focusedDate;
    invoke3.focusChange(ctx);
  },
  adjustedValue(ctx, value) {
    ctx.startValue = value.startDate;
    if (isDateEqual(ctx.focusedValue, value.focusedDate)) return;
    ctx.focusedValue = value.focusedDate;
    invoke3.focusChange(ctx);
  },
  view(ctx, value) {
    if (isEqual(ctx.view, value)) return;
    ctx.view = value;
    invoke3.viewChange(ctx);
  },
  inputValue(ctx, index) {
    const value = ctx.valueAsString[index];
    if (ctx.inputValue === value) return;
    ctx.inputValue = value;
  }
};
var props3 = createProps2()([
  "closeOnSelect",
  "dir",
  "disabled",
  "fixedWeeks",
  "focusedValue",
  "format",
  "parse",
  "placeholder",
  "getRootNode",
  "id",
  "ids",
  "isDateUnavailable",
  "isDateUnavailable",
  "locale",
  "max",
  "min",
  "name",
  "numOfMonths",
  "onFocusChange",
  "onOpenChange",
  "onValueChange",
  "onViewChange",
  "open",
  "open.controlled",
  "positioning",
  "readOnly",
  "selectionMode",
  "startOfWeek",
  "timeZone",
  "translations",
  "value",
  "view",
  "minView",
  "maxView"
]);
var splitProps5 = createSplitProps(props3);
var inputProps = createProps2()(["index", "fixOnBlur"]);
var splitInputProps = createSplitProps(inputProps);
var presetTriggerProps = createProps2()(["value"]);
var splitPresetTriggerProps = createSplitProps(presetTriggerProps);
var tableProps = createProps2()(["columns", "id", "view"]);
var splitTableProps = createSplitProps(tableProps);
var tableCellProps = createProps2()(["disabled", "value", "columns"]);
var splitTableCellProps = createSplitProps(tableCellProps);
var viewProps = createProps2()(["view"]);
var splitViewProps = createSplitProps(viewProps);

// node_modules/@ark-ui/react/dist/utils/render-strategy.js
var [RenderStrategyPropsProvider, useRenderStrategyPropsContext] = createContext({
  name: "RenderStrategyContext",
  hookName: "useRenderStrategyContext",
  providerName: "<RenderStrategyPropsProvider />"
});
var splitRenderStrategyProps = (props21) => createSplitProps2()(props21, ["lazyMount", "unmountOnExit"]);

// node_modules/@ark-ui/react/dist/components/accordion/use-accordion-item-props-context.js
var [AccordionItemPropsProvider, useAccordionItemPropsContext] = createContext({
  name: "AccordionItemPropsContext",
  hookName: "useAccordionItemPropsContext",
  providerName: "<AccordionItemPropsProvider />"
});

// node_modules/@ark-ui/react/dist/components/accordion/accordion-item.js
var AccordionItem = (0, import_react10.forwardRef)((props21, ref2) => {
  const [itemProps7, localProps] = splitItemProps(props21);
  const accordion = useAccordionContext();
  const renderStrategy = useRenderStrategyPropsContext();
  const mergedProps = mergeProps(accordion.getItemProps(itemProps7), localProps);
  const item = accordion.getItemState(itemProps7);
  const itemContentProps = accordion.getItemContentProps(itemProps7);
  return (0, import_jsx_runtime3.jsx)(AccordionItemPropsProvider, { value: itemProps7, children: (0, import_jsx_runtime3.jsx)(AccordionItemProvider, { value: item, children: (0, import_jsx_runtime3.jsx)(
    CollapsibleRoot,
    {
      ref: ref2,
      open: item.expanded,
      ids: { content: itemContentProps.id },
      ...renderStrategy,
      ...mergedProps
    }
  ) }) });
});
AccordionItem.displayName = "AccordionItem";

// node_modules/@ark-ui/react/dist/components/accordion/accordion-item-content.js
var import_jsx_runtime5 = __toESM(require_jsx_runtime(), 1);
var import_react14 = __toESM(require_react(), 1);

// node_modules/@ark-ui/react/dist/components/collapsible/collapsible-content.js
var import_jsx_runtime4 = __toESM(require_jsx_runtime(), 1);
var import_react12 = __toESM(require_react(), 1);
var CollapsibleContent = (0, import_react12.forwardRef)(
  (props21, ref2) => {
    const collapsible = useCollapsibleContext();
    if (collapsible.isUnmounted) {
      return null;
    }
    const mergedProps = mergeProps(collapsible.getContentProps(), props21);
    return (0, import_jsx_runtime4.jsx)(ark.div, { ...mergedProps, ref: ref2 });
  }
);
CollapsibleContent.displayName = "CollapsibleContent";

// node_modules/@ark-ui/react/dist/components/accordion/accordion-item-content.js
var splitVisibilityProps = createSplitProps2();
var AccordionItemContent = (0, import_react14.forwardRef)(
  (props21, ref2) => {
    const accordion = useAccordionContext();
    const itemProps7 = useAccordionItemPropsContext();
    const contentProps = accordion.getItemContentProps(itemProps7);
    const [, itemContentProps] = splitVisibilityProps(contentProps, ["hidden", "data-state"]);
    const mergedProps = mergeProps(itemContentProps, props21);
    return (0, import_jsx_runtime5.jsx)(CollapsibleContent, { ref: ref2, ...mergedProps });
  }
);
AccordionItemContent.displayName = "AccordionItemContent";

// node_modules/@ark-ui/react/dist/components/accordion/accordion-item-context.js
var AccordionItemContext = (props21) => props21.children(useAccordionItemContext());

// node_modules/@ark-ui/react/dist/components/accordion/accordion-item-indicator.js
var import_jsx_runtime6 = __toESM(require_jsx_runtime(), 1);
var import_react16 = __toESM(require_react(), 1);
var AccordionItemIndicator = (0, import_react16.forwardRef)(
  (props21, ref2) => {
    const accordion = useAccordionContext();
    const itemProps7 = useAccordionItemPropsContext();
    const mergedProps = mergeProps(accordion.getItemIndicatorProps(itemProps7), props21);
    return (0, import_jsx_runtime6.jsx)(ark.div, { ...mergedProps, ref: ref2 });
  }
);
AccordionItemIndicator.displayName = "AccordionItemIndicator";

// node_modules/@ark-ui/react/dist/components/accordion/accordion-item-trigger.js
var import_jsx_runtime7 = __toESM(require_jsx_runtime(), 1);
var import_react18 = __toESM(require_react(), 1);
var AccordionItemTrigger = (0, import_react18.forwardRef)(
  (props21, ref2) => {
    const accordion = useAccordionContext();
    const itemProps7 = useAccordionItemPropsContext();
    const collapsible = useCollapsibleContext();
    const triggerProps = accordion.getItemTriggerProps(itemProps7);
    const mergedProps = mergeProps(
      {
        ...triggerProps,
        "aria-controls": collapsible.isUnmounted ? void 0 : triggerProps["aria-controls"]
      },
      props21
    );
    return (0, import_jsx_runtime7.jsx)(ark.button, { ...mergedProps, ref: ref2 });
  }
);
AccordionItemTrigger.displayName = "AccordionItemTrigger";

// node_modules/@ark-ui/react/dist/components/accordion/accordion-root.js
var import_jsx_runtime8 = __toESM(require_jsx_runtime(), 1);
var import_react22 = __toESM(require_react(), 1);

// node_modules/@ark-ui/react/dist/components/accordion/use-accordion.js
var import_react20 = __toESM(require_react(), 1);
var useAccordion = (props21 = {}) => {
  const { getRootNode } = useEnvironmentContext();
  const { dir } = useLocaleContext();
  const initialContext = {
    id: (0, import_react20.useId)(),
    dir,
    getRootNode,
    value: props21.defaultValue,
    ...props21
  };
  const context = {
    ...initialContext,
    value: props21.value,
    onFocusChange: useEvent(props21.onFocusChange),
    onValueChange: useEvent(props21.onValueChange)
  };
  const [state2, send] = useMachine(machine(initialContext), { context });
  return connect(state2, send, normalizeProps);
};

// node_modules/@ark-ui/react/dist/components/accordion/accordion-root.js
var AccordionRoot = (0, import_react22.forwardRef)((props21, ref2) => {
  const [renderStrategyProps, accordionProps] = splitRenderStrategyProps(props21);
  const [useAccordionProps, localProps] = createSplitProps2()(accordionProps, [
    "collapsible",
    "defaultValue",
    "disabled",
    "id",
    "ids",
    "multiple",
    "onFocusChange",
    "onValueChange",
    "orientation",
    "value"
  ]);
  const accordion = useAccordion(useAccordionProps);
  const mergedProps = mergeProps(accordion.getRootProps(), localProps);
  return (0, import_jsx_runtime8.jsx)(AccordionProvider, { value: accordion, children: (0, import_jsx_runtime8.jsx)(RenderStrategyPropsProvider, { value: renderStrategyProps, children: (0, import_jsx_runtime8.jsx)(ark.div, { ...mergedProps, ref: ref2 }) }) });
});
AccordionRoot.displayName = "AccordionRoot";

// node_modules/@ark-ui/react/dist/components/accordion/accordion-root-provider.js
var import_jsx_runtime9 = __toESM(require_jsx_runtime(), 1);
var import_react24 = __toESM(require_react(), 1);
var AccordionRootProvider = (0, import_react24.forwardRef)(
  (props21, ref2) => {
    const [renderStrategyProps, accordionProps] = splitRenderStrategyProps(props21);
    const [{ value: accordion }, localProps] = createSplitProps2()(
      accordionProps,
      ["value"]
    );
    const mergedProps = mergeProps(accordion.getRootProps(), localProps);
    return (0, import_jsx_runtime9.jsx)(AccordionProvider, { value: accordion, children: (0, import_jsx_runtime9.jsx)(RenderStrategyPropsProvider, { value: renderStrategyProps, children: (0, import_jsx_runtime9.jsx)(ark.div, { ...mergedProps, ref: ref2 }) }) });
  }
);
AccordionRootProvider.displayName = "AccordionRootProvider";

// node_modules/@ark-ui/react/dist/components/accordion/accordion.js
var accordion_exports = {};
__export(accordion_exports, {
  Context: () => AccordionContext,
  Item: () => AccordionItem,
  ItemContent: () => AccordionItemContent,
  ItemContext: () => AccordionItemContext,
  ItemIndicator: () => AccordionItemIndicator,
  ItemTrigger: () => AccordionItemTrigger,
  Root: () => AccordionRoot,
  RootProvider: () => AccordionRootProvider
});

// node_modules/@ark-ui/react/dist/components/dialog/dialog-backdrop.js
var import_jsx_runtime10 = __toESM(require_jsx_runtime(), 1);
var import_react28 = __toESM(require_react(), 1);

// node_modules/@zag-js/presence/dist/index.mjs
function connect5(state2, send, _normalize) {
  const present = state2.matches("mounted", "unmountSuspended");
  return {
    skip: !state2.context.initial && present,
    present,
    setNode(node) {
      if (!node) return;
      send({ type: "NODE.SET", node });
    },
    unmount() {
      send({ type: "UNMOUNT" });
    }
  };
}
function machine5(ctx) {
  return createMachine(
    {
      initial: ctx.present ? "mounted" : "unmounted",
      context: {
        node: null,
        styles: null,
        unmountAnimationName: null,
        prevAnimationName: null,
        present: false,
        initial: false,
        ...ctx
      },
      exit: ["clearInitial", "cleanupNode"],
      watch: {
        present: ["setInitial", "syncPresence"]
      },
      on: {
        "NODE.SET": {
          actions: ["setNode", "setStyles"]
        }
      },
      states: {
        mounted: {
          on: {
            UNMOUNT: {
              target: "unmounted",
              actions: ["invokeOnExitComplete"]
            },
            "UNMOUNT.SUSPEND": "unmountSuspended"
          }
        },
        unmountSuspended: {
          activities: ["trackAnimationEvents"],
          after: {
            // Fallback to timeout to ensure we exit this state even if the `animationend` event
            // did not get trigger
            ANIMATION_DURATION: {
              target: "unmounted",
              actions: ["invokeOnExitComplete"]
            }
          },
          on: {
            MOUNT: {
              target: "mounted",
              actions: ["setPrevAnimationName"]
            },
            UNMOUNT: {
              target: "unmounted",
              actions: ["invokeOnExitComplete"]
            }
          }
        },
        unmounted: {
          entry: ["clearPrevAnimationName"],
          on: {
            MOUNT: {
              target: "mounted",
              actions: ["setPrevAnimationName"]
            }
          }
        }
      }
    },
    {
      delays: {
        ANIMATION_DURATION(ctx2) {
          var _a8, _b7;
          return parseMs((_a8 = ctx2.styles) == null ? void 0 : _a8.animationDuration) + parseMs((_b7 = ctx2.styles) == null ? void 0 : _b7.animationDelay) + ANIMATION_TIMEOUT_MARGIN;
        }
      },
      actions: {
        setInitial(ctx2) {
          ctx2.initial = true;
        },
        clearInitial(ctx2) {
          ctx2.initial = false;
        },
        cleanupNode(ctx2) {
          ctx2.node = null;
          ctx2.styles = null;
        },
        invokeOnExitComplete(ctx2) {
          var _a8;
          (_a8 = ctx2.onExitComplete) == null ? void 0 : _a8.call(ctx2);
        },
        setNode(ctx2, evt) {
          ctx2.node = ref(evt.node);
        },
        setStyles(ctx2, evt) {
          const win = evt.node.ownerDocument.defaultView || window;
          ctx2.styles = ref(win.getComputedStyle(evt.node));
        },
        syncPresence(ctx2, _evt, { send }) {
          var _a8;
          if (ctx2.present) {
            send({ type: "MOUNT", src: "presence.changed" });
            return;
          }
          if (!ctx2.present && ((_a8 = ctx2.node) == null ? void 0 : _a8.ownerDocument.visibilityState) === "hidden") {
            send({ type: "UNMOUNT", src: "visibilitychange" });
            return;
          }
          const animationName = getAnimationName(ctx2.styles);
          const exec2 = ctx2.immediate ? queueMicrotask : requestAnimationFrame;
          exec2(() => {
            var _a9, _b7;
            ctx2.unmountAnimationName = animationName;
            if (animationName === "none" || animationName === ctx2.prevAnimationName || ((_a9 = ctx2.styles) == null ? void 0 : _a9.display) === "none" || ((_b7 = ctx2.styles) == null ? void 0 : _b7.animationDuration) === "0s") {
              send({ type: "UNMOUNT", src: "presence.changed" });
            } else {
              send({ type: "UNMOUNT.SUSPEND" });
            }
          });
        },
        setPrevAnimationName(ctx2) {
          const exec2 = ctx2.immediate ? queueMicrotask : requestAnimationFrame;
          exec2(() => {
            ctx2.prevAnimationName = getAnimationName(ctx2.styles);
          });
        },
        clearPrevAnimationName(ctx2) {
          ctx2.prevAnimationName = null;
        }
      },
      activities: {
        trackAnimationEvents(ctx2, _evt, { send }) {
          const node = ctx2.node;
          if (!node) return;
          const onStart = (event) => {
            var _a8, _b7;
            const target = ((_b7 = (_a8 = event.composedPath) == null ? void 0 : _a8.call(event)) == null ? void 0 : _b7[0]) ?? event.target;
            if (target === node) {
              ctx2.prevAnimationName = getAnimationName(ctx2.styles);
            }
          };
          const onEnd = (event) => {
            var _a8, _b7;
            const animationName = getAnimationName(ctx2.styles);
            const target = ((_b7 = (_a8 = event.composedPath) == null ? void 0 : _a8.call(event)) == null ? void 0 : _b7[0]) ?? event.target;
            if (target === node && animationName === ctx2.unmountAnimationName) {
              send({ type: "UNMOUNT", src: "animationend" });
            }
          };
          node.addEventListener("animationstart", onStart);
          node.addEventListener("animationcancel", onEnd);
          node.addEventListener("animationend", onEnd);
          return () => {
            node.removeEventListener("animationstart", onStart);
            node.removeEventListener("animationcancel", onEnd);
            node.removeEventListener("animationend", onEnd);
          };
        }
      }
    }
  );
}
function getAnimationName(styles) {
  return (styles == null ? void 0 : styles.animationName) || "none";
}
function parseMs(value) {
  return parseFloat(value || "0") * 1e3;
}
var ANIMATION_TIMEOUT_MARGIN = 16.667;
var props4 = createProps2()(["onExitComplete", "present", "immediate"]);

// node_modules/@ark-ui/react/dist/components/presence/use-presence.js
var import_react26 = __toESM(require_react(), 1);
var usePresence = (props21) => {
  const { lazyMount, unmountOnExit, present, ...rest } = props21;
  const wasEverPresent = (0, import_react26.useRef)(false);
  const context = {
    ...rest,
    present,
    onExitComplete: useEvent(props21.onExitComplete)
  };
  const [state2, send] = useMachine(machine5(context), { context });
  const api = connect5(state2, send, normalizeProps);
  if (api.present) {
    wasEverPresent.current = true;
  }
  const unmounted = !api.present && !wasEverPresent.current && lazyMount || unmountOnExit && !api.present && wasEverPresent.current;
  const getPresenceProps = () => ({
    "data-state": present ? "open" : "closed",
    hidden: !api.present
  });
  return {
    ref: api.setNode,
    getPresenceProps,
    present: api.present,
    unmounted
  };
};

// node_modules/@ark-ui/react/dist/components/dialog/use-dialog-context.js
var [DialogProvider, useDialogContext] = createContext({
  name: "DialogContext",
  hookName: "useDialogContext",
  providerName: "<DialogProvider />"
});

// node_modules/@ark-ui/react/dist/components/dialog/dialog-backdrop.js
var DialogBackdrop = (0, import_react28.forwardRef)((props21, ref2) => {
  const dialog = useDialogContext();
  const renderStrategyProps = useRenderStrategyPropsContext();
  const presence = usePresence({ ...renderStrategyProps, present: dialog.open });
  const mergedProps = mergeProps(dialog.getBackdropProps(), presence.getPresenceProps(), props21);
  if (presence.unmounted) {
    return null;
  }
  return (0, import_jsx_runtime10.jsx)(ark.div, { ...mergedProps, ref: composeRefs(presence.ref, ref2) });
});
DialogBackdrop.displayName = "DialogBackdrop";

// node_modules/@ark-ui/react/dist/components/dialog/dialog-close-trigger.js
var import_jsx_runtime11 = __toESM(require_jsx_runtime(), 1);
var import_react30 = __toESM(require_react(), 1);
var DialogCloseTrigger = (0, import_react30.forwardRef)(
  (props21, ref2) => {
    const dialog = useDialogContext();
    const mergedProps = mergeProps(dialog.getCloseTriggerProps(), props21);
    return (0, import_jsx_runtime11.jsx)(ark.button, { ...mergedProps, ref: ref2 });
  }
);
DialogCloseTrigger.displayName = "DialogCloseTrigger";

// node_modules/@ark-ui/react/dist/components/dialog/dialog-content.js
var import_jsx_runtime12 = __toESM(require_jsx_runtime(), 1);
var import_react32 = __toESM(require_react(), 1);

// node_modules/@ark-ui/react/dist/components/presence/use-presence-context.js
var [PresenceProvider, usePresenceContext] = createContext({
  name: "PresenceContext",
  hookName: "usePresenceContext",
  providerName: "<PresenceProvider />"
});

// node_modules/@ark-ui/react/dist/components/dialog/dialog-content.js
var DialogContent = (0, import_react32.forwardRef)((props21, ref2) => {
  const dialog = useDialogContext();
  const presence = usePresenceContext();
  const mergedProps = mergeProps(dialog.getContentProps(), presence.getPresenceProps(), props21);
  if (presence.unmounted) {
    return null;
  }
  return (0, import_jsx_runtime12.jsx)(ark.div, { ...mergedProps, ref: composeRefs(presence.ref, ref2) });
});
DialogContent.displayName = "DialogContent";

// node_modules/@ark-ui/react/dist/components/dialog/dialog-context.js
var DialogContext = (props21) => props21.children(useDialogContext());

// node_modules/@ark-ui/react/dist/components/dialog/dialog-description.js
var import_jsx_runtime13 = __toESM(require_jsx_runtime(), 1);
var import_react34 = __toESM(require_react(), 1);
var DialogDescription = (0, import_react34.forwardRef)(
  (props21, ref2) => {
    const dialog = useDialogContext();
    const mergedProps = mergeProps(dialog.getDescriptionProps(), props21);
    return (0, import_jsx_runtime13.jsx)(ark.div, { ...mergedProps, ref: ref2 });
  }
);
DialogDescription.displayName = "DialogDescription";

// node_modules/@ark-ui/react/dist/components/dialog/dialog-positioner.js
var import_jsx_runtime14 = __toESM(require_jsx_runtime(), 1);
var import_react36 = __toESM(require_react(), 1);
var DialogPositioner = (0, import_react36.forwardRef)((props21, ref2) => {
  const dialog = useDialogContext();
  const mergedProps = mergeProps(dialog.getPositionerProps(), props21);
  const presence = usePresenceContext();
  if (presence.unmounted) {
    return null;
  }
  return (0, import_jsx_runtime14.jsx)(ark.div, { ...mergedProps, ref: ref2 });
});
DialogPositioner.displayName = "DialogPositioner";

// node_modules/@ark-ui/react/dist/components/dialog/dialog-root.js
var import_jsx_runtime15 = __toESM(require_jsx_runtime(), 1);

// node_modules/@ark-ui/react/dist/components/presence/split-presence-props.js
var splitPresenceProps = (props21) => createSplitProps2()(props21, [
  "immediate",
  "lazyMount",
  "onExitComplete",
  "present",
  "unmountOnExit"
]);

// node_modules/@zag-js/aria-hidden/dist/index.mjs
var counterMap = /* @__PURE__ */ new WeakMap();
var uncontrolledNodes = /* @__PURE__ */ new WeakMap();
var markerMap = {};
var lockCount = 0;
var unwrapHost = (node) => node && (node.host || unwrapHost(node.parentNode));
var correctTargets = (parent, targets) => targets.map((target) => {
  if (parent.contains(target)) return target;
  const correctedTarget = unwrapHost(target);
  if (correctedTarget && parent.contains(correctedTarget)) {
    return correctedTarget;
  }
  console.error("[zag-js > ariaHidden] target", target, "in not contained inside", parent, ". Doing nothing");
  return null;
}).filter((x) => Boolean(x));
var isIgnoredNode = (node) => {
  if (node.localName === "next-route-announcer") return true;
  if (node.localName === "script") return true;
  if (node.hasAttribute("aria-live")) return true;
  return node.matches("[data-live-announcer]");
};
var walkTreeOutside = (originalTarget, props21) => {
  const { parentNode, markerName, controlAttribute } = props21;
  const targets = correctTargets(parentNode, Array.isArray(originalTarget) ? originalTarget : [originalTarget]);
  markerMap[markerName] || (markerMap[markerName] = /* @__PURE__ */ new WeakMap());
  const markerCounter = markerMap[markerName];
  const hiddenNodes = [];
  const elementsToKeep = /* @__PURE__ */ new Set();
  const elementsToStop = new Set(targets);
  const keep = (el) => {
    if (!el || elementsToKeep.has(el)) return;
    elementsToKeep.add(el);
    keep(el.parentNode);
  };
  targets.forEach(keep);
  const deep = (parent) => {
    if (!parent || elementsToStop.has(parent)) {
      return;
    }
    Array.prototype.forEach.call(parent.children, (node) => {
      if (elementsToKeep.has(node)) {
        deep(node);
      } else {
        try {
          if (isIgnoredNode(node)) return;
          const attr = node.getAttribute(controlAttribute);
          const alreadyHidden = attr !== null && attr !== "false";
          const counterValue = (counterMap.get(node) || 0) + 1;
          const markerValue = (markerCounter.get(node) || 0) + 1;
          counterMap.set(node, counterValue);
          markerCounter.set(node, markerValue);
          hiddenNodes.push(node);
          if (counterValue === 1 && alreadyHidden) {
            uncontrolledNodes.set(node, true);
          }
          if (markerValue === 1) {
            node.setAttribute(markerName, "");
          }
          if (!alreadyHidden) {
            node.setAttribute(controlAttribute, "");
          }
        } catch (e) {
          console.error("[zag-js > ariaHidden] cannot operate on ", node, e);
        }
      }
    });
  };
  deep(parentNode);
  elementsToKeep.clear();
  lockCount++;
  return () => {
    hiddenNodes.forEach((node) => {
      const counterValue = counterMap.get(node) - 1;
      const markerValue = markerCounter.get(node) - 1;
      counterMap.set(node, counterValue);
      markerCounter.set(node, markerValue);
      if (!counterValue) {
        if (!uncontrolledNodes.has(node)) {
          node.removeAttribute(controlAttribute);
        }
        uncontrolledNodes.delete(node);
      }
      if (!markerValue) {
        node.removeAttribute(markerName);
      }
    });
    lockCount--;
    if (!lockCount) {
      counterMap = /* @__PURE__ */ new WeakMap();
      counterMap = /* @__PURE__ */ new WeakMap();
      uncontrolledNodes = /* @__PURE__ */ new WeakMap();
      markerMap = {};
    }
  };
};
var getParentNode3 = (originalTarget) => {
  const target = Array.isArray(originalTarget) ? originalTarget[0] : originalTarget;
  return target.ownerDocument.body;
};
var hideOthers = (originalTarget, parentNode = getParentNode3(originalTarget), markerName = "data-aria-hidden") => {
  if (!parentNode) return;
  return walkTreeOutside(originalTarget, {
    parentNode,
    markerName,
    controlAttribute: "aria-hidden"
  });
};
var raf2 = (fn) => {
  const frameId = requestAnimationFrame(() => fn());
  return () => cancelAnimationFrame(frameId);
};
function ariaHidden(targetsOrFn, options = {}) {
  const { defer = true } = options;
  const func = defer ? raf2 : (v) => v();
  const cleanups2 = [];
  cleanups2.push(
    func(() => {
      const targets = typeof targetsOrFn === "function" ? targetsOrFn() : targetsOrFn;
      const elements = targets.filter(Boolean);
      if (elements.length === 0) return;
      cleanups2.push(hideOthers(elements));
    })
  );
  return () => {
    cleanups2.forEach((fn) => fn == null ? void 0 : fn());
  };
}

// node_modules/@zag-js/focus-trap/dist/index.mjs
var __defProp3 = Object.defineProperty;
var __defNormalProp3 = (obj, key, value) => key in obj ? __defProp3(obj, key, { enumerable: true, configurable: true, writable: true, value }) : obj[key] = value;
var __publicField3 = (obj, key, value) => __defNormalProp3(obj, typeof key !== "symbol" ? key + "" : key, value);
var activeFocusTraps = {
  activateTrap(trapStack, trap) {
    if (trapStack.length > 0) {
      const activeTrap = trapStack[trapStack.length - 1];
      if (activeTrap !== trap) {
        activeTrap.pause();
      }
    }
    const trapIndex = trapStack.indexOf(trap);
    if (trapIndex === -1) {
      trapStack.push(trap);
    } else {
      trapStack.splice(trapIndex, 1);
      trapStack.push(trap);
    }
  },
  deactivateTrap(trapStack, trap) {
    const trapIndex = trapStack.indexOf(trap);
    if (trapIndex !== -1) {
      trapStack.splice(trapIndex, 1);
    }
    if (trapStack.length > 0) {
      trapStack[trapStack.length - 1].unpause();
    }
  }
};
var sharedTrapStack = [];
var FocusTrap = class {
  constructor(elements, options) {
    __publicField3(this, "trapStack");
    __publicField3(this, "config");
    __publicField3(this, "doc");
    __publicField3(this, "state", {
      containers: [],
      containerGroups: [],
      tabbableGroups: [],
      nodeFocusedBeforeActivation: null,
      mostRecentlyFocusedNode: null,
      active: false,
      paused: false,
      delayInitialFocusTimer: void 0,
      recentNavEvent: void 0
    });
    __publicField3(this, "listenerCleanups", []);
    __publicField3(this, "handleFocus", (event) => {
      const target = getEventTarget(event);
      const targetContained = this.findContainerIndex(target, event) >= 0;
      if (targetContained || isDocument(target)) {
        if (targetContained) {
          this.state.mostRecentlyFocusedNode = target;
        }
      } else {
        event.stopImmediatePropagation();
        let nextNode;
        let navAcrossContainers = true;
        if (this.state.mostRecentlyFocusedNode) {
          if (getTabIndex(this.state.mostRecentlyFocusedNode) > 0) {
            const mruContainerIdx = this.findContainerIndex(this.state.mostRecentlyFocusedNode);
            const { tabbableNodes } = this.state.containerGroups[mruContainerIdx];
            if (tabbableNodes.length > 0) {
              const mruTabIdx = tabbableNodes.findIndex((node) => node === this.state.mostRecentlyFocusedNode);
              if (mruTabIdx >= 0) {
                if (this.config.isKeyForward(this.state.recentNavEvent)) {
                  if (mruTabIdx + 1 < tabbableNodes.length) {
                    nextNode = tabbableNodes[mruTabIdx + 1];
                    navAcrossContainers = false;
                  }
                } else {
                  if (mruTabIdx - 1 >= 0) {
                    nextNode = tabbableNodes[mruTabIdx - 1];
                    navAcrossContainers = false;
                  }
                }
              }
            }
          } else {
            if (!this.state.containerGroups.some((g) => g.tabbableNodes.some((n) => getTabIndex(n) > 0))) {
              navAcrossContainers = false;
            }
          }
        } else {
          navAcrossContainers = false;
        }
        if (navAcrossContainers) {
          nextNode = this.findNextNavNode({
            // move FROM the MRU node, not event-related node (which will be the node that is
            //  outside the trap causing the focus escape we're trying to fix)
            target: this.state.mostRecentlyFocusedNode,
            isBackward: this.config.isKeyBackward(this.state.recentNavEvent)
          });
        }
        if (nextNode) {
          this.tryFocus(nextNode);
        } else {
          this.tryFocus(this.state.mostRecentlyFocusedNode || this.getInitialFocusNode());
        }
      }
      this.state.recentNavEvent = void 0;
    });
    __publicField3(this, "handlePointerDown", (event) => {
      const target = getEventTarget(event);
      if (this.findContainerIndex(target, event) >= 0) {
        return;
      }
      if (valueOrHandler(this.config.clickOutsideDeactivates, event)) {
        this.deactivate({ returnFocus: this.config.returnFocusOnDeactivate });
        return;
      }
      if (valueOrHandler(this.config.allowOutsideClick, event)) {
        return;
      }
      event.preventDefault();
    });
    __publicField3(this, "handleClick", (event) => {
      const target = getEventTarget(event);
      if (this.findContainerIndex(target, event) >= 0) {
        return;
      }
      if (valueOrHandler(this.config.clickOutsideDeactivates, event)) {
        return;
      }
      if (valueOrHandler(this.config.allowOutsideClick, event)) {
        return;
      }
      event.preventDefault();
      event.stopImmediatePropagation();
    });
    __publicField3(this, "handleTabKey", (event) => {
      if (this.config.isKeyForward(event) || this.config.isKeyBackward(event)) {
        this.state.recentNavEvent = event;
        const isBackward = this.config.isKeyBackward(event);
        const destinationNode = this.findNextNavNode({ event, isBackward });
        if (!destinationNode) return;
        if (isTabEvent(event)) {
          event.preventDefault();
        }
        this.tryFocus(destinationNode);
      }
    });
    __publicField3(this, "handleEscapeKey", (event) => {
      if (isEscapeEvent(event) && valueOrHandler(this.config.escapeDeactivates, event) !== false) {
        event.preventDefault();
        this.deactivate();
      }
    });
    __publicField3(this, "_mutationObserver");
    __publicField3(this, "setupMutationObserver", () => {
      const win = this.doc.defaultView || window;
      this._mutationObserver = new win.MutationObserver((mutations) => {
        const isFocusedNodeRemoved = mutations.some((mutation) => {
          const removedNodes = Array.from(mutation.removedNodes);
          return removedNodes.some((node) => node === this.state.mostRecentlyFocusedNode);
        });
        if (isFocusedNodeRemoved) {
          this.tryFocus(this.getInitialFocusNode());
        }
      });
    });
    __publicField3(this, "updateObservedNodes", () => {
      var _a8;
      (_a8 = this._mutationObserver) == null ? void 0 : _a8.disconnect();
      if (this.state.active && !this.state.paused) {
        this.state.containers.map((container) => {
          var _a9;
          (_a9 = this._mutationObserver) == null ? void 0 : _a9.observe(container, { subtree: true, childList: true });
        });
      }
    });
    __publicField3(this, "getInitialFocusNode", () => {
      let node = this.getNodeForOption("initialFocus", { hasFallback: true });
      if (node === false) {
        return false;
      }
      if (node === void 0 || node && !isFocusable(node)) {
        if (this.findContainerIndex(this.doc.activeElement) >= 0) {
          node = this.doc.activeElement;
        } else {
          const firstTabbableGroup = this.state.tabbableGroups[0];
          const firstTabbableNode = firstTabbableGroup && firstTabbableGroup.firstTabbableNode;
          node = firstTabbableNode || this.getNodeForOption("fallbackFocus");
        }
      } else if (node === null) {
        node = this.getNodeForOption("fallbackFocus");
      }
      if (!node) {
        throw new Error("Your focus-trap needs to have at least one focusable element");
      }
      if (!node.isConnected) {
        node = this.getNodeForOption("fallbackFocus");
      }
      return node;
    });
    __publicField3(this, "tryFocus", (node) => {
      if (node === false) return;
      if (node === getActiveElement(this.doc)) return;
      if (!node || !node.focus) {
        this.tryFocus(this.getInitialFocusNode());
        return;
      }
      node.focus({ preventScroll: !!this.config.preventScroll });
      this.state.mostRecentlyFocusedNode = node;
      if (isSelectableInput(node)) {
        node.select();
      }
    });
    __publicField3(this, "deactivate", (deactivateOptions) => {
      if (!this.state.active) return this;
      const options2 = {
        onDeactivate: this.config.onDeactivate,
        onPostDeactivate: this.config.onPostDeactivate,
        checkCanReturnFocus: this.config.checkCanReturnFocus,
        ...deactivateOptions
      };
      clearTimeout(this.state.delayInitialFocusTimer);
      this.state.delayInitialFocusTimer = void 0;
      this.removeListeners();
      this.state.active = false;
      this.state.paused = false;
      this.updateObservedNodes();
      activeFocusTraps.deactivateTrap(this.trapStack, this);
      const onDeactivate = this.getOption(options2, "onDeactivate");
      const onPostDeactivate = this.getOption(options2, "onPostDeactivate");
      const checkCanReturnFocus = this.getOption(options2, "checkCanReturnFocus");
      const returnFocus = this.getOption(options2, "returnFocus", "returnFocusOnDeactivate");
      onDeactivate == null ? void 0 : onDeactivate();
      const finishDeactivation = () => {
        delay(() => {
          if (returnFocus) {
            const returnFocusNode = this.getReturnFocusNode(this.state.nodeFocusedBeforeActivation);
            this.tryFocus(returnFocusNode);
          }
          onPostDeactivate == null ? void 0 : onPostDeactivate();
        });
      };
      if (returnFocus && checkCanReturnFocus) {
        const returnFocusNode = this.getReturnFocusNode(this.state.nodeFocusedBeforeActivation);
        checkCanReturnFocus(returnFocusNode).then(finishDeactivation, finishDeactivation);
        return this;
      }
      finishDeactivation();
      return this;
    });
    __publicField3(this, "pause", (pauseOptions) => {
      if (this.state.paused || !this.state.active) {
        return this;
      }
      const onPause = this.getOption(pauseOptions, "onPause");
      const onPostPause = this.getOption(pauseOptions, "onPostPause");
      this.state.paused = true;
      onPause == null ? void 0 : onPause();
      this.removeListeners();
      this.updateObservedNodes();
      onPostPause == null ? void 0 : onPostPause();
      return this;
    });
    __publicField3(this, "unpause", (unpauseOptions) => {
      if (!this.state.paused || !this.state.active) {
        return this;
      }
      const onUnpause = this.getOption(unpauseOptions, "onUnpause");
      const onPostUnpause = this.getOption(unpauseOptions, "onPostUnpause");
      this.state.paused = false;
      onUnpause == null ? void 0 : onUnpause();
      this.updateTabbableNodes();
      this.addListeners();
      this.updateObservedNodes();
      onPostUnpause == null ? void 0 : onPostUnpause();
      return this;
    });
    __publicField3(this, "updateContainerElements", (containerElements) => {
      this.state.containers = Array.isArray(containerElements) ? containerElements.filter(Boolean) : [containerElements].filter(Boolean);
      if (this.state.active) {
        this.updateTabbableNodes();
      }
      this.updateObservedNodes();
      return this;
    });
    __publicField3(this, "getReturnFocusNode", (previousActiveElement) => {
      const node = this.getNodeForOption("setReturnFocus", {
        params: [previousActiveElement]
      });
      return node ? node : node === false ? false : previousActiveElement;
    });
    __publicField3(this, "getOption", (configOverrideOptions, optionName, configOptionName) => {
      return configOverrideOptions && configOverrideOptions[optionName] !== void 0 ? configOverrideOptions[optionName] : (
        // @ts-expect-error
        this.config[configOptionName || optionName]
      );
    });
    __publicField3(this, "getNodeForOption", (optionName, { hasFallback = false, params = [] } = {}) => {
      let optionValue = this.config[optionName];
      if (typeof optionValue === "function") optionValue = optionValue(...params);
      if (optionValue === true) optionValue = void 0;
      if (!optionValue) {
        if (optionValue === void 0 || optionValue === false) {
          return optionValue;
        }
        throw new Error(`\`${optionName}\` was specified but was not a node, or did not return a node`);
      }
      let node = optionValue;
      if (typeof optionValue === "string") {
        try {
          node = this.doc.querySelector(optionValue);
        } catch (err) {
          throw new Error(`\`${optionName}\` appears to be an invalid selector; error="${err.message}"`);
        }
        if (!node) {
          if (!hasFallback) {
            throw new Error(`\`${optionName}\` as selector refers to no known node`);
          }
        }
      }
      return node;
    });
    __publicField3(this, "findNextNavNode", (opts) => {
      const { event, isBackward = false } = opts;
      const target = opts.target || getEventTarget(event);
      this.updateTabbableNodes();
      let destinationNode = null;
      if (this.state.tabbableGroups.length > 0) {
        const containerIndex = this.findContainerIndex(target, event);
        const containerGroup = containerIndex >= 0 ? this.state.containerGroups[containerIndex] : void 0;
        if (containerIndex < 0) {
          if (isBackward) {
            destinationNode = this.state.tabbableGroups[this.state.tabbableGroups.length - 1].lastTabbableNode;
          } else {
            destinationNode = this.state.tabbableGroups[0].firstTabbableNode;
          }
        } else if (isBackward) {
          let startOfGroupIndex = this.state.tabbableGroups.findIndex(
            ({ firstTabbableNode }) => target === firstTabbableNode
          );
          if (startOfGroupIndex < 0 && ((containerGroup == null ? void 0 : containerGroup.container) === target || isFocusable(target) && !isTabbable(target) && !(containerGroup == null ? void 0 : containerGroup.nextTabbableNode(target, false)))) {
            startOfGroupIndex = containerIndex;
          }
          if (startOfGroupIndex >= 0) {
            const destinationGroupIndex = startOfGroupIndex === 0 ? this.state.tabbableGroups.length - 1 : startOfGroupIndex - 1;
            const destinationGroup = this.state.tabbableGroups[destinationGroupIndex];
            destinationNode = getTabIndex(target) >= 0 ? destinationGroup.lastTabbableNode : destinationGroup.lastDomTabbableNode;
          } else if (!isTabEvent(event)) {
            destinationNode = containerGroup == null ? void 0 : containerGroup.nextTabbableNode(target, false);
          }
        } else {
          let lastOfGroupIndex = this.state.tabbableGroups.findIndex(
            ({ lastTabbableNode }) => target === lastTabbableNode
          );
          if (lastOfGroupIndex < 0 && ((containerGroup == null ? void 0 : containerGroup.container) === target || isFocusable(target) && !isTabbable(target) && !(containerGroup == null ? void 0 : containerGroup.nextTabbableNode(target)))) {
            lastOfGroupIndex = containerIndex;
          }
          if (lastOfGroupIndex >= 0) {
            const destinationGroupIndex = lastOfGroupIndex === this.state.tabbableGroups.length - 1 ? 0 : lastOfGroupIndex + 1;
            const destinationGroup = this.state.tabbableGroups[destinationGroupIndex];
            destinationNode = getTabIndex(target) >= 0 ? destinationGroup.firstTabbableNode : destinationGroup.firstDomTabbableNode;
          } else if (!isTabEvent(event)) {
            destinationNode = containerGroup == null ? void 0 : containerGroup.nextTabbableNode(target);
          }
        }
      } else {
        destinationNode = this.getNodeForOption("fallbackFocus");
      }
      return destinationNode;
    });
    this.trapStack = options.trapStack || sharedTrapStack;
    const config = {
      returnFocusOnDeactivate: true,
      escapeDeactivates: true,
      delayInitialFocus: true,
      isKeyForward(e) {
        return isTabEvent(e) && !e.shiftKey;
      },
      isKeyBackward(e) {
        return isTabEvent(e) && e.shiftKey;
      },
      ...options
    };
    this.doc = config.document || getDocument(Array.isArray(elements) ? elements[0] : elements);
    this.config = config;
    this.updateContainerElements(elements);
    this.setupMutationObserver();
  }
  get active() {
    return this.state.active;
  }
  get paused() {
    return this.state.paused;
  }
  findContainerIndex(element, event) {
    const composedPath = typeof (event == null ? void 0 : event.composedPath) === "function" ? event.composedPath() : void 0;
    return this.state.containerGroups.findIndex(
      ({ container, tabbableNodes }) => container.contains(element) || (composedPath == null ? void 0 : composedPath.includes(container)) || tabbableNodes.find((node) => node === element)
    );
  }
  updateTabbableNodes() {
    this.state.containerGroups = this.state.containers.map((container) => {
      const tabbableNodes = getTabbables(container);
      const focusableNodes = getFocusables(container);
      const firstTabbableNode = tabbableNodes.length > 0 ? tabbableNodes[0] : void 0;
      const lastTabbableNode = tabbableNodes.length > 0 ? tabbableNodes[tabbableNodes.length - 1] : void 0;
      const firstDomTabbableNode = focusableNodes.find((node) => isTabbable(node));
      const lastDomTabbableNode = focusableNodes.slice().reverse().find((node) => isTabbable(node));
      const posTabIndexesFound = !!tabbableNodes.find((node) => getTabIndex(node) > 0);
      function nextTabbableNode(node, forward = true) {
        const nodeIdx = tabbableNodes.indexOf(node);
        if (nodeIdx < 0) {
          if (forward) {
            return focusableNodes.slice(focusableNodes.indexOf(node) + 1).find((el) => isTabbable(el));
          }
          return focusableNodes.slice(0, focusableNodes.indexOf(node)).reverse().find((el) => isTabbable(el));
        }
        return tabbableNodes[nodeIdx + (forward ? 1 : -1)];
      }
      return {
        container,
        tabbableNodes,
        focusableNodes,
        posTabIndexesFound,
        firstTabbableNode,
        lastTabbableNode,
        firstDomTabbableNode,
        lastDomTabbableNode,
        nextTabbableNode
      };
    });
    this.state.tabbableGroups = this.state.containerGroups.filter((group) => group.tabbableNodes.length > 0);
    if (this.state.tabbableGroups.length <= 0 && !this.getNodeForOption("fallbackFocus")) {
      throw new Error(
        "Your focus-trap must have at least one container with at least one tabbable node in it at all times"
      );
    }
    if (this.state.containerGroups.find((g) => g.posTabIndexesFound) && this.state.containerGroups.length > 1) {
      throw new Error(
        "At least one node with a positive tabindex was found in one of your focus-trap's multiple containers. Positive tabindexes are only supported in single-container focus-traps."
      );
    }
  }
  addListeners() {
    if (!this.state.active) return;
    activeFocusTraps.activateTrap(this.trapStack, this);
    this.state.delayInitialFocusTimer = this.config.delayInitialFocus ? delay(() => {
      this.tryFocus(this.getInitialFocusNode());
    }) : this.tryFocus(this.getInitialFocusNode());
    this.listenerCleanups.push(
      addDomEvent(this.doc, "focusin", this.handleFocus, true),
      addDomEvent(this.doc, "mousedown", this.handlePointerDown, { capture: true, passive: false }),
      addDomEvent(this.doc, "touchstart", this.handlePointerDown, { capture: true, passive: false }),
      addDomEvent(this.doc, "click", this.handleClick, { capture: true, passive: false }),
      addDomEvent(this.doc, "keydown", this.handleTabKey, { capture: true, passive: false }),
      addDomEvent(this.doc, "keydown", this.handleEscapeKey)
    );
    return this;
  }
  removeListeners() {
    if (!this.state.active) return;
    this.listenerCleanups.forEach((cleanup) => cleanup());
    this.listenerCleanups = [];
    return this;
  }
  activate(activateOptions) {
    if (this.state.active) {
      return this;
    }
    const onActivate = this.getOption(activateOptions, "onActivate");
    const onPostActivate = this.getOption(activateOptions, "onPostActivate");
    const checkCanFocusTrap = this.getOption(activateOptions, "checkCanFocusTrap");
    if (!checkCanFocusTrap) {
      this.updateTabbableNodes();
    }
    this.state.active = true;
    this.state.paused = false;
    this.state.nodeFocusedBeforeActivation = this.doc.activeElement || null;
    onActivate == null ? void 0 : onActivate();
    const finishActivation = () => {
      if (checkCanFocusTrap) {
        this.updateTabbableNodes();
      }
      this.addListeners();
      this.updateObservedNodes();
      onPostActivate == null ? void 0 : onPostActivate();
    };
    if (checkCanFocusTrap) {
      checkCanFocusTrap(this.state.containers.concat()).then(finishActivation, finishActivation);
      return this;
    }
    finishActivation();
    return this;
  }
};
var isTabEvent = (event) => event.key === "Tab";
var valueOrHandler = (value, ...params) => typeof value === "function" ? value(...params) : value;
var isEscapeEvent = (event) => !event.isComposing && event.key === "Escape";
var delay = (fn) => setTimeout(fn, 0);
var isSelectableInput = (node) => node.localName === "input" && "select" in node && typeof node.select === "function";
function trapFocus(el, options = {}) {
  let trap;
  const cleanup = raf(() => {
    const contentEl = typeof el === "function" ? el() : el;
    if (!contentEl) return;
    trap = new FocusTrap(contentEl, {
      escapeDeactivates: false,
      allowOutsideClick: true,
      preventScroll: true,
      returnFocusOnDeactivate: true,
      delayInitialFocus: false,
      fallbackFocus: contentEl,
      ...options,
      document: getDocument(contentEl)
    });
    try {
      trap.activate();
    } catch {
    }
  });
  return function destroy() {
    trap == null ? void 0 : trap.deactivate();
    cleanup();
  };
}

// node_modules/@zag-js/remove-scroll/dist/index.mjs
var LOCK_CLASSNAME = "data-scroll-lock";
function assignStyle(el, style) {
  if (!el) return;
  const previousStyle = Object.keys(style).reduce(
    (acc, key) => {
      acc[key] = el.style.getPropertyValue(key);
      return acc;
    },
    {}
  );
  Object.assign(el.style, style);
  return () => {
    Object.assign(el.style, previousStyle);
  };
}
function setCSSProperty(el, property, value) {
  if (!el) return;
  const previousValue = el.style.getPropertyValue(property);
  el.style.setProperty(property, value);
  return () => {
    if (previousValue) {
      el.style.setProperty(property, previousValue);
    } else {
      el.style.removeProperty(property);
    }
  };
}
function getPaddingProperty(documentElement) {
  const documentLeft = documentElement.getBoundingClientRect().left;
  const scrollbarX = Math.round(documentLeft) + documentElement.scrollLeft;
  return scrollbarX ? "paddingLeft" : "paddingRight";
}
function preventBodyScroll(_document) {
  const doc = _document ?? document;
  const win = doc.defaultView ?? window;
  const { documentElement, body } = doc;
  const locked = body.hasAttribute(LOCK_CLASSNAME);
  if (locked) return;
  body.setAttribute(LOCK_CLASSNAME, "");
  const scrollbarWidth = win.innerWidth - documentElement.clientWidth;
  const setScrollbarWidthProperty = () => setCSSProperty(documentElement, "--scrollbar-width", `${scrollbarWidth}px`);
  const paddingProperty = getPaddingProperty(documentElement);
  const setStyle2 = () => assignStyle(body, {
    overflow: "hidden",
    [paddingProperty]: `${scrollbarWidth}px`
  });
  const setIOSStyle = () => {
    const { scrollX, scrollY, visualViewport } = win;
    const offsetLeft = (visualViewport == null ? void 0 : visualViewport.offsetLeft) ?? 0;
    const offsetTop = (visualViewport == null ? void 0 : visualViewport.offsetTop) ?? 0;
    const restoreStyle = assignStyle(body, {
      position: "fixed",
      overflow: "hidden",
      top: `${-(scrollY - Math.floor(offsetTop))}px`,
      left: `${-(scrollX - Math.floor(offsetLeft))}px`,
      right: "0",
      [paddingProperty]: `${scrollbarWidth}px`
    });
    return () => {
      restoreStyle == null ? void 0 : restoreStyle();
      win.scrollTo({ left: scrollX, top: scrollY, behavior: "instant" });
    };
  };
  const cleanups2 = [setScrollbarWidthProperty(), isIos() ? setIOSStyle() : setStyle2()];
  return () => {
    cleanups2.forEach((fn) => fn == null ? void 0 : fn());
    body.removeAttribute(LOCK_CLASSNAME);
  };
}

// node_modules/@zag-js/dialog/dist/index.mjs
var anatomy5 = createAnatomy("dialog").parts(
  "trigger",
  "backdrop",
  "positioner",
  "content",
  "title",
  "description",
  "closeTrigger"
);
var parts5 = anatomy5.build();
var dom5 = createScope({
  getPositionerId: (ctx) => {
    var _a8;
    return ((_a8 = ctx.ids) == null ? void 0 : _a8.positioner) ?? `dialog:${ctx.id}:positioner`;
  },
  getBackdropId: (ctx) => {
    var _a8;
    return ((_a8 = ctx.ids) == null ? void 0 : _a8.backdrop) ?? `dialog:${ctx.id}:backdrop`;
  },
  getContentId: (ctx) => {
    var _a8;
    return ((_a8 = ctx.ids) == null ? void 0 : _a8.content) ?? `dialog:${ctx.id}:content`;
  },
  getTriggerId: (ctx) => {
    var _a8;
    return ((_a8 = ctx.ids) == null ? void 0 : _a8.trigger) ?? `dialog:${ctx.id}:trigger`;
  },
  getTitleId: (ctx) => {
    var _a8;
    return ((_a8 = ctx.ids) == null ? void 0 : _a8.title) ?? `dialog:${ctx.id}:title`;
  },
  getDescriptionId: (ctx) => {
    var _a8;
    return ((_a8 = ctx.ids) == null ? void 0 : _a8.description) ?? `dialog:${ctx.id}:description`;
  },
  getCloseTriggerId: (ctx) => {
    var _a8;
    return ((_a8 = ctx.ids) == null ? void 0 : _a8.closeTrigger) ?? `dialog:${ctx.id}:close`;
  },
  getContentEl: (ctx) => dom5.getById(ctx, dom5.getContentId(ctx)),
  getPositionerEl: (ctx) => dom5.getById(ctx, dom5.getPositionerId(ctx)),
  getBackdropEl: (ctx) => dom5.getById(ctx, dom5.getBackdropId(ctx)),
  getTriggerEl: (ctx) => dom5.getById(ctx, dom5.getTriggerId(ctx)),
  getTitleEl: (ctx) => dom5.getById(ctx, dom5.getTitleId(ctx)),
  getDescriptionEl: (ctx) => dom5.getById(ctx, dom5.getDescriptionId(ctx)),
  getCloseTriggerEl: (ctx) => dom5.getById(ctx, dom5.getCloseTriggerId(ctx))
});
function connect6(state2, send, normalize2) {
  const ariaLabel = state2.context["aria-label"];
  const open = state2.matches("open");
  const rendered = state2.context.renderedElements;
  return {
    open,
    setOpen(nextOpen) {
      if (nextOpen === open) return;
      send(nextOpen ? "OPEN" : "CLOSE");
    },
    getTriggerProps() {
      return normalize2.button({
        ...parts5.trigger.attrs,
        dir: state2.context.dir,
        id: dom5.getTriggerId(state2.context),
        "aria-haspopup": "dialog",
        type: "button",
        "aria-expanded": open,
        "data-state": open ? "open" : "closed",
        "aria-controls": dom5.getContentId(state2.context),
        onClick(event) {
          if (event.defaultPrevented) return;
          send("TOGGLE");
        }
      });
    },
    getBackdropProps() {
      return normalize2.element({
        ...parts5.backdrop.attrs,
        dir: state2.context.dir,
        hidden: !open,
        id: dom5.getBackdropId(state2.context),
        "data-state": open ? "open" : "closed"
      });
    },
    getPositionerProps() {
      return normalize2.element({
        ...parts5.positioner.attrs,
        dir: state2.context.dir,
        id: dom5.getPositionerId(state2.context),
        style: {
          pointerEvents: open ? void 0 : "none"
        }
      });
    },
    getContentProps() {
      return normalize2.element({
        ...parts5.content.attrs,
        dir: state2.context.dir,
        role: state2.context.role,
        hidden: !open,
        id: dom5.getContentId(state2.context),
        tabIndex: -1,
        "data-state": open ? "open" : "closed",
        "aria-modal": true,
        "aria-label": ariaLabel || void 0,
        "aria-labelledby": ariaLabel || !rendered.title ? void 0 : dom5.getTitleId(state2.context),
        "aria-describedby": rendered.description ? dom5.getDescriptionId(state2.context) : void 0
      });
    },
    getTitleProps() {
      return normalize2.element({
        ...parts5.title.attrs,
        dir: state2.context.dir,
        id: dom5.getTitleId(state2.context)
      });
    },
    getDescriptionProps() {
      return normalize2.element({
        ...parts5.description.attrs,
        dir: state2.context.dir,
        id: dom5.getDescriptionId(state2.context)
      });
    },
    getCloseTriggerProps() {
      return normalize2.button({
        ...parts5.closeTrigger.attrs,
        dir: state2.context.dir,
        id: dom5.getCloseTriggerId(state2.context),
        type: "button",
        onClick(event) {
          if (event.defaultPrevented) return;
          event.stopPropagation();
          send("CLOSE");
        }
      });
    }
  };
}
function machine6(userContext) {
  const ctx = compact2(userContext);
  return createMachine(
    {
      id: "dialog",
      initial: ctx.open ? "open" : "closed",
      context: {
        role: "dialog",
        renderedElements: {
          title: true,
          description: true
        },
        modal: true,
        trapFocus: true,
        preventScroll: true,
        closeOnInteractOutside: true,
        closeOnEscape: true,
        restoreFocus: true,
        ...ctx
      },
      created: ["setAlertDialogProps"],
      watch: {
        open: ["toggleVisibility"]
      },
      states: {
        open: {
          entry: ["checkRenderedElements", "syncZIndex"],
          activities: ["trackDismissableElement", "trapFocus", "preventScroll", "hideContentBelow"],
          on: {
            "CONTROLLED.CLOSE": {
              target: "closed"
            },
            CLOSE: [
              {
                guard: "isOpenControlled",
                actions: ["invokeOnClose"]
              },
              {
                target: "closed",
                actions: ["invokeOnClose"]
              }
            ],
            TOGGLE: [
              {
                guard: "isOpenControlled",
                actions: ["invokeOnClose"]
              },
              {
                target: "closed",
                actions: ["invokeOnClose"]
              }
            ]
          }
        },
        closed: {
          on: {
            "CONTROLLED.OPEN": {
              target: "open"
            },
            OPEN: [
              {
                guard: "isOpenControlled",
                actions: ["invokeOnOpen"]
              },
              {
                target: "open",
                actions: ["invokeOnOpen"]
              }
            ],
            TOGGLE: [
              {
                guard: "isOpenControlled",
                actions: ["invokeOnOpen"]
              },
              {
                target: "open",
                actions: ["invokeOnOpen"]
              }
            ]
          }
        }
      }
    },
    {
      guards: {
        isOpenControlled: (ctx2) => !!ctx2["open.controlled"]
      },
      activities: {
        trackDismissableElement(ctx2, _evt, { send }) {
          const getContentEl = () => dom5.getContentEl(ctx2);
          return trackDismissableElement(getContentEl, {
            defer: true,
            pointerBlocking: ctx2.modal,
            exclude: [dom5.getTriggerEl(ctx2)],
            onInteractOutside(event) {
              var _a8;
              (_a8 = ctx2.onInteractOutside) == null ? void 0 : _a8.call(ctx2, event);
              if (!ctx2.closeOnInteractOutside) {
                event.preventDefault();
              }
            },
            persistentElements: ctx2.persistentElements,
            onFocusOutside: ctx2.onFocusOutside,
            onPointerDownOutside: ctx2.onPointerDownOutside,
            onEscapeKeyDown(event) {
              var _a8;
              (_a8 = ctx2.onEscapeKeyDown) == null ? void 0 : _a8.call(ctx2, event);
              if (!ctx2.closeOnEscape) {
                event.preventDefault();
              }
            },
            onDismiss() {
              send({ type: "CLOSE", src: "interact-outside" });
            }
          });
        },
        preventScroll(ctx2) {
          if (!ctx2.preventScroll) return;
          return preventBodyScroll(dom5.getDoc(ctx2));
        },
        trapFocus(ctx2) {
          if (!ctx2.trapFocus || !ctx2.modal) return;
          const contentEl = () => dom5.getContentEl(ctx2);
          return trapFocus(contentEl, {
            preventScroll: true,
            returnFocusOnDeactivate: !!ctx2.restoreFocus,
            initialFocus: ctx2.initialFocusEl,
            setReturnFocus: (el) => {
              var _a8;
              return ((_a8 = ctx2.finalFocusEl) == null ? void 0 : _a8.call(ctx2)) ?? el;
            }
          });
        },
        hideContentBelow(ctx2) {
          if (!ctx2.modal) return;
          const getElements = () => [dom5.getContentEl(ctx2)];
          return ariaHidden(getElements, { defer: true });
        }
      },
      actions: {
        setAlertDialogProps(ctx2) {
          if (ctx2.role !== "alertdialog") return;
          ctx2.initialFocusEl || (ctx2.initialFocusEl = () => dom5.getCloseTriggerEl(ctx2));
          ctx2.closeOnInteractOutside = false;
        },
        checkRenderedElements(ctx2) {
          raf(() => {
            ctx2.renderedElements.title = !!dom5.getTitleEl(ctx2);
            ctx2.renderedElements.description = !!dom5.getDescriptionEl(ctx2);
          });
        },
        syncZIndex(ctx2) {
          raf(() => {
            const contentEl = dom5.getContentEl(ctx2);
            if (!contentEl) return;
            const styles = getComputedStyle(contentEl);
            const elems = [dom5.getPositionerEl(ctx2), dom5.getBackdropEl(ctx2)];
            elems.forEach((node) => {
              node == null ? void 0 : node.style.setProperty("--z-index", styles.zIndex);
            });
          });
        },
        invokeOnClose(ctx2) {
          var _a8;
          (_a8 = ctx2.onOpenChange) == null ? void 0 : _a8.call(ctx2, { open: false });
        },
        invokeOnOpen(ctx2) {
          var _a8;
          (_a8 = ctx2.onOpenChange) == null ? void 0 : _a8.call(ctx2, { open: true });
        },
        toggleVisibility(ctx2, evt, { send }) {
          send({ type: ctx2.open ? "CONTROLLED.OPEN" : "CONTROLLED.CLOSE", previousEvent: evt });
        }
      }
    }
  );
}
var props5 = createProps2()([
  "aria-label",
  "closeOnEscape",
  "closeOnInteractOutside",
  "dir",
  "finalFocusEl",
  "getRootNode",
  "getRootNode",
  "id",
  "id",
  "ids",
  "initialFocusEl",
  "modal",
  "onEscapeKeyDown",
  "onFocusOutside",
  "onInteractOutside",
  "onOpenChange",
  "onPointerDownOutside",
  "open.controlled",
  "open",
  "persistentElements",
  "preventScroll",
  "restoreFocus",
  "role",
  "trapFocus"
]);
var splitProps6 = createSplitProps(props5);

// node_modules/@ark-ui/react/dist/components/dialog/use-dialog.js
var import_react38 = __toESM(require_react(), 1);
var useDialog = (props21 = {}) => {
  const { getRootNode } = useEnvironmentContext();
  const { dir } = useLocaleContext();
  const initialContext = {
    id: (0, import_react38.useId)(),
    getRootNode,
    dir,
    open: props21.defaultOpen,
    "open.controlled": props21.open !== void 0,
    ...props21
  };
  const context = {
    ...initialContext,
    open: props21.open,
    onOpenChange: useEvent(props21.onOpenChange, { sync: true }),
    onEscapeKeyDown: useEvent(props21.onEscapeKeyDown),
    onInteractOutside: useEvent(props21.onInteractOutside)
  };
  const [state2, send] = useMachine(machine6(initialContext), { context });
  return connect6(state2, send, normalizeProps);
};

// node_modules/@ark-ui/react/dist/components/dialog/dialog-root.js
var DialogRoot = (props21) => {
  const [presenceProps, { children, ...localProps }] = splitPresenceProps(props21);
  const [renderStrategyProps] = splitRenderStrategyProps(presenceProps);
  const dialog = useDialog(localProps);
  const presence = usePresence(mergeProps({ present: dialog.open }, presenceProps));
  return (0, import_jsx_runtime15.jsx)(DialogProvider, { value: dialog, children: (0, import_jsx_runtime15.jsx)(RenderStrategyPropsProvider, { value: renderStrategyProps, children: (0, import_jsx_runtime15.jsx)(PresenceProvider, { value: presence, children }) }) });
};

// node_modules/@ark-ui/react/dist/components/dialog/dialog-root-provider.js
var import_jsx_runtime16 = __toESM(require_jsx_runtime(), 1);
var DialogRootProvider = (props21) => {
  const [presenceProps, { value: dialog, children }] = splitPresenceProps(props21);
  const [renderStrategyProps] = splitRenderStrategyProps(presenceProps);
  const presence = usePresence(mergeProps({ present: dialog.open }, presenceProps));
  return (0, import_jsx_runtime16.jsx)(DialogProvider, { value: dialog, children: (0, import_jsx_runtime16.jsx)(RenderStrategyPropsProvider, { value: renderStrategyProps, children: (0, import_jsx_runtime16.jsx)(PresenceProvider, { value: presence, children }) }) });
};

// node_modules/@ark-ui/react/dist/components/dialog/dialog-title.js
var import_jsx_runtime17 = __toESM(require_jsx_runtime(), 1);
var import_react42 = __toESM(require_react(), 1);
var DialogTitle = (0, import_react42.forwardRef)((props21, ref2) => {
  const dialog = useDialogContext();
  const mergedProps = mergeProps(dialog.getTitleProps(), props21);
  return (0, import_jsx_runtime17.jsx)(ark.h2, { ...mergedProps, ref: ref2 });
});
DialogTitle.displayName = "DialogTitle";

// node_modules/@ark-ui/react/dist/components/dialog/dialog-trigger.js
var import_jsx_runtime18 = __toESM(require_jsx_runtime(), 1);
var import_react44 = __toESM(require_react(), 1);
var DialogTrigger = (0, import_react44.forwardRef)((props21, ref2) => {
  const dialog = useDialogContext();
  const presence = usePresenceContext();
  const mergedProps = mergeProps(
    {
      ...dialog.getTriggerProps(),
      "aria-controls": presence.unmounted ? void 0 : dialog.getTriggerProps()["aria-controls"]
    },
    props21
  );
  return (0, import_jsx_runtime18.jsx)(ark.button, { ...mergedProps, ref: ref2 });
});
DialogTrigger.displayName = "DialogTrigger";

// node_modules/@ark-ui/react/dist/components/dialog/dialog.js
var dialog_exports = {};
__export(dialog_exports, {
  Backdrop: () => DialogBackdrop,
  CloseTrigger: () => DialogCloseTrigger,
  Content: () => DialogContent,
  Context: () => DialogContext,
  Description: () => DialogDescription,
  Positioner: () => DialogPositioner,
  Root: () => DialogRoot,
  RootProvider: () => DialogRootProvider,
  Title: () => DialogTitle,
  Trigger: () => DialogTrigger
});

// node_modules/@ark-ui/react/dist/components/editable/editable-area.js
var import_jsx_runtime19 = __toESM(require_jsx_runtime(), 1);
var import_react46 = __toESM(require_react(), 1);

// node_modules/@ark-ui/react/dist/components/editable/use-editable-context.js
var [EditableProvider, useEditableContext] = createContext({
  name: "EditableContext",
  hookName: "useEditableContext",
  providerName: "<EditableProvider />"
});

// node_modules/@ark-ui/react/dist/components/editable/editable-area.js
var EditableArea = (0, import_react46.forwardRef)((props21, ref2) => {
  const editable = useEditableContext();
  const mergedProps = mergeProps(editable.getAreaProps(), props21);
  return (0, import_jsx_runtime19.jsx)(ark.div, { ...mergedProps, ref: ref2 });
});
EditableArea.displayName = "EditableArea";

// node_modules/@ark-ui/react/dist/components/editable/editable-cancel-trigger.js
var import_jsx_runtime20 = __toESM(require_jsx_runtime(), 1);
var import_react48 = __toESM(require_react(), 1);
var EditableCancelTrigger = (0, import_react48.forwardRef)(
  (props21, ref2) => {
    const editable = useEditableContext();
    const mergedProps = mergeProps(editable.getCancelTriggerProps(), props21);
    return (0, import_jsx_runtime20.jsx)(ark.button, { ...mergedProps, ref: ref2 });
  }
);
EditableCancelTrigger.displayName = "EditableCancelTrigger";

// node_modules/@ark-ui/react/dist/components/editable/editable-context.js
var EditableContext = (props21) => props21.children(useEditableContext());

// node_modules/@ark-ui/react/dist/components/editable/editable-control.js
var import_jsx_runtime21 = __toESM(require_jsx_runtime(), 1);
var import_react50 = __toESM(require_react(), 1);
var EditableControl = (0, import_react50.forwardRef)((props21, ref2) => {
  const editable = useEditableContext();
  const mergedProps = mergeProps(editable.getControlProps(), props21);
  return (0, import_jsx_runtime21.jsx)(ark.div, { ...mergedProps, ref: ref2 });
});
EditableControl.displayName = "EditableControl";

// node_modules/@ark-ui/react/dist/components/editable/editable-edit-trigger.js
var import_jsx_runtime22 = __toESM(require_jsx_runtime(), 1);
var import_react52 = __toESM(require_react(), 1);
var EditableEditTrigger = (0, import_react52.forwardRef)(
  (props21, ref2) => {
    const editable = useEditableContext();
    const mergedProps = mergeProps(editable.getEditTriggerProps(), props21);
    return (0, import_jsx_runtime22.jsx)(ark.button, { ...mergedProps, ref: ref2 });
  }
);
EditableEditTrigger.displayName = "EditableEditTrigger";

// node_modules/@ark-ui/react/dist/components/editable/editable-input.js
var import_jsx_runtime23 = __toESM(require_jsx_runtime(), 1);
var import_react54 = __toESM(require_react(), 1);

// node_modules/@ark-ui/react/dist/components/field/use-field-context.js
var [FieldProvider, useFieldContext] = createContext({
  name: "FieldContext",
  hookName: "useFieldContext",
  providerName: "<FieldProvider />",
  strict: false
});

// node_modules/@ark-ui/react/dist/components/editable/editable-input.js
var EditableInput = (0, import_react54.forwardRef)((props21, ref2) => {
  const editable = useEditableContext();
  const mergedProps = mergeProps(editable.getInputProps(), props21);
  const field = useFieldContext();
  return (0, import_jsx_runtime23.jsx)(ark.input, { "aria-describedby": field == null ? void 0 : field.ariaDescribedby, ...mergedProps, ref: ref2 });
});
EditableInput.displayName = "EditableInput";

// node_modules/@ark-ui/react/dist/components/editable/editable-label.js
var import_jsx_runtime24 = __toESM(require_jsx_runtime(), 1);
var import_react56 = __toESM(require_react(), 1);
var EditableLabel = (0, import_react56.forwardRef)((props21, ref2) => {
  const editable = useEditableContext();
  const mergedProps = mergeProps(editable.getLabelProps(), props21);
  return (0, import_jsx_runtime24.jsx)(ark.label, { ...mergedProps, ref: ref2 });
});
EditableLabel.displayName = "EditableLabel";

// node_modules/@ark-ui/react/dist/components/editable/editable-preview.js
var import_jsx_runtime25 = __toESM(require_jsx_runtime(), 1);
var import_react58 = __toESM(require_react(), 1);
var EditablePreview = (0, import_react58.forwardRef)((props21, ref2) => {
  const editable = useEditableContext();
  const mergedProps = mergeProps(editable.getPreviewProps(), props21);
  return (0, import_jsx_runtime25.jsx)(ark.span, { ...mergedProps, ref: ref2 });
});
EditablePreview.displayName = "EditablePreview";

// node_modules/@ark-ui/react/dist/components/editable/editable-root.js
var import_jsx_runtime26 = __toESM(require_jsx_runtime(), 1);
var import_react62 = __toESM(require_react(), 1);

// node_modules/@zag-js/editable/dist/index.mjs
var anatomy6 = createAnatomy("editable").parts(
  "root",
  "area",
  "label",
  "preview",
  "input",
  "editTrigger",
  "submitTrigger",
  "cancelTrigger",
  "control"
);
var parts6 = anatomy6.build();
var dom6 = createScope({
  getRootId: (ctx) => {
    var _a8;
    return ((_a8 = ctx.ids) == null ? void 0 : _a8.root) ?? `editable:${ctx.id}`;
  },
  getAreaId: (ctx) => {
    var _a8;
    return ((_a8 = ctx.ids) == null ? void 0 : _a8.area) ?? `editable:${ctx.id}:area`;
  },
  getLabelId: (ctx) => {
    var _a8;
    return ((_a8 = ctx.ids) == null ? void 0 : _a8.label) ?? `editable:${ctx.id}:label`;
  },
  getPreviewId: (ctx) => {
    var _a8;
    return ((_a8 = ctx.ids) == null ? void 0 : _a8.preview) ?? `editable:${ctx.id}:preview`;
  },
  getInputId: (ctx) => {
    var _a8;
    return ((_a8 = ctx.ids) == null ? void 0 : _a8.input) ?? `editable:${ctx.id}:input`;
  },
  getControlId: (ctx) => {
    var _a8;
    return ((_a8 = ctx.ids) == null ? void 0 : _a8.control) ?? `editable:${ctx.id}:control`;
  },
  getSubmitTriggerId: (ctx) => {
    var _a8;
    return ((_a8 = ctx.ids) == null ? void 0 : _a8.submitTrigger) ?? `editable:${ctx.id}:submit`;
  },
  getCancelTriggerId: (ctx) => {
    var _a8;
    return ((_a8 = ctx.ids) == null ? void 0 : _a8.cancelTrigger) ?? `editable:${ctx.id}:cancel`;
  },
  getEditTriggerId: (ctx) => {
    var _a8;
    return ((_a8 = ctx.ids) == null ? void 0 : _a8.editTrigger) ?? `editable:${ctx.id}:edit`;
  },
  getInputEl: (ctx) => dom6.getById(ctx, dom6.getInputId(ctx)),
  getPreviewEl: (ctx) => dom6.getById(ctx, dom6.getPreviewId(ctx)),
  getSubmitTriggerEl: (ctx) => dom6.getById(ctx, dom6.getSubmitTriggerId(ctx)),
  getCancelTriggerEl: (ctx) => dom6.getById(ctx, dom6.getCancelTriggerId(ctx)),
  getEditTriggerEl: (ctx) => dom6.getById(ctx, dom6.getEditTriggerId(ctx))
});
function connect7(state2, send, normalize2) {
  const disabled = state2.context.disabled;
  const interactive = state2.context.isInteractive;
  const readOnly = state2.context.readOnly;
  const invalid = state2.context.invalid;
  const autoResize = state2.context.autoResize;
  const translations = state2.context.translations;
  const editing = state2.matches("edit");
  const placeholderProp = state2.context.placeholder;
  const placeholder = typeof placeholderProp === "string" ? { edit: placeholderProp, preview: placeholderProp } : placeholderProp;
  const value = state2.context.value;
  const empty2 = value.trim() === "";
  const valueText = empty2 ? (placeholder == null ? void 0 : placeholder.preview) ?? "" : value;
  return {
    editing,
    empty: empty2,
    value,
    valueText,
    setValue(value2) {
      send({ type: "VALUE.SET", value: value2, src: "setValue" });
    },
    clearValue() {
      send({ type: "VALUE.SET", value: "", src: "clearValue" });
    },
    edit() {
      if (!interactive) return;
      send("EDIT");
    },
    cancel() {
      if (!interactive) return;
      send("CANCEL");
    },
    submit() {
      if (!interactive) return;
      send("SUBMIT");
    },
    getRootProps() {
      return normalize2.element({
        ...parts6.root.attrs,
        id: dom6.getRootId(state2.context),
        dir: state2.context.dir
      });
    },
    getAreaProps() {
      return normalize2.element({
        ...parts6.area.attrs,
        id: dom6.getAreaId(state2.context),
        dir: state2.context.dir,
        style: autoResize ? { display: "inline-grid" } : void 0,
        "data-focus": dataAttr(editing),
        "data-disabled": dataAttr(disabled),
        "data-placeholder-shown": dataAttr(empty2)
      });
    },
    getLabelProps() {
      return normalize2.label({
        ...parts6.label.attrs,
        id: dom6.getLabelId(state2.context),
        dir: state2.context.dir,
        htmlFor: dom6.getInputId(state2.context),
        "data-focus": dataAttr(editing),
        "data-invalid": dataAttr(invalid),
        onClick() {
          if (editing) return;
          const previewEl = dom6.getPreviewEl(state2.context);
          previewEl == null ? void 0 : previewEl.focus({ preventScroll: true });
        }
      });
    },
    getInputProps() {
      return normalize2.input({
        ...parts6.input.attrs,
        dir: state2.context.dir,
        "aria-label": translations.input,
        name: state2.context.name,
        form: state2.context.form,
        id: dom6.getInputId(state2.context),
        hidden: autoResize ? void 0 : !editing,
        placeholder: placeholder == null ? void 0 : placeholder.edit,
        maxLength: state2.context.maxLength,
        required: state2.context.required,
        disabled,
        "data-disabled": dataAttr(disabled),
        readOnly,
        "data-readonly": dataAttr(readOnly),
        "aria-invalid": ariaAttr(invalid),
        "data-invalid": dataAttr(invalid),
        "data-autoresize": dataAttr(autoResize),
        defaultValue: value,
        size: autoResize ? 1 : void 0,
        onChange(event) {
          send({ type: "VALUE.SET", src: "input.change", value: event.currentTarget.value });
        },
        onKeyDown(event) {
          if (event.defaultPrevented) return;
          if (isComposingEvent(event)) return;
          const keyMap2 = {
            Escape() {
              send("CANCEL");
              event.preventDefault();
            },
            Enter(event2) {
              if (!state2.context.submitOnEnter) return;
              const { localName } = event2.currentTarget;
              if (localName === "textarea") {
                const submitMod = isApple() ? event2.metaKey : event2.ctrlKey;
                if (!submitMod) return;
                send({ type: "SUBMIT", src: "keydown.enter" });
                return;
              }
              if (localName === "input" && !event2.shiftKey && !event2.metaKey) {
                send({ type: "SUBMIT", src: "keydown.enter" });
                event2.preventDefault();
              }
            }
          };
          const exec2 = keyMap2[event.key];
          if (exec2) {
            exec2(event);
          }
        },
        style: autoResize ? {
          gridArea: "1 / 1 / auto / auto",
          visibility: !editing ? "hidden" : void 0
        } : void 0
      });
    },
    getPreviewProps() {
      return normalize2.element({
        id: dom6.getPreviewId(state2.context),
        ...parts6.preview.attrs,
        dir: state2.context.dir,
        "data-placeholder-shown": dataAttr(empty2),
        "aria-readonly": ariaAttr(readOnly),
        "data-readonly": dataAttr(disabled),
        "data-disabled": dataAttr(disabled),
        "aria-disabled": ariaAttr(disabled),
        "aria-invalid": ariaAttr(invalid),
        "data-invalid": dataAttr(invalid),
        "aria-label": translations.edit,
        "data-autoresize": dataAttr(autoResize),
        children: valueText,
        hidden: autoResize ? void 0 : editing,
        tabIndex: interactive ? 0 : void 0,
        onClick() {
          if (!interactive) return;
          if (state2.context.activationMode !== "click") return;
          send({ type: "EDIT", src: "click" });
        },
        onFocus() {
          if (!interactive) return;
          if (state2.context.activationMode !== "focus") return;
          send({ type: "EDIT", src: "focus" });
        },
        onDoubleClick(event) {
          if (event.defaultPrevented) return;
          if (!interactive) return;
          if (state2.context.activationMode !== "dblclick") return;
          send({ type: "EDIT", src: "dblclick" });
        },
        style: autoResize ? {
          whiteSpace: "pre",
          userSelect: "none",
          gridArea: "1 / 1 / auto / auto",
          visibility: editing ? "hidden" : void 0,
          // in event the preview overflow's the parent element
          overflow: "hidden",
          textOverflow: "ellipsis"
        } : void 0
      });
    },
    getEditTriggerProps() {
      return normalize2.button({
        ...parts6.editTrigger.attrs,
        id: dom6.getEditTriggerId(state2.context),
        dir: state2.context.dir,
        "aria-label": translations.edit,
        hidden: editing,
        type: "button",
        disabled,
        onClick(event) {
          if (event.defaultPrevented) return;
          if (!interactive) return;
          send({ type: "EDIT", src: "edit.click" });
        }
      });
    },
    getControlProps() {
      return normalize2.element({
        id: dom6.getControlId(state2.context),
        ...parts6.control.attrs,
        dir: state2.context.dir
      });
    },
    getSubmitTriggerProps() {
      return normalize2.button({
        ...parts6.submitTrigger.attrs,
        dir: state2.context.dir,
        id: dom6.getSubmitTriggerId(state2.context),
        "aria-label": translations.submit,
        hidden: !editing,
        disabled,
        type: "button",
        onClick(event) {
          if (event.defaultPrevented) return;
          if (!interactive) return;
          send({ type: "SUBMIT", src: "submit.click" });
        }
      });
    },
    getCancelTriggerProps() {
      return normalize2.button({
        ...parts6.cancelTrigger.attrs,
        dir: state2.context.dir,
        "aria-label": translations.cancel,
        id: dom6.getCancelTriggerId(state2.context),
        hidden: !editing,
        type: "button",
        disabled,
        onClick(event) {
          if (event.defaultPrevented) return;
          if (!interactive) return;
          send({ type: "CANCEL", src: "cancel.click" });
        }
      });
    }
  };
}
var submitOnEnter = (ctx) => ["both", "enter"].includes(ctx.submitMode);
var submitOnBlur = (ctx) => ["both", "blur"].includes(ctx.submitMode);
function machine7(userContext) {
  const ctx = compact2(userContext);
  return createMachine(
    {
      id: "editable",
      initial: ctx.edit ? "edit" : "preview",
      entry: ctx.edit ? ["focusInput"] : void 0,
      context: {
        activationMode: "focus",
        submitMode: "both",
        value: "",
        previousValue: "",
        selectOnFocus: true,
        disabled: false,
        readOnly: false,
        ...ctx,
        translations: {
          input: "editable input",
          edit: "edit",
          submit: "submit",
          cancel: "cancel",
          ...ctx.translations
        }
      },
      watch: {
        value: ["syncInputValue"],
        edit: ["toggleEditing"]
      },
      computed: {
        submitOnEnter,
        submitOnBlur,
        isInteractive: (ctx2) => !(ctx2.disabled || ctx2.readOnly)
      },
      on: {
        "VALUE.SET": {
          actions: "setValue"
        }
      },
      states: {
        preview: {
          // https://bugzilla.mozilla.org/show_bug.cgi?id=559561
          entry: ["blurInputIfNeeded"],
          on: {
            "CONTROLLED.EDIT": {
              target: "edit",
              actions: ["setPreviousValue", "focusInput"]
            },
            EDIT: [
              {
                guard: "isEditControlled",
                actions: ["invokeOnEdit"]
              },
              {
                target: "edit",
                actions: ["setPreviousValue", "focusInput", "invokeOnEdit"]
              }
            ]
          }
        },
        edit: {
          activities: ["trackInteractOutside"],
          on: {
            "CONTROLLED.PREVIEW": [
              {
                guard: "isSubmitEvent",
                target: "preview",
                actions: ["setPreviousValue", "restoreFocus", "invokeOnSubmit"]
              },
              {
                target: "preview",
                actions: ["revertValue", "restoreFocus", "invokeOnCancel"]
              }
            ],
            CANCEL: [
              {
                guard: "isEditControlled",
                actions: ["invokeOnPreview"]
              },
              {
                target: "preview",
                actions: ["revertValue", "restoreFocus", "invokeOnCancel", "invokeOnPreview"]
              }
            ],
            SUBMIT: [
              {
                guard: "isEditControlled",
                actions: ["invokeOnPreview"]
              },
              {
                target: "preview",
                actions: ["setPreviousValue", "restoreFocus", "invokeOnSubmit", "invokeOnPreview"]
              }
            ]
          }
        }
      }
    },
    {
      guards: {
        isEditControlled: (ctx2) => !!ctx2["edit.controlled"],
        isSubmitEvent: (_ctx, evt) => {
          var _a8;
          return ((_a8 = evt.previousEvent) == null ? void 0 : _a8.type) === "SUBMIT";
        }
      },
      activities: {
        trackInteractOutside(ctx2, _evt, { send }) {
          return trackInteractOutside(dom6.getInputEl(ctx2), {
            exclude(target) {
              const ignore = [dom6.getCancelTriggerEl(ctx2), dom6.getSubmitTriggerEl(ctx2)];
              return ignore.some((el) => contains(el, target));
            },
            onFocusOutside: ctx2.onFocusOutside,
            onPointerDownOutside: ctx2.onPointerDownOutside,
            onInteractOutside(event) {
              var _a8;
              (_a8 = ctx2.onInteractOutside) == null ? void 0 : _a8.call(ctx2, event);
              if (event.defaultPrevented) return;
              const { focusable } = event.detail;
              send({ type: submitOnBlur(ctx2) ? "SUBMIT" : "CANCEL", src: "interact-outside", focusable });
            }
          });
        }
      },
      actions: {
        restoreFocus(ctx2, evt) {
          if (evt.focusable) return;
          raf(() => {
            var _a8;
            const finalEl = ((_a8 = ctx2.finalFocusEl) == null ? void 0 : _a8.call(ctx2)) ?? dom6.getEditTriggerEl(ctx2);
            finalEl == null ? void 0 : finalEl.focus({ preventScroll: true });
          });
        },
        focusInput(ctx2) {
          raf(() => {
            const inputEl = dom6.getInputEl(ctx2);
            if (!inputEl) return;
            if (ctx2.selectOnFocus) {
              inputEl.select();
            } else {
              inputEl.focus({ preventScroll: true });
            }
          });
        },
        invokeOnCancel(ctx2) {
          var _a8;
          (_a8 = ctx2.onValueRevert) == null ? void 0 : _a8.call(ctx2, { value: ctx2.previousValue });
        },
        invokeOnSubmit(ctx2) {
          var _a8;
          (_a8 = ctx2.onValueCommit) == null ? void 0 : _a8.call(ctx2, { value: ctx2.value });
        },
        invokeOnEdit(ctx2) {
          var _a8;
          (_a8 = ctx2.onEditChange) == null ? void 0 : _a8.call(ctx2, { edit: true });
        },
        invokeOnPreview(ctx2) {
          var _a8;
          (_a8 = ctx2.onEditChange) == null ? void 0 : _a8.call(ctx2, { edit: false });
        },
        toggleEditing(ctx2, evt, { send }) {
          send({ type: ctx2.edit ? "CONTROLLED.EDIT" : "CONTROLLED.PREVIEW", previousEvent: evt });
        },
        syncInputValue(ctx2) {
          sync2.value(ctx2);
        },
        setValue(ctx2, evt) {
          const value = ctx2.maxLength != null ? evt.value.slice(0, ctx2.maxLength) : evt.value;
          set6.value(ctx2, value);
        },
        setPreviousValue(ctx2) {
          ctx2.previousValue = ctx2.value;
        },
        revertValue(ctx2) {
          set6.value(ctx2, ctx2.previousValue);
        },
        blurInputIfNeeded(ctx2) {
          var _a8;
          (_a8 = dom6.getInputEl(ctx2)) == null ? void 0 : _a8.blur();
        }
      }
    }
  );
}
var sync2 = {
  value: (ctx) => {
    const inputEl = dom6.getInputEl(ctx);
    dom6.setValue(inputEl, ctx.value);
  }
};
var invoke4 = {
  change(ctx) {
    var _a8;
    (_a8 = ctx.onValueChange) == null ? void 0 : _a8.call(ctx, { value: ctx.value });
    sync2.value(ctx);
  }
};
var set6 = {
  value(ctx, value) {
    if (isEqual(ctx.value, value)) return;
    ctx.value = value;
    invoke4.change(ctx);
  }
};
var props6 = createProps2()([
  "activationMode",
  "autoResize",
  "dir",
  "disabled",
  "finalFocusEl",
  "form",
  "getRootNode",
  "id",
  "ids",
  "invalid",
  "maxLength",
  "name",
  "onEditChange",
  "onFocusOutside",
  "onInteractOutside",
  "onPointerDownOutside",
  "onValueChange",
  "onValueCommit",
  "onValueRevert",
  "placeholder",
  "readOnly",
  "required",
  "selectOnFocus",
  "edit",
  "edit.controlled",
  "submitMode",
  "translations",
  "value"
]);
var splitProps7 = createSplitProps(props6);

// node_modules/@ark-ui/react/dist/components/editable/use-editable.js
var import_react60 = __toESM(require_react(), 1);
var useEditable = (props21 = {}) => {
  const { getRootNode } = useEnvironmentContext();
  const { dir } = useLocaleContext();
  const field = useFieldContext();
  const initialContext = {
    id: (0, import_react60.useId)(),
    ids: {
      label: field == null ? void 0 : field.ids.label,
      input: field == null ? void 0 : field.ids.control
    },
    dir,
    disabled: field == null ? void 0 : field.disabled,
    invalid: field == null ? void 0 : field.invalid,
    readOnly: field == null ? void 0 : field.readOnly,
    required: field == null ? void 0 : field.required,
    getRootNode,
    edit: props21.defaultEdit,
    value: props21.defaultValue,
    "edit.controlled": props21.edit !== void 0,
    ...props21
  };
  const context = {
    ...initialContext,
    value: props21.value,
    onValueChange: useEvent(props21.onValueChange, { sync: true }),
    onEditChange: useEvent(props21.onEditChange),
    onValueCommit: useEvent(props21.onValueCommit),
    onValueRevert: useEvent(props21.onValueRevert)
  };
  const [state2, send] = useMachine(machine7(initialContext), { context });
  return connect7(state2, send, normalizeProps);
};

// node_modules/@ark-ui/react/dist/components/editable/editable-root.js
var EditableRoot = (0, import_react62.forwardRef)((props21, ref2) => {
  const [useEditableProps, localProps] = createSplitProps2()(props21, [
    "activationMode",
    "autoResize",
    "defaultEdit",
    "defaultValue",
    "disabled",
    "edit",
    "finalFocusEl",
    "form",
    "id",
    "ids",
    "invalid",
    "maxLength",
    "name",
    "onEditChange",
    "onFocusOutside",
    "onInteractOutside",
    "onPointerDownOutside",
    "onValueChange",
    "onValueCommit",
    "onValueRevert",
    "placeholder",
    "readOnly",
    "required",
    "selectOnFocus",
    "submitMode",
    "translations",
    "value"
  ]);
  const editable = useEditable(useEditableProps);
  const mergedProps = mergeProps(editable.getRootProps(), localProps);
  return (0, import_jsx_runtime26.jsx)(EditableProvider, { value: editable, children: (0, import_jsx_runtime26.jsx)(ark.div, { ...mergedProps, ref: ref2 }) });
});
EditableRoot.displayName = "EditableRoot";

// node_modules/@ark-ui/react/dist/components/editable/editable-root-provider.js
var import_jsx_runtime27 = __toESM(require_jsx_runtime(), 1);
var import_react64 = __toESM(require_react(), 1);
var EditableRootProvider = (0, import_react64.forwardRef)(
  (props21, ref2) => {
    const [{ value: editable }, localProps] = createSplitProps2()(props21, [
      "value"
    ]);
    const mergedProps = mergeProps(editable.getRootProps(), localProps);
    return (0, import_jsx_runtime27.jsx)(EditableProvider, { value: editable, children: (0, import_jsx_runtime27.jsx)(ark.div, { ...mergedProps, ref: ref2 }) });
  }
);
EditableRootProvider.displayName = "EditableRootProvider";

// node_modules/@ark-ui/react/dist/components/editable/editable-submit-trigger.js
var import_jsx_runtime28 = __toESM(require_jsx_runtime(), 1);
var import_react66 = __toESM(require_react(), 1);
var EditableSubmitTrigger = (0, import_react66.forwardRef)(
  (props21, ref2) => {
    const editable = useEditableContext();
    const mergedProps = mergeProps(editable.getSubmitTriggerProps(), props21);
    return (0, import_jsx_runtime28.jsx)(ark.button, { ...mergedProps, ref: ref2 });
  }
);
EditableSubmitTrigger.displayName = "EditableSubmitTrigger";

// node_modules/@ark-ui/react/dist/components/editable/editable.js
var editable_exports = {};
__export(editable_exports, {
  Area: () => EditableArea,
  CancelTrigger: () => EditableCancelTrigger,
  Context: () => EditableContext,
  Control: () => EditableControl,
  EditTrigger: () => EditableEditTrigger,
  Input: () => EditableInput,
  Label: () => EditableLabel,
  Preview: () => EditablePreview,
  Root: () => EditableRoot,
  RootProvider: () => EditableRootProvider,
  SubmitTrigger: () => EditableSubmitTrigger
});

// node_modules/@ark-ui/react/dist/components/field/field-context.js
var FieldContext = (props21) => props21.children(useFieldContext());

// node_modules/@ark-ui/react/dist/components/field/field-error-text.js
var import_jsx_runtime29 = __toESM(require_jsx_runtime(), 1);
var import_react68 = __toESM(require_react(), 1);
var FieldErrorText = (0, import_react68.forwardRef)((props21, ref2) => {
  const field = useFieldContext();
  const mergedProps = mergeProps(field.getErrorTextProps(), props21);
  if (field == null ? void 0 : field.invalid) {
    return (0, import_jsx_runtime29.jsx)(ark.span, { ...mergedProps, ref: ref2 });
  }
  return null;
});
FieldErrorText.displayName = "FieldErrorText";

// node_modules/@ark-ui/react/dist/components/field/field-helper-text.js
var import_jsx_runtime30 = __toESM(require_jsx_runtime(), 1);
var import_react70 = __toESM(require_react(), 1);
var FieldHelperText = (0, import_react70.forwardRef)((props21, ref2) => {
  const field = useFieldContext();
  const mergedProps = mergeProps(field == null ? void 0 : field.getHelperTextProps(), props21);
  return (0, import_jsx_runtime30.jsx)(ark.span, { ...mergedProps, ref: ref2 });
});
FieldHelperText.displayName = "FieldHelperText";

// node_modules/@ark-ui/react/dist/components/field/field-input.js
var import_jsx_runtime31 = __toESM(require_jsx_runtime(), 1);
var import_react72 = __toESM(require_react(), 1);
var FieldInput = (0, import_react72.forwardRef)((props21, ref2) => {
  const field = useFieldContext();
  const mergedProps = mergeProps(field == null ? void 0 : field.getInputProps(), props21);
  return (0, import_jsx_runtime31.jsx)(ark.input, { ...mergedProps, ref: ref2 });
});
FieldInput.displayName = "FieldInput";

// node_modules/@ark-ui/react/dist/components/field/field-label.js
var import_jsx_runtime32 = __toESM(require_jsx_runtime(), 1);
var import_react74 = __toESM(require_react(), 1);
var FieldLabel = (0, import_react74.forwardRef)((props21, ref2) => {
  const field = useFieldContext();
  const mergedProps = mergeProps(field == null ? void 0 : field.getLabelProps(), props21);
  return (0, import_jsx_runtime32.jsx)(ark.label, { ...mergedProps, ref: ref2 });
});
FieldLabel.displayName = "FieldLabel";

// node_modules/@ark-ui/react/dist/components/field/field-required-indicator.js
var import_jsx_runtime33 = __toESM(require_jsx_runtime(), 1);
var import_react75 = __toESM(require_react(), 1);
var FieldRequiredIndicator = (0, import_react75.forwardRef)(
  ({ fallback: fallback4, ...props21 }, ref2) => {
    const field = useFieldContext();
    if (!field.required) {
      return fallback4;
    }
    const mergedProps = mergeProps(field.getRequiredIndicatorProps(), props21);
    return (0, import_jsx_runtime33.jsx)(ark.span, { ...mergedProps, ref: ref2, children: props21.children ?? "*" });
  }
);
FieldRequiredIndicator.displayName = "FieldRequiredIndicator";

// node_modules/@ark-ui/react/dist/components/field/field-root.js
var import_jsx_runtime34 = __toESM(require_jsx_runtime(), 1);
var import_react79 = __toESM(require_react(), 1);

// node_modules/@ark-ui/react/dist/components/field/use-field.js
var import_react77 = __toESM(require_react(), 1);

// node_modules/@ark-ui/react/dist/utils/use-safe-layout-effect.js
var import_react76 = __toESM(require_react(), 1);
var useSafeLayoutEffect2 = typeof window !== "undefined" ? import_react76.useLayoutEffect : import_react76.useEffect;

// node_modules/@ark-ui/react/dist/components/fieldset/use-fieldset-context.js
var [FieldsetProvider, useFieldsetContext] = createContext({
  name: "FieldsetContext",
  hookName: "useFieldsetContext",
  providerName: "<FieldsetProvider />",
  strict: false
});

// node_modules/@ark-ui/react/dist/components/field/field.anatomy.js
var fieldAnatomy = createAnatomy("field").parts(
  "root",
  "errorText",
  "helperText",
  "input",
  "label",
  "select",
  "textarea",
  "requiredIndicator"
);
var parts7 = fieldAnatomy.build();

// node_modules/@ark-ui/react/dist/components/field/use-field.js
var useField = (props21) => {
  const fieldset = useFieldsetContext();
  const {
    ids,
    disabled = Boolean(fieldset == null ? void 0 : fieldset.disabled),
    invalid = false,
    readOnly = false,
    required = false
  } = props21;
  const hasErrorText = (0, import_react77.useRef)(false);
  const hasHelperText = (0, import_react77.useRef)(false);
  const id = props21.id ?? (0, import_react77.useId)();
  const rootRef = (0, import_react77.useRef)(null);
  const rootId = (ids == null ? void 0 : ids.control) ?? `field::${id}`;
  const errorTextId = (ids == null ? void 0 : ids.errorText) ?? `field::${id}::error-text`;
  const helperTextId = (ids == null ? void 0 : ids.helperText) ?? `field::${id}::helper-text`;
  const labelId = (ids == null ? void 0 : ids.label) ?? `field::${id}::label`;
  useSafeLayoutEffect2(() => {
    const rootNode = rootRef.current;
    if (!rootNode) return;
    const win = getWindow(rootNode);
    const doc = win.document;
    const checkTextElements = () => {
      hasErrorText.current = !!doc.getElementById(errorTextId);
      hasHelperText.current = !!doc.getElementById(helperTextId);
    };
    checkTextElements();
    const observer = new win.MutationObserver(checkTextElements);
    observer.observe(rootNode, { childList: true, subtree: true });
    return () => observer.disconnect();
  }, [errorTextId, helperTextId]);
  const labelIds = (0, import_react77.useMemo)(() => {
    const ids2 = [];
    if (hasErrorText.current && invalid) ids2.push(errorTextId);
    if (hasHelperText.current) ids2.push(helperTextId);
    return ids2.join(" ") || void 0;
  }, [invalid, errorTextId, helperTextId]);
  const getRootProps = (0, import_react77.useMemo)(
    () => () => ({
      ...parts7.root.attrs,
      id: rootId,
      ref: rootRef,
      role: "group",
      "data-disabled": dataAttr(disabled),
      "data-invalid": dataAttr(invalid),
      "data-readonly": dataAttr(readOnly)
    }),
    [disabled, invalid, readOnly, rootId]
  );
  const getLabelProps = (0, import_react77.useMemo)(
    () => () => ({
      ...parts7.label.attrs,
      id: labelId,
      "data-disabled": dataAttr(disabled),
      "data-invalid": dataAttr(invalid),
      "data-readonly": dataAttr(readOnly),
      htmlFor: id
    }),
    [disabled, invalid, readOnly, id, labelId]
  );
  const getControlProps = (0, import_react77.useMemo)(
    () => () => ({
      "aria-describedby": labelIds,
      "aria-invalid": ariaAttr(invalid),
      "data-invalid": dataAttr(invalid),
      "data-required": dataAttr(required),
      "data-readonly": dataAttr(readOnly),
      id,
      required,
      disabled,
      readOnly
    }),
    [labelIds, invalid, required, readOnly, id, disabled]
  );
  const getInputProps = (0, import_react77.useMemo)(
    () => () => ({
      ...getControlProps(),
      ...parts7.input.attrs
    }),
    [getControlProps]
  );
  const getTextareaProps = (0, import_react77.useMemo)(
    () => () => ({
      ...getControlProps(),
      ...parts7.textarea.attrs
    }),
    [getControlProps]
  );
  const getSelectProps = (0, import_react77.useMemo)(
    () => () => ({
      ...getControlProps(),
      ...parts7.select.attrs
    }),
    [getControlProps]
  );
  const getHelperTextProps = (0, import_react77.useMemo)(
    () => () => ({
      id: helperTextId,
      ...parts7.helperText.attrs
    }),
    [helperTextId]
  );
  const getErrorTextProps = (0, import_react77.useMemo)(
    () => () => ({
      id: errorTextId,
      ...parts7.errorText.attrs,
      "aria-live": "polite"
    }),
    [errorTextId]
  );
  const getRequiredIndicatorProps = (0, import_react77.useMemo)(
    () => () => ({
      "aria-hidden": true,
      ...parts7.requiredIndicator.attrs
    }),
    []
  );
  return {
    ariaDescribedby: labelIds,
    ids: {
      root: rootId,
      control: id,
      label: labelId,
      errorText: errorTextId,
      helperText: helperTextId
    },
    refs: {
      rootRef
    },
    disabled,
    invalid,
    readOnly,
    required,
    getLabelProps,
    getRootProps,
    getInputProps,
    getTextareaProps,
    getSelectProps,
    getHelperTextProps,
    getErrorTextProps,
    getRequiredIndicatorProps
  };
};

// node_modules/@ark-ui/react/dist/components/field/field-root.js
var FieldRoot = (0, import_react79.forwardRef)((props21, ref2) => {
  const [useFieldProps, localProps] = createSplitProps2()(props21, [
    "id",
    "ids",
    "disabled",
    "invalid",
    "readOnly",
    "required"
  ]);
  const field = useField(useFieldProps);
  const mergedProps = mergeProps(field.getRootProps(), localProps);
  return (0, import_jsx_runtime34.jsx)(FieldProvider, { value: field, children: (0, import_jsx_runtime34.jsx)(ark.div, { ...mergedProps, ref: composeRefs(ref2, field.refs.rootRef) }) });
});
FieldRoot.displayName = "FieldRoot";

// node_modules/@ark-ui/react/dist/components/field/field-root-provider.js
var import_jsx_runtime35 = __toESM(require_jsx_runtime(), 1);
var import_react81 = __toESM(require_react(), 1);
var FieldRootProvider = (0, import_react81.forwardRef)(
  (props21, ref2) => {
    const [{ value: field }, localProps] = createSplitProps2()(props21, ["value"]);
    const mergedProps = mergeProps(field.getRootProps(), localProps);
    return (0, import_jsx_runtime35.jsx)(FieldProvider, { value: field, children: (0, import_jsx_runtime35.jsx)(ark.div, { ...mergedProps, ref: ref2 }) });
  }
);
FieldRootProvider.displayName = "FieldRootProvider";

// node_modules/@ark-ui/react/dist/components/field/field-select.js
var import_jsx_runtime36 = __toESM(require_jsx_runtime(), 1);
var import_react83 = __toESM(require_react(), 1);
var FieldSelect = (0, import_react83.forwardRef)((props21, ref2) => {
  const field = useFieldContext();
  const mergedProps = mergeProps(field == null ? void 0 : field.getSelectProps(), props21);
  return (0, import_jsx_runtime36.jsx)(ark.select, { ...mergedProps, ref: ref2 });
});
FieldSelect.displayName = "FieldSelect";

// node_modules/@ark-ui/react/dist/components/field/field-textarea.js
var import_jsx_runtime37 = __toESM(require_jsx_runtime(), 1);

// node_modules/@zag-js/auto-resize/dist/index.mjs
function getVisualStyles(node) {
  if (!node) return;
  const style = getComputedStyle(node);
  return "box-sizing:" + style.boxSizing + ";border-left:" + style.borderLeftWidth + " solid red;border-right:" + style.borderRightWidth + " solid red;font-family:" + style.fontFamily + ";font-feature-settings:" + style.fontFeatureSettings + ";font-kerning:" + style.fontKerning + ";font-size:" + style.fontSize + ";font-stretch:" + style.fontStretch + ";font-style:" + style.fontStyle + ";font-variant:" + style.fontVariant + ";font-variant-caps:" + style.fontVariantCaps + ";font-variant-ligatures:" + style.fontVariantLigatures + ";font-variant-numeric:" + style.fontVariantNumeric + ";font-weight:" + style.fontWeight + ";letter-spacing:" + style.letterSpacing + ";margin-left:" + style.marginLeft + ";margin-right:" + style.marginRight + ";padding-left:" + style.paddingLeft + ";padding-right:" + style.paddingRight + ";text-indent:" + style.textIndent + ";text-transform:" + style.textTransform;
}
function createGhostElement(doc) {
  var el = doc.createElement("div");
  el.id = "ghost";
  el.style.cssText = "display:inline-block;height:0;overflow:hidden;position:absolute;top:0;visibility:hidden;white-space:nowrap;";
  doc.body.appendChild(el);
  return el;
}
function autoResizeInput(input) {
  if (!input) return;
  const doc = getDocument(input);
  const win = getWindow(input);
  const ghost = createGhostElement(doc);
  const cssText = getVisualStyles(input);
  if (cssText) ghost.style.cssText += cssText;
  function resize() {
    win.requestAnimationFrame(() => {
      ghost.innerHTML = input.value;
      const rect = win.getComputedStyle(ghost);
      input == null ? void 0 : input.style.setProperty("width", rect.width);
    });
  }
  resize();
  input == null ? void 0 : input.addEventListener("input", resize);
  input == null ? void 0 : input.addEventListener("change", resize);
  return () => {
    doc.body.removeChild(ghost);
    input == null ? void 0 : input.removeEventListener("input", resize);
    input == null ? void 0 : input.removeEventListener("change", resize);
  };
}
var autoresizeTextarea = (el) => {
  var _a8;
  if (!el) return;
  const style = getComputedStyle(el);
  const win = getWindow(el);
  const doc = getDocument(el);
  const resize = () => {
    el.style.height = "auto";
    const borderTopWidth = parseInt(style.borderTopWidth, 10);
    const borderBottomWidth = parseInt(style.borderBottomWidth, 10);
    el.style.height = `${el.scrollHeight + borderTopWidth + borderBottomWidth}px`;
  };
  el.addEventListener("input", resize);
  const elementPrototype = Object.getPrototypeOf(el);
  const descriptor = Object.getOwnPropertyDescriptor(elementPrototype, "value");
  Object.defineProperty(el, "value", {
    ...descriptor,
    set() {
      var _a9;
      (_a9 = descriptor == null ? void 0 : descriptor.set) == null ? void 0 : _a9.apply(this, arguments);
      resize();
    }
  });
  const resizeObserver = new win.ResizeObserver(() => resize());
  resizeObserver.observe(el);
  const attrObserver = new win.MutationObserver(() => resize());
  attrObserver.observe(el, { attributes: true, attributeFilter: ["rows", "placeholder"] });
  (_a8 = doc.fonts) == null ? void 0 : _a8.addEventListener("loadingdone", resize);
  return () => {
    var _a9;
    el.removeEventListener("input", resize);
    (_a9 = doc.fonts) == null ? void 0 : _a9.removeEventListener("loadingdone", resize);
    resizeObserver.disconnect();
    attrObserver.disconnect();
  };
};

// node_modules/@ark-ui/react/dist/components/field/field-textarea.js
var import_react85 = __toESM(require_react(), 1);
var FieldTextarea = (0, import_react85.forwardRef)((props21, ref2) => {
  const { autoresize, ...textareaProps } = props21;
  const textareaRef = (0, import_react85.useRef)(null);
  const field = useFieldContext();
  const mergedProps = mergeProps(
    field == null ? void 0 : field.getTextareaProps(),
    { style: { resize: autoresize ? "none" : void 0 } },
    textareaProps
  );
  (0, import_react85.useEffect)(() => {
    if (!autoresize) return;
    return autoresizeTextarea(textareaRef.current);
  }, [autoresize]);
  return (0, import_jsx_runtime37.jsx)(ark.textarea, { ...mergedProps, ref: composeRefs(ref2, textareaRef) });
});
FieldTextarea.displayName = "FieldTextarea";

// node_modules/@ark-ui/react/dist/components/field/field.js
var field_exports = {};
__export(field_exports, {
  Context: () => FieldContext,
  ErrorText: () => FieldErrorText,
  HelperText: () => FieldHelperText,
  Input: () => FieldInput,
  Label: () => FieldLabel,
  RequiredIndicator: () => FieldRequiredIndicator,
  Root: () => FieldRoot,
  RootProvider: () => FieldRootProvider,
  Select: () => FieldSelect,
  Textarea: () => FieldTextarea
});

// node_modules/@ark-ui/react/dist/components/fieldset/fieldset-context.js
var FieldsetContext = (props21) => props21.children(useFieldsetContext());

// node_modules/@ark-ui/react/dist/components/fieldset/fieldset-error-text.js
var import_jsx_runtime38 = __toESM(require_jsx_runtime(), 1);
var import_react87 = __toESM(require_react(), 1);
var FieldsetErrorText = (0, import_react87.forwardRef)(
  (props21, ref2) => {
    const fieldset = useFieldsetContext();
    const mergedProps = mergeProps(fieldset.getErrorTextProps(), props21);
    return fieldset.invalid ? (0, import_jsx_runtime38.jsx)(ark.span, { ...mergedProps, ref: ref2 }) : null;
  }
);
FieldsetErrorText.displayName = "FieldsetErrorText";

// node_modules/@ark-ui/react/dist/components/fieldset/fieldset-helper-text.js
var import_jsx_runtime39 = __toESM(require_jsx_runtime(), 1);
var import_react89 = __toESM(require_react(), 1);
var FieldsetHelperText = (0, import_react89.forwardRef)(
  (props21, ref2) => {
    const fieldset = useFieldsetContext();
    const mergedProps = mergeProps(fieldset.getHelperTextProps(), props21);
    return (0, import_jsx_runtime39.jsx)(ark.span, { ...mergedProps, ref: ref2 });
  }
);
FieldsetHelperText.displayName = "FieldsetHelperText";

// node_modules/@ark-ui/react/dist/components/fieldset/fieldset-legend.js
var import_jsx_runtime40 = __toESM(require_jsx_runtime(), 1);
var import_react91 = __toESM(require_react(), 1);
var FieldsetLegend = (0, import_react91.forwardRef)((props21, ref2) => {
  const fieldset = useFieldsetContext();
  const mergedProps = mergeProps(fieldset.getLegendProps(), props21);
  return (0, import_jsx_runtime40.jsx)(ark.legend, { ...mergedProps, ref: ref2 });
});
FieldsetLegend.displayName = "FieldsetLegend";

// node_modules/@ark-ui/react/dist/components/fieldset/fieldset-root.js
var import_jsx_runtime41 = __toESM(require_jsx_runtime(), 1);
var import_react94 = __toESM(require_react(), 1);

// node_modules/@ark-ui/react/dist/components/fieldset/use-fieldset.js
var import_react92 = __toESM(require_react(), 1);

// node_modules/@ark-ui/react/dist/components/fieldset/fieldset.anatomy.js
var fieldsetAnatomy = createAnatomy("fieldset").parts(
  "root",
  "errorText",
  "helperText",
  "legend"
);
var parts8 = fieldsetAnatomy.build();

// node_modules/@ark-ui/react/dist/components/fieldset/use-fieldset.js
var useFieldset = (props21) => {
  const { disabled = false, invalid = false } = props21;
  const hasErrorText = (0, import_react92.useRef)(false);
  const hasHelperText = (0, import_react92.useRef)(false);
  const id = props21.id ?? (0, import_react92.useId)();
  const rootRef = (0, import_react92.useRef)(null);
  const errorTextId = `fieldset::${id}::error-text`;
  const helperTextId = `fieldset::${id}::helper-text`;
  useSafeLayoutEffect2(() => {
    const rootNode = rootRef.current;
    if (!rootNode) return;
    const win = getWindow(rootNode);
    const doc = win.document;
    const checkTextElements = () => {
      hasErrorText.current = !!doc.getElementById(errorTextId);
      hasHelperText.current = !!doc.getElementById(helperTextId);
    };
    checkTextElements();
    const observer = new win.MutationObserver(checkTextElements);
    observer.observe(rootNode, { childList: true, subtree: true });
    return () => observer.disconnect();
  }, [errorTextId, helperTextId]);
  const labelIds = (0, import_react92.useMemo)(() => {
    const ids = [];
    if (hasErrorText.current && invalid) ids.push(errorTextId);
    if (hasHelperText.current) ids.push(helperTextId);
    return ids.join(" ") || void 0;
  }, [invalid, errorTextId, helperTextId]);
  const getRootProps = (0, import_react92.useMemo)(
    () => () => ({
      ...parts8.root.attrs,
      ref: rootRef,
      disabled,
      "data-disabled": disabled ? "true" : void 0,
      "data-invalid": invalid ? "true" : void 0,
      "aria-describedby": labelIds
    }),
    [disabled, invalid, labelIds]
  );
  const getLegendProps = (0, import_react92.useMemo)(
    () => () => ({
      ...parts8.legend.attrs,
      "data-disabled": disabled ? "true" : void 0,
      "data-invalid": invalid ? "true" : void 0
    }),
    [disabled, invalid]
  );
  const getHelperTextProps = (0, import_react92.useMemo)(
    () => () => ({
      id: helperTextId,
      ...parts8.helperText.attrs
    }),
    [helperTextId]
  );
  const getErrorTextProps = (0, import_react92.useMemo)(
    () => () => ({
      id: errorTextId,
      ...parts8.errorText.attrs,
      "aria-live": "polite"
    }),
    [errorTextId]
  );
  return {
    refs: {
      rootRef
    },
    disabled,
    invalid,
    getRootProps,
    getLegendProps,
    getHelperTextProps,
    getErrorTextProps
  };
};

// node_modules/@ark-ui/react/dist/components/fieldset/fieldset-root.js
var FieldsetRoot = (0, import_react94.forwardRef)((props21, ref2) => {
  const [useFieldsetProps, localProps] = createSplitProps2()(props21, [
    "id",
    "disabled",
    "invalid"
  ]);
  const fieldset = useFieldset(useFieldsetProps);
  const mergedProps = mergeProps(fieldset.getRootProps(), localProps);
  return (0, import_jsx_runtime41.jsx)(FieldsetProvider, { value: fieldset, children: (0, import_jsx_runtime41.jsx)(ark.fieldset, { ...mergedProps, ref: composeRefs(ref2, fieldset.refs.rootRef) }) });
});
FieldsetRoot.displayName = "FieldsetRoot";

// node_modules/@ark-ui/react/dist/components/fieldset/fieldset-root-provider.js
var import_jsx_runtime42 = __toESM(require_jsx_runtime(), 1);
var import_react96 = __toESM(require_react(), 1);
var FieldsetRootProvider = (0, import_react96.forwardRef)(
  (props21, ref2) => {
    const [{ value: fieldset }, localProps] = createSplitProps2()(props21, [
      "value"
    ]);
    const mergedProps = mergeProps(fieldset.getRootProps(), localProps);
    return (0, import_jsx_runtime42.jsx)(FieldsetProvider, { value: fieldset, children: (0, import_jsx_runtime42.jsx)(ark.fieldset, { ...mergedProps, ref: ref2 }) });
  }
);
FieldsetRootProvider.displayName = "FieldsetRootProvider";

// node_modules/@ark-ui/react/dist/components/fieldset/fieldset.js
var fieldset_exports = {};
__export(fieldset_exports, {
  Context: () => FieldsetContext,
  ErrorText: () => FieldsetErrorText,
  HelperText: () => FieldsetHelperText,
  Legend: () => FieldsetLegend,
  Root: () => FieldsetRoot,
  RootProvider: () => FieldsetRootProvider
});

// node_modules/@ark-ui/react/dist/components/file-upload/file-upload-clear-trigger.js
var import_jsx_runtime43 = __toESM(require_jsx_runtime(), 1);
var import_react98 = __toESM(require_react(), 1);

// node_modules/@ark-ui/react/dist/components/file-upload/use-file-upload-context.js
var [FileUploadProvider, useFileUploadContext] = createContext({
  name: "FileUploadContext",
  hookName: "useFileUploadContext",
  providerName: "<FileUploadProvider />"
});

// node_modules/@ark-ui/react/dist/components/file-upload/file-upload-clear-trigger.js
var FileUploadClearTrigger = (0, import_react98.forwardRef)(
  (props21, ref2) => {
    const fileUpload = useFileUploadContext();
    const mergedProps = mergeProps(fileUpload.getClearTriggerProps(), props21);
    return (0, import_jsx_runtime43.jsx)(ark.button, { ...mergedProps, ref: ref2 });
  }
);
FileUploadClearTrigger.displayName = "FileUploadClearTrigger";

// node_modules/@ark-ui/react/dist/components/file-upload/file-upload-context.js
var FileUploadContext = (props21) => props21.children(useFileUploadContext());

// node_modules/@ark-ui/react/dist/components/file-upload/file-upload-dropzone.js
var import_jsx_runtime44 = __toESM(require_jsx_runtime(), 1);
var import_react100 = __toESM(require_react(), 1);
var FileUploadDropzone = (0, import_react100.forwardRef)((props21, ref2) => {
  const [dropzoneProps, localProps] = createSplitProps2()(props21, [
    "disableClick"
  ]);
  const fileUpload = useFileUploadContext();
  const mergedProps = mergeProps(
    fileUpload.getDropzoneProps(dropzoneProps),
    localProps
  );
  return (0, import_jsx_runtime44.jsx)(ark.div, { ...mergedProps, ref: ref2 });
});
FileUploadDropzone.displayName = "FileUploadDropzone";

// node_modules/@ark-ui/react/dist/components/file-upload/file-upload-hidden-input.js
var import_jsx_runtime45 = __toESM(require_jsx_runtime(), 1);
var import_react102 = __toESM(require_react(), 1);
var FileUploadHiddenInput = (0, import_react102.forwardRef)(
  (props21, ref2) => {
    const fileUpload = useFileUploadContext();
    const mergedProps = mergeProps(fileUpload.getHiddenInputProps(), props21);
    const field = useFieldContext();
    return (0, import_jsx_runtime45.jsx)(ark.input, { "aria-describedby": field == null ? void 0 : field.ariaDescribedby, ...mergedProps, ref: ref2 });
  }
);
FileUploadHiddenInput.displayName = "FileUploadHiddenInput";

// node_modules/@ark-ui/react/dist/components/file-upload/file-upload-item.js
var import_jsx_runtime46 = __toESM(require_jsx_runtime(), 1);
var import_react104 = __toESM(require_react(), 1);

// node_modules/@ark-ui/react/dist/components/file-upload/use-file-upload-item-props-context.js
var [FileUploadItemPropsProvider, useFileUploadItemPropsContext] = createContext({
  name: "FileUploadItemPropsContext",
  hookName: "useFileUploadItemPropsContext",
  providerName: "<FileUploadItemPropsProvider />"
});

// node_modules/@ark-ui/react/dist/components/file-upload/file-upload-item.js
var FileUploadItem = (0, import_react104.forwardRef)((props21, ref2) => {
  const [itemProps7, localProps] = createSplitProps2()(props21, ["file"]);
  const fileUpload = useFileUploadContext();
  const mergedProps = mergeProps(fileUpload.getItemProps(itemProps7), localProps);
  return (0, import_jsx_runtime46.jsx)(FileUploadItemPropsProvider, { value: itemProps7, children: (0, import_jsx_runtime46.jsx)(ark.li, { ...mergedProps, ref: ref2 }) });
});
FileUploadItem.displayName = "FileUploadItem";

// node_modules/@ark-ui/react/dist/components/file-upload/file-upload-item-delete-trigger.js
var import_jsx_runtime47 = __toESM(require_jsx_runtime(), 1);
var import_react106 = __toESM(require_react(), 1);
var FileUploadItemDeleteTrigger = (0, import_react106.forwardRef)((props21, ref2) => {
  const fileUpload = useFileUploadContext();
  const itemProps7 = useFileUploadItemPropsContext();
  const mergedProps = mergeProps(fileUpload.getItemDeleteTriggerProps(itemProps7), props21);
  return (0, import_jsx_runtime47.jsx)(ark.button, { ...mergedProps, ref: ref2 });
});
FileUploadItemDeleteTrigger.displayName = "FileUploadItemDeleteTrigger";

// node_modules/@ark-ui/react/dist/components/file-upload/file-upload-item-group.js
var import_jsx_runtime48 = __toESM(require_jsx_runtime(), 1);
var import_react108 = __toESM(require_react(), 1);
var FileUploadItemGroup = (0, import_react108.forwardRef)(
  (props21, ref2) => {
    const fileUpload = useFileUploadContext();
    const mergedProps = mergeProps(fileUpload.getItemGroupProps(), props21);
    return (0, import_jsx_runtime48.jsx)(ark.ul, { ...mergedProps, ref: ref2 });
  }
);
FileUploadItemGroup.displayName = "FileUploadItemGroup";

// node_modules/@ark-ui/react/dist/components/file-upload/file-upload-item-name.js
var import_jsx_runtime49 = __toESM(require_jsx_runtime(), 1);
var import_react110 = __toESM(require_react(), 1);
var FileUploadItemName = (0, import_react110.forwardRef)(
  (props21, ref2) => {
    const { children, ...rest } = props21;
    const fileUpload = useFileUploadContext();
    const itemProps7 = useFileUploadItemPropsContext();
    const mergedProps = mergeProps(fileUpload.getItemNameProps(itemProps7), rest);
    return (0, import_jsx_runtime49.jsx)(ark.div, { ...mergedProps, ref: ref2, children: children || itemProps7.file.name });
  }
);
FileUploadItemName.displayName = "FileUploadItemName";

// node_modules/@ark-ui/react/dist/components/file-upload/file-upload-item-preview.js
var import_jsx_runtime50 = __toESM(require_jsx_runtime(), 1);
var import_react112 = __toESM(require_react(), 1);
var FileUploadItemPreview = (0, import_react112.forwardRef)(
  (props21, ref2) => {
    const fileUpload = useFileUploadContext();
    const itemProps7 = useFileUploadItemPropsContext();
    const mergedProps = mergeProps(fileUpload.getItemPreviewProps(itemProps7), props21);
    if (!itemProps7.file.type.match(props21.type ?? ".*")) return null;
    return (0, import_jsx_runtime50.jsx)(ark.div, { ...mergedProps, ref: ref2 });
  }
);
FileUploadItemPreview.displayName = "FileUploadItemPreview";

// node_modules/@ark-ui/react/dist/components/file-upload/file-upload-item-preview-image.js
var import_jsx_runtime51 = __toESM(require_jsx_runtime(), 1);
var import_react114 = __toESM(require_react(), 1);
var FileUploadItemPreviewImage = (0, import_react114.forwardRef)((props21, ref2) => {
  const [url, setUrl] = (0, import_react114.useState)("");
  const fileUpload = useFileUploadContext();
  const itemProps7 = useFileUploadItemPropsContext();
  const mergedProps = mergeProps(
    fileUpload.getItemPreviewImageProps({ ...itemProps7, url }),
    props21
  );
  (0, import_react114.useEffect)(() => {
    return fileUpload.createFileUrl(itemProps7.file, (url2) => setUrl(url2));
  }, [itemProps7, fileUpload]);
  if (!url) return null;
  return (0, import_jsx_runtime51.jsx)(ark.img, { ...mergedProps, ref: ref2 });
});
FileUploadItemPreviewImage.displayName = "FileUploadItemPreviewImage";

// node_modules/@ark-ui/react/dist/components/file-upload/file-upload-item-size-text.js
var import_jsx_runtime52 = __toESM(require_jsx_runtime(), 1);
var import_react116 = __toESM(require_react(), 1);
var FileUploadItemSizeText = (0, import_react116.forwardRef)(
  (props21, ref2) => {
    const { children, ...rest } = props21;
    const fileUpload = useFileUploadContext();
    const itemProps7 = useFileUploadItemPropsContext();
    const mergedProps = mergeProps(fileUpload.getItemSizeTextProps(itemProps7), rest);
    return (0, import_jsx_runtime52.jsx)(ark.div, { ...mergedProps, ref: ref2, children: children || fileUpload.getFileSize(itemProps7.file) });
  }
);
FileUploadItemSizeText.displayName = "FileUploadItemSizeText";

// node_modules/@ark-ui/react/dist/components/file-upload/file-upload-label.js
var import_jsx_runtime53 = __toESM(require_jsx_runtime(), 1);
var import_react118 = __toESM(require_react(), 1);
var FileUploadLabel = (0, import_react118.forwardRef)((props21, ref2) => {
  const fileUpload = useFileUploadContext();
  const mergedProps = mergeProps(fileUpload.getLabelProps(), props21);
  return (0, import_jsx_runtime53.jsx)(ark.label, { ...mergedProps, ref: ref2 });
});
FileUploadLabel.displayName = "FileUploadLabel";

// node_modules/@ark-ui/react/dist/components/file-upload/file-upload-root.js
var import_jsx_runtime54 = __toESM(require_jsx_runtime(), 1);
var import_react122 = __toESM(require_react(), 1);

// node_modules/@zag-js/i18n-utils/dist/index.mjs
function i18nCache(Ins) {
  const formatterCache = /* @__PURE__ */ new Map();
  return function create(locale, options) {
    const cacheKey = locale + (options ? Object.entries(options).sort((a, b) => a[0] < b[0] ? -1 : 1).join() : "");
    if (formatterCache.has(cacheKey)) {
      return formatterCache.get(cacheKey);
    }
    let formatter = new Ins(locale, options);
    formatterCache.set(cacheKey, formatter);
    return formatter;
  };
}
var collatorCache = i18nCache(Intl.Collator);
var getNumberFormatter = i18nCache(Intl.NumberFormat);
function formatNumber(v, locale, options = {}) {
  const formatter = getNumberFormatter(locale, options);
  return formatter.format(v);
}
var bitPrefixes = ["", "kilo", "mega", "giga", "tera"];
var bytePrefixes = ["", "kilo", "mega", "giga", "tera", "peta"];
var formatBytes = (bytes, locale = "en-US", options = {}) => {
  if (isNaN(bytes)) return "";
  if (bytes === 0) return "0 B";
  const { unit = "byte", unitDisplay = "short" } = options;
  const prefix = unit === "bit" ? bitPrefixes : bytePrefixes;
  const index = Math.max(0, Math.min(Math.floor(Math.log10(bytes) / 3), prefix.length - 1));
  const _unit = prefix[index] + unit;
  const _unitDisplay = unitDisplay || "short";
  const v = parseFloat((bytes / Math.pow(1e3, index)).toPrecision(3));
  return formatNumber(v, locale, {
    style: "unit",
    unit: _unit,
    unitDisplay: _unitDisplay
  });
};
var getListFormatter = i18nCache(Intl.ListFormat);
var getRelativeTimeFormatter = i18nCache(Intl.RelativeTimeFormat);
var MINUTE_TO_MS = 1e3 * 60;
var HOUR_TO_MS = 1e3 * 60 * 60;
var DAY_TO_MS = 1e3 * 60 * 60 * 24;
var WEEK_TO_MS = 1e3 * 60 * 60 * 24 * 7;
var MONTH_TO_MS = 1e3 * 60 * 60 * 24 * 30;
var YEAR_TO_MS = 1e3 * 60 * 60 * 24 * 365;
var RTL_SCRIPTS = /* @__PURE__ */ new Set([
  "Avst",
  "Arab",
  "Armi",
  "Syrc",
  "Samr",
  "Mand",
  "Thaa",
  "Mend",
  "Nkoo",
  "Adlm",
  "Rohg",
  "Hebr"
]);
var RTL_LANGS = /* @__PURE__ */ new Set([
  "ae",
  "ar",
  "arc",
  "bcc",
  "bqi",
  "ckb",
  "dv",
  "fa",
  "glk",
  "he",
  "ku",
  "mzn",
  "nqo",
  "pnb",
  "ps",
  "sd",
  "ug",
  "ur",
  "yi"
]);
function isRTL2(locale) {
  if (Intl.Locale) {
    const script = new Intl.Locale(locale).maximize().script ?? "";
    return RTL_SCRIPTS.has(script);
  }
  const lang = locale.split("-")[0];
  return RTL_LANGS.has(lang);
}

// node_modules/@zag-js/file-utils/dist/index.mjs
function isMIMEType(v) {
  return v === "audio/*" || v === "video/*" || v === "image/*" || v === "text/*" || /\w+\/[-+.\w]+/g.test(v);
}
function isExt(v) {
  return /^.*\.[\w]+$/.test(v);
}
var isValidMIME = (v) => isMIMEType(v) || isExt(v);
function getAcceptAttrString(accept) {
  if (!accept) return;
  if (typeof accept === "string") {
    return accept;
  }
  if (Array.isArray(accept)) {
    return accept.filter(isValidMIME).join(",");
  }
  return Object.entries(accept).reduce((a, [mimeType, ext]) => [...a, mimeType, ...ext], []).filter(isValidMIME).join(",");
}
var isFileEqual = (file1, file2) => {
  return file1.name === file2.name && file1.size === file2.size && file1.type === file2.type;
};
var isDefined = (v) => v !== void 0 && v !== null;
function isValidFileSize(file, minSize, maxSize) {
  if (isDefined(file.size)) {
    if (isDefined(minSize) && isDefined(maxSize)) {
      if (file.size > maxSize) return [false, "FILE_TOO_LARGE"];
      if (file.size < minSize) return [false, "FILE_TOO_SMALL"];
    } else if (isDefined(minSize) && file.size < minSize) {
      return [false, "FILE_TOO_SMALL"];
    } else if (isDefined(maxSize) && file.size > maxSize) {
      return [false, "FILE_TOO_LARGE"];
    }
  }
  return [true, null];
}
function isFileAccepted(file, accept) {
  if (file && accept) {
    const types = Array.isArray(accept) ? accept : accept.split(",");
    const fileName = file.name || "";
    const mimeType = (file.type || "").toLowerCase();
    const baseMimeType = mimeType.replace(/\/.*$/, "");
    return types.some((type) => {
      const validType = type.trim().toLowerCase();
      if (validType.charAt(0) === ".") {
        return fileName.toLowerCase().endsWith(validType);
      }
      if (validType.endsWith("/*")) {
        return baseMimeType === validType.replace(/\/.*$/, "");
      }
      return mimeType === validType;
    });
  }
  return true;
}
function isValidFileType(file, accept) {
  const isAcceptable = file.type === "application/x-moz-file" || isFileAccepted(file, accept);
  return [isAcceptable, isAcceptable ? null : "FILE_INVALID_TYPE"];
}

// node_modules/@zag-js/file-upload/dist/index.mjs
var anatomy7 = createAnatomy("file-upload").parts(
  "root",
  "dropzone",
  "item",
  "itemDeleteTrigger",
  "itemGroup",
  "itemName",
  "itemPreview",
  "itemPreviewImage",
  "itemSizeText",
  "label",
  "trigger",
  "clearTrigger"
);
var parts9 = anatomy7.build();
var dom7 = createScope({
  getRootId: (ctx) => {
    var _a8;
    return ((_a8 = ctx.ids) == null ? void 0 : _a8.root) ?? `file:${ctx.id}`;
  },
  getDropzoneId: (ctx) => {
    var _a8;
    return ((_a8 = ctx.ids) == null ? void 0 : _a8.dropzone) ?? `file:${ctx.id}:dropzone`;
  },
  getHiddenInputId: (ctx) => {
    var _a8;
    return ((_a8 = ctx.ids) == null ? void 0 : _a8.hiddenInput) ?? `file:${ctx.id}:input`;
  },
  getTriggerId: (ctx) => {
    var _a8;
    return ((_a8 = ctx.ids) == null ? void 0 : _a8.trigger) ?? `file:${ctx.id}:trigger`;
  },
  getLabelId: (ctx) => {
    var _a8;
    return ((_a8 = ctx.ids) == null ? void 0 : _a8.label) ?? `file:${ctx.id}:label`;
  },
  getItemId: (ctx, id) => {
    var _a8, _b7;
    return ((_b7 = (_a8 = ctx.ids) == null ? void 0 : _a8.item) == null ? void 0 : _b7.call(_a8, id)) ?? `file:${ctx.id}:item:${id}`;
  },
  getItemNameId: (ctx, id) => {
    var _a8, _b7;
    return ((_b7 = (_a8 = ctx.ids) == null ? void 0 : _a8.itemName) == null ? void 0 : _b7.call(_a8, id)) ?? `file:${ctx.id}:item-name:${id}`;
  },
  getItemSizeTextId: (ctx, id) => {
    var _a8, _b7;
    return ((_b7 = (_a8 = ctx.ids) == null ? void 0 : _a8.itemSizeText) == null ? void 0 : _b7.call(_a8, id)) ?? `file:${ctx.id}:item-size:${id}`;
  },
  getItemPreviewId: (ctx, id) => {
    var _a8, _b7;
    return ((_b7 = (_a8 = ctx.ids) == null ? void 0 : _a8.itemPreview) == null ? void 0 : _b7.call(_a8, id)) ?? `file:${ctx.id}:item-preview:${id}`;
  },
  getRootEl: (ctx) => dom7.getById(ctx, dom7.getRootId(ctx)),
  getHiddenInputEl: (ctx) => dom7.getById(ctx, dom7.getHiddenInputId(ctx)),
  getDropzoneEl: (ctx) => dom7.getById(ctx, dom7.getDropzoneId(ctx))
});
function isEventWithFiles(event) {
  const target = getEventTarget(event);
  if (!event.dataTransfer) return !!target && "files" in target;
  return event.dataTransfer.types.some((type) => {
    return type === "Files" || type === "application/x-moz-file";
  });
}
function isFilesWithinRange(ctx, incomingCount) {
  if (!ctx.multiple && incomingCount > 1) return false;
  if (!ctx.multiple && incomingCount + ctx.acceptedFiles.length === 2) return true;
  if (incomingCount + ctx.acceptedFiles.length > ctx.maxFiles) return false;
  return true;
}
function getFilesFromEvent(ctx, files) {
  const acceptedFiles = [];
  const rejectedFiles = [];
  files.forEach((file) => {
    var _a8;
    const [accepted, acceptError] = isValidFileType(file, ctx.acceptAttr);
    const [sizeMatch, sizeError] = isValidFileSize(file, ctx.minFileSize, ctx.maxFileSize);
    const validateErrors = (_a8 = ctx.validate) == null ? void 0 : _a8.call(ctx, file, {
      acceptedFiles: ctx.acceptedFiles,
      rejectedFiles: ctx.rejectedFiles
    });
    const valid = validateErrors ? validateErrors.length === 0 : true;
    if (accepted && sizeMatch && valid) {
      acceptedFiles.push(file);
    } else {
      const errors = [acceptError, sizeError];
      if (!valid) errors.push(...validateErrors ?? []);
      rejectedFiles.push({ file, errors: errors.filter(Boolean) });
    }
  });
  if (!isFilesWithinRange(ctx, acceptedFiles.length)) {
    acceptedFiles.forEach((file) => {
      rejectedFiles.push({ file, errors: ["TOO_MANY_FILES"] });
    });
    acceptedFiles.splice(0);
  }
  return {
    acceptedFiles,
    rejectedFiles
  };
}
function connect8(state2, send, normalize2) {
  const disabled = state2.context.disabled;
  const allowDrop = state2.context.allowDrop;
  const translations = state2.context.translations;
  const dragging = state2.matches("dragging");
  const focused = state2.matches("focused") && !disabled;
  return {
    dragging,
    focused,
    disabled: !!disabled,
    openFilePicker() {
      if (disabled) return;
      send("OPEN");
    },
    deleteFile(file) {
      send({ type: "FILE.DELETE", file });
    },
    acceptedFiles: state2.context.acceptedFiles,
    rejectedFiles: state2.context.rejectedFiles,
    setFiles(files) {
      const count = files.length;
      send({ type: "FILES.SET", files, count });
    },
    clearRejectedFiles() {
      send({ type: "REJECTED_FILES.CLEAR" });
    },
    clearFiles() {
      send({ type: "FILES.CLEAR" });
    },
    getFileSize(file) {
      return formatBytes(file.size, state2.context.locale);
    },
    createFileUrl(file, cb) {
      const win = dom7.getWin(state2.context);
      const url = win.URL.createObjectURL(file);
      cb(url);
      return () => win.URL.revokeObjectURL(url);
    },
    setClipboardFiles(dt) {
      if (disabled) return false;
      const items = Array.from((dt == null ? void 0 : dt.items) ?? []);
      const files = items.reduce((acc, item) => {
        if (item.kind !== "file") return acc;
        const file = item.getAsFile();
        if (!file) return acc;
        return [...acc, file];
      }, []);
      if (!files.length) return false;
      send({ type: "FILES.SET", files });
      return true;
    },
    getRootProps() {
      return normalize2.element({
        ...parts9.root.attrs,
        dir: state2.context.dir,
        id: dom7.getRootId(state2.context),
        "data-disabled": dataAttr(disabled),
        "data-dragging": dataAttr(dragging)
      });
    },
    getDropzoneProps(props22 = {}) {
      return normalize2.element({
        ...parts9.dropzone.attrs,
        dir: state2.context.dir,
        id: dom7.getDropzoneId(state2.context),
        tabIndex: disabled || props22.disableClick ? void 0 : 0,
        role: props22.disableClick ? "application" : "button",
        "aria-label": translations.dropzone,
        "aria-disabled": disabled,
        "data-invalid": dataAttr(state2.context.invalid),
        "data-disabled": dataAttr(disabled),
        "data-dragging": dataAttr(dragging),
        onKeyDown(event) {
          if (disabled) return;
          if (event.defaultPrevented) return;
          if (!isSelfTarget(event)) return;
          if (props22.disableClick) return;
          if (event.key !== "Enter" && event.key !== " ") return;
          send({ type: "DROPZONE.CLICK", src: "keydown" });
        },
        onClick(event) {
          if (disabled) return;
          if (event.defaultPrevented) return;
          if (props22.disableClick) return;
          if (!isSelfTarget(event)) return;
          if (event.currentTarget.localName === "label") {
            event.preventDefault();
          }
          send("DROPZONE.CLICK");
        },
        onDragOver(event) {
          if (disabled) return;
          if (!allowDrop) return;
          event.preventDefault();
          event.stopPropagation();
          try {
            event.dataTransfer.dropEffect = "copy";
          } catch {
          }
          const hasFiles = isEventWithFiles(event);
          if (!hasFiles) return;
          const count = event.dataTransfer.items.length;
          send({ type: "DROPZONE.DRAG_OVER", count });
        },
        onDragLeave(event) {
          if (disabled) return;
          if (!allowDrop) return;
          if (contains(event.currentTarget, event.relatedTarget)) return;
          send({ type: "DROPZONE.DRAG_LEAVE" });
        },
        onDrop(event) {
          if (disabled) return;
          if (allowDrop) {
            event.preventDefault();
            event.stopPropagation();
          }
          const hasFiles = isEventWithFiles(event);
          if (disabled || !hasFiles) return;
          send({ type: "DROPZONE.DROP", files: Array.from(event.dataTransfer.files) });
        },
        onFocus() {
          if (disabled) return;
          send("DROPZONE.FOCUS");
        },
        onBlur() {
          if (disabled) return;
          send("DROPZONE.BLUR");
        }
      });
    },
    getTriggerProps() {
      return normalize2.button({
        ...parts9.trigger.attrs,
        dir: state2.context.dir,
        id: dom7.getTriggerId(state2.context),
        disabled,
        "data-disabled": dataAttr(disabled),
        "data-invalid": dataAttr(state2.context.invalid),
        type: "button",
        onClick(event) {
          if (disabled) return;
          if (contains(dom7.getDropzoneEl(state2.context), event.currentTarget)) {
            event.stopPropagation();
          }
          send("OPEN");
        }
      });
    },
    getHiddenInputProps() {
      return normalize2.input({
        id: dom7.getHiddenInputId(state2.context),
        tabIndex: -1,
        disabled,
        type: "file",
        required: state2.context.required,
        capture: state2.context.capture,
        name: state2.context.name,
        accept: state2.context.acceptAttr,
        webkitdirectory: state2.context.directory ? "" : void 0,
        multiple: state2.context.multiple || state2.context.maxFiles > 1,
        onClick(event) {
          event.stopPropagation();
          event.currentTarget.value = "";
        },
        onInput(event) {
          if (disabled) return;
          const { files } = event.currentTarget;
          send({ type: "FILES.SET", files: files ? Array.from(files) : [] });
        },
        style: visuallyHiddenStyle
      });
    },
    getItemGroupProps() {
      return normalize2.element({
        ...parts9.itemGroup.attrs,
        dir: state2.context.dir,
        "data-disabled": dataAttr(disabled)
      });
    },
    getItemProps(props22) {
      const { file } = props22;
      return normalize2.element({
        ...parts9.item.attrs,
        dir: state2.context.dir,
        id: dom7.getItemId(state2.context, file.name),
        "data-disabled": dataAttr(disabled)
      });
    },
    getItemNameProps(props22) {
      const { file } = props22;
      return normalize2.element({
        ...parts9.itemName.attrs,
        dir: state2.context.dir,
        id: dom7.getItemNameId(state2.context, file.name),
        "data-disabled": dataAttr(disabled)
      });
    },
    getItemSizeTextProps(props22) {
      const { file } = props22;
      return normalize2.element({
        ...parts9.itemSizeText.attrs,
        dir: state2.context.dir,
        id: dom7.getItemSizeTextId(state2.context, file.name),
        "data-disabled": dataAttr(disabled)
      });
    },
    getItemPreviewProps(props22) {
      const { file } = props22;
      return normalize2.element({
        ...parts9.itemPreview.attrs,
        dir: state2.context.dir,
        id: dom7.getItemPreviewId(state2.context, file.name),
        "data-disabled": dataAttr(disabled)
      });
    },
    getItemPreviewImageProps(props22) {
      var _a8;
      const { file, url } = props22;
      const isImage = file.type.startsWith("image/");
      if (!isImage) {
        throw new Error("Preview Image is only supported for image files");
      }
      return normalize2.img({
        ...parts9.itemPreviewImage.attrs,
        alt: (_a8 = translations.itemPreview) == null ? void 0 : _a8.call(translations, file),
        src: url,
        "data-disabled": dataAttr(disabled)
      });
    },
    getItemDeleteTriggerProps(props22) {
      var _a8;
      const { file } = props22;
      return normalize2.button({
        ...parts9.itemDeleteTrigger.attrs,
        dir: state2.context.dir,
        type: "button",
        disabled,
        "data-disabled": dataAttr(disabled),
        "aria-label": (_a8 = translations.deleteFile) == null ? void 0 : _a8.call(translations, file),
        onClick() {
          if (disabled) return;
          send({ type: "FILE.DELETE", file });
        }
      });
    },
    getLabelProps() {
      return normalize2.label({
        ...parts9.label.attrs,
        dir: state2.context.dir,
        id: dom7.getLabelId(state2.context),
        htmlFor: dom7.getHiddenInputId(state2.context),
        "data-disabled": dataAttr(disabled)
      });
    },
    getClearTriggerProps() {
      return normalize2.button({
        ...parts9.clearTrigger.attrs,
        dir: state2.context.dir,
        type: "button",
        disabled,
        hidden: state2.context.acceptedFiles.length === 0,
        "data-disabled": dataAttr(disabled),
        onClick(event) {
          if (event.defaultPrevented) return;
          if (disabled) return;
          send({ type: "FILES.CLEAR" });
        }
      });
    }
  };
}
function machine8(userContext) {
  const ctx = compact2(userContext);
  return createMachine(
    {
      id: "fileupload",
      initial: "idle",
      context: {
        minFileSize: 0,
        maxFileSize: Number.POSITIVE_INFINITY,
        maxFiles: 1,
        allowDrop: true,
        accept: ctx.accept,
        preventDocumentDrop: true,
        ...ctx,
        acceptedFiles: ref([]),
        rejectedFiles: ref([]),
        translations: {
          dropzone: "dropzone",
          itemPreview: (file) => `preview of ${file.name}`,
          deleteFile: (file) => `delete file ${file.name}`,
          ...ctx.translations
        }
      },
      computed: {
        acceptAttr: (ctx2) => getAcceptAttrString(ctx2.accept),
        multiple: (ctx2) => ctx2.maxFiles > 1
      },
      watch: {
        acceptedFiles: ["syncInputElement"]
      },
      on: {
        "FILES.SET": {
          actions: ["setFilesFromEvent"]
        },
        "FILE.DELETE": {
          actions: ["removeFile"]
        },
        "FILES.CLEAR": {
          actions: ["clearFiles"]
        },
        "REJECTED_FILES.CLEAR": {
          actions: ["clearRejectedFiles"]
        }
      },
      activities: ["preventDocumentDrop"],
      states: {
        idle: {
          on: {
            OPEN: {
              actions: ["openFilePicker"]
            },
            "DROPZONE.CLICK": {
              actions: ["openFilePicker"]
            },
            "DROPZONE.FOCUS": "focused",
            "DROPZONE.DRAG_OVER": "dragging"
          }
        },
        focused: {
          on: {
            "DROPZONE.BLUR": "idle",
            OPEN: {
              actions: ["openFilePicker"]
            },
            "DROPZONE.CLICK": {
              actions: ["openFilePicker"]
            },
            "DROPZONE.DRAG_OVER": "dragging"
          }
        },
        dragging: {
          on: {
            "DROPZONE.DROP": {
              target: "idle",
              actions: ["setFilesFromEvent"]
            },
            "DROPZONE.DRAG_LEAVE": "idle"
          }
        }
      }
    },
    {
      activities: {
        preventDocumentDrop(ctx2) {
          if (!ctx2.preventDocumentDrop) return;
          if (!ctx2.allowDrop) return;
          if (ctx2.disabled) return;
          const doc = dom7.getDoc(ctx2);
          const onDragOver = (event) => {
            event == null ? void 0 : event.preventDefault();
          };
          const onDrop = (event) => {
            if (contains(dom7.getRootEl(ctx2), getEventTarget(event))) return;
            event.preventDefault();
          };
          return callAll(addDomEvent(doc, "dragover", onDragOver, false), addDomEvent(doc, "drop", onDrop, false));
        }
      },
      actions: {
        syncInputElement(ctx2) {
          queueMicrotask(() => {
            const inputEl = dom7.getHiddenInputEl(ctx2);
            if (!inputEl) return;
            const win = dom7.getWin(ctx2);
            const dataTransfer = new win.DataTransfer();
            ctx2.acceptedFiles.forEach((v) => {
              dataTransfer.items.add(v);
            });
            inputEl.files = dataTransfer.files;
            inputEl.dispatchEvent(new win.Event("change", { bubbles: true }));
          });
        },
        openFilePicker(ctx2) {
          raf(() => {
            var _a8;
            (_a8 = dom7.getHiddenInputEl(ctx2)) == null ? void 0 : _a8.click();
          });
        },
        setFilesFromEvent(ctx2, evt) {
          const result = getFilesFromEvent(ctx2, evt.files);
          const { acceptedFiles, rejectedFiles } = result;
          if (ctx2.multiple) {
            const files = ref([...ctx2.acceptedFiles, ...acceptedFiles]);
            set7.files(ctx2, files, rejectedFiles);
            return;
          }
          if (acceptedFiles.length) {
            const files = ref([acceptedFiles[0]]);
            set7.files(ctx2, files, rejectedFiles);
          } else if (rejectedFiles.length) {
            set7.files(ctx2, ctx2.acceptedFiles, rejectedFiles);
          }
        },
        removeFile(ctx2, evt) {
          const files = Array.from(ctx2.acceptedFiles.filter((file) => file !== evt.file));
          const rejectedFiles = Array.from(ctx2.rejectedFiles.filter((item) => item.file !== evt.file));
          ctx2.acceptedFiles = ref(files);
          ctx2.rejectedFiles = ref(rejectedFiles);
          invoke5.change(ctx2);
        },
        clearRejectedFiles(ctx2) {
          ctx2.rejectedFiles = ref([]);
          invoke5.change(ctx2);
        },
        clearFiles(ctx2) {
          ctx2.acceptedFiles = ref([]);
          ctx2.rejectedFiles = ref([]);
          invoke5.change(ctx2);
        }
      },
      compareFns: {
        acceptedFiles: (a, b) => a.length === b.length && a.every((file, i) => isFileEqual(file, b[i]))
      }
    }
  );
}
var invoke5 = {
  change: (ctx) => {
    var _a8;
    (_a8 = ctx.onFileChange) == null ? void 0 : _a8.call(ctx, {
      acceptedFiles: ctx.acceptedFiles,
      rejectedFiles: ctx.rejectedFiles
    });
  },
  accept: (ctx) => {
    var _a8;
    (_a8 = ctx.onFileAccept) == null ? void 0 : _a8.call(ctx, { files: ctx.acceptedFiles });
  },
  reject: (ctx) => {
    var _a8;
    (_a8 = ctx.onFileReject) == null ? void 0 : _a8.call(ctx, { files: ctx.rejectedFiles });
  }
};
var set7 = {
  files: (ctx, acceptedFiles, rejectedFiles) => {
    ctx.acceptedFiles = ref(acceptedFiles);
    invoke5.accept(ctx);
    if (rejectedFiles) {
      ctx.rejectedFiles = ref(rejectedFiles);
      invoke5.reject(ctx);
    }
    invoke5.change(ctx);
  }
};
var props7 = createProps2()([
  "accept",
  "allowDrop",
  "capture",
  "dir",
  "directory",
  "disabled",
  "getRootNode",
  "id",
  "ids",
  "locale",
  "maxFiles",
  "maxFileSize",
  "minFileSize",
  "name",
  "invalid",
  "onFileAccept",
  "onFileReject",
  "onFileChange",
  "preventDocumentDrop",
  "required",
  "translations",
  "validate"
]);
var splitProps8 = createSplitProps(props7);
var itemProps2 = createProps2()(["file"]);
var splitItemProps2 = createSplitProps(itemProps2);

// node_modules/@ark-ui/react/dist/components/file-upload/use-file-upload.js
var import_react120 = __toESM(require_react(), 1);
var useFileUpload = (props21 = {}) => {
  const { getRootNode } = useEnvironmentContext();
  const { dir } = useLocaleContext();
  const field = useFieldContext();
  const initialContext = {
    id: (0, import_react120.useId)(),
    ids: {
      label: field == null ? void 0 : field.ids.label,
      hiddenInput: field == null ? void 0 : field.ids.control
    },
    dir,
    disabled: field == null ? void 0 : field.disabled,
    required: field == null ? void 0 : field.required,
    invalid: field == null ? void 0 : field.invalid,
    getRootNode,
    ...props21
  };
  const context = {
    ...initialContext,
    onFileAccept: useEvent(props21.onFileAccept),
    onFileReject: useEvent(props21.onFileReject),
    onFileChange: useEvent(props21.onFileChange, { sync: true })
  };
  const [state2, send] = useMachine(machine8(initialContext), { context });
  return connect8(state2, send, normalizeProps);
};

// node_modules/@ark-ui/react/dist/components/file-upload/file-upload-root.js
var FileUploadRoot = (0, import_react122.forwardRef)((props21, ref2) => {
  const [useFileUploadProps, localProps] = createSplitProps2()(props21, [
    "accept",
    "allowDrop",
    "capture",
    "directory",
    "disabled",
    "id",
    "ids",
    "invalid",
    "locale",
    "maxFiles",
    "maxFileSize",
    "minFileSize",
    "name",
    "onFileAccept",
    "onFileChange",
    "onFileReject",
    "preventDocumentDrop",
    "required",
    "translations",
    "validate"
  ]);
  const fileUpload = useFileUpload(useFileUploadProps);
  const mergedProps = mergeProps(fileUpload.getRootProps(), localProps);
  return (0, import_jsx_runtime54.jsx)(FileUploadProvider, { value: fileUpload, children: (0, import_jsx_runtime54.jsx)(ark.div, { ...mergedProps, ref: ref2 }) });
});
FileUploadRoot.displayName = "FileUploadRoot";

// node_modules/@ark-ui/react/dist/components/file-upload/file-upload-root-provider.js
var import_jsx_runtime55 = __toESM(require_jsx_runtime(), 1);
var import_react124 = __toESM(require_react(), 1);
var FileUploadRootProvider = (0, import_react124.forwardRef)(
  (props21, ref2) => {
    const [{ value: fileUpload }, localProps] = createSplitProps2()(props21, [
      "value"
    ]);
    const mergedProps = mergeProps(fileUpload.getRootProps(), localProps);
    return (0, import_jsx_runtime55.jsx)(FileUploadProvider, { value: fileUpload, children: (0, import_jsx_runtime55.jsx)(ark.div, { ...mergedProps, ref: ref2 }) });
  }
);
FileUploadRootProvider.displayName = "FileUploadRootProvider";

// node_modules/@ark-ui/react/dist/components/file-upload/file-upload-trigger.js
var import_jsx_runtime56 = __toESM(require_jsx_runtime(), 1);
var import_react126 = __toESM(require_react(), 1);
var FileUploadTrigger = (0, import_react126.forwardRef)(
  (props21, ref2) => {
    const fileUpload = useFileUploadContext();
    const mergedProps = mergeProps(fileUpload.getTriggerProps(), props21);
    return (0, import_jsx_runtime56.jsx)(ark.button, { ...mergedProps, ref: ref2 });
  }
);
FileUploadTrigger.displayName = "FileUploadTrigger";

// node_modules/@ark-ui/react/dist/components/file-upload/file-upload.js
var file_upload_exports = {};
__export(file_upload_exports, {
  ClearTrigger: () => FileUploadClearTrigger,
  Context: () => FileUploadContext,
  Dropzone: () => FileUploadDropzone,
  HiddenInput: () => FileUploadHiddenInput,
  Item: () => FileUploadItem,
  ItemDeleteTrigger: () => FileUploadItemDeleteTrigger,
  ItemGroup: () => FileUploadItemGroup,
  ItemName: () => FileUploadItemName,
  ItemPreview: () => FileUploadItemPreview,
  ItemPreviewImage: () => FileUploadItemPreviewImage,
  ItemSizeText: () => FileUploadItemSizeText,
  Label: () => FileUploadLabel,
  Root: () => FileUploadRoot,
  RootProvider: () => FileUploadRootProvider,
  Trigger: () => FileUploadTrigger
});

// node_modules/@ark-ui/react/dist/components/menu/menu-arrow.js
var import_jsx_runtime57 = __toESM(require_jsx_runtime(), 1);
var import_react128 = __toESM(require_react(), 1);

// node_modules/@ark-ui/react/dist/components/menu/use-menu-context.js
var [MenuProvider, useMenuContext] = createContext({
  name: "MenuContext",
  hookName: "useMenuContext",
  providerName: "<MenuProvider />",
  strict: false
});

// node_modules/@ark-ui/react/dist/components/menu/menu-arrow.js
var MenuArrow = (0, import_react128.forwardRef)((props21, ref2) => {
  const menu = useMenuContext();
  const mergedProps = mergeProps(menu.getArrowProps(), props21);
  return (0, import_jsx_runtime57.jsx)(ark.div, { ...mergedProps, ref: ref2 });
});
MenuArrow.displayName = "MenuArrow";

// node_modules/@ark-ui/react/dist/components/menu/menu-arrow-tip.js
var import_jsx_runtime58 = __toESM(require_jsx_runtime(), 1);
var import_react130 = __toESM(require_react(), 1);
var MenuArrowTip = (0, import_react130.forwardRef)((props21, ref2) => {
  const menu = useMenuContext();
  const mergedProps = mergeProps(menu.getArrowTipProps(), props21);
  return (0, import_jsx_runtime58.jsx)(ark.div, { ...mergedProps, ref: ref2 });
});
MenuArrowTip.displayName = "MenuArrowTip";

// node_modules/@ark-ui/react/dist/components/menu/menu-checkbox-item.js
var import_jsx_runtime59 = __toESM(require_jsx_runtime(), 1);
var import_react132 = __toESM(require_react(), 1);

// node_modules/@ark-ui/react/dist/components/menu/use-menu-item-context.js
var [MenuItemProvider, useMenuItemContext] = createContext({
  name: "MenuItemContext",
  hookName: "useMenuItemContext",
  providerName: "<MenuItemProvider />"
});

// node_modules/@ark-ui/react/dist/components/menu/use-menu-option-item-props-context.js
var [MenuOptionItemPropsProvider, useMenuOptionItemPropsContext] = createContext({
  name: "MenuOptionItemPropsContext",
  hookName: "useMenuOptionItemPropsContext",
  providerName: "<MenuOptionItemPropsProvider />"
});

// node_modules/@ark-ui/react/dist/components/menu/menu-checkbox-item.js
var MenuCheckboxItem = (0, import_react132.forwardRef)((props21, ref2) => {
  const [partialOptionItemProps, localProps] = createSplitProps2()(props21, [
    "checked",
    "closeOnSelect",
    "disabled",
    "onCheckedChange",
    "value",
    "valueText"
  ]);
  const optionItemProps2 = {
    ...partialOptionItemProps,
    type: "checkbox"
  };
  const menu = useMenuContext();
  const mergedProps = mergeProps(menu.getOptionItemProps(optionItemProps2), localProps);
  const optionItemState = menu.getOptionItemState(optionItemProps2);
  return (0, import_jsx_runtime59.jsx)(MenuOptionItemPropsProvider, { value: optionItemProps2, children: (0, import_jsx_runtime59.jsx)(MenuItemProvider, { value: optionItemState, children: (0, import_jsx_runtime59.jsx)(ark.div, { ...mergedProps, ref: ref2 }) }) });
});
MenuCheckboxItem.displayName = "MenuCheckboxItem";

// node_modules/@ark-ui/react/dist/components/menu/menu-content.js
var import_jsx_runtime60 = __toESM(require_jsx_runtime(), 1);
var import_react134 = __toESM(require_react(), 1);
var MenuContent = (0, import_react134.forwardRef)((props21, ref2) => {
  const menu = useMenuContext();
  const presence = usePresenceContext();
  const mergedProps = mergeProps(menu.getContentProps(), presence.getPresenceProps(), props21);
  if (presence.unmounted) {
    return null;
  }
  return (0, import_jsx_runtime60.jsx)(ark.div, { ...mergedProps, ref: composeRefs(presence.ref, ref2) });
});
MenuContent.displayName = "MenuContent";

// node_modules/@ark-ui/react/dist/components/menu/menu-context.js
var MenuContext = (props21) => props21.children(useMenuContext());

// node_modules/@ark-ui/react/dist/components/menu/menu-context-trigger.js
var import_jsx_runtime61 = __toESM(require_jsx_runtime(), 1);
var import_react136 = __toESM(require_react(), 1);
var MenuContextTrigger = (0, import_react136.forwardRef)(
  (props21, ref2) => {
    const menu = useMenuContext();
    const mergedProps = mergeProps(menu.getContextTriggerProps(), props21);
    return (0, import_jsx_runtime61.jsx)(ark.button, { ...mergedProps, ref: ref2 });
  }
);
MenuContextTrigger.displayName = "MenuContextTrigger";

// node_modules/@ark-ui/react/dist/components/menu/menu-indicator.js
var import_jsx_runtime62 = __toESM(require_jsx_runtime(), 1);
var import_react138 = __toESM(require_react(), 1);
var MenuIndicator = (0, import_react138.forwardRef)((props21, ref2) => {
  const menu = useMenuContext();
  const mergedProps = mergeProps(menu.getIndicatorProps(), props21);
  return (0, import_jsx_runtime62.jsx)(ark.div, { ...mergedProps, ref: ref2 });
});
MenuIndicator.displayName = "MenuIndicator";

// node_modules/@ark-ui/react/dist/components/menu/menu-item.js
var import_jsx_runtime63 = __toESM(require_jsx_runtime(), 1);
var import_react140 = __toESM(require_react(), 1);
var MenuItem = (0, import_react140.forwardRef)((props21, ref2) => {
  const [itemProps7, localProps] = createSplitProps2()(props21, [
    "closeOnSelect",
    "disabled",
    "value",
    "valueText"
  ]);
  const menu = useMenuContext();
  const mergedProps = mergeProps(menu.getItemProps(itemProps7), localProps);
  const itemState = menu.getItemState(itemProps7);
  return (0, import_jsx_runtime63.jsx)(MenuItemProvider, { value: itemState, children: (0, import_jsx_runtime63.jsx)(ark.div, { ...mergedProps, ref: ref2 }) });
});
MenuItem.displayName = "MenuItem";

// node_modules/@ark-ui/react/dist/components/menu/menu-item-context.js
var MenuItemContext = (props21) => props21.children(useMenuItemContext());

// node_modules/@ark-ui/react/dist/components/menu/menu-item-group.js
var import_jsx_runtime64 = __toESM(require_jsx_runtime(), 1);
var import_react142 = __toESM(require_react(), 1);

// node_modules/@ark-ui/react/dist/components/menu/use-menu-item-group-context.js
var [MenuItemGroupProvider, useMenuItemGroupContext] = createContext({
  name: "MenuItemGroupContext",
  hookName: "useMenuItemGroupContext",
  providerName: "<MenuItemGroupProvider />"
});

// node_modules/@ark-ui/react/dist/components/menu/menu-item-group.js
var MenuItemGroup = (0, import_react142.forwardRef)((props21, ref2) => {
  const [optionalItemGroupProps, localProps] = createSplitProps2()(props21, [
    "id"
  ]);
  const menu = useMenuContext();
  const id = (0, import_react142.useId)();
  const itemGroupProps3 = { id, ...optionalItemGroupProps };
  const mergedProps = mergeProps(menu.getItemGroupProps(itemGroupProps3), localProps);
  return (0, import_jsx_runtime64.jsx)(MenuItemGroupProvider, { value: itemGroupProps3, children: (0, import_jsx_runtime64.jsx)(ark.div, { ...mergedProps, ref: ref2 }) });
});
MenuItemGroup.displayName = "MenuItemGroup";

// node_modules/@ark-ui/react/dist/components/menu/menu-item-group-label.js
var import_jsx_runtime65 = __toESM(require_jsx_runtime(), 1);
var import_react144 = __toESM(require_react(), 1);
var MenuItemGroupLabel = (0, import_react144.forwardRef)(
  (props21, ref2) => {
    const menu = useMenuContext();
    const itemGroup = useMenuItemGroupContext();
    const mergedProps = mergeProps(menu.getItemGroupLabelProps({ htmlFor: itemGroup.id }), props21);
    return (0, import_jsx_runtime65.jsx)(ark.div, { ...mergedProps, ref: ref2 });
  }
);
MenuItemGroupLabel.displayName = "MenuItemGroupLabel";

// node_modules/@ark-ui/react/dist/components/menu/menu-item-indicator.js
var import_jsx_runtime66 = __toESM(require_jsx_runtime(), 1);
var import_react146 = __toESM(require_react(), 1);
var MenuItemIndicator = (0, import_react146.forwardRef)(
  (props21, ref2) => {
    const menu = useMenuContext();
    const optionItemProps2 = useMenuOptionItemPropsContext();
    const mergedProps = mergeProps(menu.getItemIndicatorProps(optionItemProps2), props21);
    return (0, import_jsx_runtime66.jsx)(ark.div, { ...mergedProps, ref: ref2 });
  }
);
MenuItemIndicator.displayName = "MenuItemIndicator";

// node_modules/@ark-ui/react/dist/components/menu/menu-item-text.js
var import_jsx_runtime67 = __toESM(require_jsx_runtime(), 1);
var import_react148 = __toESM(require_react(), 1);
var MenuItemText = (0, import_react148.forwardRef)((props21, ref2) => {
  const menu = useMenuContext();
  const optionItemProps2 = useMenuOptionItemPropsContext();
  const mergedProps = mergeProps(menu.getItemTextProps(optionItemProps2), props21);
  return (0, import_jsx_runtime67.jsx)(ark.div, { ...mergedProps, ref: ref2 });
});
MenuItemText.displayName = "MenuItemText";

// node_modules/@ark-ui/react/dist/components/menu/menu-positioner.js
var import_jsx_runtime68 = __toESM(require_jsx_runtime(), 1);
var import_react150 = __toESM(require_react(), 1);
var MenuPositioner = (0, import_react150.forwardRef)((props21, ref2) => {
  const menu = useMenuContext();
  const mergedProps = mergeProps(menu.getPositionerProps(), props21);
  const presence = usePresenceContext();
  if (presence.unmounted) {
    return null;
  }
  return (0, import_jsx_runtime68.jsx)(ark.div, { ...mergedProps, ref: ref2 });
});
MenuPositioner.displayName = "MenuPositioner";

// node_modules/@ark-ui/react/dist/components/menu/menu-radio-item.js
var import_jsx_runtime69 = __toESM(require_jsx_runtime(), 1);
var import_react152 = __toESM(require_react(), 1);
var MenuRadioItem = (0, import_react152.forwardRef)((props21, ref2) => {
  const [partialItemProps, localProps] = createSplitProps2()(props21, [
    "closeOnSelect",
    "disabled",
    "value",
    "valueText"
  ]);
  const menu = useMenuContext();
  const itemGroup = useMenuItemGroupContext();
  const optionItemProps2 = {
    ...partialItemProps,
    checked: itemGroup.value === partialItemProps.value,
    type: "radio",
    onCheckedChange: () => {
      var _a8;
      return (_a8 = itemGroup.onValueChange) == null ? void 0 : _a8.call(itemGroup, { value: partialItemProps.value });
    }
  };
  const mergedProps = mergeProps(menu.getOptionItemProps(optionItemProps2), localProps);
  const optionItemState = menu.getOptionItemState(optionItemProps2);
  return (0, import_jsx_runtime69.jsx)(MenuOptionItemPropsProvider, { value: optionItemProps2, children: (0, import_jsx_runtime69.jsx)(MenuItemProvider, { value: optionItemState, children: (0, import_jsx_runtime69.jsx)(ark.div, { ...mergedProps, ref: ref2 }) }) });
});
MenuRadioItem.displayName = "MenuRadioItem";

// node_modules/@ark-ui/react/dist/components/menu/menu-radio-item-group.js
var import_jsx_runtime70 = __toESM(require_jsx_runtime(), 1);
var import_react154 = __toESM(require_react(), 1);
var MenuRadioItemGroup = (0, import_react154.forwardRef)(
  (props21, ref2) => {
    const [optionalItemGroupProps, localProps] = createSplitProps2()(props21, ["id", "onValueChange", "value"]);
    const menu = useMenuContext();
    const id = (0, import_react154.useId)();
    const itemGroupProps3 = { id, ...optionalItemGroupProps };
    const mergedProps = mergeProps(menu.getItemGroupProps({ id: itemGroupProps3.id }), localProps);
    return (0, import_jsx_runtime70.jsx)(MenuItemGroupProvider, { value: itemGroupProps3, children: (0, import_jsx_runtime70.jsx)(ark.div, { ...mergedProps, ref: ref2 }) });
  }
);
MenuRadioItemGroup.displayName = "MenuRadioItemGroup";

// node_modules/@ark-ui/react/dist/components/menu/menu-root.js
var import_jsx_runtime71 = __toESM(require_jsx_runtime(), 1);
var import_react159 = __toESM(require_react(), 1);

// node_modules/@ark-ui/react/dist/utils/use-effect-once.js
var import_react155 = __toESM(require_react(), 1);
var useEffectOnce = (cb) => {
  const savedCallback = (0, import_react155.useRef)(cb);
  const effectGuard = (0, import_react155.useRef)(false);
  (0, import_react155.useEffect)(() => {
    savedCallback.current = cb;
  });
  (0, import_react155.useEffect)(() => {
    if (effectGuard.current !== true) {
      effectGuard.current = true;
      savedCallback.current();
    }
  }, []);
};

// node_modules/@zag-js/rect-utils/dist/index.mjs
var createPoint = (x, y) => ({ x, y });
function createRect(r) {
  const { x, y, width, height } = r;
  const midX = x + width / 2;
  const midY = y + height / 2;
  return {
    x,
    y,
    width,
    height,
    minX: x,
    minY: y,
    maxX: x + width,
    maxY: y + height,
    midX,
    midY,
    center: createPoint(midX, midY)
  };
}
function getRectCorners(v) {
  const top = createPoint(v.minX, v.minY);
  const right = createPoint(v.maxX, v.minY);
  const bottom = createPoint(v.maxX, v.maxY);
  const left = createPoint(v.minX, v.maxY);
  return { top, right, bottom, left };
}
var { min: min3, max: max3 } = Math;
function getElementPolygon(rectValue, placement) {
  const rect = createRect(rectValue);
  const { top, right, left, bottom } = getRectCorners(rect);
  const [base] = placement.split("-");
  return {
    top: [left, top, right, bottom],
    right: [top, right, bottom, left],
    bottom: [top, left, bottom, right],
    left: [right, top, left, bottom]
  }[base];
}
function isPointInPolygon(polygon, point) {
  const { x, y } = point;
  let c = false;
  for (let i = 0, j = polygon.length - 1; i < polygon.length; j = i++) {
    const xi = polygon[i].x;
    const yi = polygon[i].y;
    const xj = polygon[j].x;
    const yj = polygon[j].y;
    if (yi > y !== yj > y && x < (xj - xi) * (y - yi) / (yj - yi) + xi) {
      c = !c;
    }
  }
  return c;
}
var { sign: sign2, abs: abs2, min: min22 } = Math;

// node_modules/@zag-js/menu/dist/index.mjs
var anatomy8 = createAnatomy("menu").parts(
  "arrow",
  "arrowTip",
  "content",
  "contextTrigger",
  "indicator",
  "item",
  "itemGroup",
  "itemGroupLabel",
  "itemIndicator",
  "itemText",
  "positioner",
  "separator",
  "trigger",
  "triggerItem"
);
var parts10 = anatomy8.build();
var dom8 = createScope({
  getTriggerId: (ctx) => {
    var _a8;
    return ((_a8 = ctx.ids) == null ? void 0 : _a8.trigger) ?? `menu:${ctx.id}:trigger`;
  },
  getContextTriggerId: (ctx) => {
    var _a8;
    return ((_a8 = ctx.ids) == null ? void 0 : _a8.contextTrigger) ?? `menu:${ctx.id}:ctx-trigger`;
  },
  getContentId: (ctx) => {
    var _a8;
    return ((_a8 = ctx.ids) == null ? void 0 : _a8.content) ?? `menu:${ctx.id}:content`;
  },
  getArrowId: (ctx) => {
    var _a8;
    return ((_a8 = ctx.ids) == null ? void 0 : _a8.arrow) ?? `menu:${ctx.id}:arrow`;
  },
  getPositionerId: (ctx) => {
    var _a8;
    return ((_a8 = ctx.ids) == null ? void 0 : _a8.positioner) ?? `menu:${ctx.id}:popper`;
  },
  getGroupId: (ctx, id) => {
    var _a8, _b7;
    return ((_b7 = (_a8 = ctx.ids) == null ? void 0 : _a8.group) == null ? void 0 : _b7.call(_a8, id)) ?? `menu:${ctx.id}:group:${id}`;
  },
  getGroupLabelId: (ctx, id) => {
    var _a8, _b7;
    return ((_b7 = (_a8 = ctx.ids) == null ? void 0 : _a8.groupLabel) == null ? void 0 : _b7.call(_a8, id)) ?? `menu:${ctx.id}:group-label:${id}`;
  },
  getContentEl: (ctx) => dom8.getById(ctx, dom8.getContentId(ctx)),
  getPositionerEl: (ctx) => dom8.getById(ctx, dom8.getPositionerId(ctx)),
  getTriggerEl: (ctx) => dom8.getById(ctx, dom8.getTriggerId(ctx)),
  getHighlightedItemEl: (ctx) => ctx.highlightedValue ? dom8.getById(ctx, ctx.highlightedValue) : null,
  getArrowEl: (ctx) => dom8.getById(ctx, dom8.getArrowId(ctx)),
  getElements: (ctx) => {
    const ownerId = CSS.escape(dom8.getContentId(ctx));
    const selector = `[role^="menuitem"][data-ownedby=${ownerId}]:not([data-disabled])`;
    return queryAll(dom8.getContentEl(ctx), selector);
  },
  getFirstEl: (ctx) => first(dom8.getElements(ctx)),
  getLastEl: (ctx) => last(dom8.getElements(ctx)),
  getNextEl: (ctx, loop) => nextById(dom8.getElements(ctx), ctx.highlightedValue, loop ?? ctx.loopFocus),
  getPrevEl: (ctx, loop) => prevById(dom8.getElements(ctx), ctx.highlightedValue, loop ?? ctx.loopFocus),
  getElemByKey: (ctx, key) => getByTypeahead(dom8.getElements(ctx), { state: ctx.typeaheadState, key, activeId: ctx.highlightedValue }),
  isTargetDisabled: (v) => {
    return isHTMLElement(v) && (v.dataset.disabled === "" || v.hasAttribute("disabled"));
  },
  isTriggerItem: (el) => {
    var _a8;
    return !!((_a8 = el == null ? void 0 : el.getAttribute("role")) == null ? void 0 : _a8.startsWith("menuitem")) && !!(el == null ? void 0 : el.hasAttribute("aria-controls"));
  },
  getOptionFromItemEl(el) {
    return {
      id: el.id,
      name: el.dataset.name,
      value: el.dataset.value,
      valueText: el.dataset.valueText,
      type: el.dataset.type
    };
  }
});
function connect9(state2, send, normalize2) {
  const isSubmenu = state2.context.isSubmenu;
  const isTypingAhead = state2.context.isTypingAhead;
  const composite = state2.context.composite;
  const open = state2.hasTag("open");
  const popperStyles = getPlacementStyles({
    ...state2.context.positioning,
    placement: state2.context.anchorPoint ? "bottom" : state2.context.currentPlacement
  });
  function getItemState(props22) {
    return {
      disabled: !!props22.disabled,
      highlighted: state2.context.highlightedValue === props22.value
    };
  }
  function getOptionItemProps(props22) {
    const valueText = props22.valueText ?? props22.value;
    return { ...props22, id: props22.value, valueText };
  }
  function getOptionItemState(props22) {
    const itemState = getItemState(getOptionItemProps(props22));
    return {
      ...itemState,
      checked: !!props22.checked
    };
  }
  function getItemProps(props22) {
    const { value: id, closeOnSelect, valueText } = props22;
    const itemState = getItemState(props22);
    return normalize2.element({
      ...parts10.item.attrs,
      id,
      role: "menuitem",
      "aria-disabled": itemState.disabled,
      "data-disabled": dataAttr(itemState.disabled),
      "data-ownedby": dom8.getContentId(state2.context),
      "data-highlighted": dataAttr(itemState.highlighted),
      "data-valuetext": valueText,
      onDragStart(event) {
        const isLink = event.currentTarget.matches("a[href]");
        if (isLink) event.preventDefault();
      },
      onPointerMove(event) {
        if (itemState.disabled) return;
        if (event.pointerType !== "mouse") return;
        const target = event.currentTarget;
        if (itemState.highlighted) return;
        send({ type: "ITEM_POINTERMOVE", id, target, closeOnSelect });
      },
      onPointerLeave(event) {
        if (itemState.disabled) return;
        if (event.pointerType !== "mouse") return;
        const pointerMoved = state2.previousEvent.type.includes("POINTER");
        if (!pointerMoved) return;
        const target = event.currentTarget;
        send({ type: "ITEM_POINTERLEAVE", id, target, closeOnSelect });
      },
      onPointerDown(event) {
        if (itemState.disabled) return;
        const target = event.currentTarget;
        send({ type: "ITEM_POINTERDOWN", target, id, closeOnSelect });
      },
      onClick(event) {
        if (isDownloadingEvent(event)) return;
        if (isOpeningInNewTab(event)) return;
        if (itemState.disabled) return;
        const target = event.currentTarget;
        send({ type: "ITEM_CLICK", target, id, closeOnSelect });
      }
    });
  }
  return {
    highlightedValue: state2.context.highlightedValue,
    open,
    setOpen(nextOpen) {
      if (nextOpen === open) return;
      send(nextOpen ? "OPEN" : "CLOSE");
    },
    setHighlightedValue(value) {
      send({ type: "HIGHLIGHTED.SET", id: value });
    },
    setParent(parent) {
      send({ type: "PARENT.SET", value: parent, id: parent.state.context.id });
    },
    setChild(child) {
      send({ type: "CHILD.SET", value: child, id: child.state.context.id });
    },
    reposition(options = {}) {
      send({ type: "POSITIONING.SET", options });
    },
    getContextTriggerProps() {
      return normalize2.element({
        ...parts10.contextTrigger.attrs,
        dir: state2.context.dir,
        id: dom8.getContextTriggerId(state2.context),
        onPointerDown(event) {
          if (event.pointerType === "mouse") return;
          const point = getEventPoint(event);
          send({ type: "CONTEXT_MENU_START", point });
        },
        onPointerCancel(event) {
          if (event.pointerType === "mouse") return;
          send("CONTEXT_MENU_CANCEL");
        },
        onPointerMove(event) {
          if (event.pointerType === "mouse") return;
          send("CONTEXT_MENU_CANCEL");
        },
        onPointerUp(event) {
          if (event.pointerType === "mouse") return;
          send("CONTEXT_MENU_CANCEL");
        },
        onContextMenu(event) {
          const point = getEventPoint(event);
          send({ type: "CONTEXT_MENU", point });
          event.preventDefault();
        },
        style: {
          WebkitTouchCallout: "none",
          WebkitUserSelect: "none",
          userSelect: "none"
        }
      });
    },
    getTriggerItemProps(childApi) {
      return mergeProps(
        getItemProps({ value: childApi.getTriggerProps().id }),
        childApi.getTriggerProps()
      );
    },
    getTriggerProps() {
      return normalize2.button({
        ...isSubmenu ? parts10.triggerItem.attrs : parts10.trigger.attrs,
        "data-placement": state2.context.currentPlacement,
        type: "button",
        dir: state2.context.dir,
        id: dom8.getTriggerId(state2.context),
        "data-uid": state2.context.id,
        "aria-haspopup": composite ? "menu" : "dialog",
        "aria-controls": dom8.getContentId(state2.context),
        "aria-expanded": open || void 0,
        "data-state": open ? "open" : "closed",
        onPointerMove(event) {
          if (event.pointerType !== "mouse") return;
          const disabled = dom8.isTargetDisabled(event.currentTarget);
          if (disabled || !isSubmenu) return;
          send({ type: "TRIGGER_POINTERMOVE", target: event.currentTarget });
        },
        onPointerLeave(event) {
          if (dom8.isTargetDisabled(event.currentTarget)) return;
          if (event.pointerType !== "mouse") return;
          if (!isSubmenu) return;
          const point = getEventPoint(event);
          send({ type: "TRIGGER_POINTERLEAVE", target: event.currentTarget, point });
        },
        onPointerDown(event) {
          if (dom8.isTargetDisabled(event.currentTarget)) return;
          if (isContextMenuEvent(event)) return;
          event.preventDefault();
        },
        onClick(event) {
          if (event.defaultPrevented) return;
          if (dom8.isTargetDisabled(event.currentTarget)) return;
          send({ type: "TRIGGER_CLICK", target: event.currentTarget });
        },
        onBlur() {
          send("TRIGGER_BLUR");
        },
        onFocus() {
          send("TRIGGER_FOCUS");
        },
        onKeyDown(event) {
          if (event.defaultPrevented) return;
          const keyMap2 = {
            ArrowDown() {
              send("ARROW_DOWN");
            },
            ArrowUp() {
              send("ARROW_UP");
            },
            Enter() {
              send({ type: "ARROW_DOWN", src: "enter" });
            },
            Space() {
              send({ type: "ARROW_DOWN", src: "space" });
            }
          };
          const key = getEventKey(event, state2.context);
          const exec2 = keyMap2[key];
          if (exec2) {
            event.preventDefault();
            exec2(event);
          }
        }
      });
    },
    getIndicatorProps() {
      return normalize2.element({
        ...parts10.indicator.attrs,
        dir: state2.context.dir,
        "data-state": open ? "open" : "closed"
      });
    },
    getPositionerProps() {
      return normalize2.element({
        ...parts10.positioner.attrs,
        dir: state2.context.dir,
        id: dom8.getPositionerId(state2.context),
        style: popperStyles.floating
      });
    },
    getArrowProps() {
      return normalize2.element({
        id: dom8.getArrowId(state2.context),
        ...parts10.arrow.attrs,
        dir: state2.context.dir,
        style: popperStyles.arrow
      });
    },
    getArrowTipProps() {
      return normalize2.element({
        ...parts10.arrowTip.attrs,
        dir: state2.context.dir,
        style: popperStyles.arrowTip
      });
    },
    getContentProps() {
      return normalize2.element({
        ...parts10.content.attrs,
        id: dom8.getContentId(state2.context),
        "aria-label": state2.context["aria-label"],
        hidden: !open,
        "data-state": open ? "open" : "closed",
        role: composite ? "menu" : "dialog",
        tabIndex: 0,
        dir: state2.context.dir,
        "aria-activedescendant": state2.context.highlightedValue ?? void 0,
        "aria-labelledby": dom8.getTriggerId(state2.context),
        "data-placement": state2.context.currentPlacement,
        onPointerEnter(event) {
          if (event.pointerType !== "mouse") return;
          send("MENU_POINTERENTER");
        },
        onKeyDown(event) {
          if (event.defaultPrevented) return;
          if (!isSelfTarget(event)) return;
          const target = getEventTarget(event);
          const sameMenu = (target == null ? void 0 : target.closest("[role=menu]")) === event.currentTarget || target === event.currentTarget;
          if (!sameMenu) return;
          if (event.key === "Tab") {
            const valid = isValidTabEvent(event);
            if (!valid) {
              event.preventDefault();
              return;
            }
          }
          const item = dom8.getHighlightedItemEl(state2.context);
          const keyMap2 = {
            ArrowDown() {
              send("ARROW_DOWN");
            },
            ArrowUp() {
              send("ARROW_UP");
            },
            ArrowLeft() {
              send("ARROW_LEFT");
            },
            ArrowRight() {
              send("ARROW_RIGHT");
            },
            Enter() {
              send("ENTER");
              if (isAnchorElement(item)) {
                state2.context.navigate({ value: state2.context.highlightedValue, node: item });
              }
            },
            Space(event2) {
              var _a8;
              if (isTypingAhead) {
                send({ type: "TYPEAHEAD", key: event2.key });
              } else {
                (_a8 = keyMap2.Enter) == null ? void 0 : _a8.call(keyMap2, event2);
              }
            },
            Home() {
              send("HOME");
            },
            End() {
              send("END");
            }
          };
          const key = getEventKey(event, { dir: state2.context.dir });
          const exec2 = keyMap2[key];
          if (exec2) {
            exec2(event);
            event.stopPropagation();
            event.preventDefault();
            return;
          }
          if (!state2.context.typeahead) return;
          if (!isPrintableKey(event)) return;
          if (isModifierKey(event)) return;
          if (isEditableElement(target)) return;
          send({ type: "TYPEAHEAD", key: event.key });
          event.preventDefault();
        }
      });
    },
    getSeparatorProps() {
      return normalize2.element({
        ...parts10.separator.attrs,
        role: "separator",
        dir: state2.context.dir,
        "aria-orientation": "horizontal"
      });
    },
    getItemState,
    getItemProps,
    getOptionItemState,
    getOptionItemProps(props22) {
      const { type, disabled, onCheckedChange, closeOnSelect } = props22;
      const option = getOptionItemProps(props22);
      const itemState = getOptionItemState(props22);
      return {
        ...getItemProps(option),
        ...normalize2.element({
          "data-type": type,
          ...parts10.item.attrs,
          dir: state2.context.dir,
          "data-value": option.value,
          role: `menuitem${type}`,
          "aria-checked": !!itemState.checked,
          "data-state": itemState.checked ? "checked" : "unchecked",
          onClick(event) {
            if (disabled) return;
            if (isDownloadingEvent(event)) return;
            if (isOpeningInNewTab(event)) return;
            const target = event.currentTarget;
            send({ type: "ITEM_CLICK", target, option, closeOnSelect });
            onCheckedChange == null ? void 0 : onCheckedChange(!itemState.checked);
          }
        })
      };
    },
    getItemIndicatorProps(props22) {
      const itemState = getOptionItemState(props22);
      return normalize2.element({
        ...parts10.itemIndicator.attrs,
        dir: state2.context.dir,
        "data-disabled": dataAttr(itemState.disabled),
        "data-highlighted": dataAttr(itemState.highlighted),
        "data-state": itemState.checked ? "checked" : "unchecked",
        hidden: !itemState.checked
      });
    },
    getItemTextProps(props22) {
      const itemState = getOptionItemState(props22);
      return normalize2.element({
        ...parts10.itemText.attrs,
        dir: state2.context.dir,
        "data-disabled": dataAttr(itemState.disabled),
        "data-highlighted": dataAttr(itemState.highlighted),
        "data-state": itemState.checked ? "checked" : "unchecked"
      });
    },
    getItemGroupLabelProps(props22) {
      return normalize2.element({
        id: dom8.getGroupLabelId(state2.context, props22.htmlFor),
        dir: state2.context.dir,
        ...parts10.itemGroupLabel.attrs
      });
    },
    getItemGroupProps(props22) {
      return normalize2.element({
        id: dom8.getGroupId(state2.context, props22.id),
        ...parts10.itemGroup.attrs,
        dir: state2.context.dir,
        "aria-labelledby": dom8.getGroupLabelId(state2.context, props22.id),
        role: "group"
      });
    }
  };
}
var { not: not3, and: and5, or: or2 } = guards;
function machine9(userContext) {
  const ctx = compact2(userContext);
  return createMachine(
    {
      id: "menu",
      initial: ctx.open ? "open" : "idle",
      context: {
        highlightedValue: null,
        loopFocus: false,
        anchorPoint: null,
        closeOnSelect: true,
        typeahead: true,
        composite: true,
        navigate(details) {
          clickIfLink(details.node);
        },
        ...ctx,
        positioning: {
          placement: "bottom-start",
          gutter: 8,
          ...ctx.positioning
        },
        intentPolygon: null,
        parent: null,
        lastHighlightedValue: null,
        children: cast(ref({})),
        suspendPointer: false,
        typeaheadState: getByTypeahead.defaultOptions
      },
      computed: {
        isSubmenu: (ctx2) => ctx2.parent !== null,
        isRtl: (ctx2) => ctx2.dir === "rtl",
        isTypingAhead: (ctx2) => ctx2.typeaheadState.keysSoFar !== ""
      },
      watch: {
        isSubmenu: "setSubmenuPlacement",
        anchorPoint: "reposition",
        open: "toggleVisibility"
      },
      on: {
        "PARENT.SET": {
          actions: "setParentMenu"
        },
        "CHILD.SET": {
          actions: "setChildMenu"
        },
        OPEN: [
          {
            guard: "isOpenControlled",
            actions: "invokeOnOpen"
          },
          {
            target: "open",
            actions: "invokeOnOpen"
          }
        ],
        OPEN_AUTOFOCUS: [
          {
            guard: "isOpenControlled",
            actions: ["invokeOnOpen"]
          },
          {
            internal: true,
            target: "open",
            actions: ["highlightFirstItem", "invokeOnOpen"]
          }
        ],
        CLOSE: [
          {
            guard: "isOpenControlled",
            actions: "invokeOnClose"
          },
          {
            target: "closed",
            actions: "invokeOnClose"
          }
        ],
        "HIGHLIGHTED.RESTORE": {
          actions: "restoreHighlightedItem"
        },
        "HIGHLIGHTED.SET": {
          actions: "setHighlightedItem"
        }
      },
      states: {
        idle: {
          tags: ["closed"],
          on: {
            "CONTROLLED.OPEN": "open",
            "CONTROLLED.CLOSE": "closed",
            CONTEXT_MENU_START: {
              target: "opening:contextmenu",
              actions: "setAnchorPoint"
            },
            CONTEXT_MENU: [
              {
                guard: "isOpenControlled",
                actions: ["setAnchorPoint", "invokeOnOpen"]
              },
              {
                target: "open",
                actions: ["setAnchorPoint", "invokeOnOpen"]
              }
            ],
            TRIGGER_CLICK: [
              {
                guard: "isOpenControlled",
                actions: "invokeOnOpen"
              },
              {
                target: "open",
                actions: "invokeOnOpen"
              }
            ],
            TRIGGER_FOCUS: {
              guard: not3("isSubmenu"),
              target: "closed"
            },
            TRIGGER_POINTERMOVE: {
              guard: "isSubmenu",
              target: "opening"
            }
          }
        },
        "opening:contextmenu": {
          tags: ["closed"],
          after: {
            LONG_PRESS_DELAY: [
              {
                guard: "isOpenControlled",
                actions: "invokeOnOpen"
              },
              {
                target: "open",
                actions: "invokeOnOpen"
              }
            ]
          },
          on: {
            "CONTROLLED.OPEN": "open",
            "CONTROLLED.CLOSE": "closed",
            CONTEXT_MENU_CANCEL: [
              {
                guard: "isOpenControlled",
                actions: "invokeOnClose"
              },
              {
                target: "closed",
                actions: "invokeOnClose"
              }
            ]
          }
        },
        opening: {
          tags: ["closed"],
          after: {
            SUBMENU_OPEN_DELAY: [
              {
                guard: "isOpenControlled",
                actions: "invokeOnOpen"
              },
              {
                target: "open",
                actions: "invokeOnOpen"
              }
            ]
          },
          on: {
            "CONTROLLED.OPEN": "open",
            "CONTROLLED.CLOSE": "closed",
            BLUR: [
              {
                guard: "isOpenControlled",
                actions: "invokeOnClose"
              },
              {
                target: "closed",
                actions: "invokeOnClose"
              }
            ],
            TRIGGER_POINTERLEAVE: [
              {
                guard: "isOpenControlled",
                actions: "invokeOnClose"
              },
              {
                target: "closed",
                actions: "invokeOnClose"
              }
            ]
          }
        },
        closing: {
          tags: ["open"],
          activities: ["trackPointerMove", "trackInteractOutside"],
          after: {
            SUBMENU_CLOSE_DELAY: [
              {
                guard: "isOpenControlled",
                actions: ["invokeOnClose"]
              },
              {
                target: "closed",
                actions: ["focusParentMenu", "restoreParentHighlightedItem", "invokeOnClose"]
              }
            ]
          },
          on: {
            "CONTROLLED.OPEN": "open",
            "CONTROLLED.CLOSE": {
              target: "closed",
              actions: ["focusParentMenu", "restoreParentHighlightedItem"]
            },
            // don't invoke on open here since the menu is still open (we're only keeping it open)
            MENU_POINTERENTER: {
              target: "open",
              actions: "clearIntentPolygon"
            },
            POINTER_MOVED_AWAY_FROM_SUBMENU: [
              {
                guard: "isOpenControlled",
                actions: "invokeOnClose"
              },
              {
                target: "closed",
                actions: ["focusParentMenu", "restoreParentHighlightedItem"]
              }
            ]
          }
        },
        closed: {
          tags: ["closed"],
          entry: ["clearHighlightedItem", "focusTrigger", "resumePointer"],
          on: {
            "CONTROLLED.OPEN": [
              {
                guard: or2("isOpenAutoFocusEvent", "isArrowDownEvent"),
                target: "open",
                actions: "highlightFirstItem"
              },
              {
                guard: "isArrowUpEvent",
                target: "open",
                actions: "highlightLastItem"
              },
              {
                target: "open"
              }
            ],
            CONTEXT_MENU_START: {
              target: "opening:contextmenu",
              actions: "setAnchorPoint"
            },
            CONTEXT_MENU: [
              {
                guard: "isOpenControlled",
                actions: ["setAnchorPoint", "invokeOnOpen"]
              },
              {
                target: "open",
                actions: ["setAnchorPoint", "invokeOnOpen"]
              }
            ],
            TRIGGER_CLICK: [
              {
                guard: "isOpenControlled",
                actions: "invokeOnOpen"
              },
              {
                target: "open",
                actions: "invokeOnOpen"
              }
            ],
            TRIGGER_POINTERMOVE: {
              guard: "isTriggerItem",
              target: "opening"
            },
            TRIGGER_BLUR: "idle",
            ARROW_DOWN: [
              {
                guard: "isOpenControlled",
                actions: "invokeOnOpen"
              },
              {
                target: "open",
                actions: ["highlightFirstItem", "invokeOnOpen"]
              }
            ],
            ARROW_UP: [
              {
                guard: "isOpenControlled",
                actions: "invokeOnOpen"
              },
              {
                target: "open",
                actions: ["highlightLastItem", "invokeOnOpen"]
              }
            ]
          }
        },
        open: {
          tags: ["open"],
          activities: ["trackInteractOutside", "trackPositioning", "scrollToHighlightedItem"],
          entry: ["focusMenu", "resumePointer"],
          on: {
            "CONTROLLED.CLOSE": [
              {
                target: "closed",
                guard: "isArrowLeftEvent",
                actions: ["focusParentMenu"]
              },
              {
                target: "closed"
              }
            ],
            TRIGGER_CLICK: [
              {
                guard: and5(not3("isTriggerItem"), "isOpenControlled"),
                actions: "invokeOnClose"
              },
              {
                guard: not3("isTriggerItem"),
                target: "closed",
                actions: "invokeOnClose"
              }
            ],
            ARROW_UP: {
              actions: ["highlightPrevItem", "focusMenu"]
            },
            ARROW_DOWN: {
              actions: ["highlightNextItem", "focusMenu"]
            },
            ARROW_LEFT: [
              {
                guard: and5("isSubmenu", "isOpenControlled"),
                actions: "invokeOnClose"
              },
              {
                guard: "isSubmenu",
                target: "closed",
                actions: ["focusParentMenu", "invokeOnClose"]
              }
            ],
            HOME: {
              actions: ["highlightFirstItem", "focusMenu"]
            },
            END: {
              actions: ["highlightLastItem", "focusMenu"]
            },
            ARROW_RIGHT: {
              guard: "isTriggerItemHighlighted",
              actions: "openSubmenu"
            },
            ENTER: [
              {
                guard: "isTriggerItemHighlighted",
                actions: "openSubmenu"
              },
              {
                actions: "clickHighlightedItem"
              }
            ],
            ITEM_POINTERMOVE: [
              {
                guard: not3("suspendPointer"),
                actions: ["setHighlightedItem", "focusMenu"]
              },
              {
                actions: "setLastHighlightedItem"
              }
            ],
            ITEM_POINTERLEAVE: {
              guard: and5(not3("suspendPointer"), not3("isTriggerItem")),
              actions: "clearHighlightedItem"
            },
            ITEM_CLICK: [
              // == grouped ==
              {
                guard: and5(
                  not3("isTriggerItemHighlighted"),
                  not3("isHighlightedItemEditable"),
                  "closeOnSelect",
                  "isOpenControlled"
                ),
                actions: ["invokeOnSelect", "setOptionState", "closeRootMenu", "invokeOnClose"]
              },
              {
                guard: and5(not3("isTriggerItemHighlighted"), not3("isHighlightedItemEditable"), "closeOnSelect"),
                target: "closed",
                actions: ["invokeOnSelect", "setOptionState", "closeRootMenu", "invokeOnClose"]
              },
              //
              {
                guard: and5(not3("isTriggerItemHighlighted"), not3("isHighlightedItemEditable")),
                actions: ["invokeOnSelect", "setOptionState"]
              },
              { actions: "setHighlightedItem" }
            ],
            TRIGGER_POINTERLEAVE: {
              target: "closing",
              actions: "setIntentPolygon"
            },
            ITEM_POINTERDOWN: {
              actions: "setHighlightedItem"
            },
            TYPEAHEAD: {
              actions: "highlightMatchedItem"
            },
            FOCUS_MENU: {
              actions: "focusMenu"
            },
            "POSITIONING.SET": {
              actions: "reposition"
            }
          }
        }
      }
    },
    {
      delays: {
        LONG_PRESS_DELAY: 700,
        SUBMENU_OPEN_DELAY: 100,
        SUBMENU_CLOSE_DELAY: 100
      },
      guards: {
        closeOnSelect: (ctx2, evt) => !!((evt == null ? void 0 : evt.closeOnSelect) ?? ctx2.closeOnSelect),
        // whether the trigger is also a menu item
        isTriggerItem: (_ctx, evt) => dom8.isTriggerItem(evt.target),
        // whether the trigger item is the active item
        isTriggerItemHighlighted: (ctx2, evt) => {
          const target = evt.target ?? dom8.getHighlightedItemEl(ctx2);
          return !!(target == null ? void 0 : target.hasAttribute("aria-controls"));
        },
        isSubmenu: (ctx2) => ctx2.isSubmenu,
        suspendPointer: (ctx2) => ctx2.suspendPointer,
        isHighlightedItemEditable: (ctx2) => isEditableElement(dom8.getHighlightedItemEl(ctx2)),
        isWithinPolygon: (ctx2, evt) => {
          if (!ctx2.intentPolygon) return false;
          return isPointInPolygon(ctx2.intentPolygon, evt.point);
        },
        // guard assertions (for controlled mode)
        isOpenControlled: (ctx2) => !!ctx2["open.controlled"],
        isArrowLeftEvent: (_ctx, evt) => {
          var _a8;
          return ((_a8 = evt.previousEvent) == null ? void 0 : _a8.type) === "ARROW_LEFT";
        },
        isArrowUpEvent: (_ctx, evt) => {
          var _a8;
          return ((_a8 = evt.previousEvent) == null ? void 0 : _a8.type) === "ARROW_UP";
        },
        isArrowDownEvent: (_ctx, evt) => {
          var _a8;
          return ((_a8 = evt.previousEvent) == null ? void 0 : _a8.type) === "ARROW_DOWN";
        },
        isOpenAutoFocusEvent: (_ctx, evt) => {
          var _a8;
          return ((_a8 = evt.previousEvent) == null ? void 0 : _a8.type) === "OPEN_AUTOFOCUS";
        }
      },
      activities: {
        trackPositioning(ctx2) {
          if (ctx2.anchorPoint) return;
          ctx2.currentPlacement = ctx2.positioning.placement;
          const getPositionerEl = () => dom8.getPositionerEl(ctx2);
          return getPlacement(dom8.getTriggerEl(ctx2), getPositionerEl, {
            ...ctx2.positioning,
            defer: true,
            onComplete(data) {
              ctx2.currentPlacement = data.placement;
            }
          });
        },
        trackInteractOutside(ctx2, _evt, { send }) {
          const getContentEl = () => dom8.getContentEl(ctx2);
          let restoreFocus = true;
          return trackDismissableElement(getContentEl, {
            defer: true,
            exclude: [dom8.getTriggerEl(ctx2)],
            onInteractOutside: ctx2.onInteractOutside,
            onFocusOutside: ctx2.onFocusOutside,
            onEscapeKeyDown(event) {
              var _a8;
              (_a8 = ctx2.onEscapeKeyDown) == null ? void 0 : _a8.call(ctx2, event);
              if (ctx2.isSubmenu) event.preventDefault();
              closeRootMenu(ctx2);
            },
            onPointerDownOutside(event) {
              var _a8;
              restoreFocus = !event.detail.focusable;
              (_a8 = ctx2.onPointerDownOutside) == null ? void 0 : _a8.call(ctx2, event);
            },
            onDismiss() {
              send({ type: "CLOSE", src: "interact-outside", restoreFocus });
            }
          });
        },
        trackPointerMove(ctx2, _evt, { guards: guards2, send }) {
          const { isWithinPolygon } = guards2;
          ctx2.parent.state.context.suspendPointer = true;
          const doc = dom8.getDoc(ctx2);
          return addDomEvent(doc, "pointermove", (e) => {
            const point = { x: e.clientX, y: e.clientY };
            const isMovingToSubmenu = isWithinPolygon(ctx2, { point });
            if (!isMovingToSubmenu) {
              send("POINTER_MOVED_AWAY_FROM_SUBMENU");
              ctx2.parent.state.context.suspendPointer = false;
            }
          });
        },
        scrollToHighlightedItem(ctx2, _evt, { getState }) {
          const exec2 = () => {
            const state2 = getState();
            if (state2.event.type.startsWith("ITEM_POINTER")) return;
            const itemEl = dom8.getHighlightedItemEl(ctx2);
            const contentEl2 = dom8.getContentEl(ctx2);
            scrollIntoView(itemEl, { rootEl: contentEl2, block: "nearest" });
          };
          raf(() => exec2());
          const contentEl = () => dom8.getContentEl(ctx2);
          return observeAttributes(contentEl, {
            defer: true,
            attributes: ["aria-activedescendant"],
            callback: exec2
          });
        }
      },
      actions: {
        setAnchorPoint(ctx2, evt) {
          ctx2.anchorPoint = evt.point;
        },
        setSubmenuPlacement(ctx2) {
          if (!ctx2.isSubmenu) return;
          ctx2.positioning.placement = ctx2.isRtl ? "left-start" : "right-start";
          ctx2.positioning.gutter = 0;
        },
        reposition(ctx2, evt) {
          const getPositionerEl = () => dom8.getPositionerEl(ctx2);
          const getAnchorRect = ctx2.anchorPoint ? () => ({ width: 0, height: 0, ...ctx2.anchorPoint }) : void 0;
          getPlacement(dom8.getTriggerEl(ctx2), getPositionerEl, {
            ...ctx2.positioning,
            defer: true,
            getAnchorRect,
            ...evt.options ?? {},
            listeners: false,
            onComplete(data) {
              ctx2.currentPlacement = data.placement;
            }
          });
        },
        setOptionState(_ctx, evt) {
          if (!evt.option) return;
          const { checked, onCheckedChange, type } = evt.option;
          if (type === "radio") {
            onCheckedChange == null ? void 0 : onCheckedChange(true);
          } else if (type === "checkbox") {
            onCheckedChange == null ? void 0 : onCheckedChange(!checked);
          }
        },
        clickHighlightedItem(ctx2, _evt) {
          const itemEl = dom8.getHighlightedItemEl(ctx2);
          if (!itemEl || itemEl.dataset.disabled) return;
          queueMicrotask(() => itemEl.click());
        },
        setIntentPolygon(ctx2, evt) {
          const menu = dom8.getContentEl(ctx2);
          const placement = ctx2.currentPlacement;
          if (!menu || !placement) return;
          const rect = menu.getBoundingClientRect();
          const polygon = getElementPolygon(rect, placement);
          if (!polygon) return;
          const rightSide = getPlacementSide(placement) === "right";
          const bleed = rightSide ? -5 : 5;
          ctx2.intentPolygon = [{ ...evt.point, x: evt.point.x + bleed }, ...polygon];
        },
        clearIntentPolygon(ctx2) {
          ctx2.intentPolygon = null;
        },
        resumePointer(ctx2) {
          if (!ctx2.parent) return;
          ctx2.parent.state.context.suspendPointer = false;
        },
        setHighlightedItem(ctx2, evt) {
          set8.highlighted(ctx2, evt.id);
        },
        clearHighlightedItem(ctx2) {
          set8.highlighted(ctx2, null);
        },
        focusMenu(ctx2) {
          raf(() => {
            const contentEl = dom8.getContentEl(ctx2);
            const initialFocusEl = getInitialFocus({
              root: contentEl,
              enabled: !contains(contentEl, dom8.getActiveElement(ctx2)),
              filter(node) {
                var _a8;
                return !((_a8 = node.role) == null ? void 0 : _a8.startsWith("menuitem"));
              }
            });
            initialFocusEl == null ? void 0 : initialFocusEl.focus({ preventScroll: true });
          });
        },
        highlightFirstItem(ctx2) {
          const fn = !!dom8.getContentEl(ctx2) ? queueMicrotask : raf;
          fn(() => {
            const first2 = dom8.getFirstEl(ctx2);
            if (!first2) return;
            set8.highlighted(ctx2, first2.id);
          });
        },
        highlightLastItem(ctx2) {
          const fn = !!dom8.getContentEl(ctx2) ? queueMicrotask : raf;
          fn(() => {
            const last2 = dom8.getLastEl(ctx2);
            if (!last2) return;
            set8.highlighted(ctx2, last2.id);
          });
        },
        highlightNextItem(ctx2, evt) {
          const next2 = dom8.getNextEl(ctx2, evt.loop);
          set8.highlighted(ctx2, (next2 == null ? void 0 : next2.id) ?? null);
        },
        highlightPrevItem(ctx2, evt) {
          const prev2 = dom8.getPrevEl(ctx2, evt.loop);
          set8.highlighted(ctx2, (prev2 == null ? void 0 : prev2.id) ?? null);
        },
        invokeOnSelect(ctx2) {
          var _a8;
          if (!ctx2.highlightedValue) return;
          (_a8 = ctx2.onSelect) == null ? void 0 : _a8.call(ctx2, { value: ctx2.highlightedValue });
        },
        focusTrigger(ctx2, evt) {
          if (ctx2.isSubmenu || ctx2.anchorPoint || evt.restoreFocus === false) return;
          queueMicrotask(() => {
            var _a8;
            return (_a8 = dom8.getTriggerEl(ctx2)) == null ? void 0 : _a8.focus({ preventScroll: true });
          });
        },
        highlightMatchedItem(ctx2, evt) {
          const node = dom8.getElemByKey(ctx2, evt.key);
          if (!node) return;
          set8.highlighted(ctx2, node.id);
        },
        setParentMenu(ctx2, evt) {
          ctx2.parent = ref(evt.value);
        },
        setChildMenu(ctx2, evt) {
          ctx2.children[evt.id] = ref(evt.value);
        },
        closeRootMenu(ctx2) {
          closeRootMenu(ctx2);
        },
        openSubmenu(ctx2) {
          const item = dom8.getHighlightedItemEl(ctx2);
          const id = item == null ? void 0 : item.getAttribute("data-uid");
          const child = id ? ctx2.children[id] : null;
          child == null ? void 0 : child.send("OPEN_AUTOFOCUS");
        },
        focusParentMenu(ctx2) {
          var _a8;
          (_a8 = ctx2.parent) == null ? void 0 : _a8.send("FOCUS_MENU");
        },
        setLastHighlightedItem(ctx2, evt) {
          ctx2.lastHighlightedValue = evt.id;
        },
        restoreHighlightedItem(ctx2) {
          if (!ctx2.lastHighlightedValue) return;
          set8.highlighted(ctx2, ctx2.lastHighlightedValue);
          ctx2.lastHighlightedValue = null;
        },
        restoreParentHighlightedItem(ctx2) {
          var _a8;
          (_a8 = ctx2.parent) == null ? void 0 : _a8.send("HIGHLIGHTED.RESTORE");
        },
        invokeOnOpen(ctx2) {
          var _a8;
          (_a8 = ctx2.onOpenChange) == null ? void 0 : _a8.call(ctx2, { open: true });
        },
        invokeOnClose(ctx2) {
          var _a8;
          (_a8 = ctx2.onOpenChange) == null ? void 0 : _a8.call(ctx2, { open: false });
        },
        toggleVisibility(ctx2, evt, { send }) {
          send({ type: ctx2.open ? "CONTROLLED.OPEN" : "CONTROLLED.CLOSE", previousEvent: evt });
        }
      }
    }
  );
}
function closeRootMenu(ctx) {
  let parent = ctx.parent;
  while (parent && parent.state.context.isSubmenu) {
    parent = parent.state.context.parent;
  }
  parent == null ? void 0 : parent.send("CLOSE");
}
var set8 = {
  highlighted(ctx, value) {
    var _a8;
    if (isEqual(ctx.highlightedValue, value)) return;
    ctx.highlightedValue = value;
    (_a8 = ctx.onHighlightChange) == null ? void 0 : _a8.call(ctx, { highlightedValue: value });
  }
};
var props8 = createProps2()([
  "anchorPoint",
  "aria-label",
  "closeOnSelect",
  "composite",
  "dir",
  "getRootNode",
  "highlightedValue",
  "id",
  "ids",
  "loopFocus",
  "navigate",
  "onEscapeKeyDown",
  "onFocusOutside",
  "onHighlightChange",
  "onInteractOutside",
  "onOpenChange",
  "onPointerDownOutside",
  "onSelect",
  "open.controlled",
  "open",
  "positioning",
  "typeahead"
]);
var splitProps9 = createSplitProps(props8);
var itemProps3 = createProps2()(["closeOnSelect", "disabled", "value", "valueText"]);
var splitItemProps3 = createSplitProps(itemProps3);
var itemGroupLabelProps = createProps2()(["htmlFor"]);
var splitItemGroupLabelProps = createSplitProps(itemGroupLabelProps);
var itemGroupProps = createProps2()(["id"]);
var splitItemGroupProps = createSplitProps(itemGroupProps);
var optionItemProps = createProps2()([
  "disabled",
  "valueText",
  "closeOnSelect",
  "type",
  "value",
  "checked",
  "onCheckedChange"
]);
var splitOptionItemProps = createSplitProps(optionItemProps);

// node_modules/@ark-ui/react/dist/components/menu/use-menu.js
var import_react157 = __toESM(require_react(), 1);
var useMenu = (props21 = {}) => {
  const { getRootNode } = useEnvironmentContext();
  const { dir } = useLocaleContext();
  const initialContext = {
    id: (0, import_react157.useId)(),
    dir,
    getRootNode,
    open: props21.defaultOpen,
    "open.controlled": props21.open !== void 0,
    ...props21
  };
  const context = {
    ...initialContext,
    onOpenChange: useEvent(props21.onOpenChange),
    onSelect: useEvent(props21.onSelect)
  };
  const [state2, send, machine24] = useMachine(machine9(initialContext), { context });
  const api = connect9(state2, send, normalizeProps);
  return { api, machine: machine24 };
};

// node_modules/@ark-ui/react/dist/components/menu/use-menu-machine-context.js
var [MenuMachineProvider, useMenuMachineContext] = createContext({
  name: "MenuMachineContext",
  hookName: "useMenuMachineContext",
  providerName: "<MenuMachineProvider />",
  strict: false
});

// node_modules/@ark-ui/react/dist/components/menu/use-menu-trigger-item-context.js
var [MenuTriggerItemProvider, useMenuTriggerItemContext] = createContext({
  name: "MenuMachineContext",
  hookName: "useMenuMachineContext",
  providerName: "<MenuMachineProvider />",
  strict: false
});

// node_modules/@ark-ui/react/dist/components/menu/menu-root.js
var MenuRoot = (props21) => {
  const [presenceProps, menuProps] = splitPresenceProps(props21);
  const [useMenuProps, localProps] = createSplitProps2()(menuProps, [
    "anchorPoint",
    "aria-label",
    "closeOnSelect",
    "composite",
    "defaultOpen",
    "highlightedValue",
    "id",
    "ids",
    "loopFocus",
    "navigate",
    "onEscapeKeyDown",
    "onFocusOutside",
    "onHighlightChange",
    "onInteractOutside",
    "onOpenChange",
    "onPointerDownOutside",
    "onSelect",
    "open",
    "positioning",
    "typeahead"
  ]);
  const parentApi = useMenuContext();
  const parentMachine = useMenuMachineContext();
  const { api, machine: machine24 } = useMenu(useMenuProps);
  const presence = usePresence(mergeProps({ present: api.open }, presenceProps));
  useEffectOnce(() => {
    if (!parentMachine) return;
    if (!parentApi) return;
    parentApi.setChild(machine24);
    api.setParent(parentMachine);
  });
  const triggerItemContext = (0, import_react159.useCallback)(
    () => parentApi == null ? void 0 : parentApi.getTriggerItemProps(api),
    [api, parentApi]
  );
  return (0, import_jsx_runtime71.jsx)(MenuTriggerItemProvider, { value: triggerItemContext, children: (0, import_jsx_runtime71.jsx)(MenuMachineProvider, { value: machine24, children: (0, import_jsx_runtime71.jsx)(MenuProvider, { value: api, children: (0, import_jsx_runtime71.jsx)(PresenceProvider, { value: presence, ...localProps }) }) }) });
};

// node_modules/@ark-ui/react/dist/components/menu/menu-root-provider.js
var import_jsx_runtime72 = __toESM(require_jsx_runtime(), 1);
var import_react161 = __toESM(require_react(), 1);
var MenuRootProvider = (props21) => {
  const parentApi = useMenuContext();
  const parentMachine = useMenuMachineContext();
  const [presenceProps, { value: menu, children }] = splitPresenceProps(props21);
  const { api, machine: machine24 } = menu;
  const presence = usePresence(mergeProps({ present: api.open }, presenceProps));
  useEffectOnce(() => {
    if (!parentMachine) return;
    if (!parentApi) return;
    parentApi.setChild(machine24);
    api.setParent(parentMachine);
  });
  const triggerItemContext = (0, import_react161.useCallback)(
    () => parentApi == null ? void 0 : parentApi.getTriggerItemProps(api),
    [api, parentApi]
  );
  return (0, import_jsx_runtime72.jsx)(MenuTriggerItemProvider, { value: triggerItemContext, children: (0, import_jsx_runtime72.jsx)(MenuMachineProvider, { value: machine24, children: (0, import_jsx_runtime72.jsx)(MenuProvider, { value: api, children: (0, import_jsx_runtime72.jsx)(PresenceProvider, { value: presence, children }) }) }) });
};

// node_modules/@ark-ui/react/dist/components/menu/menu-separator.js
var import_jsx_runtime73 = __toESM(require_jsx_runtime(), 1);
var import_react163 = __toESM(require_react(), 1);
var MenuSeparator = (0, import_react163.forwardRef)((props21, ref2) => {
  const menu = useMenuContext();
  const mergedProps = mergeProps(menu.getSeparatorProps(), props21);
  return (0, import_jsx_runtime73.jsx)(ark.hr, { ...mergedProps, ref: ref2 });
});
MenuSeparator.displayName = "MenuSeparator";

// node_modules/@ark-ui/react/dist/components/menu/menu-trigger.js
var import_jsx_runtime74 = __toESM(require_jsx_runtime(), 1);
var import_react165 = __toESM(require_react(), 1);
var MenuTrigger = (0, import_react165.forwardRef)((props21, ref2) => {
  const menu = useMenuContext();
  const presence = usePresenceContext();
  const mergedProps = mergeProps(
    {
      ...menu.getTriggerProps(),
      "aria-controls": presence.unmounted ? void 0 : menu.getTriggerProps()["aria-controls"]
    },
    props21
  );
  return (0, import_jsx_runtime74.jsx)(ark.button, { ...mergedProps, ref: ref2 });
});
MenuTrigger.displayName = "MenuTrigger";

// node_modules/@ark-ui/react/dist/components/menu/menu-trigger-item.js
var import_jsx_runtime75 = __toESM(require_jsx_runtime(), 1);
var import_react167 = __toESM(require_react(), 1);
var MenuTriggerItem = (0, import_react167.forwardRef)((props21, ref2) => {
  const getTriggerItemProps = useMenuTriggerItemContext();
  const mergedProps = mergeProps((getTriggerItemProps == null ? void 0 : getTriggerItemProps()) ?? {}, props21);
  return (0, import_jsx_runtime75.jsx)(ark.div, { ...mergedProps, ref: ref2 });
});
MenuTriggerItem.displayName = "MenuTriggerItem";

// node_modules/@ark-ui/react/dist/components/menu/menu.js
var menu_exports = {};
__export(menu_exports, {
  Arrow: () => MenuArrow,
  ArrowTip: () => MenuArrowTip,
  CheckboxItem: () => MenuCheckboxItem,
  Content: () => MenuContent,
  Context: () => MenuContext,
  ContextTrigger: () => MenuContextTrigger,
  Indicator: () => MenuIndicator,
  Item: () => MenuItem,
  ItemContext: () => MenuItemContext,
  ItemGroup: () => MenuItemGroup,
  ItemGroupLabel: () => MenuItemGroupLabel,
  ItemIndicator: () => MenuItemIndicator,
  ItemText: () => MenuItemText,
  Positioner: () => MenuPositioner,
  RadioItem: () => MenuRadioItem,
  RadioItemGroup: () => MenuRadioItemGroup,
  Root: () => MenuRoot,
  RootProvider: () => MenuRootProvider,
  Separator: () => MenuSeparator,
  Trigger: () => MenuTrigger,
  TriggerItem: () => MenuTriggerItem
});

// node_modules/@ark-ui/react/dist/components/popover/popover-anchor.js
var import_jsx_runtime76 = __toESM(require_jsx_runtime(), 1);
var import_react169 = __toESM(require_react(), 1);

// node_modules/@ark-ui/react/dist/components/popover/use-popover-context.js
var [PopoverProvider, usePopoverContext] = createContext({
  name: "PopoverContext",
  hookName: "usePopoverContext",
  providerName: "<PopoverProvider />"
});

// node_modules/@ark-ui/react/dist/components/popover/popover-anchor.js
var PopoverAnchor = (0, import_react169.forwardRef)((props21, ref2) => {
  const popover = usePopoverContext();
  const mergedProps = mergeProps(popover.getAnchorProps(), props21);
  return (0, import_jsx_runtime76.jsx)(ark.div, { ...mergedProps, ref: ref2 });
});
PopoverAnchor.displayName = "PopoverAnchor";

// node_modules/@ark-ui/react/dist/components/popover/popover-arrow.js
var import_jsx_runtime77 = __toESM(require_jsx_runtime(), 1);
var import_react171 = __toESM(require_react(), 1);
var PopoverArrow = (0, import_react171.forwardRef)((props21, ref2) => {
  const popover = usePopoverContext();
  const mergedProps = mergeProps(popover.getArrowProps(), props21);
  return (0, import_jsx_runtime77.jsx)(ark.div, { ...mergedProps, ref: ref2 });
});
PopoverArrow.displayName = "PopoverArrow";

// node_modules/@ark-ui/react/dist/components/popover/popover-arrow-tip.js
var import_jsx_runtime78 = __toESM(require_jsx_runtime(), 1);
var import_react173 = __toESM(require_react(), 1);
var PopoverArrowTip = (0, import_react173.forwardRef)((props21, ref2) => {
  const popover = usePopoverContext();
  const mergedProps = mergeProps(popover.getArrowTipProps(), props21);
  return (0, import_jsx_runtime78.jsx)(ark.div, { ...mergedProps, ref: ref2 });
});
PopoverArrowTip.displayName = "PopoverArrowTip";

// node_modules/@ark-ui/react/dist/components/popover/popover-close-trigger.js
var import_jsx_runtime79 = __toESM(require_jsx_runtime(), 1);
var import_react175 = __toESM(require_react(), 1);
var PopoverCloseTrigger = (0, import_react175.forwardRef)(
  (props21, ref2) => {
    const popover = usePopoverContext();
    const mergedProps = mergeProps(popover.getCloseTriggerProps(), props21);
    return (0, import_jsx_runtime79.jsx)(ark.button, { ...mergedProps, ref: ref2 });
  }
);
PopoverCloseTrigger.displayName = "PopoverCloseTrigger";

// node_modules/@ark-ui/react/dist/components/popover/popover-content.js
var import_jsx_runtime80 = __toESM(require_jsx_runtime(), 1);
var import_react177 = __toESM(require_react(), 1);
var PopoverContent = (0, import_react177.forwardRef)((props21, ref2) => {
  const popover = usePopoverContext();
  const presence = usePresenceContext();
  const mergedProps = mergeProps(popover.getContentProps(), presence.getPresenceProps(), props21);
  if (presence.unmounted) {
    return null;
  }
  return (0, import_jsx_runtime80.jsx)(ark.div, { ...mergedProps, ref: composeRefs(presence.ref, ref2) });
});
PopoverContent.displayName = "PopoverContent";

// node_modules/@ark-ui/react/dist/components/popover/popover-context.js
var PopoverContext = (props21) => props21.children(usePopoverContext());

// node_modules/@ark-ui/react/dist/components/popover/popover-description.js
var import_jsx_runtime81 = __toESM(require_jsx_runtime(), 1);
var import_react179 = __toESM(require_react(), 1);
var PopoverDescription = (0, import_react179.forwardRef)(
  (props21, ref2) => {
    const popover = usePopoverContext();
    const mergedProps = mergeProps(popover.getDescriptionProps(), props21);
    return (0, import_jsx_runtime81.jsx)(ark.div, { ...mergedProps, ref: ref2 });
  }
);
PopoverDescription.displayName = "PopoverDescription";

// node_modules/@ark-ui/react/dist/components/popover/popover-indicator.js
var import_jsx_runtime82 = __toESM(require_jsx_runtime(), 1);
var import_react181 = __toESM(require_react(), 1);
var PopoverIndicator = (0, import_react181.forwardRef)((props21, ref2) => {
  const popover = usePopoverContext();
  const mergedProps = mergeProps(popover.getIndicatorProps(), props21);
  return (0, import_jsx_runtime82.jsx)(ark.div, { ...mergedProps, ref: ref2 });
});
PopoverIndicator.displayName = "PopoverIndicator";

// node_modules/@ark-ui/react/dist/components/popover/popover-positioner.js
var import_jsx_runtime83 = __toESM(require_jsx_runtime(), 1);
var import_react183 = __toESM(require_react(), 1);
var PopoverPositioner = (0, import_react183.forwardRef)(
  (props21, ref2) => {
    const popover = usePopoverContext();
    const presence = usePresenceContext();
    const mergedProps = mergeProps(popover.getPositionerProps(), props21);
    if (presence.unmounted) {
      return null;
    }
    return (0, import_jsx_runtime83.jsx)(ark.div, { ...mergedProps, ref: ref2 });
  }
);
PopoverPositioner.displayName = "PopoverPositioner";

// node_modules/@ark-ui/react/dist/components/popover/popover-root.js
var import_jsx_runtime84 = __toESM(require_jsx_runtime(), 1);

// node_modules/@zag-js/popover/dist/index.mjs
var anatomy9 = createAnatomy("popover").parts(
  "arrow",
  "arrowTip",
  "anchor",
  "trigger",
  "indicator",
  "positioner",
  "content",
  "title",
  "description",
  "closeTrigger"
);
var parts11 = anatomy9.build();
var dom9 = createScope({
  getAnchorId: (ctx) => {
    var _a8;
    return ((_a8 = ctx.ids) == null ? void 0 : _a8.anchor) ?? `popover:${ctx.id}:anchor`;
  },
  getTriggerId: (ctx) => {
    var _a8;
    return ((_a8 = ctx.ids) == null ? void 0 : _a8.trigger) ?? `popover:${ctx.id}:trigger`;
  },
  getContentId: (ctx) => {
    var _a8;
    return ((_a8 = ctx.ids) == null ? void 0 : _a8.content) ?? `popover:${ctx.id}:content`;
  },
  getPositionerId: (ctx) => {
    var _a8;
    return ((_a8 = ctx.ids) == null ? void 0 : _a8.positioner) ?? `popover:${ctx.id}:popper`;
  },
  getArrowId: (ctx) => {
    var _a8;
    return ((_a8 = ctx.ids) == null ? void 0 : _a8.arrow) ?? `popover:${ctx.id}:arrow`;
  },
  getTitleId: (ctx) => {
    var _a8;
    return ((_a8 = ctx.ids) == null ? void 0 : _a8.title) ?? `popover:${ctx.id}:title`;
  },
  getDescriptionId: (ctx) => {
    var _a8;
    return ((_a8 = ctx.ids) == null ? void 0 : _a8.description) ?? `popover:${ctx.id}:desc`;
  },
  getCloseTriggerId: (ctx) => {
    var _a8;
    return ((_a8 = ctx.ids) == null ? void 0 : _a8.closeTrigger) ?? `popover:${ctx.id}:close`;
  },
  getAnchorEl: (ctx) => dom9.getById(ctx, dom9.getAnchorId(ctx)),
  getTriggerEl: (ctx) => dom9.getById(ctx, dom9.getTriggerId(ctx)),
  getContentEl: (ctx) => dom9.getById(ctx, dom9.getContentId(ctx)),
  getPositionerEl: (ctx) => dom9.getById(ctx, dom9.getPositionerId(ctx)),
  getTitleEl: (ctx) => dom9.getById(ctx, dom9.getTitleId(ctx)),
  getDescriptionEl: (ctx) => dom9.getById(ctx, dom9.getDescriptionId(ctx)),
  getFocusableEls: (ctx) => getFocusables(dom9.getContentEl(ctx)),
  getFirstFocusableEl: (ctx) => dom9.getFocusableEls(ctx)[0]
});
function connect10(state2, send, normalize2) {
  const open = state2.matches("open");
  const currentPlacement = state2.context.currentPlacement;
  const portalled = state2.context.currentPortalled;
  const rendered = state2.context.renderedElements;
  const popperStyles = getPlacementStyles({
    ...state2.context.positioning,
    placement: currentPlacement
  });
  return {
    portalled,
    open,
    setOpen(nextOpen) {
      if (nextOpen === open) return;
      send(nextOpen ? "OPEN" : "CLOSE");
    },
    reposition(options = {}) {
      send({ type: "POSITIONING.SET", options });
    },
    getArrowProps() {
      return normalize2.element({
        id: dom9.getArrowId(state2.context),
        ...parts11.arrow.attrs,
        dir: state2.context.dir,
        style: popperStyles.arrow
      });
    },
    getArrowTipProps() {
      return normalize2.element({
        ...parts11.arrowTip.attrs,
        dir: state2.context.dir,
        style: popperStyles.arrowTip
      });
    },
    getAnchorProps() {
      return normalize2.element({
        ...parts11.anchor.attrs,
        dir: state2.context.dir,
        id: dom9.getAnchorId(state2.context)
      });
    },
    getTriggerProps() {
      return normalize2.button({
        ...parts11.trigger.attrs,
        dir: state2.context.dir,
        type: "button",
        "data-placement": currentPlacement,
        id: dom9.getTriggerId(state2.context),
        "aria-haspopup": "dialog",
        "aria-expanded": open,
        "data-state": open ? "open" : "closed",
        "aria-controls": dom9.getContentId(state2.context),
        onPointerDown(event) {
          if (isSafari()) {
            event.currentTarget.focus();
          }
        },
        onClick(event) {
          if (event.defaultPrevented) return;
          send("TOGGLE");
        },
        onBlur(event) {
          send({ type: "TRIGGER_BLUR", target: event.relatedTarget });
        }
      });
    },
    getIndicatorProps() {
      return normalize2.element({
        ...parts11.indicator.attrs,
        dir: state2.context.dir,
        "data-state": open ? "open" : "closed"
      });
    },
    getPositionerProps() {
      return normalize2.element({
        id: dom9.getPositionerId(state2.context),
        ...parts11.positioner.attrs,
        dir: state2.context.dir,
        style: popperStyles.floating
      });
    },
    getContentProps() {
      return normalize2.element({
        ...parts11.content.attrs,
        dir: state2.context.dir,
        id: dom9.getContentId(state2.context),
        tabIndex: -1,
        role: "dialog",
        hidden: !open,
        "data-state": open ? "open" : "closed",
        "data-expanded": dataAttr(open),
        "aria-labelledby": rendered.title ? dom9.getTitleId(state2.context) : void 0,
        "aria-describedby": rendered.description ? dom9.getDescriptionId(state2.context) : void 0,
        "data-placement": currentPlacement
      });
    },
    getTitleProps() {
      return normalize2.element({
        ...parts11.title.attrs,
        id: dom9.getTitleId(state2.context),
        dir: state2.context.dir
      });
    },
    getDescriptionProps() {
      return normalize2.element({
        ...parts11.description.attrs,
        id: dom9.getDescriptionId(state2.context),
        dir: state2.context.dir
      });
    },
    getCloseTriggerProps() {
      return normalize2.button({
        ...parts11.closeTrigger.attrs,
        dir: state2.context.dir,
        id: dom9.getCloseTriggerId(state2.context),
        type: "button",
        "aria-label": "close",
        onClick(event) {
          if (event.defaultPrevented) return;
          send("CLOSE");
        }
      });
    }
  };
}
function machine10(userContext) {
  const ctx = compact2(userContext);
  return createMachine(
    {
      id: "popover",
      initial: ctx.open ? "open" : "closed",
      context: {
        closeOnInteractOutside: true,
        closeOnEscape: true,
        autoFocus: true,
        modal: false,
        portalled: true,
        positioning: {
          placement: "bottom",
          ...ctx.positioning
        },
        currentPlacement: void 0,
        ...ctx,
        renderedElements: {
          title: true,
          description: true
        }
      },
      computed: {
        currentPortalled: (ctx2) => !!ctx2.modal || !!ctx2.portalled
      },
      watch: {
        open: ["toggleVisibility"]
      },
      entry: ["checkRenderedElements"],
      states: {
        closed: {
          on: {
            "CONTROLLED.OPEN": {
              target: "open",
              actions: ["setInitialFocus"]
            },
            TOGGLE: [
              {
                guard: "isOpenControlled",
                actions: ["invokeOnOpen"]
              },
              {
                target: "open",
                actions: ["invokeOnOpen", "setInitialFocus"]
              }
            ],
            OPEN: [
              {
                guard: "isOpenControlled",
                actions: ["invokeOnOpen"]
              },
              {
                target: "open",
                actions: ["invokeOnOpen", "setInitialFocus"]
              }
            ]
          }
        },
        open: {
          activities: [
            "trapFocus",
            "preventScroll",
            "hideContentBelow",
            "trackPositioning",
            "trackDismissableElement",
            "proxyTabFocus"
          ],
          on: {
            "CONTROLLED.CLOSE": {
              target: "closed",
              actions: ["setFinalFocus"]
            },
            CLOSE: [
              {
                guard: "isOpenControlled",
                actions: ["invokeOnClose"]
              },
              {
                target: "closed",
                actions: ["invokeOnClose", "setFinalFocus"]
              }
            ],
            TOGGLE: [
              {
                guard: "isOpenControlled",
                actions: ["invokeOnClose"]
              },
              {
                target: "closed",
                actions: ["invokeOnClose"]
              }
            ],
            "POSITIONING.SET": {
              actions: "reposition"
            }
          }
        }
      }
    },
    {
      guards: {
        isOpenControlled: (ctx2) => !!ctx2["open.controlled"]
      },
      activities: {
        trackPositioning(ctx2) {
          ctx2.currentPlacement = ctx2.positioning.placement;
          const anchorEl = dom9.getAnchorEl(ctx2) ?? dom9.getTriggerEl(ctx2);
          const getPositionerEl = () => dom9.getPositionerEl(ctx2);
          return getPlacement(anchorEl, getPositionerEl, {
            ...ctx2.positioning,
            defer: true,
            onComplete(data) {
              ctx2.currentPlacement = data.placement;
            }
          });
        },
        trackDismissableElement(ctx2, _evt, { send }) {
          const getContentEl = () => dom9.getContentEl(ctx2);
          let restoreFocus = true;
          return trackDismissableElement(getContentEl, {
            pointerBlocking: ctx2.modal,
            exclude: dom9.getTriggerEl(ctx2),
            defer: true,
            onEscapeKeyDown(event) {
              var _a8;
              (_a8 = ctx2.onEscapeKeyDown) == null ? void 0 : _a8.call(ctx2, event);
              if (ctx2.closeOnEscape) return;
              event.preventDefault();
            },
            onInteractOutside(event) {
              var _a8;
              (_a8 = ctx2.onInteractOutside) == null ? void 0 : _a8.call(ctx2, event);
              if (event.defaultPrevented) return;
              restoreFocus = !(event.detail.focusable || event.detail.contextmenu);
              if (!ctx2.closeOnInteractOutside) {
                event.preventDefault();
              }
            },
            onPointerDownOutside: ctx2.onPointerDownOutside,
            onFocusOutside: ctx2.onFocusOutside,
            persistentElements: ctx2.persistentElements,
            onDismiss() {
              send({ type: "CLOSE", src: "interact-outside", restoreFocus });
            }
          });
        },
        proxyTabFocus(ctx2) {
          if (ctx2.modal || !ctx2.portalled) return;
          const getContentEl = () => dom9.getContentEl(ctx2);
          return proxyTabFocus(getContentEl, {
            triggerElement: dom9.getTriggerEl(ctx2),
            defer: true,
            onFocus(el) {
              el.focus({ preventScroll: true });
            }
          });
        },
        hideContentBelow(ctx2) {
          if (!ctx2.modal) return;
          const getElements = () => [dom9.getContentEl(ctx2), dom9.getTriggerEl(ctx2)];
          return ariaHidden(getElements, { defer: true });
        },
        preventScroll(ctx2) {
          if (!ctx2.modal) return;
          return preventBodyScroll(dom9.getDoc(ctx2));
        },
        trapFocus(ctx2) {
          if (!ctx2.modal) return;
          const contentEl = () => dom9.getContentEl(ctx2);
          return trapFocus(contentEl, {
            initialFocus: () => getInitialFocus({
              root: dom9.getContentEl(ctx2),
              getInitialEl: ctx2.initialFocusEl,
              enabled: ctx2.autoFocus
            })
          });
        }
      },
      actions: {
        reposition(ctx2, evt) {
          const anchorEl = dom9.getAnchorEl(ctx2) ?? dom9.getTriggerEl(ctx2);
          const getPositionerEl = () => dom9.getPositionerEl(ctx2);
          getPlacement(anchorEl, getPositionerEl, {
            ...ctx2.positioning,
            ...evt.options,
            defer: true,
            listeners: false,
            onComplete(data) {
              ctx2.currentPlacement = data.placement;
            }
          });
        },
        checkRenderedElements(ctx2) {
          raf(() => {
            Object.assign(ctx2.renderedElements, {
              title: !!dom9.getTitleEl(ctx2),
              description: !!dom9.getDescriptionEl(ctx2)
            });
          });
        },
        setInitialFocus(ctx2) {
          if (ctx2.modal) return;
          raf(() => {
            const element = getInitialFocus({
              root: dom9.getContentEl(ctx2),
              getInitialEl: ctx2.initialFocusEl,
              enabled: ctx2.autoFocus
            });
            element == null ? void 0 : element.focus({ preventScroll: true });
          });
        },
        setFinalFocus(ctx2, evt) {
          var _a8;
          const restoreFocus = evt.restoreFocus ?? ((_a8 = evt.previousEvent) == null ? void 0 : _a8.restoreFocus);
          if (restoreFocus != null && !restoreFocus) return;
          raf(() => {
            const element = dom9.getTriggerEl(ctx2);
            element == null ? void 0 : element.focus({ preventScroll: true });
          });
        },
        invokeOnOpen(ctx2) {
          var _a8;
          (_a8 = ctx2.onOpenChange) == null ? void 0 : _a8.call(ctx2, { open: true });
        },
        invokeOnClose(ctx2) {
          var _a8;
          (_a8 = ctx2.onOpenChange) == null ? void 0 : _a8.call(ctx2, { open: false });
        },
        toggleVisibility(ctx2, evt, { send }) {
          send({ type: ctx2.open ? "CONTROLLED.OPEN" : "CONTROLLED.CLOSE", previousEvent: evt });
        }
      }
    }
  );
}
var props9 = createProps2()([
  "autoFocus",
  "closeOnEscape",
  "closeOnInteractOutside",
  "dir",
  "getRootNode",
  "id",
  "ids",
  "initialFocusEl",
  "modal",
  "onEscapeKeyDown",
  "onFocusOutside",
  "onInteractOutside",
  "onOpenChange",
  "onPointerDownOutside",
  "open.controlled",
  "open",
  "persistentElements",
  "portalled",
  "positioning"
]);
var splitProps10 = createSplitProps(props9);

// node_modules/@ark-ui/react/dist/components/popover/use-popover.js
var import_react185 = __toESM(require_react(), 1);
var usePopover = (props21 = {}) => {
  const { getRootNode } = useEnvironmentContext();
  const { dir } = useLocaleContext();
  const initialContext = {
    id: (0, import_react185.useId)(),
    dir,
    getRootNode,
    open: props21.defaultOpen,
    "open.controlled": props21.open !== void 0,
    ...props21
  };
  const context = {
    ...initialContext,
    open: props21.open,
    onOpenChange: useEvent(props21.onOpenChange, { sync: true })
  };
  const [state2, send] = useMachine(machine10(initialContext), { context });
  return connect10(state2, send, normalizeProps);
};

// node_modules/@ark-ui/react/dist/components/popover/popover-root.js
var PopoverRoot = (props21) => {
  const [presenceProps, { children, ...localProps }] = splitPresenceProps(props21);
  const popover = usePopover(localProps);
  const presence = usePresence(mergeProps({ present: popover.open }, presenceProps));
  return (0, import_jsx_runtime84.jsx)(PopoverProvider, { value: popover, children: (0, import_jsx_runtime84.jsx)(PresenceProvider, { value: presence, children }) });
};

// node_modules/@ark-ui/react/dist/components/popover/popover-root-provider.js
var import_jsx_runtime85 = __toESM(require_jsx_runtime(), 1);
var PopoverRootProvider = (props21) => {
  const [presenceProps, { value: popover, children }] = splitPresenceProps(props21);
  const presence = usePresence(mergeProps({ present: popover.open }, presenceProps));
  return (0, import_jsx_runtime85.jsx)(PopoverProvider, { value: popover, children: (0, import_jsx_runtime85.jsx)(PresenceProvider, { value: presence, children }) });
};

// node_modules/@ark-ui/react/dist/components/popover/popover-title.js
var import_jsx_runtime86 = __toESM(require_jsx_runtime(), 1);
var import_react189 = __toESM(require_react(), 1);
var PopoverTitle = (0, import_react189.forwardRef)((props21, ref2) => {
  const popover = usePopoverContext();
  const mergedProps = mergeProps(popover.getTitleProps(), props21);
  return (0, import_jsx_runtime86.jsx)(ark.div, { ...mergedProps, ref: ref2 });
});
PopoverTitle.displayName = "PopoverTitle";

// node_modules/@ark-ui/react/dist/components/popover/popover-trigger.js
var import_jsx_runtime87 = __toESM(require_jsx_runtime(), 1);
var import_react191 = __toESM(require_react(), 1);
var PopoverTrigger = (0, import_react191.forwardRef)((props21, ref2) => {
  const popover = usePopoverContext();
  const presence = usePresenceContext();
  const mergedProps = mergeProps(
    {
      ...popover.getTriggerProps(),
      "aria-controls": presence.unmounted ? void 0 : popover.getTriggerProps()["aria-controls"]
    },
    props21
  );
  return (0, import_jsx_runtime87.jsx)(ark.button, { ...mergedProps, ref: ref2 });
});
PopoverTrigger.displayName = "PopoverTrigger";

// node_modules/@ark-ui/react/dist/components/popover/popover.js
var popover_exports = {};
__export(popover_exports, {
  Anchor: () => PopoverAnchor,
  Arrow: () => PopoverArrow,
  ArrowTip: () => PopoverArrowTip,
  CloseTrigger: () => PopoverCloseTrigger,
  Content: () => PopoverContent,
  Context: () => PopoverContext,
  Description: () => PopoverDescription,
  Indicator: () => PopoverIndicator,
  Positioner: () => PopoverPositioner,
  Root: () => PopoverRoot,
  RootProvider: () => PopoverRootProvider,
  Title: () => PopoverTitle,
  Trigger: () => PopoverTrigger
});

// node_modules/@ark-ui/react/dist/components/radio-group/use-radio-group-context.js
var [RadioGroupProvider, useRadioGroupContext] = createContext({
  name: "RadioGroupContext",
  hookName: "useRadioGroupContext",
  providerName: "<RadioGroupProvider />"
});

// node_modules/@ark-ui/react/dist/components/radio-group/radio-group-context.js
var RadioGroupContext = (props21) => props21.children(useRadioGroupContext());

// node_modules/@ark-ui/react/dist/components/radio-group/radio-group-indicator.js
var import_jsx_runtime88 = __toESM(require_jsx_runtime(), 1);
var import_react193 = __toESM(require_react(), 1);
var RadioGroupIndicator = (0, import_react193.forwardRef)(
  (props21, ref2) => {
    const radioGroup = useRadioGroupContext();
    const mergedProps = mergeProps(radioGroup.getIndicatorProps(), props21);
    return (0, import_jsx_runtime88.jsx)(ark.div, { ...mergedProps, ref: ref2 });
  }
);
RadioGroupIndicator.displayName = "RadioGroupIndicator";

// node_modules/@ark-ui/react/dist/components/radio-group/radio-group-item.js
var import_jsx_runtime89 = __toESM(require_jsx_runtime(), 1);
var import_react195 = __toESM(require_react(), 1);

// node_modules/@ark-ui/react/dist/components/radio-group/use-radio-group-item-context.js
var [RadioGroupItemProvider, useRadioGroupItemContext] = createContext({
  name: "RadioGroupItemContext",
  hookName: "useRadioGroupItemContext",
  providerName: "<RadioGroupItemProvider />"
});

// node_modules/@ark-ui/react/dist/components/radio-group/use-radio-group-item-props-context.js
var [RadioGroupItemPropsProvider, useRadioGroupItemPropsContext] = createContext({
  name: "RadioGroupItemPropsContext",
  hookName: "useRadioGroupItemPropsContext",
  providerName: "<RadioGroupItemPropsProvider />"
});

// node_modules/@ark-ui/react/dist/components/radio-group/radio-group-item.js
var RadioGroupItem = (0, import_react195.forwardRef)((props21, ref2) => {
  const [itemProps7, localProps] = createSplitProps2()(props21, [
    "value",
    "disabled",
    "invalid"
  ]);
  const radioGroup = useRadioGroupContext();
  const mergedProps = mergeProps(radioGroup.getItemProps(itemProps7), localProps);
  const itemState = radioGroup.getItemState(itemProps7);
  return (0, import_jsx_runtime89.jsx)(RadioGroupItemProvider, { value: itemState, children: (0, import_jsx_runtime89.jsx)(RadioGroupItemPropsProvider, { value: itemProps7, children: (0, import_jsx_runtime89.jsx)(ark.label, { ...mergedProps, ref: ref2 }) }) });
});
RadioGroupItem.displayName = "RadioGroupItem";

// node_modules/@ark-ui/react/dist/components/radio-group/radio-group-item-context.js
var RadioGroupItemContext = (props21) => props21.children(useRadioGroupItemContext());

// node_modules/@ark-ui/react/dist/components/radio-group/radio-group-item-control.js
var import_jsx_runtime90 = __toESM(require_jsx_runtime(), 1);
var import_react197 = __toESM(require_react(), 1);
var RadioGroupItemControl = (0, import_react197.forwardRef)(
  (props21, ref2) => {
    const radioGroup = useRadioGroupContext();
    const itemProps7 = useRadioGroupItemPropsContext();
    const mergedProps = mergeProps(radioGroup.getItemControlProps(itemProps7), props21);
    return (0, import_jsx_runtime90.jsx)(ark.div, { ...mergedProps, ref: ref2 });
  }
);
RadioGroupItemControl.displayName = "RadioGroupItemControl";

// node_modules/@ark-ui/react/dist/components/radio-group/radio-group-item-hidden-input.js
var import_jsx_runtime91 = __toESM(require_jsx_runtime(), 1);
var import_react199 = __toESM(require_react(), 1);
var RadioGroupItemHiddenInput = (0, import_react199.forwardRef)((props21, ref2) => {
  const radioGroup = useRadioGroupContext();
  const itemProps7 = useRadioGroupItemPropsContext();
  const mergedProps = mergeProps(radioGroup.getItemHiddenInputProps(itemProps7), props21);
  return (0, import_jsx_runtime91.jsx)(ark.input, { ...mergedProps, ref: ref2 });
});
RadioGroupItemHiddenInput.displayName = "RadioGroupItemHiddenInput";

// node_modules/@ark-ui/react/dist/components/radio-group/radio-group-item-text.js
var import_jsx_runtime92 = __toESM(require_jsx_runtime(), 1);
var import_react201 = __toESM(require_react(), 1);
var RadioGroupItemText = (0, import_react201.forwardRef)(
  (props21, ref2) => {
    const radioGroup = useRadioGroupContext();
    const itemProps7 = useRadioGroupItemPropsContext();
    const mergedProps = mergeProps(radioGroup.getItemTextProps(itemProps7), props21);
    return (0, import_jsx_runtime92.jsx)(ark.span, { ...mergedProps, ref: ref2 });
  }
);
RadioGroupItemText.displayName = "RadioGroupItemText";

// node_modules/@ark-ui/react/dist/components/radio-group/radio-group-label.js
var import_jsx_runtime93 = __toESM(require_jsx_runtime(), 1);
var import_react203 = __toESM(require_react(), 1);
var RadioGroupLabel = (0, import_react203.forwardRef)((props21, ref2) => {
  const radioGroup = useRadioGroupContext();
  const mergedProps = mergeProps(radioGroup.getLabelProps(), props21);
  return (0, import_jsx_runtime93.jsx)(ark.label, { ...mergedProps, ref: ref2 });
});
RadioGroupLabel.displayName = "RadioGroupLabel";

// node_modules/@ark-ui/react/dist/components/radio-group/radio-group-root.js
var import_jsx_runtime94 = __toESM(require_jsx_runtime(), 1);
var import_react207 = __toESM(require_react(), 1);

// node_modules/@zag-js/focus-visible/dist/index.mjs
function isVirtualClick(event) {
  if (event.mozInputSource === 0 && event.isTrusted) return true;
  return event.detail === 0 && !event.pointerType;
}
function isValidKey(e) {
  return !(e.metaKey || !isMac() && e.altKey || e.ctrlKey || e.key === "Control" || e.key === "Shift" || e.key === "Meta");
}
var nonTextInputTypes = /* @__PURE__ */ new Set(["checkbox", "radio", "range", "color", "file", "image", "button", "submit", "reset"]);
function isKeyboardFocusEvent(isTextInput, modality, e) {
  const target = e ? getEventTarget(e) : null;
  const win = getWindow(target);
  isTextInput = isTextInput || target instanceof win.HTMLInputElement && !nonTextInputTypes.has(target == null ? void 0 : target.type) || target instanceof win.HTMLTextAreaElement || target instanceof win.HTMLElement && target.isContentEditable;
  return !(isTextInput && modality === "keyboard" && e instanceof win.KeyboardEvent && !Reflect.has(FOCUS_VISIBLE_INPUT_KEYS, e.key));
}
var currentModality = null;
var changeHandlers = /* @__PURE__ */ new Set();
var listenerMap = /* @__PURE__ */ new Map();
var hasEventBeforeFocus = false;
var hasBlurredWindowRecently = false;
var FOCUS_VISIBLE_INPUT_KEYS = {
  Tab: true,
  Escape: true
};
function triggerChangeHandlers(modality, e) {
  for (let handler of changeHandlers) {
    handler(modality, e);
  }
}
function handleKeyboardEvent(e) {
  hasEventBeforeFocus = true;
  if (isValidKey(e)) {
    currentModality = "keyboard";
    triggerChangeHandlers("keyboard", e);
  }
}
function handlePointerEvent(e) {
  currentModality = "pointer";
  if (e.type === "mousedown" || e.type === "pointerdown") {
    hasEventBeforeFocus = true;
    triggerChangeHandlers("pointer", e);
  }
}
function handleClickEvent(e) {
  if (isVirtualClick(e)) {
    hasEventBeforeFocus = true;
    currentModality = "virtual";
  }
}
function handleFocusEvent(e) {
  const target = getEventTarget(e);
  if (target === getWindow(target) || target === getDocument(target)) {
    return;
  }
  if (!hasEventBeforeFocus && !hasBlurredWindowRecently) {
    currentModality = "virtual";
    triggerChangeHandlers("virtual", e);
  }
  hasEventBeforeFocus = false;
  hasBlurredWindowRecently = false;
}
function handleWindowBlur() {
  hasEventBeforeFocus = false;
  hasBlurredWindowRecently = true;
}
function setupGlobalFocusEvents(root) {
  if (typeof window === "undefined" || listenerMap.get(getWindow(root))) {
    return;
  }
  const win = getWindow(root);
  const doc = getDocument(root);
  let focus = win.HTMLElement.prototype.focus;
  win.HTMLElement.prototype.focus = function() {
    currentModality = "virtual";
    triggerChangeHandlers("virtual", null);
    hasEventBeforeFocus = true;
    focus.apply(this, arguments);
  };
  doc.addEventListener("keydown", handleKeyboardEvent, true);
  doc.addEventListener("keyup", handleKeyboardEvent, true);
  doc.addEventListener("click", handleClickEvent, true);
  win.addEventListener("focus", handleFocusEvent, true);
  win.addEventListener("blur", handleWindowBlur, false);
  if (typeof win.PointerEvent !== "undefined") {
    doc.addEventListener("pointerdown", handlePointerEvent, true);
    doc.addEventListener("pointermove", handlePointerEvent, true);
    doc.addEventListener("pointerup", handlePointerEvent, true);
  } else {
    doc.addEventListener("mousedown", handlePointerEvent, true);
    doc.addEventListener("mousemove", handlePointerEvent, true);
    doc.addEventListener("mouseup", handlePointerEvent, true);
  }
  win.addEventListener(
    "beforeunload",
    () => {
      tearDownWindowFocusTracking(root);
    },
    { once: true }
  );
  listenerMap.set(win, { focus });
}
var tearDownWindowFocusTracking = (root, loadListener) => {
  const win = getWindow(root);
  const doc = getDocument(root);
  if (!listenerMap.has(win)) {
    return;
  }
  win.HTMLElement.prototype.focus = listenerMap.get(win).focus;
  doc.removeEventListener("keydown", handleKeyboardEvent, true);
  doc.removeEventListener("keyup", handleKeyboardEvent, true);
  doc.removeEventListener("click", handleClickEvent, true);
  win.removeEventListener("focus", handleFocusEvent, true);
  win.removeEventListener("blur", handleWindowBlur, false);
  if (typeof win.PointerEvent !== "undefined") {
    doc.removeEventListener("pointerdown", handlePointerEvent, true);
    doc.removeEventListener("pointermove", handlePointerEvent, true);
    doc.removeEventListener("pointerup", handlePointerEvent, true);
  } else {
    doc.removeEventListener("mousedown", handlePointerEvent, true);
    doc.removeEventListener("mousemove", handlePointerEvent, true);
    doc.removeEventListener("mouseup", handlePointerEvent, true);
  }
  listenerMap.delete(win);
};
function isFocusVisible() {
  return currentModality === "keyboard";
}
function trackFocusVisible(props21 = {}) {
  const { isTextInput, autoFocus, onChange, root } = props21;
  setupGlobalFocusEvents(root);
  onChange == null ? void 0 : onChange({ isFocusVisible: autoFocus || isFocusVisible(), modality: currentModality });
  const handler = (modality, e) => {
    if (!isKeyboardFocusEvent(!!isTextInput, modality, e)) return;
    onChange == null ? void 0 : onChange({ isFocusVisible: isFocusVisible(), modality });
  };
  changeHandlers.add(handler);
  return () => {
    changeHandlers.delete(handler);
  };
}

// node_modules/@zag-js/element-rect/dist/index.mjs
var rafId;
var observedElements = /* @__PURE__ */ new Map();
var getRectFn = (el) => el.getBoundingClientRect();
function trackElementRect(el, options) {
  const { scope = "rect", getRect = getRectFn, onChange } = options;
  const loop = getLoopFn({ scope, getRect });
  const data = observedElements.get(el);
  if (!data) {
    observedElements.set(el, {
      rect: {},
      callbacks: [onChange]
    });
    if (observedElements.size === 1) {
      rafId = requestAnimationFrame(loop);
    }
  } else {
    data.callbacks.push(onChange);
    onChange(getRect(el));
  }
  return function unobserve() {
    const data2 = observedElements.get(el);
    if (!data2) return;
    const index = data2.callbacks.indexOf(onChange);
    if (index > -1) {
      data2.callbacks.splice(index, 1);
    }
    if (data2.callbacks.length === 0) {
      observedElements.delete(el);
      if (observedElements.size === 0) {
        cancelAnimationFrame(rafId);
      }
    }
  };
}
function getLoopFn(options) {
  const { scope, getRect } = options;
  const isEqual3 = getEqualityFn(scope);
  return function loop() {
    const changedRectsData = [];
    observedElements.forEach((data, element) => {
      const newRect = getRect(element);
      if (!isEqual3(data.rect, newRect)) {
        data.rect = newRect;
        changedRectsData.push(data);
      }
    });
    changedRectsData.forEach((data) => {
      data.callbacks.forEach((callback) => callback(data.rect));
    });
    rafId = requestAnimationFrame(loop);
  };
}
var isEqualSize = (a, b) => a.width === b.width && a.height === b.height;
var isEqualPosition = (a, b) => a.top === b.top && a.left === b.left;
var isEqualRect = (a, b) => isEqualSize(a, b) && isEqualPosition(a, b);
function getEqualityFn(scope) {
  if (scope === "size") return isEqualSize;
  if (scope === "position") return isEqualPosition;
  return isEqualRect;
}

// node_modules/@zag-js/radio-group/dist/index.mjs
var anatomy10 = createAnatomy("radio-group").parts(
  "root",
  "label",
  "item",
  "itemText",
  "itemControl",
  "indicator"
);
var parts12 = anatomy10.build();
var dom10 = createScope({
  getRootId: (ctx) => {
    var _a8;
    return ((_a8 = ctx.ids) == null ? void 0 : _a8.root) ?? `radio-group:${ctx.id}`;
  },
  getLabelId: (ctx) => {
    var _a8;
    return ((_a8 = ctx.ids) == null ? void 0 : _a8.label) ?? `radio-group:${ctx.id}:label`;
  },
  getItemId: (ctx, value) => {
    var _a8, _b7;
    return ((_b7 = (_a8 = ctx.ids) == null ? void 0 : _a8.item) == null ? void 0 : _b7.call(_a8, value)) ?? `radio-group:${ctx.id}:radio:${value}`;
  },
  getItemHiddenInputId: (ctx, value) => {
    var _a8, _b7;
    return ((_b7 = (_a8 = ctx.ids) == null ? void 0 : _a8.itemHiddenInput) == null ? void 0 : _b7.call(_a8, value)) ?? `radio-group:${ctx.id}:radio:input:${value}`;
  },
  getItemControlId: (ctx, value) => {
    var _a8, _b7;
    return ((_b7 = (_a8 = ctx.ids) == null ? void 0 : _a8.itemControl) == null ? void 0 : _b7.call(_a8, value)) ?? `radio-group:${ctx.id}:radio:control:${value}`;
  },
  getItemLabelId: (ctx, value) => {
    var _a8, _b7;
    return ((_b7 = (_a8 = ctx.ids) == null ? void 0 : _a8.itemLabel) == null ? void 0 : _b7.call(_a8, value)) ?? `radio-group:${ctx.id}:radio:label:${value}`;
  },
  getIndicatorId: (ctx) => {
    var _a8;
    return ((_a8 = ctx.ids) == null ? void 0 : _a8.indicator) ?? `radio-group:${ctx.id}:indicator`;
  },
  getRootEl: (ctx) => dom10.getById(ctx, dom10.getRootId(ctx)),
  getItemHiddenInputEl: (ctx, value) => dom10.getById(ctx, dom10.getItemHiddenInputId(ctx, value)),
  getIndicatorEl: (ctx) => dom10.getById(ctx, dom10.getIndicatorId(ctx)),
  getFirstEnabledInputEl: (ctx) => {
    var _a8;
    return (_a8 = dom10.getRootEl(ctx)) == null ? void 0 : _a8.querySelector("input:not(:disabled)");
  },
  getFirstEnabledAndCheckedInputEl: (ctx) => {
    var _a8;
    return (_a8 = dom10.getRootEl(ctx)) == null ? void 0 : _a8.querySelector("input:not(:disabled):checked");
  },
  getInputEls: (ctx) => {
    const ownerId = CSS.escape(dom10.getRootId(ctx));
    const selector = `input[type=radio][data-ownedby='${ownerId}']:not([disabled])`;
    return queryAll(dom10.getRootEl(ctx), selector);
  },
  getActiveRadioEl: (ctx) => {
    if (!ctx.value) return;
    return dom10.getById(ctx, dom10.getItemId(ctx, ctx.value));
  },
  getOffsetRect: (el) => ({
    left: (el == null ? void 0 : el.offsetLeft) ?? 0,
    top: (el == null ? void 0 : el.offsetTop) ?? 0,
    width: (el == null ? void 0 : el.offsetWidth) ?? 0,
    height: (el == null ? void 0 : el.offsetHeight) ?? 0
  }),
  getRectById: (ctx, id) => {
    const radioEl = dom10.getById(ctx, dom10.getItemId(ctx, id));
    if (!radioEl) return;
    return dom10.resolveRect(dom10.getOffsetRect(radioEl));
  },
  resolveRect: (rect) => ({
    width: `${rect.width}px`,
    height: `${rect.height}px`,
    left: `${rect.left}px`,
    top: `${rect.top}px`
  })
});
function connect11(state2, send, normalize2) {
  const groupDisabled = state2.context.isDisabled;
  const readOnly = state2.context.readOnly;
  function getItemState(props22) {
    return {
      invalid: !!props22.invalid,
      disabled: !!props22.disabled || groupDisabled,
      checked: state2.context.value === props22.value,
      focused: state2.context.focusedValue === props22.value,
      hovered: state2.context.hoveredValue === props22.value,
      active: state2.context.activeValue === props22.value
    };
  }
  function getItemDataAttrs(props22) {
    const radioState = getItemState(props22);
    return {
      "data-focus": dataAttr(radioState.focused),
      "data-focus-visible": dataAttr(radioState.focused && state2.context.focusVisible),
      "data-disabled": dataAttr(radioState.disabled),
      "data-readonly": dataAttr(readOnly),
      "data-state": radioState.checked ? "checked" : "unchecked",
      "data-hover": dataAttr(radioState.hovered),
      "data-invalid": dataAttr(radioState.invalid),
      "data-orientation": state2.context.orientation,
      "data-ssr": dataAttr(state2.context.ssr)
    };
  }
  const focus = () => {
    const firstEnabledAndCheckedInput = dom10.getFirstEnabledAndCheckedInputEl(state2.context);
    if (firstEnabledAndCheckedInput) {
      firstEnabledAndCheckedInput.focus();
      return;
    }
    const firstEnabledInput = dom10.getFirstEnabledInputEl(state2.context);
    firstEnabledInput == null ? void 0 : firstEnabledInput.focus();
  };
  return {
    focus,
    value: state2.context.value,
    setValue(value) {
      send({ type: "SET_VALUE", value, isTrusted: false });
    },
    clearValue() {
      send({ type: "SET_VALUE", value: null, isTrusted: false });
    },
    getRootProps() {
      return normalize2.element({
        ...parts12.root.attrs,
        role: "radiogroup",
        id: dom10.getRootId(state2.context),
        "aria-labelledby": dom10.getLabelId(state2.context),
        "data-orientation": state2.context.orientation,
        "data-disabled": dataAttr(groupDisabled),
        "aria-orientation": state2.context.orientation,
        dir: state2.context.dir,
        style: {
          position: "relative"
        }
      });
    },
    getLabelProps() {
      return normalize2.element({
        ...parts12.label.attrs,
        dir: state2.context.dir,
        "data-orientation": state2.context.orientation,
        "data-disabled": dataAttr(groupDisabled),
        id: dom10.getLabelId(state2.context),
        onClick: focus
      });
    },
    getItemState,
    getItemProps(props22) {
      const itemState = getItemState(props22);
      return normalize2.label({
        ...parts12.item.attrs,
        dir: state2.context.dir,
        id: dom10.getItemId(state2.context, props22.value),
        htmlFor: dom10.getItemHiddenInputId(state2.context, props22.value),
        ...getItemDataAttrs(props22),
        onPointerMove() {
          if (itemState.disabled) return;
          if (itemState.hovered) return;
          send({ type: "SET_HOVERED", value: props22.value, hovered: true });
        },
        onPointerLeave() {
          if (itemState.disabled) return;
          send({ type: "SET_HOVERED", value: null });
        },
        onPointerDown(event) {
          if (itemState.disabled) return;
          if (itemState.focused && event.pointerType === "mouse") {
            event.preventDefault();
          }
          send({ type: "SET_ACTIVE", value: props22.value, active: true });
        },
        onPointerUp() {
          if (itemState.disabled) return;
          send({ type: "SET_ACTIVE", value: null });
        }
      });
    },
    getItemTextProps(props22) {
      return normalize2.element({
        ...parts12.itemText.attrs,
        dir: state2.context.dir,
        id: dom10.getItemLabelId(state2.context, props22.value),
        ...getItemDataAttrs(props22)
      });
    },
    getItemControlProps(props22) {
      const controlState = getItemState(props22);
      return normalize2.element({
        ...parts12.itemControl.attrs,
        dir: state2.context.dir,
        id: dom10.getItemControlId(state2.context, props22.value),
        "data-active": dataAttr(controlState.active),
        "aria-hidden": true,
        ...getItemDataAttrs(props22)
      });
    },
    getItemHiddenInputProps(props22) {
      const inputState = getItemState(props22);
      return normalize2.input({
        "data-ownedby": dom10.getRootId(state2.context),
        id: dom10.getItemHiddenInputId(state2.context, props22.value),
        type: "radio",
        name: state2.context.name || state2.context.id,
        form: state2.context.form,
        value: props22.value,
        onClick(event) {
          if (readOnly) {
            event.preventDefault();
            return;
          }
          if (event.currentTarget.checked) {
            send({ type: "SET_VALUE", value: props22.value, isTrusted: true });
          }
        },
        onBlur() {
          send({ type: "SET_FOCUSED", value: null, focused: false, focusVisible: false });
        },
        onFocus() {
          const focusVisible = isFocusVisible();
          send({ type: "SET_FOCUSED", value: props22.value, focused: true, focusVisible });
        },
        onKeyDown(event) {
          if (event.defaultPrevented) return;
          if (event.key === " ") {
            send({ type: "SET_ACTIVE", value: props22.value, active: true });
          }
        },
        onKeyUp(event) {
          if (event.defaultPrevented) return;
          if (event.key === " ") {
            send({ type: "SET_ACTIVE", value: null });
          }
        },
        disabled: inputState.disabled,
        defaultChecked: inputState.checked,
        style: visuallyHiddenStyle
      });
    },
    getIndicatorProps() {
      var _a8, _b7, _c6, _d6;
      return normalize2.element({
        id: dom10.getIndicatorId(state2.context),
        ...parts12.indicator.attrs,
        dir: state2.context.dir,
        hidden: state2.context.value == null,
        "data-disabled": dataAttr(groupDisabled),
        "data-orientation": state2.context.orientation,
        style: {
          "--transition-property": "left, top, width, height",
          "--left": (_a8 = state2.context.indicatorRect) == null ? void 0 : _a8.left,
          "--top": (_b7 = state2.context.indicatorRect) == null ? void 0 : _b7.top,
          "--width": (_c6 = state2.context.indicatorRect) == null ? void 0 : _c6.width,
          "--height": (_d6 = state2.context.indicatorRect) == null ? void 0 : _d6.height,
          position: "absolute",
          willChange: "var(--transition-property)",
          transitionProperty: "var(--transition-property)",
          transitionDuration: state2.context.canIndicatorTransition ? "var(--transition-duration, 150ms)" : "0ms",
          transitionTimingFunction: "var(--transition-timing-function)",
          [state2.context.orientation === "horizontal" ? "left" : "top"]: state2.context.orientation === "horizontal" ? "var(--left)" : "var(--top)"
        }
      });
    }
  };
}
var { not: not4 } = guards;
function machine11(userContext) {
  const ctx = compact2(userContext);
  return createMachine(
    {
      id: "radio",
      initial: "idle",
      context: {
        value: null,
        activeValue: null,
        focusedValue: null,
        hoveredValue: null,
        disabled: false,
        orientation: "vertical",
        ...ctx,
        indicatorRect: {},
        canIndicatorTransition: false,
        fieldsetDisabled: false,
        focusVisible: false,
        ssr: true
      },
      computed: {
        isDisabled: (ctx2) => !!ctx2.disabled || ctx2.fieldsetDisabled
      },
      entry: ["syncIndicatorRect", "syncSsr"],
      exit: ["cleanupObserver"],
      activities: ["trackFormControlState", "trackFocusVisible"],
      watch: {
        value: ["setIndicatorTransition", "syncIndicatorRect", "syncInputElements"]
      },
      on: {
        SET_VALUE: [
          {
            guard: not4("isTrusted"),
            actions: ["setValue", "dispatchChangeEvent"]
          },
          {
            actions: ["setValue"]
          }
        ],
        SET_HOVERED: {
          actions: "setHovered"
        },
        SET_ACTIVE: {
          actions: "setActive"
        },
        SET_FOCUSED: {
          actions: "setFocused"
        }
      },
      states: {
        idle: {}
      }
    },
    {
      guards: {
        isTrusted: (_ctx, evt) => !!evt.isTrusted
      },
      activities: {
        trackFormControlState(ctx2, _evt, { send, initialContext }) {
          return trackFormControl(dom10.getRootEl(ctx2), {
            onFieldsetDisabledChange(disabled) {
              ctx2.fieldsetDisabled = disabled;
            },
            onFormReset() {
              send({ type: "SET_VALUE", value: initialContext.value });
            }
          });
        },
        trackFocusVisible(ctx2) {
          return trackFocusVisible({ root: dom10.getRootNode(ctx2) });
        }
      },
      actions: {
        setValue(ctx2, evt) {
          set9.value(ctx2, evt.value);
        },
        setHovered(ctx2, evt) {
          ctx2.hoveredValue = evt.value;
        },
        setActive(ctx2, evt) {
          ctx2.activeValue = evt.value;
        },
        setFocused(ctx2, evt) {
          ctx2.focusedValue = evt.value;
          ctx2.focusVisible = evt.focusVisible;
        },
        syncInputElements(ctx2) {
          const inputs = dom10.getInputEls(ctx2);
          inputs.forEach((input) => {
            input.checked = input.value === ctx2.value;
          });
        },
        setIndicatorTransition(ctx2) {
          ctx2.canIndicatorTransition = isString2(ctx2.value);
        },
        cleanupObserver(ctx2) {
          var _a8;
          (_a8 = ctx2.indicatorCleanup) == null ? void 0 : _a8.call(ctx2);
        },
        syncSsr(ctx2) {
          ctx2.ssr = false;
        },
        syncIndicatorRect(ctx2) {
          var _a8;
          (_a8 = ctx2.indicatorCleanup) == null ? void 0 : _a8.call(ctx2);
          if (!dom10.getIndicatorEl(ctx2)) return;
          const value = ctx2.value;
          const radioEl = dom10.getActiveRadioEl(ctx2);
          if (value == null || !radioEl) {
            ctx2.indicatorRect = {};
            return;
          }
          ctx2.indicatorCleanup = trackElementRect(radioEl, {
            getRect(el) {
              return dom10.getOffsetRect(el);
            },
            onChange(rect) {
              ctx2.indicatorRect = dom10.resolveRect(rect);
              nextTick(() => {
                ctx2.canIndicatorTransition = false;
              });
            }
          });
        },
        dispatchChangeEvent(ctx2) {
          const inputEls = dom10.getInputEls(ctx2);
          inputEls.forEach((inputEl) => {
            const checked = inputEl.value === ctx2.value;
            if (checked === inputEl.checked) return;
            dispatchInputCheckedEvent(inputEl, { checked });
          });
        }
      }
    }
  );
}
var invoke6 = {
  change: (ctx) => {
    var _a8;
    if (ctx.value == null) return;
    (_a8 = ctx.onValueChange) == null ? void 0 : _a8.call(ctx, { value: ctx.value });
  }
};
var set9 = {
  value: (ctx, value) => {
    if (isEqual(ctx.value, value)) return;
    ctx.value = value;
    invoke6.change(ctx);
  }
};
var props10 = createProps2()([
  "dir",
  "disabled",
  "form",
  "getRootNode",
  "id",
  "ids",
  "name",
  "onValueChange",
  "orientation",
  "readOnly",
  "value"
]);
var splitProps11 = createSplitProps(props10);
var itemProps4 = createProps2()(["value", "disabled", "invalid"]);
var splitItemProps4 = createSplitProps(itemProps4);

// node_modules/@ark-ui/react/dist/components/radio-group/use-radio-group.js
var import_react205 = __toESM(require_react(), 1);
var useRadioGroup = (props21 = {}) => {
  const { getRootNode } = useEnvironmentContext();
  const { dir } = useLocaleContext();
  const initialContext = {
    id: (0, import_react205.useId)(),
    dir,
    getRootNode,
    value: props21.defaultValue,
    ...props21
  };
  const context = {
    ...initialContext,
    value: props21.value,
    onValueChange: useEvent(props21.onValueChange, { sync: true })
  };
  const [state2, send] = useMachine(machine11(initialContext), {
    context
  });
  return connect11(state2, send, normalizeProps);
};

// node_modules/@ark-ui/react/dist/components/radio-group/radio-group-root.js
var RadioGroupRoot = (0, import_react207.forwardRef)((props21, ref2) => {
  const [useRadioGroupProps, localProps] = createSplitProps2()(props21, [
    "defaultValue",
    "disabled",
    "form",
    "id",
    "ids",
    "name",
    "onValueChange",
    "orientation",
    "readOnly",
    "value"
  ]);
  const radioGroup = useRadioGroup(useRadioGroupProps);
  const mergedProps = mergeProps(radioGroup.getRootProps(), localProps);
  return (0, import_jsx_runtime94.jsx)(RadioGroupProvider, { value: radioGroup, children: (0, import_jsx_runtime94.jsx)(ark.div, { ...mergedProps, ref: ref2 }) });
});
RadioGroupRoot.displayName = "RadioGroupRoot";

// node_modules/@ark-ui/react/dist/components/radio-group/radio-group-root-provider.js
var import_jsx_runtime95 = __toESM(require_jsx_runtime(), 1);
var import_react209 = __toESM(require_react(), 1);
var RadioGroupRootProvider = (0, import_react209.forwardRef)(
  (props21, ref2) => {
    const [{ value: radioGroup }, localProps] = createSplitProps2()(props21, [
      "value"
    ]);
    const mergedProps = mergeProps(radioGroup.getRootProps(), localProps);
    return (0, import_jsx_runtime95.jsx)(RadioGroupProvider, { value: radioGroup, children: (0, import_jsx_runtime95.jsx)(ark.div, { ...mergedProps, ref: ref2 }) });
  }
);
RadioGroupRootProvider.displayName = "RadioGroupRootProvider";

// node_modules/@ark-ui/react/dist/components/radio-group/radio-group.js
var radio_group_exports = {};
__export(radio_group_exports, {
  Context: () => RadioGroupContext,
  Indicator: () => RadioGroupIndicator,
  Item: () => RadioGroupItem,
  ItemContext: () => RadioGroupItemContext,
  ItemControl: () => RadioGroupItemControl,
  ItemHiddenInput: () => RadioGroupItemHiddenInput,
  ItemText: () => RadioGroupItemText,
  Label: () => RadioGroupLabel,
  Root: () => RadioGroupRoot,
  RootProvider: () => RadioGroupRootProvider
});

// node_modules/@ark-ui/react/dist/components/rating-group/use-rating-group-context.js
var [RatingGroupProvider, useRatingGroupContext] = createContext({
  name: "RatingGroupContext",
  hookName: "useRatingGroupContext",
  providerName: "<RatingGroupProvider />"
});

// node_modules/@ark-ui/react/dist/components/rating-group/rating-group-context.js
var RatingGroupContext = (props21) => props21.children(useRatingGroupContext());

// node_modules/@ark-ui/react/dist/components/rating-group/rating-group-control.js
var import_jsx_runtime96 = __toESM(require_jsx_runtime(), 1);
var import_react211 = __toESM(require_react(), 1);
var RatingGroupControl = (0, import_react211.forwardRef)(
  (props21, ref2) => {
    const ratingGroup = useRatingGroupContext();
    const mergedProps = mergeProps(ratingGroup.getControlProps(), props21);
    return (0, import_jsx_runtime96.jsx)(ark.div, { ...mergedProps, ref: ref2 });
  }
);
RatingGroupControl.displayName = "RatingGroupControl";

// node_modules/@ark-ui/react/dist/components/rating-group/rating-group-hidden-input.js
var import_jsx_runtime97 = __toESM(require_jsx_runtime(), 1);
var import_react213 = __toESM(require_react(), 1);
var RatingGroupHiddenInput = (0, import_react213.forwardRef)(
  (props21, ref2) => {
    const ratingGroup = useRatingGroupContext();
    const mergedProps = mergeProps(ratingGroup.getHiddenInputProps(), props21);
    const field = useFieldContext();
    return (0, import_jsx_runtime97.jsx)(ark.input, { "aria-describedby": field == null ? void 0 : field.ariaDescribedby, ...mergedProps, ref: ref2 });
  }
);
RatingGroupHiddenInput.displayName = "RatingGroupHiddenInput";

// node_modules/@ark-ui/react/dist/components/rating-group/rating-group-item.js
var import_jsx_runtime98 = __toESM(require_jsx_runtime(), 1);
var import_react215 = __toESM(require_react(), 1);

// node_modules/@ark-ui/react/dist/components/rating-group/use-rating-group-item-context.js
var [RatingGroupItemProvider, useRatingGroupItemContext] = createContext({
  name: "RatingGroupItemContext",
  hookName: "useRatingGroupItemContext",
  providerName: "<RatingGroupItemProvider />"
});

// node_modules/@ark-ui/react/dist/components/rating-group/rating-group-item.js
var RatingGroupItem = (0, import_react215.forwardRef)((props21, ref2) => {
  const [itemProps7, localProps] = createSplitProps2()(props21, ["index"]);
  const ratingGroup = useRatingGroupContext();
  const mergedProps = mergeProps(ratingGroup.getItemProps(itemProps7), localProps);
  const itemState = ratingGroup.getItemState(itemProps7);
  return (0, import_jsx_runtime98.jsx)(RatingGroupItemProvider, { value: itemState, children: (0, import_jsx_runtime98.jsx)(ark.span, { ...mergedProps, ref: ref2 }) });
});
RatingGroupItem.displayName = "RatingGroupItem";

// node_modules/@ark-ui/react/dist/components/rating-group/rating-group-item-context.js
var RatingGroupItemContext = (props21) => props21.children(useRatingGroupItemContext());

// node_modules/@ark-ui/react/dist/components/rating-group/rating-group-label.js
var import_jsx_runtime99 = __toESM(require_jsx_runtime(), 1);
var import_react217 = __toESM(require_react(), 1);
var RatingGroupLabel = (0, import_react217.forwardRef)(
  (props21, ref2) => {
    const ratingGroup = useRatingGroupContext();
    const mergedProps = mergeProps(ratingGroup.getLabelProps(), props21);
    return (0, import_jsx_runtime99.jsx)(ark.label, { ...mergedProps, ref: ref2 });
  }
);
RatingGroupLabel.displayName = "RatingGroupLabel";

// node_modules/@ark-ui/react/dist/components/rating-group/rating-group-root.js
var import_jsx_runtime100 = __toESM(require_jsx_runtime(), 1);
var import_react221 = __toESM(require_react(), 1);

// node_modules/@zag-js/rating-group/dist/index.mjs
var anatomy11 = createAnatomy("rating-group").parts("root", "label", "item", "control");
var parts13 = anatomy11.build();
var dom11 = createScope({
  getRootId: (ctx) => {
    var _a8;
    return ((_a8 = ctx.ids) == null ? void 0 : _a8.root) ?? `rating:${ctx.id}`;
  },
  getLabelId: (ctx) => {
    var _a8;
    return ((_a8 = ctx.ids) == null ? void 0 : _a8.label) ?? `rating:${ctx.id}:label`;
  },
  getHiddenInputId: (ctx) => {
    var _a8;
    return ((_a8 = ctx.ids) == null ? void 0 : _a8.hiddenInput) ?? `rating:${ctx.id}:input`;
  },
  getControlId: (ctx) => {
    var _a8;
    return ((_a8 = ctx.ids) == null ? void 0 : _a8.control) ?? `rating:${ctx.id}:control`;
  },
  getItemId: (ctx, id) => {
    var _a8, _b7;
    return ((_b7 = (_a8 = ctx.ids) == null ? void 0 : _a8.item) == null ? void 0 : _b7.call(_a8, id)) ?? `rating:${ctx.id}:item:${id}`;
  },
  getRootEl: (ctx) => dom11.getById(ctx, dom11.getRootId(ctx)),
  getControlEl: (ctx) => dom11.getById(ctx, dom11.getControlId(ctx)),
  getRadioEl: (ctx, value = ctx.value) => {
    const selector = `[role=radio][aria-posinset='${Math.ceil(value)}']`;
    return query(dom11.getControlEl(ctx), selector);
  },
  getHiddenInputEl: (ctx) => dom11.getById(ctx, dom11.getHiddenInputId(ctx)),
  dispatchChangeEvent: (ctx) => {
    const inputEl = dom11.getHiddenInputEl(ctx);
    if (!inputEl) return;
    dispatchInputValueEvent(inputEl, { value: ctx.value });
  }
});
function connect12(state2, send, normalize2) {
  const interactive = state2.context.isInteractive;
  const disabled = state2.context.isDisabled;
  const readOnly = state2.context.readOnly;
  const value = state2.context.value;
  const hoveredValue = state2.context.hoveredValue;
  const translations = state2.context.translations;
  function getItemState(props22) {
    const value2 = state2.context.isHovering ? state2.context.hoveredValue : state2.context.value;
    const equal = Math.ceil(value2) === props22.index;
    const highlighted = props22.index <= value2 || equal;
    const half = equal && Math.abs(value2 - props22.index) === 0.5;
    return {
      highlighted,
      half,
      checked: equal || state2.context.value === -1 && props22.index === 1
    };
  }
  return {
    hovering: state2.context.isHovering,
    value,
    hoveredValue,
    count: state2.context.count,
    items: Array.from({ length: state2.context.count }).map((_, index) => index + 1),
    setValue(value2) {
      send({ type: "SET_VALUE", value: value2 });
    },
    clearValue() {
      send("CLEAR_VALUE");
    },
    getRootProps() {
      return normalize2.element({
        ...parts13.root.attrs,
        dir: state2.context.dir,
        id: dom11.getRootId(state2.context)
      });
    },
    getHiddenInputProps() {
      return normalize2.input({
        name: state2.context.name,
        form: state2.context.form,
        type: "text",
        hidden: true,
        disabled,
        readOnly,
        required: state2.context.required,
        id: dom11.getHiddenInputId(state2.context),
        defaultValue: state2.context.value
      });
    },
    getLabelProps() {
      return normalize2.label({
        ...parts13.label.attrs,
        dir: state2.context.dir,
        id: dom11.getLabelId(state2.context),
        "data-disabled": dataAttr(disabled),
        htmlFor: dom11.getHiddenInputId(state2.context),
        onClick(event) {
          if (event.defaultPrevented) return;
          if (!interactive) return;
          event.preventDefault();
          const radioEl = dom11.getRadioEl(state2.context, 1);
          radioEl == null ? void 0 : radioEl.focus({ preventScroll: true });
        }
      });
    },
    getControlProps() {
      return normalize2.element({
        id: dom11.getControlId(state2.context),
        ...parts13.control.attrs,
        dir: state2.context.dir,
        role: "radiogroup",
        "aria-orientation": "horizontal",
        "aria-labelledby": dom11.getLabelId(state2.context),
        "aria-readonly": ariaAttr(readOnly),
        "data-readonly": dataAttr(readOnly),
        "data-disabled": dataAttr(disabled),
        onPointerMove(event) {
          if (!interactive) return;
          if (event.pointerType === "touch") return;
          send("GROUP_POINTER_OVER");
        },
        onPointerLeave(event) {
          if (!interactive) return;
          if (event.pointerType === "touch") return;
          send("GROUP_POINTER_LEAVE");
        }
      });
    },
    getItemState,
    getItemProps(props22) {
      const { index } = props22;
      const itemState = getItemState(props22);
      const valueText = translations.ratingValueText(index);
      return normalize2.element({
        ...parts13.item.attrs,
        dir: state2.context.dir,
        id: dom11.getItemId(state2.context, index.toString()),
        role: "radio",
        tabIndex: (() => {
          if (readOnly) return itemState.checked ? 0 : void 0;
          if (disabled) return void 0;
          return itemState.checked ? 0 : -1;
        })(),
        "aria-roledescription": "rating",
        "aria-label": valueText,
        "aria-disabled": disabled,
        "data-disabled": dataAttr(disabled),
        "data-readonly": dataAttr(readOnly),
        "aria-setsize": state2.context.count,
        "aria-checked": itemState.checked,
        "data-checked": dataAttr(itemState.checked),
        "aria-posinset": index,
        "data-highlighted": dataAttr(itemState.highlighted),
        "data-half": dataAttr(itemState.half),
        onPointerDown(event) {
          if (!interactive) return;
          if (!isLeftClick(event)) return;
          event.preventDefault();
        },
        onPointerMove(event) {
          if (!interactive) return;
          const point = getEventPoint(event);
          const relativePoint = getRelativePoint(point, event.currentTarget);
          const percentX = relativePoint.getPercentValue({
            orientation: "horizontal",
            dir: state2.context.dir
          });
          const isMidway = percentX < 0.5;
          send({ type: "POINTER_OVER", index, isMidway });
        },
        onKeyDown(event) {
          if (event.defaultPrevented) return;
          if (!interactive) return;
          const keyMap2 = {
            ArrowLeft() {
              send("ARROW_LEFT");
            },
            ArrowRight() {
              send("ARROW_RIGHT");
            },
            ArrowUp() {
              send("ARROW_LEFT");
            },
            ArrowDown() {
              send("ARROW_RIGHT");
            },
            Space() {
              send({ type: "SPACE", value: index });
            },
            Home() {
              send("HOME");
            },
            End() {
              send("END");
            }
          };
          const key = getEventKey(event, state2.context);
          const exec2 = keyMap2[key];
          if (exec2) {
            event.preventDefault();
            exec2(event);
          }
        },
        onClick() {
          if (!interactive) return;
          send({ type: "CLICK", value: index });
        },
        onFocus() {
          if (!interactive) return;
          send("FOCUS");
        },
        onBlur() {
          if (!interactive) return;
          send("BLUR");
        }
      });
    }
  };
}
function machine12(userContext) {
  const ctx = compact2(userContext);
  return createMachine(
    {
      id: "rating",
      initial: "idle",
      context: {
        name: "rating",
        count: 5,
        dir: "ltr",
        value: -1,
        readOnly: false,
        disabled: false,
        ...ctx,
        hoveredValue: -1,
        fieldsetDisabled: false,
        translations: {
          ratingValueText: (index) => `${index} stars`,
          ...ctx.translations
        }
      },
      created: ["roundValueIfNeeded"],
      watch: {
        allowHalf: ["roundValueIfNeeded"]
      },
      computed: {
        isDisabled: (ctx2) => !!ctx2.disabled || ctx2.fieldsetDisabled,
        isInteractive: (ctx2) => !(ctx2.isDisabled || ctx2.readOnly),
        isHovering: (ctx2) => ctx2.hoveredValue > -1
      },
      activities: ["trackFormControlState"],
      on: {
        SET_VALUE: {
          actions: ["setValue"]
        },
        CLEAR_VALUE: {
          actions: ["clearValue"]
        }
      },
      states: {
        idle: {
          entry: "clearHoveredValue",
          on: {
            GROUP_POINTER_OVER: "hover",
            FOCUS: "focus",
            CLICK: {
              actions: ["setValue", "focusActiveRadio"]
            }
          }
        },
        focus: {
          on: {
            POINTER_OVER: {
              actions: "setHoveredValue"
            },
            GROUP_POINTER_LEAVE: {
              actions: "clearHoveredValue"
            },
            BLUR: "idle",
            SPACE: {
              guard: "isValueEmpty",
              actions: ["setValue"]
            },
            CLICK: {
              actions: ["setValue", "focusActiveRadio"]
            },
            ARROW_LEFT: {
              actions: ["setPrevValue", "focusActiveRadio"]
            },
            ARROW_RIGHT: {
              actions: ["setNextValue", "focusActiveRadio"]
            },
            HOME: {
              actions: ["setValueToMin", "focusActiveRadio"]
            },
            END: {
              actions: ["setValueToMax", "focusActiveRadio"]
            }
          }
        },
        hover: {
          on: {
            POINTER_OVER: {
              actions: "setHoveredValue"
            },
            GROUP_POINTER_LEAVE: [
              {
                guard: "isRadioFocused",
                target: "focus",
                actions: "clearHoveredValue"
              },
              {
                target: "idle",
                actions: "clearHoveredValue"
              }
            ],
            CLICK: {
              actions: ["setValue", "focusActiveRadio"]
            }
          }
        }
      }
    },
    {
      guards: {
        isInteractive: (ctx2) => !(ctx2.disabled || ctx2.readOnly),
        isHoveredValueEmpty: (ctx2) => ctx2.hoveredValue === -1,
        isValueEmpty: (ctx2) => ctx2.value <= 0,
        isRadioFocused: (ctx2) => {
          var _a8;
          return !!((_a8 = dom11.getControlEl(ctx2)) == null ? void 0 : _a8.contains(dom11.getActiveElement(ctx2)));
        }
      },
      activities: {
        trackFormControlState(ctx2, _evt, { initialContext }) {
          return trackFormControl(dom11.getHiddenInputEl(ctx2), {
            onFieldsetDisabledChange(disabled) {
              ctx2.fieldsetDisabled = disabled;
            },
            onFormReset() {
              set10.value(ctx2, initialContext.value);
            }
          });
        }
      },
      actions: {
        clearHoveredValue(ctx2) {
          set10.hoveredValue(ctx2, -1);
        },
        focusActiveRadio(ctx2) {
          raf(() => {
            var _a8;
            return (_a8 = dom11.getRadioEl(ctx2)) == null ? void 0 : _a8.focus();
          });
        },
        setPrevValue(ctx2) {
          const factor = ctx2.allowHalf ? 0.5 : 1;
          set10.value(ctx2, Math.max(0, ctx2.value - factor));
        },
        setNextValue(ctx2) {
          const factor = ctx2.allowHalf ? 0.5 : 1;
          const value = ctx2.value === -1 ? 0 : ctx2.value;
          set10.value(ctx2, Math.min(ctx2.count, value + factor));
        },
        setValueToMin(ctx2) {
          set10.value(ctx2, 1);
        },
        setValueToMax(ctx2) {
          set10.value(ctx2, ctx2.count);
        },
        setValue(ctx2, evt) {
          const value = ctx2.hoveredValue === -1 ? evt.value : ctx2.hoveredValue;
          set10.value(ctx2, value);
        },
        clearValue(ctx2) {
          set10.value(ctx2, -1);
        },
        setHoveredValue(ctx2, evt) {
          const half = ctx2.allowHalf && evt.isMidway;
          const factor = half ? 0.5 : 0;
          set10.hoveredValue(ctx2, evt.index - factor);
        },
        roundValueIfNeeded(ctx2) {
          if (ctx2.allowHalf) return;
          ctx2.value = Math.round(ctx2.value);
        }
      }
    }
  );
}
var invoke7 = {
  change: (ctx) => {
    var _a8;
    (_a8 = ctx.onValueChange) == null ? void 0 : _a8.call(ctx, { value: ctx.value });
    dom11.dispatchChangeEvent(ctx);
  },
  hoverChange: (ctx) => {
    var _a8;
    (_a8 = ctx.onHoverChange) == null ? void 0 : _a8.call(ctx, { hoveredValue: ctx.hoveredValue });
  }
};
var set10 = {
  value: (ctx, value) => {
    if (isEqual(ctx.value, value)) return;
    ctx.value = value;
    invoke7.change(ctx);
  },
  hoveredValue: (ctx, value) => {
    if (isEqual(ctx.hoveredValue, value)) return;
    ctx.hoveredValue = value;
    invoke7.hoverChange(ctx);
  }
};
var props11 = createProps2()([
  "allowHalf",
  "autoFocus",
  "count",
  "dir",
  "disabled",
  "form",
  "getRootNode",
  "id",
  "ids",
  "name",
  "onHoverChange",
  "onValueChange",
  "required",
  "readOnly",
  "translations",
  "value"
]);
var splitProps12 = createSplitProps(props11);
var itemProps5 = createProps2()(["index"]);
var splitItemProps5 = createSplitProps(itemProps5);

// node_modules/@ark-ui/react/dist/components/rating-group/use-rating-group.js
var import_react219 = __toESM(require_react(), 1);
var useRatingGroup = (props21 = {}) => {
  const { getRootNode } = useEnvironmentContext();
  const { dir } = useLocaleContext();
  const field = useFieldContext();
  const initialContext = {
    id: (0, import_react219.useId)(),
    ids: {
      label: field == null ? void 0 : field.ids.label,
      hiddenInput: field == null ? void 0 : field.ids.control
    },
    dir,
    disabled: field == null ? void 0 : field.disabled,
    readOnly: field == null ? void 0 : field.readOnly,
    required: field == null ? void 0 : field.required,
    getRootNode,
    value: props21.defaultValue,
    ...props21
  };
  const context = {
    ...initialContext,
    value: props21.value,
    onValueChange: useEvent(props21.onValueChange, { sync: true }),
    onHoverChange: useEvent(props21.onHoverChange)
  };
  const [state2, send] = useMachine(machine12(initialContext), {
    context
  });
  return connect12(state2, send, normalizeProps);
};

// node_modules/@ark-ui/react/dist/components/rating-group/rating-group-root.js
var RatingGroupRoot = (0, import_react221.forwardRef)((props21, ref2) => {
  const [useRatingProps, localProps] = createSplitProps2()(props21, [
    "allowHalf",
    "autoFocus",
    "count",
    "defaultValue",
    "disabled",
    "form",
    "id",
    "ids",
    "name",
    "onHoverChange",
    "onValueChange",
    "readOnly",
    "required",
    "translations",
    "value"
  ]);
  const ratingGroup = useRatingGroup(useRatingProps);
  const mergedProps = mergeProps(ratingGroup.getRootProps(), localProps);
  return (0, import_jsx_runtime100.jsx)(RatingGroupProvider, { value: ratingGroup, children: (0, import_jsx_runtime100.jsx)(ark.div, { ...mergedProps, ref: ref2 }) });
});
RatingGroupRoot.displayName = "RatingGroupRoot";

// node_modules/@ark-ui/react/dist/components/rating-group/rating-group-root-provider.js
var import_jsx_runtime101 = __toESM(require_jsx_runtime(), 1);
var import_react223 = __toESM(require_react(), 1);
var RatingGroupRootProvider = (0, import_react223.forwardRef)(
  (props21, ref2) => {
    const [{ value: ratingGroup }, localProps] = createSplitProps2()(props21, [
      "value"
    ]);
    const mergedProps = mergeProps(ratingGroup.getRootProps(), localProps);
    return (0, import_jsx_runtime101.jsx)(RatingGroupProvider, { value: ratingGroup, children: (0, import_jsx_runtime101.jsx)(ark.div, { ...mergedProps, ref: ref2 }) });
  }
);
RatingGroupRootProvider.displayName = "RatingGroupRootProvider";

// node_modules/@ark-ui/react/dist/components/rating-group/rating-group.js
var rating_group_exports = {};
__export(rating_group_exports, {
  Context: () => RatingGroupContext,
  Control: () => RatingGroupControl,
  HiddenInput: () => RatingGroupHiddenInput,
  Item: () => RatingGroupItem,
  ItemContext: () => RatingGroupItemContext,
  Label: () => RatingGroupLabel,
  Root: () => RatingGroupRoot,
  RootProvider: () => RatingGroupRootProvider
});

// node_modules/@zag-js/collection/dist/index.mjs
var __defProp4 = Object.defineProperty;
var __defNormalProp4 = (obj, key, value) => key in obj ? __defProp4(obj, key, { enumerable: true, configurable: true, writable: true, value }) : obj[key] = value;
var __publicField4 = (obj, key, value) => __defNormalProp4(obj, typeof key !== "symbol" ? key + "" : key, value);
var fallback = {
  itemToValue(item) {
    if (typeof item === "string") return item;
    if (isObject3(item) && hasProp(item, "value")) return item.value;
    return "";
  },
  itemToString(item) {
    if (typeof item === "string") return item;
    if (isObject3(item) && hasProp(item, "label")) return item.label;
    return fallback.itemToValue(item);
  },
  isItemDisabled(item) {
    if (isObject3(item) && hasProp(item, "disabled")) return !!item.disabled;
    return false;
  }
};
var ListCollection = class {
  constructor(options) {
    this.options = options;
    __publicField4(this, "items");
    this.items = [...options.items];
  }
  isEqual(other) {
    return isEqual(this.items, other.items);
  }
  /**
   * Function to update the collection items
   */
  setItems(items) {
    this.items = Array.from(items);
  }
  /**
   * Returns all the values in the collection
   */
  getValues(items = this.items) {
    return Array.from(items).map((item) => this.getItemValue(item)).filter(Boolean);
  }
  /**
   * Get the item based on its value
   */
  find(value) {
    if (value == null) return null;
    const index = this.items.findIndex((item) => this.getItemValue(item) === value);
    return index != null ? this.items[index] : null;
  }
  /**
   * Get the items based on its values
   */
  findMany(values) {
    return Array.from(values).map((value) => this.find(value)).filter(Boolean);
  }
  /**
   * Get the item based on its index
   */
  at(index) {
    return this.items[index] ?? null;
  }
  sortFn(valueA, valueB) {
    const indexA = this.indexOf(valueA);
    const indexB = this.indexOf(valueB);
    return (indexA ?? 0) - (indexB ?? 0);
  }
  /**
   * Sort the values based on their index
   */
  sort(values) {
    return [...values].sort(this.sortFn.bind(this));
  }
  /**
   * Convert an item to a value
   */
  getItemValue(item) {
    var _a8, _b7;
    if (item == null) return null;
    return ((_b7 = (_a8 = this.options).itemToValue) == null ? void 0 : _b7.call(_a8, item)) ?? fallback.itemToValue(item);
  }
  /**
   * Whether an item is disabled
   */
  getItemDisabled(item) {
    var _a8, _b7;
    if (item == null) return false;
    return ((_b7 = (_a8 = this.options).isItemDisabled) == null ? void 0 : _b7.call(_a8, item)) ?? fallback.isItemDisabled(item);
  }
  /**
   * Convert an item to a string
   */
  stringifyItem(item) {
    var _a8, _b7;
    if (item == null) return null;
    return ((_b7 = (_a8 = this.options).itemToString) == null ? void 0 : _b7.call(_a8, item)) ?? fallback.itemToString(item);
  }
  /**
   * Convert a value to a string
   */
  stringify(value) {
    if (value == null) return null;
    return this.stringifyItem(this.find(value));
  }
  /**
   * Convert an array of items to a string
   */
  stringifyItems(items, separator = ", ") {
    return Array.from(items).map((item) => this.stringifyItem(item)).filter(Boolean).join(separator);
  }
  /**
   * Convert an array of items to a string
   */
  stringifyMany(value, separator) {
    return this.stringifyItems(this.findMany(value), separator);
  }
  /**
   * Whether the collection has a value
   */
  has(value) {
    return this.indexOf(value) !== -1;
  }
  /**
   * Whether the collection has an item
   */
  hasItem(item) {
    if (item == null) return false;
    return this.has(this.getItemValue(item));
  }
  /**
   * Returns the number of items in the collection
   */
  get size() {
    return this.items.length;
  }
  /**
   * Returns the first value in the collection
   */
  get firstValue() {
    let index = 0;
    while (this.getItemDisabled(this.at(index))) index++;
    return this.getItemValue(this.at(index));
  }
  /**
   * Returns the last value in the collection
   */
  get lastValue() {
    let index = this.size - 1;
    while (this.getItemDisabled(this.at(index))) index--;
    return this.getItemValue(this.at(index));
  }
  /**
   * Returns the next value in the collection
   */
  getNextValue(value, step = 1, clamp3 = false) {
    let index = this.indexOf(value);
    if (index === -1) return null;
    index = clamp3 ? Math.min(index + step, this.size - 1) : index + step;
    while (index <= this.size && this.getItemDisabled(this.at(index))) index++;
    return this.getItemValue(this.at(index));
  }
  /**
   * Returns the previous value in the collection
   */
  getPreviousValue(value, step = 1, clamp3 = false) {
    let index = this.indexOf(value);
    if (index === -1) return null;
    index = clamp3 ? Math.max(index - step, 0) : index - step;
    while (index >= 0 && this.getItemDisabled(this.at(index))) index--;
    return this.getItemValue(this.at(index));
  }
  /**
   * Get the index of an item based on its key
   */
  indexOf(value) {
    if (value == null) return -1;
    return this.items.findIndex((item) => this.getItemValue(item) === value);
  }
  getByText(text, current) {
    let items = current != null ? wrap4(this.items, this.indexOf(current)) : this.items;
    const isSingleKey = text.length === 1;
    if (isSingleKey) items = items.filter((item) => this.getItemValue(item) !== current);
    return items.find((item) => match3(this.stringifyItem(item), text));
  }
  /**
   * Search for a value based on a query
   */
  search(queryString, options) {
    const { state: state2, currentValue, timeout = 350 } = options;
    const search = state2.keysSoFar + queryString;
    const isRepeated = search.length > 1 && Array.from(search).every((char) => char === search[0]);
    const query2 = isRepeated ? search[0] : search;
    const item = this.getByText(query2, currentValue);
    const value = this.getItemValue(item);
    function cleanup() {
      clearTimeout(state2.timer);
      state2.timer = -1;
    }
    function update(value2) {
      state2.keysSoFar = value2;
      cleanup();
      if (value2 !== "") {
        state2.timer = +setTimeout(() => {
          update("");
          cleanup();
        }, timeout);
      }
    }
    update(search);
    return value;
  }
  *[Symbol.iterator]() {
    yield* this.items;
  }
  insertBefore(value, item) {
    const index = this.indexOf(value);
    if (index === -1) return;
    this.items.splice(index, 0, item);
  }
  insertAfter(value, item) {
    const index = this.indexOf(value);
    if (index === -1) return;
    this.items.splice(index + 1, 0, item);
  }
  reorder(fromIndex, toIndex) {
    if (fromIndex === -1 || toIndex === -1) return;
    if (fromIndex === toIndex) return;
    const [removed] = this.items.splice(fromIndex, 1);
    this.items.splice(toIndex, 0, removed);
  }
  json() {
    return {
      size: this.size,
      first: this.firstValue,
      last: this.lastValue
    };
  }
};
var match3 = (label, query2) => {
  return !!(label == null ? void 0 : label.toLowerCase().startsWith(query2.toLowerCase()));
};
var wrap4 = (v, idx) => {
  return v.map((_, index) => v[(Math.max(idx, 0) + index) % v.length]);
};
function access(node, indexPath, options) {
  for (let i = 0; i < indexPath.length; i++) node = options.getChildren(node, indexPath.slice(i + 1))[indexPath[i]];
  return node;
}
function ancestorIndexPaths(indexPaths) {
  const sortedPaths = sortIndexPaths(indexPaths);
  const result = [];
  const seen = /* @__PURE__ */ new Set();
  for (const indexPath of sortedPaths) {
    const key = indexPath.join();
    if (!seen.has(key)) {
      seen.add(key);
      result.push(indexPath);
    }
  }
  return result;
}
function compareIndexPaths(a, b) {
  for (let i = 0; i < Math.min(a.length, b.length); i++) {
    if (a[i] < b[i]) return -1;
    if (a[i] > b[i]) return 1;
  }
  return a.length - b.length;
}
function sortIndexPaths(indexPaths) {
  return indexPaths.sort(compareIndexPaths);
}
function find(node, options) {
  let found;
  visit(node, {
    ...options,
    onEnter: (child, indexPath) => {
      if (options.predicate(child, indexPath)) {
        found = child;
        return "stop";
      }
    }
  });
  return found;
}
function findIndexPath(node, options) {
  let found;
  visit(node, {
    onEnter: (child, indexPath) => {
      if (options.predicate(child, indexPath)) {
        found = [...indexPath];
        return "stop";
      }
    },
    getChildren: options.getChildren
  });
  return found;
}
function reduce(node, options) {
  let result = options.initialResult;
  visit(node, {
    ...options,
    onEnter: (child, indexPath) => {
      result = options.nextResult(result, child, indexPath);
    }
  });
  return result;
}
function flatMap(node, options) {
  return reduce(node, {
    ...options,
    initialResult: [],
    nextResult: (result, child, indexPath) => {
      result.push(...options.transform(child, indexPath));
      return result;
    }
  });
}
function insertOperation(index, nodes) {
  return { type: "insert", index, nodes };
}
function removeOperation(indexes) {
  return { type: "remove", indexes };
}
function replaceOperation() {
  return { type: "replace" };
}
function splitIndexPath(indexPath) {
  return [indexPath.slice(0, -1), indexPath[indexPath.length - 1]];
}
function getInsertionOperations(indexPath, nodes, operations = /* @__PURE__ */ new Map()) {
  var _a8;
  const [parentIndexPath, index] = splitIndexPath(indexPath);
  for (let i = parentIndexPath.length - 1; i >= 0; i--) {
    const parentKey = parentIndexPath.slice(0, i).join();
    switch ((_a8 = operations.get(parentKey)) == null ? void 0 : _a8.type) {
      case "remove":
        continue;
    }
    operations.set(parentKey, replaceOperation());
  }
  const operation = operations.get(parentIndexPath.join());
  switch (operation == null ? void 0 : operation.type) {
    case "remove":
      operations.set(parentIndexPath.join(), {
        type: "removeThenInsert",
        removeIndexes: operation.indexes,
        insertIndex: index,
        insertNodes: nodes
      });
      break;
    default:
      operations.set(parentIndexPath.join(), insertOperation(index, nodes));
  }
  return operations;
}
function getRemovalOperations(indexPaths) {
  const operations = /* @__PURE__ */ new Map();
  const indexesToRemove = /* @__PURE__ */ new Map();
  for (const indexPath of indexPaths) {
    const parentKey = indexPath.slice(0, -1).join();
    const value = indexesToRemove.get(parentKey) ?? [];
    value.push(indexPath[indexPath.length - 1]);
    indexesToRemove.set(
      parentKey,
      value.sort((a, b) => a - b)
    );
  }
  for (const indexPath of indexPaths) {
    for (let i = indexPath.length - 2; i >= 0; i--) {
      const parentKey = indexPath.slice(0, i).join();
      if (!operations.has(parentKey)) {
        operations.set(parentKey, replaceOperation());
      }
    }
  }
  for (const [parentKey, indexes] of indexesToRemove) {
    operations.set(parentKey, removeOperation(indexes));
  }
  return operations;
}
function getReplaceOperations(indexPath, node) {
  const operations = /* @__PURE__ */ new Map();
  const [parentIndexPath, index] = splitIndexPath(indexPath);
  for (let i = parentIndexPath.length - 1; i >= 0; i--) {
    const parentKey = parentIndexPath.slice(0, i).join();
    operations.set(parentKey, replaceOperation());
  }
  operations.set(parentIndexPath.join(), {
    type: "removeThenInsert",
    removeIndexes: [index],
    insertIndex: index,
    insertNodes: [node]
  });
  return operations;
}
function mutate(node, operations, options) {
  return map(node, {
    ...options,
    getChildren: (node2, indexPath) => {
      const key = indexPath.join();
      const operation = operations.get(key);
      switch (operation == null ? void 0 : operation.type) {
        case "replace":
        case "remove":
        case "removeThenInsert":
        case "insert":
          return options.getChildren(node2, indexPath);
        default:
          return [];
      }
    },
    transform: (node2, children, indexPath) => {
      const key = indexPath.join();
      const operation = operations.get(key);
      switch (operation == null ? void 0 : operation.type) {
        case "remove":
          return options.create(
            node2,
            children.filter((_, index) => !operation.indexes.includes(index)),
            indexPath
          );
        case "removeThenInsert":
          const updatedChildren = children.filter((_, index) => !operation.removeIndexes.includes(index));
          const adjustedIndex = operation.removeIndexes.reduce(
            (index, removedIndex) => removedIndex < index ? index - 1 : index,
            operation.insertIndex
          );
          return options.create(node2, splice(updatedChildren, adjustedIndex, 0, ...operation.insertNodes), indexPath);
        case "insert":
          return options.create(node2, splice(children, operation.index, 0, ...operation.nodes), indexPath);
        case "replace":
          return options.create(node2, children, indexPath);
        default:
          return node2;
      }
    }
  });
}
function splice(array, start, deleteCount, ...items) {
  return [...array.slice(0, start), ...items, ...array.slice(start + deleteCount)];
}
function map(node, options) {
  const childrenMap = {};
  visit(node, {
    ...options,
    onLeave: (child, indexPath) => {
      const keyIndexPath = [0, ...indexPath];
      const key = keyIndexPath.join();
      const transformed = options.transform(child, childrenMap[key] ?? [], indexPath);
      const parentKey = keyIndexPath.slice(0, -1).join();
      const parentChildren = childrenMap[parentKey] ?? [];
      parentChildren.push(transformed);
      childrenMap[parentKey] = parentChildren;
    }
  });
  return childrenMap[""][0];
}
function insert(node, options) {
  const { nodes, at } = options;
  if (at.length === 0) throw new Error(`Can't insert nodes at the root`);
  const state2 = getInsertionOperations(at, nodes);
  return mutate(node, state2, options);
}
function replace(node, options) {
  if (options.at.length === 0) return options.node;
  const operations = getReplaceOperations(options.at, options.node);
  return mutate(node, operations, options);
}
function remove2(node, options) {
  if (options.indexPaths.length === 0) return node;
  for (const indexPath of options.indexPaths) {
    if (indexPath.length === 0) throw new Error(`Can't remove the root node`);
  }
  const operations = getRemovalOperations(options.indexPaths);
  return mutate(node, operations, options);
}
function move(node, options) {
  if (options.indexPaths.length === 0) return node;
  for (const indexPath of options.indexPaths) {
    if (indexPath.length === 0) throw new Error(`Can't move the root node`);
  }
  if (options.to.length === 0) throw new Error(`Can't move nodes to the root`);
  const _ancestorIndexPaths = ancestorIndexPaths(options.indexPaths);
  const nodesToInsert = _ancestorIndexPaths.map((indexPath) => access(node, indexPath, options));
  const operations = getInsertionOperations(options.to, nodesToInsert, getRemovalOperations(_ancestorIndexPaths));
  return mutate(node, operations, options);
}
function visit(node, options) {
  const { onEnter, onLeave, getChildren } = options;
  let indexPath = [];
  let stack = [{ node }];
  const getIndexPath = options.reuseIndexPath ? () => indexPath : () => indexPath.slice();
  while (stack.length > 0) {
    let wrapper = stack[stack.length - 1];
    if (wrapper.state === void 0) {
      const enterResult = onEnter == null ? void 0 : onEnter(wrapper.node, getIndexPath());
      if (enterResult === "stop") return;
      wrapper.state = enterResult === "skip" ? -1 : 0;
    }
    const children = wrapper.children || getChildren(wrapper.node, getIndexPath());
    wrapper.children || (wrapper.children = children);
    if (wrapper.state !== -1) {
      if (wrapper.state < children.length) {
        let currentIndex = wrapper.state;
        indexPath.push(currentIndex);
        stack.push({ node: children[currentIndex] });
        wrapper.state = currentIndex + 1;
        continue;
      }
      const leaveResult = onLeave == null ? void 0 : onLeave(wrapper.node, getIndexPath());
      if (leaveResult === "stop") return;
    }
    indexPath.pop();
    stack.pop();
  }
}
var TreeCollection = class {
  constructor(options) {
    this.options = options;
    __publicField4(this, "rootNode");
    __publicField4(this, "isEqual", (other) => {
      return isEqual(this.rootNode, other.rootNode);
    });
    __publicField4(this, "getNodeChildren", (node) => {
      var _a8, _b7;
      return ((_b7 = (_a8 = this.options).nodeToChildren) == null ? void 0 : _b7.call(_a8, node)) ?? fallback2.nodeToChildren(node) ?? [];
    });
    __publicField4(this, "getNodeValue", (node) => {
      var _a8, _b7;
      return ((_b7 = (_a8 = this.options).nodeToValue) == null ? void 0 : _b7.call(_a8, node)) ?? fallback2.nodeToValue(node);
    });
    __publicField4(this, "getNodeDisabled", (node) => {
      var _a8, _b7;
      return ((_b7 = (_a8 = this.options).isNodeDisabled) == null ? void 0 : _b7.call(_a8, node)) ?? fallback2.isNodeDisabled(node);
    });
    __publicField4(this, "stringify", (value) => {
      const node = this.findNode(value);
      if (!node) return null;
      return this.stringifyNode(node);
    });
    __publicField4(this, "stringifyNode", (node) => {
      var _a8, _b7;
      return ((_b7 = (_a8 = this.options).nodeToString) == null ? void 0 : _b7.call(_a8, node)) ?? fallback2.nodeToString(node);
    });
    __publicField4(this, "getFirstNode", (rootNode = this.rootNode) => {
      let firstChild;
      visit(rootNode, {
        getChildren: this.getNodeChildren,
        onEnter: (node, indexPath) => {
          if (!firstChild && indexPath.length > 0 && !this.getNodeDisabled(node)) {
            firstChild = node;
            return "stop";
          }
        }
      });
      return firstChild;
    });
    __publicField4(this, "getLastNode", (rootNode = this.rootNode, opts = {}) => {
      let lastChild;
      visit(rootNode, {
        getChildren: this.getNodeChildren,
        onEnter: (node, indexPath) => {
          var _a8;
          const nodeValue = this.getNodeValue(node);
          if ((_a8 = opts.skip) == null ? void 0 : _a8.call(opts, { value: nodeValue, node, indexPath })) return "skip";
          if (indexPath.length > 1) return "skip";
          if (!this.getNodeDisabled(node)) {
            lastChild = node;
          }
        }
      });
      return lastChild;
    });
    __publicField4(this, "at", (indexPath) => {
      return access(this.rootNode, indexPath, {
        getChildren: this.getNodeChildren
      });
    });
    __publicField4(this, "findNode", (value, rootNode = this.rootNode) => {
      return find(rootNode, {
        getChildren: this.getNodeChildren,
        predicate: (node) => this.getNodeValue(node) === value
      });
    });
    __publicField4(this, "sort", (values) => {
      return values.reduce(
        (acc, value) => {
          const indexPath = this.getIndexPath(value);
          if (indexPath != null) acc.push({ value, indexPath });
          return acc;
        },
        []
      ).sort((a, b) => compareIndexPaths(a.indexPath, b.indexPath)).map(({ value }) => value);
    });
    __publicField4(this, "getIndexPath", (value) => {
      return findIndexPath(this.rootNode, {
        getChildren: this.getNodeChildren,
        predicate: (node) => this.getNodeValue(node) === value
      });
    });
    __publicField4(this, "getValue", (indexPath) => {
      const node = this.at(indexPath);
      return node ? this.getNodeValue(node) : void 0;
    });
    __publicField4(this, "getValuePath", (indexPath) => {
      if (!indexPath) return [];
      const valuePath = [];
      let currentPath = [...indexPath];
      while (currentPath.length > 0) {
        const node = this.at(currentPath);
        if (node) valuePath.unshift(this.getNodeValue(node));
        currentPath.pop();
      }
      return valuePath;
    });
    __publicField4(this, "getDepth", (value) => {
      const indexPath = findIndexPath(this.rootNode, {
        getChildren: this.getNodeChildren,
        predicate: (node) => this.getNodeValue(node) === value
      });
      return (indexPath == null ? void 0 : indexPath.length) ?? 0;
    });
    __publicField4(this, "isRootNode", (node) => {
      return this.getNodeValue(node) === this.getNodeValue(this.rootNode);
    });
    __publicField4(this, "contains", (parentIndexPath, valueIndexPath) => {
      if (!parentIndexPath || !valueIndexPath) return false;
      return valueIndexPath.slice(0, parentIndexPath.length).every((_, i) => parentIndexPath[i] === valueIndexPath[i]);
    });
    __publicField4(this, "getNextNode", (value, opts = {}) => {
      let found = false;
      let nextNode;
      visit(this.rootNode, {
        getChildren: this.getNodeChildren,
        onEnter: (node, indexPath) => {
          var _a8;
          if (this.isRootNode(node)) return;
          const nodeValue = this.getNodeValue(node);
          if ((_a8 = opts.skip) == null ? void 0 : _a8.call(opts, { value: nodeValue, node, indexPath })) {
            if (nodeValue === value) {
              found = true;
            }
            return "skip";
          }
          if (found && !this.getNodeDisabled(node)) {
            nextNode = node;
            return "stop";
          }
          if (nodeValue === value) {
            found = true;
          }
        }
      });
      return nextNode;
    });
    __publicField4(this, "getPreviousNode", (value, opts = {}) => {
      let previousNode;
      let found = false;
      visit(this.rootNode, {
        getChildren: this.getNodeChildren,
        onEnter: (node, indexPath) => {
          var _a8;
          if (this.isRootNode(node)) return;
          const nodeValue = this.getNodeValue(node);
          if ((_a8 = opts.skip) == null ? void 0 : _a8.call(opts, { value: nodeValue, node, indexPath })) {
            return "skip";
          }
          if (nodeValue === value) {
            found = true;
            return "stop";
          }
          if (!this.getNodeDisabled(node)) {
            previousNode = node;
          }
        }
      });
      return found ? previousNode : void 0;
    });
    __publicField4(this, "getParentNodes", (values) => {
      const result = [];
      let indexPath = this.getIndexPath(values);
      while (indexPath && indexPath.length > 0) {
        indexPath.pop();
        const parentNode = this.at(indexPath);
        if (parentNode && !this.isRootNode(parentNode)) {
          result.unshift(parentNode);
        }
      }
      return result;
    });
    __publicField4(this, "getParentIndexPath", (indexPath) => {
      return indexPath.slice(0, -1);
    });
    __publicField4(this, "getParentNode", (valueOrIndexPath) => {
      const indexPath = typeof valueOrIndexPath === "string" ? this.getIndexPath(valueOrIndexPath) : valueOrIndexPath;
      return indexPath ? this.at(this.getParentIndexPath(indexPath)) : void 0;
    });
    __publicField4(this, "visit", (opts) => {
      const { skip, ...rest } = opts;
      visit(this.rootNode, {
        ...rest,
        getChildren: this.getNodeChildren,
        onEnter: (node, indexPath) => {
          var _a8;
          if (this.isRootNode(node)) return;
          if (skip == null ? void 0 : skip({ value: this.getNodeValue(node), node, indexPath })) return "skip";
          return (_a8 = rest.onEnter) == null ? void 0 : _a8.call(rest, node, indexPath);
        }
      });
    });
    __publicField4(this, "getPreviousSibling", (indexPath) => {
      const parentNode = this.getParentNode(indexPath);
      if (!parentNode) return;
      const siblings = this.getNodeChildren(parentNode);
      let idx = siblings.findIndex((sibling) => this.getValue(indexPath) === this.getNodeValue(sibling));
      while (--idx >= 0) {
        const sibling = siblings[idx];
        if (!this.getNodeDisabled(sibling)) return sibling;
      }
      return;
    });
    __publicField4(this, "getNextSibling", (indexPath) => {
      const parentNode = this.getParentNode(indexPath);
      if (!parentNode) return;
      const siblings = this.getNodeChildren(parentNode);
      let idx = siblings.findIndex((sibling) => this.getValue(indexPath) === this.getNodeValue(sibling));
      while (++idx < siblings.length) {
        const sibling = siblings[idx];
        if (!this.getNodeDisabled(sibling)) return sibling;
      }
      return;
    });
    __publicField4(this, "getSiblingNodes", (indexPath) => {
      const parentNode = this.getParentNode(indexPath);
      return parentNode ? this.getNodeChildren(parentNode) : [];
    });
    __publicField4(this, "getValues", (rootNode = this.rootNode) => {
      const values = flatMap(rootNode, {
        getChildren: this.getNodeChildren,
        transform: (node) => [this.getNodeValue(node)]
      });
      return values.slice(1);
    });
    __publicField4(this, "isSameDepth", (indexPath, depth) => {
      if (depth == null) return true;
      return indexPath.length === depth;
    });
    __publicField4(this, "isBranchNode", (node) => {
      return this.getNodeChildren(node).length > 0;
    });
    __publicField4(this, "getBranchValues", (rootNode = this.rootNode, opts = {}) => {
      let values = [];
      visit(rootNode, {
        getChildren: this.getNodeChildren,
        onEnter: (node, indexPath) => {
          var _a8;
          const nodeValue = this.getNodeValue(node);
          if ((_a8 = opts.skip) == null ? void 0 : _a8.call(opts, { value: nodeValue, node, indexPath })) return "skip";
          if (this.getNodeChildren(node).length > 0 && this.isSameDepth(indexPath, opts.depth)) {
            values.push(this.getNodeValue(node));
          }
        }
      });
      return values.slice(1);
    });
    __publicField4(this, "flatten", (rootNode = this.rootNode) => {
      const nodes = flatMap(rootNode, {
        getChildren: this.getNodeChildren,
        transform: (node, indexPath) => {
          const children = this.getNodeChildren(node).map((child) => this.getNodeValue(child));
          return [
            compact2({
              label: this.stringifyNode(node),
              value: this.getNodeValue(node),
              indexPath,
              children: children.length > 0 ? children : void 0
            })
          ];
        }
      });
      return nodes.slice(1);
    });
    __publicField4(this, "_create", (node, children) => {
      return compact2({ ...node, children });
    });
    __publicField4(this, "_insert", (rootNode, indexPath, nodes) => {
      return insert(rootNode, { at: indexPath, nodes, getChildren: this.getNodeChildren, create: this._create });
    });
    __publicField4(this, "_replace", (rootNode, indexPath, node) => {
      return replace(rootNode, { at: indexPath, node, getChildren: this.getNodeChildren, create: this._create });
    });
    __publicField4(this, "_move", (rootNode, indexPaths, to) => {
      return move(rootNode, { indexPaths, to, getChildren: this.getNodeChildren, create: this._create });
    });
    __publicField4(this, "_remove", (rootNode, indexPaths) => {
      return remove2(rootNode, { indexPaths, getChildren: this.getNodeChildren, create: this._create });
    });
    __publicField4(this, "replace", (indexPath, node) => {
      return this._replace(this.rootNode, indexPath, node);
    });
    __publicField4(this, "remove", (indexPaths) => {
      return this._remove(this.rootNode, indexPaths);
    });
    __publicField4(this, "insertBefore", (indexPath, nodes) => {
      const parentNode = this.getParentNode(indexPath);
      return parentNode ? this._insert(this.rootNode, indexPath, nodes) : void 0;
    });
    __publicField4(this, "insertAfter", (indexPath, nodes) => {
      const parentNode = this.getParentNode(indexPath);
      if (!parentNode) return;
      const nextIndex2 = [...indexPath.slice(0, -1), indexPath[indexPath.length - 1] + 1];
      return this._insert(this.rootNode, nextIndex2, nodes);
    });
    __publicField4(this, "move", (fromIndexPaths, toIndexPath) => {
      return this._move(this.rootNode, fromIndexPaths, toIndexPath);
    });
    __publicField4(this, "json", () => {
      return this.getValues(this.rootNode);
    });
    this.rootNode = options.rootNode;
  }
};
var fallback2 = {
  nodeToValue(node) {
    if (typeof node === "string") return node;
    if (isObject3(node) && hasProp(node, "value")) return node.value;
    return "";
  },
  nodeToString(node) {
    if (typeof node === "string") return node;
    if (isObject3(node) && hasProp(node, "label")) return node.label;
    return fallback2.nodeToValue(node);
  },
  isNodeDisabled(node) {
    if (isObject3(node) && hasProp(node, "disabled")) return !!node.disabled;
    return false;
  },
  nodeToChildren(node) {
    return node.children;
  }
};

// node_modules/@ark-ui/react/dist/components/collection.js
var createListCollection = (options) => ref(new ListCollection(options));

// node_modules/@ark-ui/react/dist/components/select/select-clear-trigger.js
var import_jsx_runtime102 = __toESM(require_jsx_runtime(), 1);
var import_react225 = __toESM(require_react(), 1);

// node_modules/@ark-ui/react/dist/components/select/use-select-context.js
var [SelectProvider, useSelectContext] = createContext({
  name: "SelectContext",
  hookName: "useSelectContext",
  providerName: "<SelectProvider />"
});

// node_modules/@ark-ui/react/dist/components/select/select-clear-trigger.js
var SelectClearTrigger = (0, import_react225.forwardRef)(
  (props21, ref2) => {
    const select = useSelectContext();
    const mergedProps = mergeProps(select.getClearTriggerProps(), props21);
    return (0, import_jsx_runtime102.jsx)(ark.button, { ...mergedProps, ref: ref2 });
  }
);
SelectClearTrigger.displayName = "SelectClearTrigger";

// node_modules/@ark-ui/react/dist/components/select/select-content.js
var import_jsx_runtime103 = __toESM(require_jsx_runtime(), 1);
var import_react227 = __toESM(require_react(), 1);
var SelectContent = (0, import_react227.forwardRef)((props21, ref2) => {
  const select = useSelectContext();
  const presence = usePresenceContext();
  const mergedProps = mergeProps(select.getContentProps(), presence.getPresenceProps(), props21);
  if (presence.unmounted) {
    return null;
  }
  return (0, import_jsx_runtime103.jsx)(ark.div, { ...mergedProps, ref: composeRefs(presence.ref, ref2) });
});
SelectContent.displayName = "SelectContent";

// node_modules/@ark-ui/react/dist/components/select/select-context.js
var SelectContext = (props21) => props21.children(useSelectContext());

// node_modules/@ark-ui/react/dist/components/select/select-control.js
var import_jsx_runtime104 = __toESM(require_jsx_runtime(), 1);
var import_react229 = __toESM(require_react(), 1);
var SelectControl = (0, import_react229.forwardRef)((props21, ref2) => {
  const select = useSelectContext();
  const mergedProps = mergeProps(select.getControlProps(), props21);
  return (0, import_jsx_runtime104.jsx)(ark.div, { ...mergedProps, ref: ref2 });
});
SelectControl.displayName = "SelectControl";

// node_modules/@ark-ui/react/dist/components/select/select-hidden-select.js
var import_jsx_runtime105 = __toESM(require_jsx_runtime(), 1);
var import_react231 = __toESM(require_react(), 1);
var SelectHiddenSelect = (0, import_react231.forwardRef)(
  (props21, ref2) => {
    const select = useSelectContext();
    const mergedProps = mergeProps(select.getHiddenSelectProps(), props21);
    const isValueEmpty = select.value.length === 0;
    const field = useFieldContext();
    return (0, import_jsx_runtime105.jsxs)(ark.select, { "aria-describedby": field == null ? void 0 : field.ariaDescribedby, ...mergedProps, ref: ref2, children: [
      isValueEmpty && (0, import_jsx_runtime105.jsx)("option", { value: "" }),
      select.collection.items.map((item, index) => (0, import_jsx_runtime105.jsx)(
        "option",
        {
          value: select.collection.getItemValue(item) ?? "",
          disabled: select.collection.getItemDisabled(item)
        },
        index
      ))
    ] });
  }
);
SelectHiddenSelect.displayName = "SelectHiddenSelect";

// node_modules/@ark-ui/react/dist/components/select/select-indicator.js
var import_jsx_runtime106 = __toESM(require_jsx_runtime(), 1);
var import_react233 = __toESM(require_react(), 1);
var SelectIndicator = (0, import_react233.forwardRef)((props21, ref2) => {
  const select = useSelectContext();
  const mergedProps = mergeProps(select.getIndicatorProps(), props21);
  return (0, import_jsx_runtime106.jsx)(ark.div, { ...mergedProps, ref: ref2 });
});
SelectIndicator.displayName = "SelectIndicator";

// node_modules/@ark-ui/react/dist/components/select/select-item.js
var import_jsx_runtime107 = __toESM(require_jsx_runtime(), 1);
var import_react235 = __toESM(require_react(), 1);

// node_modules/@ark-ui/react/dist/components/select/use-select-item-context.js
var [SelectItemProvider, useSelectItemContext] = createContext({
  name: "SelectItemContext",
  hookName: "useSelectItemContext",
  providerName: "<SelectItemProvider />"
});

// node_modules/@ark-ui/react/dist/components/select/use-select-item-props-context.js
var [SelectItemPropsProvider, useSelectItemPropsContext] = createContext({
  name: "SelectItemPropsContext",
  hookName: "useSelectItemPropsContext",
  providerName: "<SelectItemPropsProvider />"
});

// node_modules/@ark-ui/react/dist/components/select/select-item.js
var SelectItem = (0, import_react235.forwardRef)((props21, ref2) => {
  const [itemProps7, localProps] = createSplitProps2()(props21, ["item", "persistFocus"]);
  const select = useSelectContext();
  const mergedProps = mergeProps(select.getItemProps(itemProps7), localProps);
  const itemState = select.getItemState(itemProps7);
  return (0, import_jsx_runtime107.jsx)(SelectItemPropsProvider, { value: itemProps7, children: (0, import_jsx_runtime107.jsx)(SelectItemProvider, { value: itemState, children: (0, import_jsx_runtime107.jsx)(ark.div, { ...mergedProps, ref: ref2 }) }) });
});
SelectItem.displayName = "SelectItem";

// node_modules/@ark-ui/react/dist/components/select/select-item-context.js
var SelectItemContext = (props21) => props21.children(useSelectItemContext());

// node_modules/@ark-ui/react/dist/components/select/select-item-group.js
var import_jsx_runtime108 = __toESM(require_jsx_runtime(), 1);
var import_react237 = __toESM(require_react(), 1);

// node_modules/@ark-ui/react/dist/components/select/use-select-item-group-props.js
var [SelectItemGroupPropsProvider, useSelectItemGroupPropsContext] = createContext({
  name: "SelectItemGroupPropsContext",
  hookName: "useSelectItemGroupPropsContext",
  providerName: "<SelectItemGroupPropsProvider />"
});

// node_modules/@ark-ui/react/dist/components/select/select-item-group.js
var SelectItemGroup = (0, import_react237.forwardRef)((props21, ref2) => {
  const id = (0, import_react237.useId)();
  const [_itemGroupProps, localProps] = createSplitProps2()(props21, ["id"]);
  const itemGroupProps3 = { id, ..._itemGroupProps };
  const select = useSelectContext();
  const mergedProps = mergeProps(select.getItemGroupProps(itemGroupProps3), localProps);
  return (0, import_jsx_runtime108.jsx)(SelectItemGroupPropsProvider, { value: itemGroupProps3, children: (0, import_jsx_runtime108.jsx)(ark.div, { ...mergedProps, ref: ref2 }) });
});
SelectItemGroup.displayName = "SelectItemGroup";

// node_modules/@ark-ui/react/dist/components/select/select-item-group-label.js
var import_jsx_runtime109 = __toESM(require_jsx_runtime(), 1);
var import_react239 = __toESM(require_react(), 1);
var SelectItemGroupLabel = (0, import_react239.forwardRef)(
  (props21, ref2) => {
    const select = useSelectContext();
    const itemGroupProps3 = useSelectItemGroupPropsContext();
    const mergedProps = mergeProps(
      select.getItemGroupLabelProps({ htmlFor: itemGroupProps3.id }),
      props21
    );
    return (0, import_jsx_runtime109.jsx)(ark.div, { ...mergedProps, ref: ref2 });
  }
);
SelectItemGroupLabel.displayName = "SelectItemGroupLabel";

// node_modules/@ark-ui/react/dist/components/select/select-item-indicator.js
var import_jsx_runtime110 = __toESM(require_jsx_runtime(), 1);
var import_react241 = __toESM(require_react(), 1);
var SelectItemIndicator = (0, import_react241.forwardRef)(
  (props21, ref2) => {
    const select = useSelectContext();
    const itemProps7 = useSelectItemPropsContext();
    const mergedProps = mergeProps(select.getItemIndicatorProps(itemProps7), props21);
    return (0, import_jsx_runtime110.jsx)(ark.div, { ...mergedProps, ref: ref2 });
  }
);
SelectItemIndicator.displayName = "SelectItemIndicator";

// node_modules/@ark-ui/react/dist/components/select/select-item-text.js
var import_jsx_runtime111 = __toESM(require_jsx_runtime(), 1);
var import_react243 = __toESM(require_react(), 1);
var SelectItemText = (0, import_react243.forwardRef)((props21, ref2) => {
  const select = useSelectContext();
  const itemProps7 = useSelectItemPropsContext();
  const mergedProps = mergeProps(select.getItemTextProps(itemProps7), props21);
  return (0, import_jsx_runtime111.jsx)(ark.span, { ...mergedProps, ref: ref2 });
});
SelectItemText.displayName = "SelectItemText";

// node_modules/@ark-ui/react/dist/components/select/select-label.js
var import_jsx_runtime112 = __toESM(require_jsx_runtime(), 1);
var import_react245 = __toESM(require_react(), 1);
var SelectLabel = (0, import_react245.forwardRef)((props21, ref2) => {
  const select = useSelectContext();
  const mergedProps = mergeProps(select.getLabelProps(), props21);
  return (0, import_jsx_runtime112.jsx)(ark.label, { ...mergedProps, ref: ref2 });
});
SelectLabel.displayName = "SelectLabel";

// node_modules/@ark-ui/react/dist/components/select/select-list.js
var import_jsx_runtime113 = __toESM(require_jsx_runtime(), 1);
var import_react247 = __toESM(require_react(), 1);
var SelectList = (0, import_react247.forwardRef)((props21, ref2) => {
  const select = useSelectContext();
  const mergedProps = mergeProps(select.getListProps(), props21);
  return (0, import_jsx_runtime113.jsx)(ark.div, { ...mergedProps, ref: ref2 });
});
SelectList.displayName = "SelectList";

// node_modules/@ark-ui/react/dist/components/select/select-positioner.js
var import_jsx_runtime114 = __toESM(require_jsx_runtime(), 1);
var import_react249 = __toESM(require_react(), 1);
var SelectPositioner = (0, import_react249.forwardRef)((props21, ref2) => {
  const select = useSelectContext();
  const mergedProps = mergeProps(select.getPositionerProps(), props21);
  const presence = usePresenceContext();
  if (presence.unmounted) {
    return null;
  }
  return (0, import_jsx_runtime114.jsx)(ark.div, { ...mergedProps, ref: ref2 });
});
SelectPositioner.displayName = "SelectPositioner";

// node_modules/@ark-ui/react/dist/components/select/select-root.js
var import_jsx_runtime115 = __toESM(require_jsx_runtime(), 1);
var import_react253 = __toESM(require_react(), 1);

// node_modules/@zag-js/select/dist/index.mjs
var anatomy12 = createAnatomy("select").parts(
  "label",
  "positioner",
  "trigger",
  "indicator",
  "clearTrigger",
  "item",
  "itemText",
  "itemIndicator",
  "itemGroup",
  "itemGroupLabel",
  "list",
  "content",
  "root",
  "control",
  "valueText"
);
var parts14 = anatomy12.build();
var collection = (options) => {
  return ref(new ListCollection(options));
};
collection.empty = () => {
  return ref(new ListCollection({ items: [] }));
};
var dom12 = createScope({
  getRootId: (ctx) => {
    var _a8;
    return ((_a8 = ctx.ids) == null ? void 0 : _a8.root) ?? `select:${ctx.id}`;
  },
  getContentId: (ctx) => {
    var _a8;
    return ((_a8 = ctx.ids) == null ? void 0 : _a8.content) ?? `select:${ctx.id}:content`;
  },
  getTriggerId: (ctx) => {
    var _a8;
    return ((_a8 = ctx.ids) == null ? void 0 : _a8.trigger) ?? `select:${ctx.id}:trigger`;
  },
  getClearTriggerId: (ctx) => {
    var _a8;
    return ((_a8 = ctx.ids) == null ? void 0 : _a8.clearTrigger) ?? `select:${ctx.id}:clear-trigger`;
  },
  getLabelId: (ctx) => {
    var _a8;
    return ((_a8 = ctx.ids) == null ? void 0 : _a8.label) ?? `select:${ctx.id}:label`;
  },
  getControlId: (ctx) => {
    var _a8;
    return ((_a8 = ctx.ids) == null ? void 0 : _a8.control) ?? `select:${ctx.id}:control`;
  },
  getItemId: (ctx, id) => {
    var _a8, _b7;
    return ((_b7 = (_a8 = ctx.ids) == null ? void 0 : _a8.item) == null ? void 0 : _b7.call(_a8, id)) ?? `select:${ctx.id}:option:${id}`;
  },
  getHiddenSelectId: (ctx) => {
    var _a8;
    return ((_a8 = ctx.ids) == null ? void 0 : _a8.hiddenSelect) ?? `select:${ctx.id}:select`;
  },
  getPositionerId: (ctx) => {
    var _a8;
    return ((_a8 = ctx.ids) == null ? void 0 : _a8.positioner) ?? `select:${ctx.id}:positioner`;
  },
  getItemGroupId: (ctx, id) => {
    var _a8, _b7;
    return ((_b7 = (_a8 = ctx.ids) == null ? void 0 : _a8.itemGroup) == null ? void 0 : _b7.call(_a8, id)) ?? `select:${ctx.id}:optgroup:${id}`;
  },
  getItemGroupLabelId: (ctx, id) => {
    var _a8, _b7;
    return ((_b7 = (_a8 = ctx.ids) == null ? void 0 : _a8.itemGroupLabel) == null ? void 0 : _b7.call(_a8, id)) ?? `select:${ctx.id}:optgroup-label:${id}`;
  },
  getHiddenSelectEl: (ctx) => dom12.getById(ctx, dom12.getHiddenSelectId(ctx)),
  getContentEl: (ctx) => dom12.getById(ctx, dom12.getContentId(ctx)),
  getControlEl: (ctx) => dom12.getById(ctx, dom12.getControlId(ctx)),
  getTriggerEl: (ctx) => dom12.getById(ctx, dom12.getTriggerId(ctx)),
  getClearTriggerEl: (ctx) => dom12.getById(ctx, dom12.getClearTriggerId(ctx)),
  getPositionerEl: (ctx) => dom12.getById(ctx, dom12.getPositionerId(ctx)),
  getHighlightedOptionEl(ctx) {
    if (!ctx.highlightedValue) return null;
    return dom12.getById(ctx, dom12.getItemId(ctx, ctx.highlightedValue));
  }
});
function connect13(state2, send, normalize2) {
  const disabled = state2.context.isDisabled;
  const invalid = state2.context.invalid;
  const readOnly = state2.context.readOnly;
  const interactive = state2.context.isInteractive;
  const composite = state2.context.composite;
  const open = state2.hasTag("open");
  const focused = state2.matches("focused");
  const highlightedValue = state2.context.highlightedValue;
  const highlightedItem = state2.context.highlightedItem;
  const selectedItems = state2.context.selectedItems;
  const isTypingAhead = state2.context.isTypingAhead;
  const collection2 = state2.context.collection;
  const ariaActiveDescendant = highlightedValue ? dom12.getItemId(state2.context, highlightedValue) : void 0;
  function getItemState(props22) {
    const _disabled = collection2.getItemDisabled(props22.item);
    const value = collection2.getItemValue(props22.item);
    return {
      value,
      disabled: Boolean(disabled || _disabled),
      highlighted: highlightedValue === value,
      selected: state2.context.value.includes(value)
    };
  }
  const popperStyles = getPlacementStyles({
    ...state2.context.positioning,
    placement: state2.context.currentPlacement
  });
  return {
    open,
    focused,
    empty: state2.context.value.length === 0,
    highlightedItem,
    highlightedValue,
    selectedItems,
    hasSelectedItems: state2.context.hasSelectedItems,
    value: state2.context.value,
    valueAsString: state2.context.valueAsString,
    collection: collection2,
    multiple: !!state2.context.multiple,
    disabled: !!disabled,
    setCollection(collection3) {
      send({ type: "COLLECTION.SET", value: collection3 });
    },
    reposition(options = {}) {
      send({ type: "POSITIONING.SET", options });
    },
    focus() {
      var _a8;
      (_a8 = dom12.getTriggerEl(state2.context)) == null ? void 0 : _a8.focus({ preventScroll: true });
    },
    setOpen(nextOpen) {
      if (nextOpen === open) return;
      send(nextOpen ? "OPEN" : "CLOSE");
    },
    selectValue(value) {
      send({ type: "ITEM.SELECT", value });
    },
    setValue(value) {
      send({ type: "VALUE.SET", value });
    },
    selectAll() {
      send({ type: "VALUE.SET", value: collection2.getValues() });
    },
    highlightValue(value) {
      send({ type: "HIGHLIGHTED_VALUE.SET", value });
    },
    clearValue(value) {
      if (value) {
        send({ type: "ITEM.CLEAR", value });
      } else {
        send({ type: "VALUE.CLEAR" });
      }
    },
    getItemState,
    getRootProps() {
      return normalize2.element({
        ...parts14.root.attrs,
        dir: state2.context.dir,
        id: dom12.getRootId(state2.context),
        "data-invalid": dataAttr(invalid),
        "data-readonly": dataAttr(readOnly)
      });
    },
    getLabelProps() {
      return normalize2.label({
        dir: state2.context.dir,
        id: dom12.getLabelId(state2.context),
        ...parts14.label.attrs,
        "data-disabled": dataAttr(disabled),
        "data-invalid": dataAttr(invalid),
        "data-readonly": dataAttr(readOnly),
        htmlFor: dom12.getHiddenSelectId(state2.context),
        onClick(event) {
          var _a8;
          if (event.defaultPrevented) return;
          if (disabled) return;
          (_a8 = dom12.getTriggerEl(state2.context)) == null ? void 0 : _a8.focus({ preventScroll: true });
        }
      });
    },
    getControlProps() {
      return normalize2.element({
        ...parts14.control.attrs,
        dir: state2.context.dir,
        id: dom12.getControlId(state2.context),
        "data-state": open ? "open" : "closed",
        "data-focus": dataAttr(focused),
        "data-disabled": dataAttr(disabled),
        "data-invalid": dataAttr(invalid)
      });
    },
    getValueTextProps() {
      return normalize2.element({
        ...parts14.valueText.attrs,
        dir: state2.context.dir,
        "data-disabled": dataAttr(disabled),
        "data-invalid": dataAttr(invalid),
        "data-focus": dataAttr(focused)
      });
    },
    getTriggerProps() {
      return normalize2.button({
        id: dom12.getTriggerId(state2.context),
        disabled,
        dir: state2.context.dir,
        type: "button",
        role: "combobox",
        "aria-controls": dom12.getContentId(state2.context),
        "aria-expanded": open,
        "aria-haspopup": "listbox",
        "data-state": open ? "open" : "closed",
        "aria-invalid": invalid,
        "aria-labelledby": dom12.getLabelId(state2.context),
        ...parts14.trigger.attrs,
        "data-disabled": dataAttr(disabled),
        "data-invalid": dataAttr(invalid),
        "data-readonly": dataAttr(readOnly),
        "data-placement": state2.context.currentPlacement,
        "data-placeholder-shown": dataAttr(!state2.context.hasSelectedItems),
        onClick(event) {
          if (!interactive) return;
          if (event.defaultPrevented) return;
          send({ type: "TRIGGER.CLICK" });
        },
        onFocus() {
          send("TRIGGER.FOCUS");
        },
        onBlur() {
          send("TRIGGER.BLUR");
        },
        onKeyDown(event) {
          if (event.defaultPrevented) return;
          if (!interactive) return;
          const keyMap2 = {
            ArrowUp() {
              send({ type: "TRIGGER.ARROW_UP" });
            },
            ArrowDown(event2) {
              send({ type: event2.altKey ? "OPEN" : "TRIGGER.ARROW_DOWN" });
            },
            ArrowLeft() {
              send({ type: "TRIGGER.ARROW_LEFT" });
            },
            ArrowRight() {
              send({ type: "TRIGGER.ARROW_RIGHT" });
            },
            Home() {
              send({ type: "TRIGGER.HOME" });
            },
            End() {
              send({ type: "TRIGGER.END" });
            },
            Enter() {
              send({ type: "TRIGGER.ENTER" });
            },
            Space(event2) {
              if (isTypingAhead) {
                send({ type: "TRIGGER.TYPEAHEAD", key: event2.key });
              } else {
                send({ type: "TRIGGER.ENTER" });
              }
            }
          };
          const exec2 = keyMap2[getEventKey(event, state2.context)];
          if (exec2) {
            exec2(event);
            event.preventDefault();
            return;
          }
          if (getByTypeahead.isValidEvent(event)) {
            send({ type: "TRIGGER.TYPEAHEAD", key: event.key });
            event.preventDefault();
          }
        }
      });
    },
    getIndicatorProps() {
      return normalize2.element({
        ...parts14.indicator.attrs,
        dir: state2.context.dir,
        "aria-hidden": true,
        "data-state": open ? "open" : "closed",
        "data-disabled": dataAttr(disabled),
        "data-invalid": dataAttr(invalid),
        "data-readonly": dataAttr(readOnly)
      });
    },
    getItemProps(props22) {
      const itemState = getItemState(props22);
      return normalize2.element({
        id: dom12.getItemId(state2.context, itemState.value),
        role: "option",
        ...parts14.item.attrs,
        dir: state2.context.dir,
        "data-value": itemState.value,
        "aria-selected": itemState.selected,
        "data-state": itemState.selected ? "checked" : "unchecked",
        "data-highlighted": dataAttr(itemState.highlighted),
        "data-disabled": dataAttr(itemState.disabled),
        "aria-disabled": ariaAttr(itemState.disabled),
        onPointerMove(event) {
          if (itemState.disabled || event.pointerType !== "mouse") return;
          if (itemState.value === state2.context.highlightedValue) return;
          send({ type: "ITEM.POINTER_MOVE", value: itemState.value });
        },
        onClick(event) {
          if (event.defaultPrevented) return;
          if (itemState.disabled) return;
          send({ type: "ITEM.CLICK", src: "pointerup", value: itemState.value });
        },
        onPointerLeave(event) {
          if (itemState.disabled) return;
          if (props22.persistFocus) return;
          if (event.pointerType !== "mouse") return;
          const pointerMoved = state2.previousEvent.type.includes("POINTER");
          if (!pointerMoved) return;
          send({ type: "ITEM.POINTER_LEAVE" });
        }
      });
    },
    getItemTextProps(props22) {
      const itemState = getItemState(props22);
      return normalize2.element({
        ...parts14.itemText.attrs,
        "data-state": itemState.selected ? "checked" : "unchecked",
        "data-disabled": dataAttr(itemState.disabled),
        "data-highlighted": dataAttr(itemState.highlighted)
      });
    },
    getItemIndicatorProps(props22) {
      const itemState = getItemState(props22);
      return normalize2.element({
        "aria-hidden": true,
        ...parts14.itemIndicator.attrs,
        "data-state": itemState.selected ? "checked" : "unchecked",
        hidden: !itemState.selected
      });
    },
    getItemGroupLabelProps(props22) {
      const { htmlFor } = props22;
      return normalize2.element({
        ...parts14.itemGroupLabel.attrs,
        id: dom12.getItemGroupLabelId(state2.context, htmlFor),
        role: "group",
        dir: state2.context.dir
      });
    },
    getItemGroupProps(props22) {
      const { id } = props22;
      return normalize2.element({
        ...parts14.itemGroup.attrs,
        "data-disabled": dataAttr(disabled),
        id: dom12.getItemGroupId(state2.context, id),
        "aria-labelledby": dom12.getItemGroupLabelId(state2.context, id),
        dir: state2.context.dir
      });
    },
    getClearTriggerProps() {
      return normalize2.button({
        ...parts14.clearTrigger.attrs,
        id: dom12.getClearTriggerId(state2.context),
        type: "button",
        "aria-label": "Clear value",
        "data-invalid": dataAttr(invalid),
        disabled,
        hidden: !state2.context.hasSelectedItems,
        dir: state2.context.dir,
        onClick(event) {
          if (event.defaultPrevented) return;
          send("CLEAR.CLICK");
        }
      });
    },
    getHiddenSelectProps() {
      return normalize2.select({
        name: state2.context.name,
        form: state2.context.form,
        disabled,
        multiple: state2.context.multiple,
        required: state2.context.required,
        "aria-hidden": true,
        id: dom12.getHiddenSelectId(state2.context),
        defaultValue: state2.context.multiple ? state2.context.value : state2.context.value[0],
        style: visuallyHiddenStyle,
        tabIndex: -1,
        // Some browser extensions will focus the hidden select.
        // Let's forward the focus to the trigger.
        onFocus() {
          var _a8;
          (_a8 = dom12.getTriggerEl(state2.context)) == null ? void 0 : _a8.focus({ preventScroll: true });
        },
        "aria-labelledby": dom12.getLabelId(state2.context)
      });
    },
    getPositionerProps() {
      return normalize2.element({
        ...parts14.positioner.attrs,
        dir: state2.context.dir,
        id: dom12.getPositionerId(state2.context),
        style: popperStyles.floating
      });
    },
    getContentProps() {
      return normalize2.element({
        hidden: !open,
        dir: state2.context.dir,
        id: dom12.getContentId(state2.context),
        role: composite ? "listbox" : "dialog",
        ...parts14.content.attrs,
        "data-state": open ? "open" : "closed",
        "data-placement": state2.context.currentPlacement,
        "data-activedescendant": ariaActiveDescendant,
        "aria-activedescendant": composite ? ariaActiveDescendant : void 0,
        "aria-multiselectable": state2.context.multiple && composite ? true : void 0,
        "aria-labelledby": dom12.getLabelId(state2.context),
        tabIndex: 0,
        onKeyDown(event) {
          if (!interactive) return;
          if (!isSelfTarget(event)) return;
          if (event.key === "Tab") {
            const valid = isValidTabEvent(event);
            if (!valid) {
              event.preventDefault();
              return;
            }
          }
          const keyMap2 = {
            ArrowUp() {
              send({ type: "CONTENT.ARROW_UP" });
            },
            ArrowDown() {
              send({ type: "CONTENT.ARROW_DOWN" });
            },
            Home() {
              send({ type: "CONTENT.HOME" });
            },
            End() {
              send({ type: "CONTENT.END" });
            },
            Enter() {
              send({ type: "ITEM.CLICK", src: "keydown.enter" });
            },
            Space(event2) {
              var _a8;
              if (isTypingAhead) {
                send({ type: "CONTENT.TYPEAHEAD", key: event2.key });
              } else {
                (_a8 = keyMap2.Enter) == null ? void 0 : _a8.call(keyMap2, event2);
              }
            }
          };
          const exec2 = keyMap2[getEventKey(event)];
          if (exec2) {
            exec2(event);
            event.preventDefault();
            return;
          }
          const target = getEventTarget(event);
          if (isEditableElement(target)) {
            return;
          }
          if (getByTypeahead.isValidEvent(event)) {
            send({ type: "CONTENT.TYPEAHEAD", key: event.key });
            event.preventDefault();
          }
        }
      });
    },
    getListProps() {
      return normalize2.element({
        ...parts14.list.attrs,
        tabIndex: 0,
        role: !composite ? "listbox" : void 0,
        "aria-labelledby": dom12.getTriggerId(state2.context),
        "aria-activedescendant": !composite ? ariaActiveDescendant : void 0,
        "aria-multiselectable": !composite && state2.context.multiple ? true : void 0
      });
    }
  };
}
var { and: and6, not: not5, or: or3 } = guards;
function machine13(userContext) {
  const ctx = compact2(userContext);
  return createMachine(
    {
      id: "select",
      context: {
        value: [],
        highlightedValue: null,
        loopFocus: false,
        closeOnSelect: !ctx.multiple,
        disabled: false,
        readOnly: false,
        composite: true,
        ...ctx,
        highlightedItem: null,
        selectedItems: [],
        valueAsString: "",
        collection: ctx.collection ?? collection.empty(),
        typeahead: getByTypeahead.defaultOptions,
        fieldsetDisabled: false,
        positioning: {
          placement: "bottom-start",
          gutter: 8,
          ...ctx.positioning
        }
      },
      computed: {
        hasSelectedItems: (ctx2) => ctx2.value.length > 0,
        isTypingAhead: (ctx2) => ctx2.typeahead.keysSoFar !== "",
        isDisabled: (ctx2) => !!ctx2.disabled || ctx2.fieldsetDisabled,
        isInteractive: (ctx2) => !(ctx2.isDisabled || ctx2.readOnly)
      },
      initial: ctx.open ? "open" : "idle",
      created: ["syncCollection"],
      entry: ["syncSelectElement"],
      watch: {
        open: ["toggleVisibility"],
        value: ["syncSelectedItems", "syncSelectElement"],
        highlightedValue: ["syncHighlightedItem"],
        collection: ["syncCollection"]
      },
      on: {
        "HIGHLIGHTED_VALUE.SET": {
          actions: ["setHighlightedItem"]
        },
        "ITEM.SELECT": {
          actions: ["selectItem"]
        },
        "ITEM.CLEAR": {
          actions: ["clearItem"]
        },
        "VALUE.SET": {
          actions: ["setSelectedItems"]
        },
        "VALUE.CLEAR": {
          actions: ["clearSelectedItems"]
        },
        "CLEAR.CLICK": {
          actions: ["clearSelectedItems", "focusTriggerEl"]
        },
        "COLLECTION.SET": {
          actions: ["setCollection"]
        }
      },
      activities: ["trackFormControlState"],
      states: {
        idle: {
          tags: ["closed"],
          on: {
            "CONTROLLED.OPEN": [
              {
                guard: "isTriggerClickEvent",
                target: "open",
                actions: ["setInitialFocus", "highlightFirstSelectedItem"]
              },
              {
                target: "open",
                actions: ["setInitialFocus"]
              }
            ],
            "TRIGGER.CLICK": [
              {
                guard: "isOpenControlled",
                actions: ["invokeOnOpen"]
              },
              {
                target: "open",
                actions: ["invokeOnOpen", "setInitialFocus", "highlightFirstSelectedItem"]
              }
            ],
            "TRIGGER.FOCUS": {
              target: "focused"
            },
            OPEN: [
              {
                guard: "isOpenControlled",
                actions: ["invokeOnOpen"]
              },
              {
                target: "open",
                actions: ["setInitialFocus", "invokeOnOpen"]
              }
            ]
          }
        },
        focused: {
          tags: ["closed"],
          on: {
            "CONTROLLED.OPEN": [
              {
                guard: "isTriggerClickEvent",
                target: "open",
                actions: ["setInitialFocus", "highlightFirstSelectedItem"]
              },
              {
                guard: "isTriggerArrowUpEvent",
                target: "open",
                actions: ["setInitialFocus", "highlightComputedLastItem"]
              },
              {
                guard: or3("isTriggerArrowDownEvent", "isTriggerEnterEvent"),
                target: "open",
                actions: ["setInitialFocus", "highlightComputedFirstItem"]
              },
              {
                target: "open",
                actions: ["setInitialFocus"]
              }
            ],
            OPEN: [
              {
                guard: "isOpenControlled",
                actions: ["invokeOnOpen"]
              },
              {
                target: "open",
                actions: ["setInitialFocus", "invokeOnOpen"]
              }
            ],
            "TRIGGER.BLUR": {
              target: "idle"
            },
            "TRIGGER.CLICK": [
              {
                guard: "isOpenControlled",
                actions: ["invokeOnOpen"]
              },
              {
                target: "open",
                actions: ["setInitialFocus", "invokeOnOpen", "highlightFirstSelectedItem"]
              }
            ],
            "TRIGGER.ENTER": [
              {
                guard: "isOpenControlled",
                actions: ["invokeOnOpen"]
              },
              {
                target: "open",
                actions: ["setInitialFocus", "invokeOnOpen", "highlightComputedFirstItem"]
              }
            ],
            "TRIGGER.ARROW_UP": [
              {
                guard: "isOpenControlled",
                actions: ["invokeOnOpen"]
              },
              {
                target: "open",
                actions: ["setInitialFocus", "invokeOnOpen", "highlightComputedLastItem"]
              }
            ],
            "TRIGGER.ARROW_DOWN": [
              {
                guard: "isOpenControlled",
                actions: ["invokeOnOpen"]
              },
              {
                target: "open",
                actions: ["setInitialFocus", "invokeOnOpen", "highlightComputedFirstItem"]
              }
            ],
            "TRIGGER.ARROW_LEFT": [
              {
                guard: and6(not5("multiple"), "hasSelectedItems"),
                actions: ["selectPreviousItem"]
              },
              {
                guard: not5("multiple"),
                actions: ["selectLastItem"]
              }
            ],
            "TRIGGER.ARROW_RIGHT": [
              {
                guard: and6(not5("multiple"), "hasSelectedItems"),
                actions: ["selectNextItem"]
              },
              {
                guard: not5("multiple"),
                actions: ["selectFirstItem"]
              }
            ],
            "TRIGGER.HOME": {
              guard: not5("multiple"),
              actions: ["selectFirstItem"]
            },
            "TRIGGER.END": {
              guard: not5("multiple"),
              actions: ["selectLastItem"]
            },
            "TRIGGER.TYPEAHEAD": {
              guard: not5("multiple"),
              actions: ["selectMatchingItem"]
            }
          }
        },
        open: {
          tags: ["open"],
          exit: ["scrollContentToTop"],
          activities: ["trackDismissableElement", "computePlacement", "scrollToHighlightedItem"],
          on: {
            "CONTROLLED.CLOSE": {
              target: "focused",
              actions: ["focusTriggerEl", "clearHighlightedItem"]
            },
            CLOSE: [
              {
                guard: "isOpenControlled",
                actions: ["invokeOnClose"]
              },
              {
                target: "focused",
                actions: ["invokeOnClose", "focusTriggerEl", "clearHighlightedItem"]
              }
            ],
            "TRIGGER.CLICK": [
              {
                guard: "isOpenControlled",
                actions: ["invokeOnClose"]
              },
              {
                target: "focused",
                actions: ["invokeOnClose", "clearHighlightedItem"]
              }
            ],
            "ITEM.CLICK": [
              {
                guard: and6("closeOnSelect", "isOpenControlled"),
                actions: ["selectHighlightedItem", "invokeOnClose"]
              },
              {
                guard: "closeOnSelect",
                target: "focused",
                actions: ["selectHighlightedItem", "invokeOnClose", "focusTriggerEl", "clearHighlightedItem"]
              },
              {
                actions: ["selectHighlightedItem"]
              }
            ],
            "CONTENT.HOME": {
              actions: ["highlightFirstItem"]
            },
            "CONTENT.END": {
              actions: ["highlightLastItem"]
            },
            "CONTENT.ARROW_DOWN": [
              {
                guard: and6("hasHighlightedItem", "loop", "isLastItemHighlighted"),
                actions: ["highlightFirstItem"]
              },
              {
                guard: "hasHighlightedItem",
                actions: ["highlightNextItem"]
              },
              {
                actions: ["highlightFirstItem"]
              }
            ],
            "CONTENT.ARROW_UP": [
              {
                guard: and6("hasHighlightedItem", "loop", "isFirstItemHighlighted"),
                actions: ["highlightLastItem"]
              },
              {
                guard: "hasHighlightedItem",
                actions: ["highlightPreviousItem"]
              },
              {
                actions: ["highlightLastItem"]
              }
            ],
            "CONTENT.TYPEAHEAD": {
              actions: ["highlightMatchingItem"]
            },
            "ITEM.POINTER_MOVE": {
              actions: ["highlightItem"]
            },
            "ITEM.POINTER_LEAVE": {
              actions: ["clearHighlightedItem"]
            },
            "POSITIONING.SET": {
              actions: ["reposition"]
            }
          }
        }
      }
    },
    {
      guards: {
        loop: (ctx2) => !!ctx2.loopFocus,
        multiple: (ctx2) => !!ctx2.multiple,
        hasSelectedItems: (ctx2) => !!ctx2.hasSelectedItems,
        hasHighlightedItem: (ctx2) => ctx2.highlightedValue != null,
        isFirstItemHighlighted: (ctx2) => ctx2.highlightedValue === ctx2.collection.firstValue,
        isLastItemHighlighted: (ctx2) => ctx2.highlightedValue === ctx2.collection.lastValue,
        closeOnSelect: (ctx2, evt) => !!(evt.closeOnSelect ?? ctx2.closeOnSelect),
        // guard assertions (for controlled mode)
        isOpenControlled: (ctx2) => !!ctx2["open.controlled"],
        isTriggerClickEvent: (_ctx, evt) => {
          var _a8;
          return ((_a8 = evt.previousEvent) == null ? void 0 : _a8.type) === "TRIGGER.CLICK";
        },
        isTriggerEnterEvent: (_ctx, evt) => {
          var _a8;
          return ((_a8 = evt.previousEvent) == null ? void 0 : _a8.type) === "TRIGGER.ENTER";
        },
        isTriggerArrowUpEvent: (_ctx, evt) => {
          var _a8;
          return ((_a8 = evt.previousEvent) == null ? void 0 : _a8.type) === "TRIGGER.ARROW_UP";
        },
        isTriggerArrowDownEvent: (_ctx, evt) => {
          var _a8;
          return ((_a8 = evt.previousEvent) == null ? void 0 : _a8.type) === "TRIGGER.ARROW_DOWN";
        }
      },
      activities: {
        trackFormControlState(ctx2, _evt, { initialContext }) {
          return trackFormControl(dom12.getHiddenSelectEl(ctx2), {
            onFieldsetDisabledChange(disabled) {
              ctx2.fieldsetDisabled = disabled;
            },
            onFormReset() {
              set11.selectedItems(ctx2, initialContext.value);
            }
          });
        },
        trackDismissableElement(ctx2, _evt, { send }) {
          const contentEl = () => dom12.getContentEl(ctx2);
          let restoreFocus = true;
          return trackDismissableElement(contentEl, {
            defer: true,
            exclude: [dom12.getTriggerEl(ctx2), dom12.getClearTriggerEl(ctx2)],
            onFocusOutside: ctx2.onFocusOutside,
            onPointerDownOutside: ctx2.onPointerDownOutside,
            onInteractOutside(event) {
              var _a8;
              (_a8 = ctx2.onInteractOutside) == null ? void 0 : _a8.call(ctx2, event);
              restoreFocus = !(event.detail.focusable || event.detail.contextmenu);
            },
            onDismiss() {
              send({ type: "CLOSE", src: "interact-outside", restoreFocus });
            }
          });
        },
        computePlacement(ctx2) {
          ctx2.currentPlacement = ctx2.positioning.placement;
          const triggerEl = () => dom12.getTriggerEl(ctx2);
          const positionerEl = () => dom12.getPositionerEl(ctx2);
          return getPlacement(triggerEl, positionerEl, {
            defer: true,
            ...ctx2.positioning,
            onComplete(data) {
              ctx2.currentPlacement = data.placement;
            }
          });
        },
        scrollToHighlightedItem(ctx2, _evt, { getState }) {
          const exec2 = (immediate) => {
            if (ctx2.highlightedValue == null) return;
            const state2 = getState();
            if (state2.event.type.includes("POINTER")) return;
            const optionEl = dom12.getHighlightedOptionEl(ctx2);
            const contentEl2 = dom12.getContentEl(ctx2);
            if (ctx2.scrollToIndexFn) {
              const highlightedIndex = ctx2.collection.indexOf(ctx2.highlightedValue);
              ctx2.scrollToIndexFn({ index: highlightedIndex, immediate });
              return;
            }
            scrollIntoView(optionEl, { rootEl: contentEl2, block: "nearest" });
          };
          raf(() => exec2(true));
          const contentEl = () => dom12.getContentEl(ctx2);
          return observeAttributes(contentEl, {
            defer: true,
            attributes: ["data-activedescendant"],
            callback() {
              exec2(false);
            }
          });
        }
      },
      actions: {
        reposition(ctx2, evt) {
          const positionerEl = () => dom12.getPositionerEl(ctx2);
          getPlacement(dom12.getTriggerEl(ctx2), positionerEl, {
            ...ctx2.positioning,
            ...evt.options,
            defer: true,
            listeners: false,
            onComplete(data) {
              ctx2.currentPlacement = data.placement;
            }
          });
        },
        toggleVisibility(ctx2, evt, { send }) {
          send({ type: ctx2.open ? "CONTROLLED.OPEN" : "CONTROLLED.CLOSE", previousEvent: evt });
        },
        highlightPreviousItem(ctx2) {
          if (ctx2.highlightedValue == null) return;
          const value = ctx2.collection.getPreviousValue(ctx2.highlightedValue);
          set11.highlightedItem(ctx2, value);
        },
        highlightNextItem(ctx2) {
          if (ctx2.highlightedValue == null) return;
          const value = ctx2.collection.getNextValue(ctx2.highlightedValue);
          set11.highlightedItem(ctx2, value);
        },
        highlightFirstItem(ctx2) {
          const value = ctx2.collection.firstValue;
          set11.highlightedItem(ctx2, value);
        },
        highlightLastItem(ctx2) {
          const value = ctx2.collection.lastValue;
          set11.highlightedItem(ctx2, value);
        },
        setInitialFocus(ctx2) {
          raf(() => {
            const element = getInitialFocus({
              root: dom12.getContentEl(ctx2)
            });
            element == null ? void 0 : element.focus({ preventScroll: true });
          });
        },
        focusTriggerEl(ctx2, evt) {
          var _a8;
          const restoreFocus = evt.restoreFocus ?? ((_a8 = evt.previousEvent) == null ? void 0 : _a8.restoreFocus);
          if (restoreFocus != null && !restoreFocus) return;
          raf(() => {
            const element = dom12.getTriggerEl(ctx2);
            element == null ? void 0 : element.focus({ preventScroll: true });
          });
        },
        selectHighlightedItem(ctx2, evt) {
          let value = evt.value ?? ctx2.highlightedValue;
          if (value == null) return;
          const nullable = ctx2.deselectable && !ctx2.multiple && ctx2.value.includes(value);
          value = nullable ? null : value;
          set11.selectedItem(ctx2, value, nullable);
        },
        highlightComputedFirstItem(ctx2) {
          const value = ctx2.hasSelectedItems ? ctx2.collection.sort(ctx2.value)[0] : ctx2.collection.firstValue;
          set11.highlightedItem(ctx2, value);
        },
        highlightComputedLastItem(ctx2) {
          const value = ctx2.hasSelectedItems ? ctx2.collection.sort(ctx2.value)[0] : ctx2.collection.lastValue;
          set11.highlightedItem(ctx2, value);
        },
        highlightFirstSelectedItem(ctx2) {
          if (!ctx2.hasSelectedItems) return;
          const [value] = ctx2.collection.sort(ctx2.value);
          set11.highlightedItem(ctx2, value);
        },
        highlightItem(ctx2, evt) {
          set11.highlightedItem(ctx2, evt.value);
        },
        highlightMatchingItem(ctx2, evt) {
          const value = ctx2.collection.search(evt.key, {
            state: ctx2.typeahead,
            currentValue: ctx2.highlightedValue
          });
          if (value == null) return;
          set11.highlightedItem(ctx2, value);
        },
        setHighlightedItem(ctx2, evt) {
          set11.highlightedItem(ctx2, evt.value);
        },
        clearHighlightedItem(ctx2) {
          set11.highlightedItem(ctx2, null, true);
        },
        selectItem(ctx2, evt) {
          const nullable = ctx2.deselectable && !ctx2.multiple && ctx2.value.includes(evt.value);
          const value = nullable ? null : evt.value;
          set11.selectedItem(ctx2, value, nullable);
        },
        clearItem(ctx2, evt) {
          const value = ctx2.value.filter((v) => v !== evt.value);
          set11.selectedItems(ctx2, value);
        },
        setSelectedItems(ctx2, evt) {
          set11.selectedItems(ctx2, evt.value);
        },
        clearSelectedItems(ctx2) {
          set11.selectedItems(ctx2, []);
        },
        selectPreviousItem(ctx2) {
          const value = ctx2.collection.getPreviousValue(ctx2.value[0]);
          set11.selectedItem(ctx2, value);
        },
        selectNextItem(ctx2) {
          const value = ctx2.collection.getNextValue(ctx2.value[0]);
          set11.selectedItem(ctx2, value);
        },
        selectFirstItem(ctx2) {
          const value = ctx2.collection.firstValue;
          set11.selectedItem(ctx2, value);
        },
        selectLastItem(ctx2) {
          const value = ctx2.collection.lastValue;
          set11.selectedItem(ctx2, value);
        },
        selectMatchingItem(ctx2, evt) {
          const value = ctx2.collection.search(evt.key, {
            state: ctx2.typeahead,
            currentValue: ctx2.value[0]
          });
          if (value == null) return;
          set11.selectedItem(ctx2, value);
        },
        scrollContentToTop(ctx2) {
          var _a8;
          if (ctx2.scrollToIndexFn) {
            ctx2.scrollToIndexFn({ index: 0, immediate: true });
          } else {
            (_a8 = dom12.getContentEl(ctx2)) == null ? void 0 : _a8.scrollTo(0, 0);
          }
        },
        invokeOnOpen(ctx2) {
          var _a8;
          (_a8 = ctx2.onOpenChange) == null ? void 0 : _a8.call(ctx2, { open: true });
        },
        invokeOnClose(ctx2) {
          var _a8;
          (_a8 = ctx2.onOpenChange) == null ? void 0 : _a8.call(ctx2, { open: false });
        },
        syncSelectElement(ctx2) {
          const selectEl = dom12.getHiddenSelectEl(ctx2);
          if (!selectEl) return;
          if (ctx2.value.length === 0 && !ctx2.multiple) {
            selectEl.selectedIndex = -1;
            return;
          }
          for (const option of selectEl.options) {
            option.selected = ctx2.value.includes(option.value);
          }
        },
        setCollection(ctx2, evt) {
          ctx2.collection = evt.value;
        },
        syncCollection(ctx2) {
          const selectedItems = ctx2.collection.findMany(ctx2.value);
          const valueAsString = ctx2.collection.stringifyItems(selectedItems);
          ctx2.highlightedItem = ctx2.collection.find(ctx2.highlightedValue);
          ctx2.selectedItems = selectedItems;
          ctx2.valueAsString = valueAsString;
        },
        syncSelectedItems(ctx2) {
          sync3.valueChange(ctx2);
        },
        syncHighlightedItem(ctx2) {
          sync3.highlightChange(ctx2);
        }
      }
    }
  );
}
function dispatchChangeEvent(ctx) {
  raf(() => {
    const node = dom12.getHiddenSelectEl(ctx);
    if (!node) return;
    const win = dom12.getWin(ctx);
    const changeEvent = new win.Event("change", { bubbles: true, composed: true });
    node.dispatchEvent(changeEvent);
  });
}
var sync3 = {
  valueChange: (ctx) => {
    const prevSelectedItems = ctx.selectedItems;
    ctx.selectedItems = ctx.value.map((value) => {
      const foundItem = prevSelectedItems.find((item) => ctx.collection.getItemValue(item) === value);
      if (foundItem) return foundItem;
      return ctx.collection.find(value);
    });
    ctx.valueAsString = ctx.collection.stringifyItems(ctx.selectedItems);
  },
  highlightChange: (ctx) => {
    ctx.highlightedItem = ctx.collection.find(ctx.highlightedValue);
  }
};
var invoke8 = {
  valueChange: (ctx) => {
    var _a8;
    sync3.valueChange(ctx);
    (_a8 = ctx.onValueChange) == null ? void 0 : _a8.call(ctx, {
      value: Array.from(ctx.value),
      items: Array.from(ctx.selectedItems)
    });
    dispatchChangeEvent(ctx);
  },
  highlightChange: (ctx) => {
    var _a8;
    sync3.highlightChange(ctx);
    (_a8 = ctx.onHighlightChange) == null ? void 0 : _a8.call(ctx, {
      highlightedValue: ctx.highlightedValue,
      highlightedItem: ctx.highlightedItem,
      highlightedIndex: ctx.collection.indexOf(ctx.highlightedValue)
    });
  }
};
var set11 = {
  selectedItem: (ctx, value, force = false) => {
    if (isEqual(ctx.value, value)) return;
    if (value == null && !force) return;
    if (value == null && force) {
      ctx.value = [];
      invoke8.valueChange(ctx);
      return;
    }
    ctx.value = ctx.multiple ? addOrRemove(ctx.value, value) : [value];
    invoke8.valueChange(ctx);
  },
  selectedItems: (ctx, value) => {
    if (isEqual(ctx.value, value)) return;
    ctx.value = value;
    invoke8.valueChange(ctx);
  },
  highlightedItem: (ctx, value, force = false) => {
    if (isEqual(ctx.highlightedValue, value)) return;
    if (value == null && !force) return;
    ctx.highlightedValue = value ?? null;
    invoke8.highlightChange(ctx);
  }
};
var props12 = createProps2()([
  "closeOnSelect",
  "collection",
  "dir",
  "disabled",
  "deselectable",
  "form",
  "getRootNode",
  "highlightedValue",
  "id",
  "ids",
  "invalid",
  "loopFocus",
  "multiple",
  "name",
  "onFocusOutside",
  "onHighlightChange",
  "onInteractOutside",
  "onOpenChange",
  "onPointerDownOutside",
  "onValueChange",
  "open.controlled",
  "open",
  "composite",
  "positioning",
  "required",
  "readOnly",
  "scrollToIndexFn",
  "value"
]);
var splitProps13 = createSplitProps(props12);
var itemProps6 = createProps2()(["item", "persistFocus"]);
var splitItemProps6 = createSplitProps(itemProps6);
var itemGroupProps2 = createProps2()(["id"]);
var splitItemGroupProps2 = createSplitProps(itemGroupProps2);
var itemGroupLabelProps2 = createProps2()(["htmlFor"]);
var splitItemGroupLabelProps2 = createSplitProps(itemGroupLabelProps2);

// node_modules/@ark-ui/react/dist/components/select/use-select.js
var import_react251 = __toESM(require_react(), 1);
var useSelect = (props21) => {
  const { collection: collection2, ...selectProps } = props21;
  const locale = useLocaleContext();
  const environment = useEnvironmentContext();
  const field = useFieldContext();
  const initialContext = {
    id: (0, import_react251.useId)(),
    ids: {
      label: field == null ? void 0 : field.ids.label,
      hiddenSelect: field == null ? void 0 : field.ids.control
    },
    disabled: field == null ? void 0 : field.disabled,
    readOnly: field == null ? void 0 : field.readOnly,
    invalid: field == null ? void 0 : field.invalid,
    required: field == null ? void 0 : field.required,
    dir: locale.dir,
    getRootNode: environment.getRootNode,
    collection: collection2,
    open: props21.defaultOpen,
    value: props21.defaultValue,
    "open.controlled": props21.open !== void 0,
    ...selectProps
  };
  const context = (() => {
    const { collection: _, ...restProps } = initialContext;
    return {
      ...restProps,
      value: props21.value,
      onValueChange: useEvent(props21.onValueChange, { sync: true }),
      onHighlightChange: useEvent(props21.onHighlightChange),
      onOpenChange: useEvent(props21.onOpenChange)
    };
  })();
  const [state2, send, service] = useMachine(machine13(initialContext), {
    context
  });
  (0, import_react251.useEffect)(() => {
    service.setContext({ collection: collection2 });
  }, [collection2]);
  return connect13(state2, send, normalizeProps);
};

// node_modules/@ark-ui/react/dist/components/select/select-root.js
var SelectImpl = (props21, ref2) => {
  const [presenceProps, selectProps] = splitPresenceProps(props21);
  const [useSelectProps, localProps] = createSplitProps2()(selectProps, [
    "closeOnSelect",
    "collection",
    "composite",
    "defaultOpen",
    "defaultValue",
    "deselectable",
    "disabled",
    "form",
    "highlightedValue",
    "id",
    "ids",
    "invalid",
    "loopFocus",
    "multiple",
    "name",
    "onFocusOutside",
    "onHighlightChange",
    "onInteractOutside",
    "onOpenChange",
    "onPointerDownOutside",
    "onValueChange",
    "open",
    "positioning",
    "readOnly",
    "required",
    "scrollToIndexFn",
    "value"
  ]);
  const select = useSelect(useSelectProps);
  const presence = usePresence(mergeProps({ present: select.open }, presenceProps));
  const mergedProps = mergeProps(select.getRootProps(), localProps);
  return (0, import_jsx_runtime115.jsx)(SelectProvider, { value: select, children: (0, import_jsx_runtime115.jsx)(PresenceProvider, { value: presence, children: (0, import_jsx_runtime115.jsx)(ark.div, { ...mergedProps, ref: ref2 }) }) });
};
var SelectRoot = (0, import_react253.forwardRef)(SelectImpl);

// node_modules/@ark-ui/react/dist/components/select/select-root-provider.js
var import_jsx_runtime116 = __toESM(require_jsx_runtime(), 1);
var import_react255 = __toESM(require_react(), 1);
var SelectImpl2 = (props21, ref2) => {
  const [presenceProps, selectProps] = splitPresenceProps(props21);
  const [{ value: select }, localProps] = createSplitProps2()(selectProps, [
    "value"
  ]);
  const presence = usePresence(mergeProps({ present: select.open }, presenceProps));
  const mergedProps = mergeProps(select.getRootProps(), localProps);
  return (0, import_jsx_runtime116.jsx)(SelectProvider, { value: select, children: (0, import_jsx_runtime116.jsx)(PresenceProvider, { value: presence, children: (0, import_jsx_runtime116.jsx)(ark.div, { ...mergedProps, ref: ref2 }) }) });
};
var SelectRootProvider = (0, import_react255.forwardRef)(SelectImpl2);

// node_modules/@ark-ui/react/dist/components/select/select-trigger.js
var import_jsx_runtime117 = __toESM(require_jsx_runtime(), 1);
var import_react257 = __toESM(require_react(), 1);
var SelectTrigger = (0, import_react257.forwardRef)((props21, ref2) => {
  const select = useSelectContext();
  const mergedProps = mergeProps(select.getTriggerProps(), props21);
  return (0, import_jsx_runtime117.jsx)(ark.button, { ...mergedProps, ref: ref2 });
});
SelectTrigger.displayName = "SelectTrigger";

// node_modules/@ark-ui/react/dist/components/select/select-value-text.js
var import_jsx_runtime118 = __toESM(require_jsx_runtime(), 1);
var import_react259 = __toESM(require_react(), 1);
var SelectValueText = (0, import_react259.forwardRef)((props21, ref2) => {
  const { children, placeholder, ...localprops } = props21;
  const select = useSelectContext();
  const mergedProps = mergeProps(select.getValueTextProps(), localprops);
  return (0, import_jsx_runtime118.jsx)(ark.span, { ...mergedProps, ref: ref2, children: children || select.valueAsString || placeholder });
});
SelectValueText.displayName = "SelectValueText";

// node_modules/@ark-ui/react/dist/components/select/select.js
var select_exports = {};
__export(select_exports, {
  ClearTrigger: () => SelectClearTrigger,
  Content: () => SelectContent,
  Context: () => SelectContext,
  Control: () => SelectControl,
  HiddenSelect: () => SelectHiddenSelect,
  Indicator: () => SelectIndicator,
  Item: () => SelectItem,
  ItemContext: () => SelectItemContext,
  ItemGroup: () => SelectItemGroup,
  ItemGroupLabel: () => SelectItemGroupLabel,
  ItemIndicator: () => SelectItemIndicator,
  ItemText: () => SelectItemText,
  Label: () => SelectLabel,
  List: () => SelectList,
  Positioner: () => SelectPositioner,
  Root: () => SelectRoot,
  RootProvider: () => SelectRootProvider,
  Trigger: () => SelectTrigger,
  ValueText: () => SelectValueText
});

// node_modules/@ark-ui/react/dist/components/slider/use-slider-context.js
var [SliderProvider, useSliderContext] = createContext({
  name: "SliderContext",
  hookName: "useSliderContext",
  providerName: "<SliderProvider />"
});

// node_modules/@ark-ui/react/dist/components/slider/slider-context.js
var SliderContext = (props21) => props21.children(useSliderContext());

// node_modules/@ark-ui/react/dist/components/slider/slider-control.js
var import_jsx_runtime119 = __toESM(require_jsx_runtime(), 1);
var import_react261 = __toESM(require_react(), 1);
var SliderControl = (0, import_react261.forwardRef)((props21, ref2) => {
  const slider = useSliderContext();
  const mergedProps = mergeProps(slider.getControlProps(), props21);
  return (0, import_jsx_runtime119.jsx)(ark.div, { ...mergedProps, ref: ref2 });
});
SliderControl.displayName = "SliderControl";

// node_modules/@ark-ui/react/dist/components/slider/slider-dragging-indicator.js
var import_jsx_runtime120 = __toESM(require_jsx_runtime(), 1);
var import_react263 = __toESM(require_react(), 1);

// node_modules/@ark-ui/react/dist/components/slider/use-slider-thumb-props-context.js
var [SliderThumbPropsProvider, useSliderThumbPropsContext] = createContext({
  name: "SliderThumbPropsContext",
  hookName: "useSliderThumbPropsContext",
  providerName: "<SliderThumbPropsProvider />"
});

// node_modules/@ark-ui/react/dist/components/slider/slider-dragging-indicator.js
var SliderDraggingIndicator = (0, import_react263.forwardRef)(
  (props21, ref2) => {
    const slider = useSliderContext();
    const { index } = useSliderThumbPropsContext();
    const mergedProps = mergeProps(slider.getDraggingIndicatorProps({ index }), props21);
    return (0, import_jsx_runtime120.jsx)(ark.span, { ...mergedProps, ref: ref2, children: props21.children || slider.getThumbValue(index) });
  }
);
SliderDraggingIndicator.displayName = "SliderDraggingIndicator";

// node_modules/@ark-ui/react/dist/components/slider/slider-hidden-input.js
var import_jsx_runtime121 = __toESM(require_jsx_runtime(), 1);
var import_react265 = __toESM(require_react(), 1);
var SliderHiddenInput = (0, import_react265.forwardRef)(
  (props21, ref2) => {
    const slider = useSliderContext();
    const thumbProps2 = useSliderThumbPropsContext();
    const mergedProps = mergeProps(slider.getHiddenInputProps(thumbProps2), props21);
    return (0, import_jsx_runtime121.jsx)(ark.input, { ...mergedProps, ref: ref2 });
  }
);
SliderHiddenInput.displayName = "SliderHiddenInput";

// node_modules/@ark-ui/react/dist/components/slider/slider-label.js
var import_jsx_runtime122 = __toESM(require_jsx_runtime(), 1);
var import_react267 = __toESM(require_react(), 1);
var SliderLabel = (0, import_react267.forwardRef)((props21, ref2) => {
  const slider = useSliderContext();
  const mergedProps = mergeProps(slider.getLabelProps(), props21);
  return (0, import_jsx_runtime122.jsx)(ark.label, { ...mergedProps, ref: ref2 });
});
SliderLabel.displayName = "SliderLabel";

// node_modules/@ark-ui/react/dist/components/slider/slider-marker.js
var import_jsx_runtime123 = __toESM(require_jsx_runtime(), 1);
var import_react269 = __toESM(require_react(), 1);
var SliderMarker = (0, import_react269.forwardRef)((props21, ref2) => {
  const [markerProps, localProps] = createSplitProps2()(props21, ["value"]);
  const slider = useSliderContext();
  const mergedProps = mergeProps(slider.getMarkerProps(markerProps), localProps);
  return (0, import_jsx_runtime123.jsx)(ark.span, { ...mergedProps, ref: ref2 });
});
SliderMarker.displayName = "SliderMarker";

// node_modules/@ark-ui/react/dist/components/slider/slider-marker-group.js
var import_jsx_runtime124 = __toESM(require_jsx_runtime(), 1);
var import_react271 = __toESM(require_react(), 1);
var SliderMarkerGroup = (0, import_react271.forwardRef)(
  (props21, ref2) => {
    const slider = useSliderContext();
    const mergedProps = mergeProps(slider.getMarkerGroupProps(), props21);
    return (0, import_jsx_runtime124.jsx)(ark.div, { ...mergedProps, ref: ref2 });
  }
);
SliderMarkerGroup.displayName = "SliderMarkerGroup";

// node_modules/@ark-ui/react/dist/components/slider/slider-range.js
var import_jsx_runtime125 = __toESM(require_jsx_runtime(), 1);
var import_react273 = __toESM(require_react(), 1);
var SliderRange = (0, import_react273.forwardRef)((props21, ref2) => {
  const slider = useSliderContext();
  const mergedProps = mergeProps(slider.getRangeProps(), props21);
  return (0, import_jsx_runtime125.jsx)(ark.div, { ...mergedProps, ref: ref2 });
});
SliderRange.displayName = "SliderRange";

// node_modules/@ark-ui/react/dist/components/slider/slider-root.js
var import_jsx_runtime126 = __toESM(require_jsx_runtime(), 1);
var import_react277 = __toESM(require_react(), 1);

// node_modules/@zag-js/element-size/dist/index.mjs
function trackElementSize(element, callback) {
  if (!element) {
    callback(void 0);
    return;
  }
  callback({ width: element.offsetWidth, height: element.offsetHeight });
  const win = element.ownerDocument.defaultView ?? window;
  const observer = new win.ResizeObserver((entries) => {
    if (!Array.isArray(entries) || !entries.length) return;
    const [entry] = entries;
    let width;
    let height;
    if ("borderBoxSize" in entry) {
      const borderSizeEntry = entry["borderBoxSize"];
      const borderSize = Array.isArray(borderSizeEntry) ? borderSizeEntry[0] : borderSizeEntry;
      width = borderSize["inlineSize"];
      height = borderSize["blockSize"];
    } else {
      width = element.offsetWidth;
      height = element.offsetHeight;
    }
    callback({ width, height });
  });
  observer.observe(element, { box: "border-box" });
  return () => observer.unobserve(element);
}
function trackElementsSize(options) {
  const { getNodes, observeMutation = true, callback } = options;
  const cleanups2 = [];
  let firstNode = null;
  function trigger() {
    const elements = getNodes();
    firstNode = elements[0];
    const fns = elements.map(
      (element, index) => trackElementSize(element, (size3) => {
        callback(size3, index);
      })
    );
    cleanups2.push(...fns);
  }
  trigger();
  if (observeMutation) {
    const fn = trackMutation(firstNode, trigger);
    cleanups2.push(fn);
  }
  return () => {
    cleanups2.forEach((cleanup) => {
      cleanup == null ? void 0 : cleanup();
    });
  };
}
function trackMutation(el, cb) {
  var _a8;
  if (!el || !el.parentElement) return;
  const win = ((_a8 = el.ownerDocument) == null ? void 0 : _a8.defaultView) ?? window;
  const observer = new win.MutationObserver(() => {
    cb();
  });
  observer.observe(el.parentElement, { childList: true });
  return () => {
    observer.disconnect();
  };
}

// node_modules/@zag-js/slider/dist/index.mjs
var anatomy13 = createAnatomy("slider").parts(
  "root",
  "label",
  "thumb",
  "valueText",
  "track",
  "range",
  "control",
  "markerGroup",
  "marker",
  "draggingIndicator"
);
var parts15 = anatomy13.build();
function getBounds(value) {
  const firstValue = value[0];
  const lastThumb = value[value.length - 1];
  return [firstValue, lastThumb];
}
function getRangeOffsets(ctx) {
  const [firstPercent, lastPercent] = getBounds(ctx.valuePercent);
  if (ctx.valuePercent.length === 1) {
    if (ctx.origin === "center") {
      const isNegative = ctx.valuePercent[0] < 50;
      const start = isNegative ? `${ctx.valuePercent[0]}%` : "50%";
      const end = isNegative ? "50%" : `${100 - ctx.valuePercent[0]}%`;
      return { start, end };
    }
    return { start: "0%", end: `${100 - lastPercent}%` };
  }
  return { start: `${firstPercent}%`, end: `${100 - lastPercent}%` };
}
function getRangeStyle(ctx) {
  if (ctx.isVertical) {
    return {
      position: "absolute",
      bottom: "var(--slider-range-start)",
      top: "var(--slider-range-end)"
    };
  }
  return {
    position: "absolute",
    [ctx.isRtl ? "right" : "left"]: "var(--slider-range-start)",
    [ctx.isRtl ? "left" : "right"]: "var(--slider-range-end)"
  };
}
function getVerticalThumbOffset(ctx) {
  const { height = 0 } = ctx.thumbSize ?? {};
  const getValue = getValueTransformer([ctx.min, ctx.max], [-height / 2, height / 2]);
  return parseFloat(getValue(ctx.value).toFixed(2));
}
function getHorizontalThumbOffset(ctx) {
  const { width = 0 } = ctx.thumbSize ?? {};
  if (ctx.isRtl) {
    const getValue2 = getValueTransformer([ctx.max, ctx.min], [-width / 2, width / 2]);
    return -1 * parseFloat(getValue2(ctx.value).toFixed(2));
  }
  const getValue = getValueTransformer([ctx.min, ctx.max], [-width / 2, width / 2]);
  return parseFloat(getValue(ctx.value).toFixed(2));
}
function getOffset(ctx, percent) {
  if (ctx.thumbAlignment === "center") return `${percent}%`;
  const offset3 = ctx.isVertical ? getVerticalThumbOffset(ctx) : getHorizontalThumbOffset(ctx);
  return `calc(${percent}% - ${offset3}px)`;
}
function getThumbOffset(ctx) {
  let percent = getValuePercent(ctx.value, ctx.min, ctx.max) * 100;
  return getOffset(ctx, percent);
}
function getVisibility(ctx) {
  let visibility = "visible";
  if (ctx.thumbAlignment === "contain" && !ctx.hasMeasuredThumbSize) {
    visibility = "hidden";
  }
  return visibility;
}
function getThumbStyle(ctx, index) {
  const placementProp = ctx.isVertical ? "bottom" : "insetInlineStart";
  return {
    visibility: getVisibility(ctx),
    position: "absolute",
    transform: "var(--slider-thumb-transform)",
    [placementProp]: `var(--slider-thumb-offset-${index})`
  };
}
function getControlStyle() {
  return {
    touchAction: "none",
    userSelect: "none",
    WebkitUserSelect: "none",
    position: "relative"
  };
}
function getRootStyle(ctx) {
  const range = getRangeOffsets(ctx);
  const offsetStyles = ctx.value.reduce((styles, value, index) => {
    const offset3 = getThumbOffset({ ...ctx, value });
    return { ...styles, [`--slider-thumb-offset-${index}`]: offset3 };
  }, {});
  return {
    ...offsetStyles,
    "--slider-thumb-transform": ctx.isVertical ? "translateY(50%)" : ctx.isRtl ? "translateX(50%)" : "translateX(-50%)",
    "--slider-range-start": range.start,
    "--slider-range-end": range.end
  };
}
function getMarkerStyle(ctx, value) {
  return {
    // @ts-expect-error
    visibility: getVisibility(ctx),
    position: "absolute",
    pointerEvents: "none",
    // @ts-expect-error
    [ctx.isHorizontal ? "insetInlineStart" : "bottom"]: getThumbOffset({ ...ctx, value }),
    translate: "var(--tx) var(--ty)",
    "--tx": ctx.isHorizontal ? ctx.isRtl ? "50%" : "-50%" : "0%",
    "--ty": !ctx.isHorizontal ? "50%" : "0%"
  };
}
function getMarkerGroupStyle() {
  return {
    userSelect: "none",
    WebkitUserSelect: "none",
    pointerEvents: "none",
    position: "relative"
  };
}
var styleGetterFns = {
  getRootStyle,
  getControlStyle,
  getThumbStyle,
  getRangeStyle,
  getMarkerStyle,
  getMarkerGroupStyle
};
var dom13 = createScope({
  ...styleGetterFns,
  getRootId: (ctx) => {
    var _a8;
    return ((_a8 = ctx.ids) == null ? void 0 : _a8.root) ?? `slider:${ctx.id}`;
  },
  getThumbId: (ctx, index) => {
    var _a8, _b7;
    return ((_b7 = (_a8 = ctx.ids) == null ? void 0 : _a8.thumb) == null ? void 0 : _b7.call(_a8, index)) ?? `slider:${ctx.id}:thumb:${index}`;
  },
  getHiddenInputId: (ctx, index) => {
    var _a8, _b7;
    return ((_b7 = (_a8 = ctx.ids) == null ? void 0 : _a8.hiddenInput) == null ? void 0 : _b7.call(_a8, index)) ?? `slider:${ctx.id}:input:${index}`;
  },
  getControlId: (ctx) => {
    var _a8;
    return ((_a8 = ctx.ids) == null ? void 0 : _a8.control) ?? `slider:${ctx.id}:control`;
  },
  getTrackId: (ctx) => {
    var _a8;
    return ((_a8 = ctx.ids) == null ? void 0 : _a8.track) ?? `slider:${ctx.id}:track`;
  },
  getRangeId: (ctx) => {
    var _a8;
    return ((_a8 = ctx.ids) == null ? void 0 : _a8.range) ?? `slider:${ctx.id}:range`;
  },
  getLabelId: (ctx) => {
    var _a8;
    return ((_a8 = ctx.ids) == null ? void 0 : _a8.label) ?? `slider:${ctx.id}:label`;
  },
  getValueTextId: (ctx) => {
    var _a8;
    return ((_a8 = ctx.ids) == null ? void 0 : _a8.valueText) ?? `slider:${ctx.id}:value-text`;
  },
  getMarkerId: (ctx, value) => {
    var _a8, _b7;
    return ((_b7 = (_a8 = ctx.ids) == null ? void 0 : _a8.marker) == null ? void 0 : _b7.call(_a8, value)) ?? `slider:${ctx.id}:marker:${value}`;
  },
  getRootEl: (ctx) => dom13.getById(ctx, dom13.getRootId(ctx)),
  getThumbEl: (ctx, index) => dom13.getById(ctx, dom13.getThumbId(ctx, index)),
  getHiddenInputEl: (ctx, index) => dom13.getById(ctx, dom13.getHiddenInputId(ctx, index)),
  getControlEl: (ctx) => dom13.getById(ctx, dom13.getControlId(ctx)),
  getElements: (ctx) => queryAll(dom13.getControlEl(ctx), "[role=slider]"),
  getFirstEl: (ctx) => dom13.getElements(ctx)[0],
  getRangeEl: (ctx) => dom13.getById(ctx, dom13.getRangeId(ctx)),
  getValueFromPoint(ctx, point) {
    const controlEl = dom13.getControlEl(ctx);
    if (!controlEl) return;
    const relativePoint = getRelativePoint(point, controlEl);
    const percent = relativePoint.getPercentValue({
      orientation: ctx.orientation,
      dir: ctx.dir,
      inverted: { y: true }
    });
    return getPercentValue(percent, ctx.min, ctx.max, ctx.step);
  },
  dispatchChangeEvent(ctx) {
    const valueArray = Array.from(ctx.value);
    valueArray.forEach((value, index) => {
      const inputEl = dom13.getHiddenInputEl(ctx, index);
      if (!inputEl) return;
      dispatchInputValueEvent(inputEl, { value });
    });
  }
});
function normalizeValues(ctx, nextValues) {
  return nextValues.map((value, index, values) => {
    return constrainValue2({ ...ctx, value: values }, value, index);
  });
}
function getRangeAtIndex(ctx, index) {
  return getValueRanges(ctx.value, ctx.min, ctx.max, ctx.minStepsBetweenThumbs)[index];
}
function constrainValue2(ctx, value, index) {
  const range = getRangeAtIndex(ctx, index);
  const snapValue = snapValueToStep(value, ctx.min, ctx.max, ctx.step);
  return clampValue(snapValue, range.min, range.max);
}
function decrement(ctx, index, step) {
  const idx = index ?? ctx.focusedIndex;
  const range = getRangeAtIndex(ctx, idx);
  const nextValues = getPreviousStepValue(idx, {
    ...range,
    step: step ?? ctx.step,
    values: ctx.value
  });
  nextValues[idx] = clampValue(nextValues[idx], range.min, range.max);
  return nextValues;
}
function increment(ctx, index, step) {
  const idx = index ?? ctx.focusedIndex;
  const range = getRangeAtIndex(ctx, idx);
  const nextValues = getNextStepValue(idx, {
    ...range,
    step: step ?? ctx.step,
    values: ctx.value
  });
  nextValues[idx] = clampValue(nextValues[idx], range.min, range.max);
  return nextValues;
}
function getClosestIndex(ctx, pointValue) {
  return getClosestValueIndex(ctx.value, pointValue);
}
function assignArray(current, next2) {
  for (let i = 0; i < next2.length; i++) {
    const value = next2[i];
    current[i] = value;
  }
}
function connect14(state2, send, normalize2) {
  const ariaLabel = state2.context["aria-label"];
  const ariaLabelledBy = state2.context["aria-labelledby"];
  const sliderValue = state2.context.value;
  const focused = state2.matches("focus");
  const dragging = state2.matches("dragging");
  const disabled = state2.context.isDisabled;
  const invalid = state2.context.invalid;
  const interactive = state2.context.isInteractive;
  const isHorizontal = state2.context.orientation === "horizontal";
  const isVertical = state2.context.orientation === "vertical";
  function getValuePercentFn(value) {
    return getValuePercent(value, state2.context.min, state2.context.max);
  }
  function getPercentValueFn(percent) {
    return getPercentValue(percent, state2.context.min, state2.context.max, state2.context.step);
  }
  return {
    value: state2.context.value,
    dragging,
    focused,
    setValue(value) {
      send({ type: "SET_VALUE", value });
    },
    getThumbValue(index) {
      return sliderValue[index];
    },
    setThumbValue(index, value) {
      send({ type: "SET_VALUE", index, value });
    },
    getValuePercent: getValuePercentFn,
    getPercentValue: getPercentValueFn,
    getThumbPercent(index) {
      return getValuePercentFn(sliderValue[index]);
    },
    setThumbPercent(index, percent) {
      const value = getPercentValueFn(percent);
      send({ type: "SET_VALUE", index, value });
    },
    getThumbMin(index) {
      return getRangeAtIndex(state2.context, index).min;
    },
    getThumbMax(index) {
      return getRangeAtIndex(state2.context, index).max;
    },
    increment(index) {
      send({ type: "INCREMENT", index });
    },
    decrement(index) {
      send({ type: "DECREMENT", index });
    },
    focus() {
      if (!interactive) return;
      send({ type: "FOCUS", index: 0 });
    },
    getLabelProps() {
      return normalize2.label({
        ...parts15.label.attrs,
        dir: state2.context.dir,
        "data-disabled": dataAttr(disabled),
        "data-orientation": state2.context.orientation,
        "data-invalid": dataAttr(invalid),
        "data-dragging": dataAttr(dragging),
        "data-focus": dataAttr(focused),
        id: dom13.getLabelId(state2.context),
        htmlFor: dom13.getHiddenInputId(state2.context, 0),
        onClick(event) {
          var _a8;
          if (!interactive) return;
          event.preventDefault();
          (_a8 = dom13.getFirstEl(state2.context)) == null ? void 0 : _a8.focus();
        },
        style: {
          userSelect: "none",
          WebkitUserSelect: "none"
        }
      });
    },
    getRootProps() {
      return normalize2.element({
        ...parts15.root.attrs,
        "data-disabled": dataAttr(disabled),
        "data-orientation": state2.context.orientation,
        "data-dragging": dataAttr(dragging),
        "data-invalid": dataAttr(invalid),
        "data-focus": dataAttr(focused),
        id: dom13.getRootId(state2.context),
        dir: state2.context.dir,
        style: dom13.getRootStyle(state2.context)
      });
    },
    getValueTextProps() {
      return normalize2.element({
        ...parts15.valueText.attrs,
        dir: state2.context.dir,
        "data-disabled": dataAttr(disabled),
        "data-orientation": state2.context.orientation,
        "data-invalid": dataAttr(invalid),
        "data-focus": dataAttr(focused),
        id: dom13.getValueTextId(state2.context)
      });
    },
    getTrackProps() {
      return normalize2.element({
        ...parts15.track.attrs,
        dir: state2.context.dir,
        id: dom13.getTrackId(state2.context),
        "data-disabled": dataAttr(disabled),
        "data-invalid": dataAttr(invalid),
        "data-dragging": dataAttr(dragging),
        "data-orientation": state2.context.orientation,
        "data-focus": dataAttr(focused),
        style: { position: "relative" }
      });
    },
    getThumbProps(props22) {
      var _a8, _b7;
      const { index = 0, name } = props22;
      const value = sliderValue[index];
      const range = getRangeAtIndex(state2.context, index);
      const valueText = (_b7 = (_a8 = state2.context).getAriaValueText) == null ? void 0 : _b7.call(_a8, { value, index });
      const _ariaLabel = Array.isArray(ariaLabel) ? ariaLabel[index] : ariaLabel;
      const _ariaLabelledBy = Array.isArray(ariaLabelledBy) ? ariaLabelledBy[index] : ariaLabelledBy;
      return normalize2.element({
        ...parts15.thumb.attrs,
        dir: state2.context.dir,
        "data-index": index,
        "data-name": name,
        id: dom13.getThumbId(state2.context, index),
        "data-disabled": dataAttr(disabled),
        "data-orientation": state2.context.orientation,
        "data-focus": dataAttr(focused && state2.context.focusedIndex === index),
        "data-dragging": dataAttr(dragging && state2.context.focusedIndex === index),
        draggable: false,
        "aria-disabled": ariaAttr(disabled),
        "aria-label": _ariaLabel,
        "aria-labelledby": _ariaLabelledBy ?? dom13.getLabelId(state2.context),
        "aria-orientation": state2.context.orientation,
        "aria-valuemax": range.max,
        "aria-valuemin": range.min,
        "aria-valuenow": sliderValue[index],
        "aria-valuetext": valueText,
        role: "slider",
        tabIndex: disabled ? void 0 : 0,
        style: dom13.getThumbStyle(state2.context, index),
        onPointerDown(event) {
          if (!interactive) return;
          send({ type: "THUMB_POINTER_DOWN", index });
          event.stopPropagation();
        },
        onBlur() {
          if (!interactive) return;
          send("BLUR");
        },
        onFocus() {
          if (!interactive) return;
          send({ type: "FOCUS", index });
        },
        onKeyDown(event) {
          if (event.defaultPrevented) return;
          if (!interactive) return;
          const step = getEventStep(event) * state2.context.step;
          const keyMap2 = {
            ArrowUp() {
              if (isHorizontal) return;
              send({ type: "ARROW_INC", step, src: "ArrowUp" });
            },
            ArrowDown() {
              if (isHorizontal) return;
              send({ type: "ARROW_DEC", step, src: "ArrowDown" });
            },
            ArrowLeft() {
              if (isVertical) return;
              send({ type: "ARROW_DEC", step, src: "ArrowLeft" });
            },
            ArrowRight() {
              if (isVertical) return;
              send({ type: "ARROW_INC", step, src: "ArrowRight" });
            },
            PageUp() {
              send({ type: "ARROW_INC", step, src: "PageUp" });
            },
            PageDown() {
              send({ type: "ARROW_DEC", step, src: "PageDown" });
            },
            Home() {
              send("HOME");
            },
            End() {
              send("END");
            }
          };
          const key = getEventKey(event, state2.context);
          const exec2 = keyMap2[key];
          if (exec2) {
            exec2(event);
            event.preventDefault();
            event.stopPropagation();
          }
        }
      });
    },
    getHiddenInputProps(props22) {
      const { index = 0, name } = props22;
      return normalize2.input({
        name: name ?? (state2.context.name ? state2.context.name + (state2.context.value.length > 1 ? "[]" : "") : void 0),
        form: state2.context.form,
        type: "text",
        hidden: true,
        defaultValue: state2.context.value[index],
        id: dom13.getHiddenInputId(state2.context, index)
      });
    },
    getRangeProps() {
      return normalize2.element({
        id: dom13.getRangeId(state2.context),
        ...parts15.range.attrs,
        dir: state2.context.dir,
        "data-dragging": dataAttr(dragging),
        "data-focus": dataAttr(focused),
        "data-invalid": dataAttr(invalid),
        "data-disabled": dataAttr(disabled),
        "data-orientation": state2.context.orientation,
        style: dom13.getRangeStyle(state2.context)
      });
    },
    getControlProps() {
      return normalize2.element({
        ...parts15.control.attrs,
        dir: state2.context.dir,
        id: dom13.getControlId(state2.context),
        "data-dragging": dataAttr(dragging),
        "data-disabled": dataAttr(disabled),
        "data-orientation": state2.context.orientation,
        "data-invalid": dataAttr(invalid),
        "data-focus": dataAttr(focused),
        style: dom13.getControlStyle(),
        onPointerDown(event) {
          if (!interactive) return;
          if (!isLeftClick(event)) return;
          if (isModifierKey(event)) return;
          const point = getEventPoint(event);
          send({ type: "POINTER_DOWN", point });
          event.preventDefault();
          event.stopPropagation();
        }
      });
    },
    getMarkerGroupProps() {
      return normalize2.element({
        ...parts15.markerGroup.attrs,
        role: "presentation",
        dir: state2.context.dir,
        "aria-hidden": true,
        "data-orientation": state2.context.orientation,
        style: dom13.getMarkerGroupStyle()
      });
    },
    getMarkerProps(props22) {
      const style = dom13.getMarkerStyle(state2.context, props22.value);
      let markerState;
      const first2 = state2.context.value[0];
      const last2 = state2.context.value[state2.context.value.length - 1];
      if (props22.value < first2) {
        markerState = "under-value";
      } else if (props22.value > last2) {
        markerState = "over-value";
      } else {
        markerState = "at-value";
      }
      return normalize2.element({
        ...parts15.marker.attrs,
        id: dom13.getMarkerId(state2.context, props22.value),
        role: "presentation",
        dir: state2.context.dir,
        "data-orientation": state2.context.orientation,
        "data-value": props22.value,
        "data-disabled": dataAttr(disabled),
        "data-state": markerState,
        style
      });
    },
    getDraggingIndicatorProps(props22) {
      const { index = 0 } = props22;
      const isDragging = index === state2.context.focusedIndex && dragging;
      return normalize2.element({
        ...parts15.draggingIndicator.attrs,
        role: "presentation",
        dir: state2.context.dir,
        hidden: !isDragging,
        "data-orientation": state2.context.orientation,
        "data-state": isDragging ? "open" : "closed",
        style: dom13.getThumbStyle(state2.context, index)
      });
    }
  };
}
var isEqualSize2 = (a, b) => {
  return (a == null ? void 0 : a.width) === (b == null ? void 0 : b.width) && (a == null ? void 0 : a.height) === (b == null ? void 0 : b.height);
};
function machine14(userContext) {
  const ctx = compact2(userContext);
  return createMachine(
    {
      id: "slider",
      initial: "idle",
      context: {
        thumbSize: null,
        thumbAlignment: "contain",
        min: 0,
        max: 100,
        step: 1,
        value: [0],
        origin: "start",
        orientation: "horizontal",
        dir: "ltr",
        minStepsBetweenThumbs: 0,
        disabled: false,
        readOnly: false,
        ...ctx,
        focusedIndex: -1,
        fieldsetDisabled: false
      },
      computed: {
        isHorizontal: (ctx2) => ctx2.orientation === "horizontal",
        isVertical: (ctx2) => ctx2.orientation === "vertical",
        isRtl: (ctx2) => ctx2.orientation === "horizontal" && ctx2.dir === "rtl",
        isDisabled: (ctx2) => !!ctx2.disabled || ctx2.fieldsetDisabled,
        isInteractive: (ctx2) => !(ctx2.readOnly || ctx2.isDisabled),
        hasMeasuredThumbSize: (ctx2) => ctx2.thumbSize != null,
        valuePercent(ctx2) {
          return ctx2.value.map((value) => 100 * getValuePercent(value, ctx2.min, ctx2.max));
        }
      },
      watch: {
        value: ["syncInputElements"]
      },
      entry: ["coarseValue"],
      activities: ["trackFormControlState", "trackThumbsSize"],
      on: {
        SET_VALUE: [
          {
            guard: "hasIndex",
            actions: "setValueAtIndex"
          },
          { actions: "setValue" }
        ],
        INCREMENT: {
          actions: "incrementThumbAtIndex"
        },
        DECREMENT: {
          actions: "decrementThumbAtIndex"
        }
      },
      states: {
        idle: {
          on: {
            POINTER_DOWN: {
              target: "dragging",
              actions: ["setClosestThumbIndex", "setPointerValue", "focusActiveThumb"]
            },
            FOCUS: {
              target: "focus",
              actions: "setFocusedIndex"
            },
            THUMB_POINTER_DOWN: {
              target: "dragging",
              actions: ["setFocusedIndex", "focusActiveThumb"]
            }
          }
        },
        focus: {
          entry: "focusActiveThumb",
          on: {
            POINTER_DOWN: {
              target: "dragging",
              actions: ["setClosestThumbIndex", "setPointerValue", "focusActiveThumb"]
            },
            THUMB_POINTER_DOWN: {
              target: "dragging",
              actions: ["setFocusedIndex", "focusActiveThumb"]
            },
            ARROW_DEC: {
              actions: ["decrementThumbAtIndex", "invokeOnChangeEnd"]
            },
            ARROW_INC: {
              actions: ["incrementThumbAtIndex", "invokeOnChangeEnd"]
            },
            HOME: {
              actions: ["setFocusedThumbToMin", "invokeOnChangeEnd"]
            },
            END: {
              actions: ["setFocusedThumbToMax", "invokeOnChangeEnd"]
            },
            BLUR: {
              target: "idle",
              actions: "clearFocusedIndex"
            }
          }
        },
        dragging: {
          entry: "focusActiveThumb",
          activities: "trackPointerMove",
          on: {
            POINTER_UP: {
              target: "focus",
              actions: "invokeOnChangeEnd"
            },
            POINTER_MOVE: {
              actions: "setPointerValue"
            }
          }
        }
      }
    },
    {
      guards: {
        hasIndex: (_ctx, evt) => evt.index != null
      },
      activities: {
        trackFormControlState(ctx2, _evt, { initialContext }) {
          return trackFormControl(dom13.getRootEl(ctx2), {
            onFieldsetDisabledChange(disabled) {
              ctx2.fieldsetDisabled = disabled;
            },
            onFormReset() {
              set12.value(ctx2, initialContext.value);
            }
          });
        },
        trackPointerMove(ctx2, _evt, { send }) {
          return trackPointerMove(dom13.getDoc(ctx2), {
            onPointerMove(info) {
              send({ type: "POINTER_MOVE", point: info.point });
            },
            onPointerUp() {
              send("POINTER_UP");
            }
          });
        },
        trackThumbsSize(ctx2) {
          if (ctx2.thumbAlignment !== "contain" || ctx2.thumbSize) return;
          return trackElementsSize({
            getNodes: () => dom13.getElements(ctx2),
            observeMutation: true,
            callback(size3) {
              if (!size3 || isEqualSize2(ctx2.thumbSize, size3)) return;
              ctx2.thumbSize = size3;
            }
          });
        }
      },
      actions: {
        syncInputElements(ctx2) {
          ctx2.value.forEach((value, index) => {
            const inputEl = dom13.getHiddenInputEl(ctx2, index);
            dom13.setValue(inputEl, value);
          });
        },
        invokeOnChangeEnd(ctx2) {
          invoke9.valueChangeEnd(ctx2);
        },
        setClosestThumbIndex(ctx2, evt) {
          const pointValue = dom13.getValueFromPoint(ctx2, evt.point);
          if (pointValue == null) return;
          const focusedIndex = getClosestIndex(ctx2, pointValue);
          set12.focusedIndex(ctx2, focusedIndex);
        },
        setFocusedIndex(ctx2, evt) {
          set12.focusedIndex(ctx2, evt.index);
        },
        clearFocusedIndex(ctx2) {
          set12.focusedIndex(ctx2, -1);
        },
        setPointerValue(ctx2, evt) {
          const pointerValue = dom13.getValueFromPoint(ctx2, evt.point);
          if (pointerValue == null) return;
          const value = constrainValue2(ctx2, pointerValue, ctx2.focusedIndex);
          set12.valueAtIndex(ctx2, ctx2.focusedIndex, value);
        },
        focusActiveThumb(ctx2) {
          raf(() => {
            const thumbEl = dom13.getThumbEl(ctx2, ctx2.focusedIndex);
            thumbEl == null ? void 0 : thumbEl.focus({ preventScroll: true });
          });
        },
        decrementThumbAtIndex(ctx2, evt) {
          const value = decrement(ctx2, evt.index, evt.step);
          set12.value(ctx2, value);
        },
        incrementThumbAtIndex(ctx2, evt) {
          const value = increment(ctx2, evt.index, evt.step);
          set12.value(ctx2, value);
        },
        setFocusedThumbToMin(ctx2) {
          const { min: min4 } = getRangeAtIndex(ctx2, ctx2.focusedIndex);
          set12.valueAtIndex(ctx2, ctx2.focusedIndex, min4);
        },
        setFocusedThumbToMax(ctx2) {
          const { max: max4 } = getRangeAtIndex(ctx2, ctx2.focusedIndex);
          set12.valueAtIndex(ctx2, ctx2.focusedIndex, max4);
        },
        coarseValue(ctx2) {
          const value = normalizeValues(ctx2, ctx2.value);
          set12.value(ctx2, value);
        },
        setValueAtIndex(ctx2, evt) {
          const value = constrainValue2(ctx2, evt.value, evt.index);
          set12.valueAtIndex(ctx2, evt.index, value);
        },
        setValue(ctx2, evt) {
          const value = normalizeValues(ctx2, evt.value);
          set12.value(ctx2, value);
        }
      }
    }
  );
}
var invoke9 = {
  valueChange(ctx) {
    var _a8;
    (_a8 = ctx.onValueChange) == null ? void 0 : _a8.call(ctx, {
      value: Array.from(ctx.value)
    });
    dom13.dispatchChangeEvent(ctx);
  },
  valueChangeEnd(ctx) {
    var _a8;
    (_a8 = ctx.onValueChangeEnd) == null ? void 0 : _a8.call(ctx, {
      value: Array.from(ctx.value)
    });
  },
  focusChange(ctx) {
    var _a8;
    (_a8 = ctx.onFocusChange) == null ? void 0 : _a8.call(ctx, {
      value: Array.from(ctx.value),
      focusedIndex: ctx.focusedIndex
    });
  }
};
var set12 = {
  valueAtIndex: (ctx, index, value) => {
    if (isEqual(ctx.value[index], value)) return;
    ctx.value[index] = value;
    invoke9.valueChange(ctx);
  },
  value: (ctx, value) => {
    if (isEqual(ctx.value, value)) return;
    assignArray(ctx.value, value);
    invoke9.valueChange(ctx);
  },
  focusedIndex: (ctx, index) => {
    if (isEqual(ctx.focusedIndex, index)) return;
    ctx.focusedIndex = index;
    invoke9.focusChange(ctx);
  }
};
var props13 = createProps2()([
  "aria-label",
  "aria-labelledby",
  "dir",
  "disabled",
  "form",
  "getAriaValueText",
  "getRootNode",
  "id",
  "ids",
  "invalid",
  "max",
  "min",
  "minStepsBetweenThumbs",
  "name",
  "onFocusChange",
  "onValueChange",
  "onValueChangeEnd",
  "orientation",
  "origin",
  "readOnly",
  "step",
  "thumbAlignment",
  "thumbAlignment",
  "thumbSize",
  "value"
]);
var splitProps14 = createSplitProps(props13);
var thumbProps = createProps2()(["index", "name"]);
var splitThumbProps = createSplitProps(thumbProps);

// node_modules/@ark-ui/react/dist/components/slider/use-slider.js
var import_react275 = __toESM(require_react(), 1);
var useSlider = (props21 = {}) => {
  const { getRootNode } = useEnvironmentContext();
  const { dir } = useLocaleContext();
  const initialContext = {
    id: (0, import_react275.useId)(),
    dir,
    getRootNode,
    value: props21.defaultValue,
    ...props21
  };
  const context = {
    ...initialContext,
    value: props21.value,
    onValueChange: useEvent(props21.onValueChange, { sync: true }),
    onValueChangeEnd: useEvent(props21.onValueChangeEnd),
    onFocusChange: useEvent(props21.onFocusChange)
  };
  const [state2, send] = useMachine(machine14(initialContext), {
    context
  });
  return connect14(state2, send, normalizeProps);
};

// node_modules/@ark-ui/react/dist/components/slider/slider-root.js
var SliderRoot = (0, import_react277.forwardRef)((props21, ref2) => {
  const [useSliderProps, localProps] = createSplitProps2()(props21, [
    "aria-label",
    "aria-labelledby",
    "defaultValue",
    "disabled",
    "form",
    "getAriaValueText",
    "id",
    "ids",
    "invalid",
    "max",
    "min",
    "minStepsBetweenThumbs",
    "name",
    "onFocusChange",
    "onValueChange",
    "onValueChangeEnd",
    "orientation",
    "origin",
    "readOnly",
    "step",
    "thumbAlignment",
    "thumbAlignment",
    "thumbSize",
    "value"
  ]);
  const slider = useSlider(useSliderProps);
  const mergedProps = mergeProps(slider.getRootProps(), localProps);
  return (0, import_jsx_runtime126.jsx)(SliderProvider, { value: slider, children: (0, import_jsx_runtime126.jsx)(ark.div, { ...mergedProps, ref: ref2 }) });
});
SliderRoot.displayName = "SliderRoot";

// node_modules/@ark-ui/react/dist/components/slider/slider-root-provider.js
var import_jsx_runtime127 = __toESM(require_jsx_runtime(), 1);
var import_react279 = __toESM(require_react(), 1);
var SliderRootProvider = (0, import_react279.forwardRef)(
  (props21, ref2) => {
    const [{ value: slider }, localProps] = createSplitProps2()(props21, ["value"]);
    const mergedProps = mergeProps(slider.getRootProps(), localProps);
    return (0, import_jsx_runtime127.jsx)(SliderProvider, { value: slider, children: (0, import_jsx_runtime127.jsx)(ark.div, { ...mergedProps, ref: ref2 }) });
  }
);
SliderRootProvider.displayName = "SliderRootProvider";

// node_modules/@ark-ui/react/dist/components/slider/slider-thumb.js
var import_jsx_runtime128 = __toESM(require_jsx_runtime(), 1);
var import_react281 = __toESM(require_react(), 1);
var SliderThumb = (0, import_react281.forwardRef)((props21, ref2) => {
  const [thumbProps2, localProps] = createSplitProps2()(props21, ["index", "name"]);
  const slider = useSliderContext();
  const mergedProps = mergeProps(slider.getThumbProps(thumbProps2), localProps);
  return (0, import_jsx_runtime128.jsx)(SliderThumbPropsProvider, { value: thumbProps2, children: (0, import_jsx_runtime128.jsx)(ark.div, { ...mergedProps, ref: ref2 }) });
});
SliderThumb.displayName = "SliderThumb";

// node_modules/@ark-ui/react/dist/components/slider/slider-track.js
var import_jsx_runtime129 = __toESM(require_jsx_runtime(), 1);
var import_react283 = __toESM(require_react(), 1);
var SliderTrack = (0, import_react283.forwardRef)((props21, ref2) => {
  const slider = useSliderContext();
  const mergedProps = mergeProps(slider.getTrackProps(), props21);
  return (0, import_jsx_runtime129.jsx)(ark.div, { ...mergedProps, ref: ref2 });
});
SliderTrack.displayName = "SliderTrack";

// node_modules/@ark-ui/react/dist/components/slider/slider-value-text.js
var import_jsx_runtime130 = __toESM(require_jsx_runtime(), 1);
var import_react285 = __toESM(require_react(), 1);
var SliderValueText = (0, import_react285.forwardRef)((props21, ref2) => {
  const { children, ...rest } = props21;
  const slider = useSliderContext();
  const mergedProps = mergeProps(slider.getValueTextProps(), rest);
  return (0, import_jsx_runtime130.jsx)(ark.span, { ...mergedProps, ref: ref2, children: children || slider.value.join(", ") });
});
SliderValueText.displayName = "SliderValueText";

// node_modules/@ark-ui/react/dist/components/slider/slider.js
var slider_exports = {};
__export(slider_exports, {
  Context: () => SliderContext,
  Control: () => SliderControl,
  DraggingIndicator: () => SliderDraggingIndicator,
  HiddenInput: () => SliderHiddenInput,
  Label: () => SliderLabel,
  Marker: () => SliderMarker,
  MarkerGroup: () => SliderMarkerGroup,
  Range: () => SliderRange,
  Root: () => SliderRoot,
  RootProvider: () => SliderRootProvider,
  Thumb: () => SliderThumb,
  Track: () => SliderTrack,
  ValueText: () => SliderValueText
});

// node_modules/@ark-ui/react/dist/components/switch/use-switch-context.js
var [SwitchProvider, useSwitchContext] = createContext({
  name: "SwitchContext",
  hookName: "useSwitchContext",
  providerName: "<SwitchProvider />"
});

// node_modules/@ark-ui/react/dist/components/switch/switch-context.js
var SwitchContext = (props21) => props21.children(useSwitchContext());

// node_modules/@ark-ui/react/dist/components/switch/switch-control.js
var import_jsx_runtime131 = __toESM(require_jsx_runtime(), 1);
var import_react287 = __toESM(require_react(), 1);
var SwitchControl = (0, import_react287.forwardRef)((props21, ref2) => {
  const switchContext = useSwitchContext();
  const mergedProps = mergeProps(switchContext.getControlProps(), props21);
  return (0, import_jsx_runtime131.jsx)(ark.span, { ...mergedProps, ref: ref2 });
});
SwitchControl.displayName = "SwitchControl";

// node_modules/@ark-ui/react/dist/components/switch/switch-hidden-input.js
var import_jsx_runtime132 = __toESM(require_jsx_runtime(), 1);
var import_react289 = __toESM(require_react(), 1);
var SwitchHiddenInput = (0, import_react289.forwardRef)(
  (props21, ref2) => {
    const switchContext = useSwitchContext();
    const mergedProps = mergeProps(switchContext.getHiddenInputProps(), props21);
    const field = useFieldContext();
    return (0, import_jsx_runtime132.jsx)(ark.input, { "aria-describedby": field == null ? void 0 : field.ariaDescribedby, ...mergedProps, ref: ref2 });
  }
);
SwitchHiddenInput.displayName = "SwitchHiddenInput";

// node_modules/@ark-ui/react/dist/components/switch/switch-label.js
var import_jsx_runtime133 = __toESM(require_jsx_runtime(), 1);
var import_react291 = __toESM(require_react(), 1);
var SwitchLabel = (0, import_react291.forwardRef)((props21, ref2) => {
  const switchContext = useSwitchContext();
  const mergedProps = mergeProps(switchContext.getLabelProps(), props21);
  return (0, import_jsx_runtime133.jsx)(ark.span, { ...mergedProps, ref: ref2 });
});
SwitchLabel.displayName = "SwitchLabel";

// node_modules/@ark-ui/react/dist/components/switch/switch-root.js
var import_jsx_runtime134 = __toESM(require_jsx_runtime(), 1);
var import_react295 = __toESM(require_react(), 1);

// node_modules/@zag-js/switch/dist/index.mjs
var anatomy14 = createAnatomy("switch").parts("root", "label", "control", "thumb");
var parts16 = anatomy14.build();
var dom14 = createScope({
  getRootId: (ctx) => {
    var _a8;
    return ((_a8 = ctx.ids) == null ? void 0 : _a8.root) ?? `switch:${ctx.id}`;
  },
  getLabelId: (ctx) => {
    var _a8;
    return ((_a8 = ctx.ids) == null ? void 0 : _a8.label) ?? `switch:${ctx.id}:label`;
  },
  getThumbId: (ctx) => {
    var _a8;
    return ((_a8 = ctx.ids) == null ? void 0 : _a8.thumb) ?? `switch:${ctx.id}:thumb`;
  },
  getControlId: (ctx) => {
    var _a8;
    return ((_a8 = ctx.ids) == null ? void 0 : _a8.control) ?? `switch:${ctx.id}:control`;
  },
  getHiddenInputId: (ctx) => {
    var _a8;
    return ((_a8 = ctx.ids) == null ? void 0 : _a8.hiddenInput) ?? `switch:${ctx.id}:input`;
  },
  getRootEl: (ctx) => dom14.getById(ctx, dom14.getRootId(ctx)),
  getHiddenInputEl: (ctx) => dom14.getById(ctx, dom14.getHiddenInputId(ctx))
});
function connect15(state2, send, normalize2) {
  const disabled = state2.context.isDisabled;
  const readOnly = state2.context.readOnly;
  const checked = state2.context.checked;
  const focused = !disabled && state2.context.focused;
  const focusVisible = !disabled && state2.context.focusVisible;
  const dataAttrs = {
    "data-active": dataAttr(state2.context.active),
    "data-focus": dataAttr(focused),
    "data-focus-visible": dataAttr(focusVisible),
    "data-readonly": dataAttr(readOnly),
    "data-hover": dataAttr(state2.context.hovered),
    "data-disabled": dataAttr(disabled),
    "data-state": state2.context.checked ? "checked" : "unchecked",
    "data-invalid": dataAttr(state2.context.invalid)
  };
  return {
    checked,
    disabled,
    focused,
    setChecked(checked2) {
      send({ type: "CHECKED.SET", checked: checked2, isTrusted: false });
    },
    toggleChecked() {
      send({ type: "CHECKED.TOGGLE", checked, isTrusted: false });
    },
    getRootProps() {
      return normalize2.label({
        ...parts16.root.attrs,
        ...dataAttrs,
        dir: state2.context.dir,
        id: dom14.getRootId(state2.context),
        htmlFor: dom14.getHiddenInputId(state2.context),
        onPointerMove() {
          if (disabled) return;
          send({ type: "CONTEXT.SET", context: { hovered: true } });
        },
        onPointerLeave() {
          if (disabled) return;
          send({ type: "CONTEXT.SET", context: { hovered: false } });
        },
        onClick(event) {
          if (disabled) return;
          const target = getEventTarget(event);
          if (target === dom14.getHiddenInputEl(state2.context)) {
            event.stopPropagation();
          }
        }
      });
    },
    getLabelProps() {
      return normalize2.element({
        ...parts16.label.attrs,
        ...dataAttrs,
        dir: state2.context.dir,
        id: dom14.getLabelId(state2.context)
      });
    },
    getThumbProps() {
      return normalize2.element({
        ...parts16.thumb.attrs,
        ...dataAttrs,
        dir: state2.context.dir,
        id: dom14.getThumbId(state2.context),
        "aria-hidden": true
      });
    },
    getControlProps() {
      return normalize2.element({
        ...parts16.control.attrs,
        ...dataAttrs,
        dir: state2.context.dir,
        id: dom14.getControlId(state2.context),
        "aria-hidden": true
      });
    },
    getHiddenInputProps() {
      return normalize2.input({
        id: dom14.getHiddenInputId(state2.context),
        type: "checkbox",
        required: state2.context.required,
        defaultChecked: checked,
        disabled,
        "aria-labelledby": dom14.getLabelId(state2.context),
        "aria-invalid": state2.context.invalid,
        name: state2.context.name,
        form: state2.context.form,
        value: state2.context.value,
        style: visuallyHiddenStyle,
        onFocus() {
          const focusVisible2 = isFocusVisible();
          send({ type: "CONTEXT.SET", context: { focused: true, focusVisible: focusVisible2 } });
        },
        onBlur() {
          send({ type: "CONTEXT.SET", context: { focused: false, focusVisible: false } });
        },
        onClick(event) {
          if (readOnly) {
            event.preventDefault();
            return;
          }
          const checked2 = event.currentTarget.checked;
          send({ type: "CHECKED.SET", checked: checked2, isTrusted: true });
        }
      });
    }
  };
}
var { not: not6 } = guards;
function machine15(userContext) {
  const ctx = compact2(userContext);
  return createMachine(
    {
      id: "switch",
      initial: "ready",
      context: {
        checked: false,
        label: "switch",
        value: "on",
        disabled: false,
        ...ctx,
        fieldsetDisabled: false,
        focusVisible: false
      },
      computed: {
        isDisabled: (ctx2) => ctx2.disabled || ctx2.fieldsetDisabled
      },
      watch: {
        disabled: "removeFocusIfNeeded",
        checked: "syncInputElement"
      },
      activities: ["trackFormControlState", "trackPressEvent", "trackFocusVisible"],
      on: {
        "CHECKED.TOGGLE": [
          {
            guard: not6("isTrusted"),
            actions: ["toggleChecked", "dispatchChangeEvent"]
          },
          {
            actions: ["toggleChecked"]
          }
        ],
        "CHECKED.SET": [
          {
            guard: not6("isTrusted"),
            actions: ["setChecked", "dispatchChangeEvent"]
          },
          {
            actions: ["setChecked"]
          }
        ],
        "CONTEXT.SET": {
          actions: ["setContext"]
        }
      },
      states: {
        ready: {}
      }
    },
    {
      guards: {
        isTrusted: (_ctx, evt) => !!evt.isTrusted
      },
      activities: {
        trackPressEvent(ctx2) {
          if (ctx2.isDisabled) return;
          return trackPress({
            pointerNode: dom14.getRootEl(ctx2),
            keyboardNode: dom14.getHiddenInputEl(ctx2),
            isValidKey: (event) => event.key === " ",
            onPress: () => ctx2.active = false,
            onPressStart: () => ctx2.active = true,
            onPressEnd: () => ctx2.active = false
          });
        },
        trackFocusVisible(ctx2) {
          if (ctx2.isDisabled) return;
          return trackFocusVisible({ root: dom14.getRootNode(ctx2) });
        },
        trackFormControlState(ctx2, _evt, { send, initialContext }) {
          return trackFormControl(dom14.getHiddenInputEl(ctx2), {
            onFieldsetDisabledChange(disabled) {
              ctx2.fieldsetDisabled = disabled;
            },
            onFormReset() {
              send({ type: "CHECKED.SET", checked: !!initialContext.checked, src: "form-reset" });
            }
          });
        }
      },
      actions: {
        setContext(ctx2, evt) {
          Object.assign(ctx2, evt.context);
        },
        syncInputElement(ctx2) {
          const inputEl = dom14.getHiddenInputEl(ctx2);
          if (!inputEl) return;
          inputEl.checked = !!ctx2.checked;
        },
        removeFocusIfNeeded(ctx2) {
          if (ctx2.disabled && ctx2.focused) {
            ctx2.focused = false;
          }
        },
        setChecked(ctx2, evt) {
          set13.checked(ctx2, evt.checked);
        },
        toggleChecked(ctx2, _evt) {
          set13.checked(ctx2, !ctx2.checked);
        },
        dispatchChangeEvent(ctx2) {
          const inputEl = dom14.getHiddenInputEl(ctx2);
          dispatchInputCheckedEvent(inputEl, { checked: ctx2.checked });
        }
      }
    }
  );
}
var invoke10 = {
  change: (ctx) => {
    var _a8;
    (_a8 = ctx.onCheckedChange) == null ? void 0 : _a8.call(ctx, { checked: ctx.checked });
  }
};
var set13 = {
  checked: (ctx, checked) => {
    if (isEqual(ctx.checked, checked)) return;
    ctx.checked = checked;
    invoke10.change(ctx);
  }
};
var props14 = createProps2()([
  "checked",
  "dir",
  "disabled",
  "form",
  "getRootNode",
  "id",
  "ids",
  "invalid",
  "label",
  "name",
  "onCheckedChange",
  "readOnly",
  "required",
  "value"
]);
var splitProps15 = createSplitProps(props14);

// node_modules/@ark-ui/react/dist/components/switch/use-switch.js
var import_react293 = __toESM(require_react(), 1);
var useSwitch = (props21 = {}) => {
  const { getRootNode } = useEnvironmentContext();
  const { dir } = useLocaleContext();
  const field = useFieldContext();
  const initialContext = {
    id: (0, import_react293.useId)(),
    ids: {
      label: field == null ? void 0 : field.ids.label,
      hiddenInput: field == null ? void 0 : field.ids.control
    },
    dir,
    disabled: field == null ? void 0 : field.disabled,
    readOnly: field == null ? void 0 : field.readOnly,
    invalid: field == null ? void 0 : field.invalid,
    required: field == null ? void 0 : field.required,
    getRootNode,
    checked: props21.defaultChecked,
    ...props21
  };
  const context = {
    ...initialContext,
    checked: props21.checked,
    onCheckedChange: useEvent(props21.onCheckedChange, { sync: true })
  };
  const [state2, send] = useMachine(machine15(initialContext), { context });
  return connect15(state2, send, normalizeProps);
};

// node_modules/@ark-ui/react/dist/components/switch/switch-root.js
var SwitchRoot = (0, import_react295.forwardRef)((props21, ref2) => {
  const [switchProps, localProps] = createSplitProps2()(props21, [
    "checked",
    "defaultChecked",
    "disabled",
    "form",
    "id",
    "ids",
    "invalid",
    "label",
    "name",
    "onCheckedChange",
    "readOnly",
    "required",
    "value"
  ]);
  const switchContext = useSwitch(switchProps);
  const mergedProps = mergeProps(switchContext.getRootProps(), localProps);
  return (0, import_jsx_runtime134.jsx)(SwitchProvider, { value: switchContext, children: (0, import_jsx_runtime134.jsx)(ark.label, { ...mergedProps, ref: ref2 }) });
});
SwitchRoot.displayName = "SwitchRoot";

// node_modules/@ark-ui/react/dist/components/switch/switch-root-provider.js
var import_jsx_runtime135 = __toESM(require_jsx_runtime(), 1);
var import_react297 = __toESM(require_react(), 1);
var SwitchRootProvider = (0, import_react297.forwardRef)(
  (props21, ref2) => {
    const [{ value: api }, localProps] = createSplitProps2()(props21, ["value"]);
    const mergedProps = mergeProps(api.getRootProps(), localProps);
    return (0, import_jsx_runtime135.jsx)(SwitchProvider, { value: api, children: (0, import_jsx_runtime135.jsx)(ark.label, { ...mergedProps, ref: ref2 }) });
  }
);
SwitchRootProvider.displayName = "SwitchRootProvider";

// node_modules/@ark-ui/react/dist/components/switch/switch-thumb.js
var import_jsx_runtime136 = __toESM(require_jsx_runtime(), 1);
var import_react299 = __toESM(require_react(), 1);
var SwitchThumb = (0, import_react299.forwardRef)((props21, ref2) => {
  const switchContext = useSwitchContext();
  const mergedProps = mergeProps(switchContext.getThumbProps(), props21);
  return (0, import_jsx_runtime136.jsx)(ark.span, { ...mergedProps, ref: ref2 });
});
SwitchThumb.displayName = "SwitchThumb";

// node_modules/@ark-ui/react/dist/components/switch/switch.js
var switch_exports = {};
__export(switch_exports, {
  Context: () => SwitchContext,
  Control: () => SwitchControl,
  HiddenInput: () => SwitchHiddenInput,
  Label: () => SwitchLabel,
  Root: () => SwitchRoot,
  RootProvider: () => SwitchRootProvider,
  Thumb: () => SwitchThumb
});

// node_modules/@ark-ui/react/dist/components/avatar/use-avatar-context.js
var [AvatarProvider, useAvatarContext] = createContext({
  name: "AvatarContext",
  hookName: "useAvatarContext",
  providerName: "<AvatarProvider />"
});

// node_modules/@ark-ui/react/dist/components/avatar/avatar-context.js
var AvatarContext = (props21) => props21.children(useAvatarContext());

// node_modules/@ark-ui/react/dist/components/avatar/avatar-fallback.js
var import_jsx_runtime137 = __toESM(require_jsx_runtime(), 1);
var import_react301 = __toESM(require_react(), 1);
var AvatarFallback = (0, import_react301.forwardRef)((props21, ref2) => {
  const avatar = useAvatarContext();
  const mergedProps = mergeProps(avatar.getFallbackProps(), props21);
  return (0, import_jsx_runtime137.jsx)(ark.span, { ...mergedProps, ref: ref2 });
});
AvatarFallback.displayName = "AvatarFallback";

// node_modules/@ark-ui/react/dist/components/avatar/avatar-image.js
var import_jsx_runtime138 = __toESM(require_jsx_runtime(), 1);
var import_react303 = __toESM(require_react(), 1);
var AvatarImage = (0, import_react303.forwardRef)((props21, ref2) => {
  const avatar = useAvatarContext();
  const mergedProps = mergeProps(avatar.getImageProps(), props21);
  return (0, import_jsx_runtime138.jsx)(ark.img, { ...mergedProps, ref: ref2 });
});
AvatarImage.displayName = "AvatarImage";

// node_modules/@ark-ui/react/dist/components/avatar/avatar-root.js
var import_jsx_runtime139 = __toESM(require_jsx_runtime(), 1);
var import_react307 = __toESM(require_react(), 1);

// node_modules/@zag-js/avatar/dist/index.mjs
var anatomy15 = createAnatomy("avatar").parts("root", "image", "fallback");
var parts17 = anatomy15.build();
var dom15 = createScope({
  getRootId: (ctx) => {
    var _a8;
    return ((_a8 = ctx.ids) == null ? void 0 : _a8.root) ?? `avatar:${ctx.id}`;
  },
  getImageId: (ctx) => {
    var _a8;
    return ((_a8 = ctx.ids) == null ? void 0 : _a8.image) ?? `avatar:${ctx.id}:image`;
  },
  getFallbackId: (ctx) => {
    var _a8;
    return ((_a8 = ctx.ids) == null ? void 0 : _a8.fallback) ?? `avatar:${ctx.id}:fallback`;
  },
  getRootEl: (ctx) => dom15.getById(ctx, dom15.getRootId(ctx)),
  getImageEl: (ctx) => dom15.getById(ctx, dom15.getImageId(ctx))
});
function connect16(state2, send, normalize2) {
  const loaded = state2.matches("loaded");
  return {
    loaded,
    setSrc(src) {
      send({ type: "SRC.SET", src });
    },
    setLoaded() {
      send({ type: "IMG.LOADED", src: "api" });
    },
    setError() {
      send({ type: "IMG.ERROR", src: "api" });
    },
    getRootProps() {
      return normalize2.element({
        ...parts17.root.attrs,
        dir: state2.context.dir,
        id: dom15.getRootId(state2.context)
      });
    },
    getImageProps() {
      return normalize2.img({
        ...parts17.image.attrs,
        hidden: !loaded,
        dir: state2.context.dir,
        id: dom15.getImageId(state2.context),
        "data-state": loaded ? "visible" : "hidden",
        onLoad() {
          send({ type: "IMG.LOADED", src: "element" });
        },
        onError() {
          send({ type: "IMG.ERROR", src: "element" });
        }
      });
    },
    getFallbackProps() {
      return normalize2.element({
        ...parts17.fallback.attrs,
        dir: state2.context.dir,
        id: dom15.getFallbackId(state2.context),
        hidden: loaded,
        "data-state": loaded ? "hidden" : "visible"
      });
    }
  };
}
function machine16(userContext) {
  const ctx = compact2(userContext);
  return createMachine(
    {
      id: "avatar",
      initial: "loading",
      activities: ["trackImageRemoval"],
      context: ctx,
      on: {
        "SRC.CHANGE": {
          target: "loading"
        },
        "IMG.UNMOUNT": {
          target: "error"
        }
      },
      states: {
        loading: {
          activities: ["trackSrcChange"],
          entry: ["checkImageStatus"],
          on: {
            "IMG.LOADED": {
              target: "loaded",
              actions: ["invokeOnLoad"]
            },
            "IMG.ERROR": {
              target: "error",
              actions: ["invokeOnError"]
            }
          }
        },
        error: {
          activities: ["trackSrcChange"],
          on: {
            "IMG.LOADED": {
              target: "loaded",
              actions: ["invokeOnLoad"]
            }
          }
        },
        loaded: {
          activities: ["trackSrcChange"],
          on: {
            "IMG.ERROR": {
              target: "error",
              actions: ["invokeOnError"]
            }
          }
        }
      }
    },
    {
      activities: {
        trackSrcChange(ctx2, _evt, { send }) {
          const imageEl = dom15.getImageEl(ctx2);
          return observeAttributes(imageEl, {
            attributes: ["src", "srcset"],
            callback() {
              send({ type: "SRC.CHANGE" });
            }
          });
        },
        trackImageRemoval(ctx2, _evt, { send }) {
          const rootEl = dom15.getRootEl(ctx2);
          return observeChildren(rootEl, {
            callback(records) {
              const removedNodes = Array.from(records[0].removedNodes);
              const removed = removedNodes.find(
                (node) => node.nodeType === Node.ELEMENT_NODE && node.matches("[data-scope=avatar][data-part=image]")
              );
              if (removed) {
                send({ type: "IMG.UNMOUNT" });
              }
            }
          });
        }
      },
      actions: {
        invokeOnLoad(ctx2) {
          var _a8;
          (_a8 = ctx2.onStatusChange) == null ? void 0 : _a8.call(ctx2, { status: "loaded" });
        },
        invokeOnError(ctx2) {
          var _a8;
          (_a8 = ctx2.onStatusChange) == null ? void 0 : _a8.call(ctx2, { status: "error" });
        },
        checkImageStatus(ctx2, _evt, { send }) {
          const imageEl = dom15.getImageEl(ctx2);
          if (imageEl == null ? void 0 : imageEl.complete) {
            const type = hasLoaded(imageEl) ? "IMG.LOADED" : "IMG.ERROR";
            send({ type, src: "ssr" });
          }
        }
      }
    }
  );
}
function hasLoaded(image) {
  return image.complete && image.naturalWidth !== 0 && image.naturalHeight !== 0;
}
var props15 = createProps2()(["dir", "id", "ids", "onStatusChange", "getRootNode"]);
var splitProps16 = createSplitProps(props15);

// node_modules/@ark-ui/react/dist/components/avatar/use-avatar.js
var import_react305 = __toESM(require_react(), 1);
var useAvatar = (props21 = {}) => {
  const { getRootNode } = useEnvironmentContext();
  const { dir } = useLocaleContext();
  const initialContext = {
    id: (0, import_react305.useId)(),
    dir,
    getRootNode,
    ...props21
  };
  const context = {
    ...initialContext,
    onStatusChange: useEvent(props21.onStatusChange)
  };
  const [state2, send] = useMachine(machine16(initialContext), { context });
  return connect16(state2, send, normalizeProps);
};

// node_modules/@ark-ui/react/dist/components/avatar/avatar-root.js
var AvatarRoot = (0, import_react307.forwardRef)((props21, ref2) => {
  const [useAvatarProps, localProps] = createSplitProps2()(props21, [
    "id",
    "ids",
    "onStatusChange"
  ]);
  const avatar = useAvatar(useAvatarProps);
  const mergedProps = mergeProps(avatar.getRootProps(), localProps);
  return (0, import_jsx_runtime139.jsx)(AvatarProvider, { value: avatar, children: (0, import_jsx_runtime139.jsx)(ark.div, { ...mergedProps, ref: ref2 }) });
});
AvatarRoot.displayName = "AvatarRoot";

// node_modules/@ark-ui/react/dist/components/avatar/avatar-root-provider.js
var import_jsx_runtime140 = __toESM(require_jsx_runtime(), 1);
var import_react309 = __toESM(require_react(), 1);
var AvatarRootProvider = (0, import_react309.forwardRef)(
  (props21, ref2) => {
    const [{ value: avatar }, localProps] = createSplitProps2()(props21, ["value"]);
    const mergedProps = mergeProps(avatar.getRootProps(), localProps);
    return (0, import_jsx_runtime140.jsx)(AvatarProvider, { value: avatar, children: (0, import_jsx_runtime140.jsx)(ark.div, { ...mergedProps, ref: ref2 }) });
  }
);
AvatarRootProvider.displayName = "AvatarRootProvider";

// node_modules/@ark-ui/react/dist/components/avatar/avatar.js
var avatar_exports = {};
__export(avatar_exports, {
  Context: () => AvatarContext,
  Fallback: () => AvatarFallback,
  Image: () => AvatarImage,
  Root: () => AvatarRoot,
  RootProvider: () => AvatarRootProvider
});

// node_modules/@ark-ui/react/dist/components/checkbox/use-checkbox-context.js
var [CheckboxProvider, useCheckboxContext] = createContext({
  name: "CheckboxContext",
  hookName: "useCheckboxContext",
  providerName: "<CheckboxProvider />"
});

// node_modules/@ark-ui/react/dist/components/checkbox/checkbox-context.js
var CheckboxContext = (props21) => props21.children(useCheckboxContext());

// node_modules/@ark-ui/react/dist/components/checkbox/checkbox-control.js
var import_jsx_runtime141 = __toESM(require_jsx_runtime(), 1);
var import_react311 = __toESM(require_react(), 1);
var CheckboxControl = (0, import_react311.forwardRef)((props21, ref2) => {
  const checkbox = useCheckboxContext();
  const mergedProps = mergeProps(checkbox.getControlProps(), props21);
  return (0, import_jsx_runtime141.jsx)(ark.div, { ...mergedProps, ref: ref2 });
});
CheckboxControl.displayName = "CheckboxControl";

// node_modules/@ark-ui/react/dist/components/checkbox/checkbox-group.js
var import_jsx_runtime142 = __toESM(require_jsx_runtime(), 1);
var import_react313 = __toESM(require_react(), 1);

// node_modules/@zag-js/checkbox/dist/index.mjs
var anatomy16 = createAnatomy("checkbox").parts("root", "label", "control", "indicator");
var parts18 = anatomy16.build();
var dom16 = createScope({
  getRootId: (ctx) => {
    var _a8;
    return ((_a8 = ctx.ids) == null ? void 0 : _a8.root) ?? `checkbox:${ctx.id}`;
  },
  getLabelId: (ctx) => {
    var _a8;
    return ((_a8 = ctx.ids) == null ? void 0 : _a8.label) ?? `checkbox:${ctx.id}:label`;
  },
  getControlId: (ctx) => {
    var _a8;
    return ((_a8 = ctx.ids) == null ? void 0 : _a8.control) ?? `checkbox:${ctx.id}:control`;
  },
  getHiddenInputId: (ctx) => {
    var _a8;
    return ((_a8 = ctx.ids) == null ? void 0 : _a8.hiddenInput) ?? `checkbox:${ctx.id}:input`;
  },
  getRootEl: (ctx) => dom16.getById(ctx, dom16.getRootId(ctx)),
  getHiddenInputEl: (ctx) => dom16.getById(ctx, dom16.getHiddenInputId(ctx))
});
function connect17(state2, send, normalize2) {
  const disabled = state2.context.isDisabled;
  const readOnly = state2.context.readOnly;
  const focused = !disabled && state2.context.focused;
  const focusVisible = !disabled && state2.context.focusVisible;
  const checked = state2.context.isChecked;
  const indeterminate = state2.context.isIndeterminate;
  const dataAttrs = {
    "data-active": dataAttr(state2.context.active),
    "data-focus": dataAttr(focused),
    "data-focus-visible": dataAttr(focusVisible),
    "data-readonly": dataAttr(readOnly),
    "data-hover": dataAttr(state2.context.hovered),
    "data-disabled": dataAttr(disabled),
    "data-state": indeterminate ? "indeterminate" : state2.context.checked ? "checked" : "unchecked",
    "data-invalid": dataAttr(state2.context.invalid)
  };
  return {
    checked,
    disabled,
    indeterminate,
    focused,
    checkedState: state2.context.checked,
    setChecked(checked2) {
      send({ type: "CHECKED.SET", checked: checked2, isTrusted: false });
    },
    toggleChecked() {
      send({ type: "CHECKED.TOGGLE", checked, isTrusted: false });
    },
    getRootProps() {
      return normalize2.label({
        ...parts18.root.attrs,
        ...dataAttrs,
        dir: state2.context.dir,
        id: dom16.getRootId(state2.context),
        htmlFor: dom16.getHiddenInputId(state2.context),
        onPointerMove() {
          if (disabled) return;
          send({ type: "CONTEXT.SET", context: { hovered: true } });
        },
        onPointerLeave() {
          if (disabled) return;
          send({ type: "CONTEXT.SET", context: { hovered: false } });
        },
        onClick(event) {
          const target = getEventTarget(event);
          if (target === dom16.getHiddenInputEl(state2.context)) {
            event.stopPropagation();
          }
        }
      });
    },
    getLabelProps() {
      return normalize2.element({
        ...parts18.label.attrs,
        ...dataAttrs,
        dir: state2.context.dir,
        id: dom16.getLabelId(state2.context)
      });
    },
    getControlProps() {
      return normalize2.element({
        ...parts18.control.attrs,
        ...dataAttrs,
        dir: state2.context.dir,
        id: dom16.getControlId(state2.context),
        "aria-hidden": true
      });
    },
    getIndicatorProps() {
      return normalize2.element({
        ...parts18.indicator.attrs,
        ...dataAttrs,
        dir: state2.context.dir,
        hidden: !indeterminate && !state2.context.checked
      });
    },
    getHiddenInputProps() {
      return normalize2.input({
        id: dom16.getHiddenInputId(state2.context),
        type: "checkbox",
        required: state2.context.required,
        defaultChecked: checked,
        disabled,
        "aria-labelledby": dom16.getLabelId(state2.context),
        "aria-invalid": state2.context.invalid,
        name: state2.context.name,
        form: state2.context.form,
        value: state2.context.value,
        style: visuallyHiddenStyle,
        onFocus() {
          const focusVisible2 = isFocusVisible();
          send({ type: "CONTEXT.SET", context: { focused: true, focusVisible: focusVisible2 } });
        },
        onBlur() {
          send({ type: "CONTEXT.SET", context: { focused: false, focusVisible: false } });
        },
        onClick(event) {
          if (readOnly) {
            event.preventDefault();
            return;
          }
          const checked2 = event.currentTarget.checked;
          send({ type: "CHECKED.SET", checked: checked2, isTrusted: true });
        }
      });
    }
  };
}
var { not: not7 } = guards;
function machine17(userContext) {
  const ctx = compact2(userContext);
  return createMachine(
    {
      id: "checkbox",
      initial: "ready",
      context: {
        checked: false,
        value: "on",
        disabled: false,
        ...ctx,
        fieldsetDisabled: false,
        focusVisible: false
      },
      watch: {
        disabled: "removeFocusIfNeeded",
        checked: "syncInputElement"
      },
      activities: ["trackFormControlState", "trackPressEvent", "trackFocusVisible"],
      on: {
        "CHECKED.TOGGLE": [
          {
            guard: not7("isTrusted"),
            actions: ["toggleChecked", "dispatchChangeEvent"]
          },
          {
            actions: ["toggleChecked"]
          }
        ],
        "CHECKED.SET": [
          {
            guard: not7("isTrusted"),
            actions: ["setChecked", "dispatchChangeEvent"]
          },
          {
            actions: ["setChecked"]
          }
        ],
        "CONTEXT.SET": {
          actions: ["setContext"]
        }
      },
      computed: {
        isIndeterminate: (ctx2) => isIndeterminate(ctx2.checked),
        isChecked: (ctx2) => isChecked(ctx2.checked),
        isDisabled: (ctx2) => !!ctx2.disabled || ctx2.fieldsetDisabled
      },
      states: {
        ready: {}
      }
    },
    {
      guards: {
        isTrusted: (_ctx, evt) => !!evt.isTrusted
      },
      activities: {
        trackPressEvent(ctx2) {
          if (ctx2.isDisabled) return;
          return trackPress({
            pointerNode: dom16.getRootEl(ctx2),
            keyboardNode: dom16.getHiddenInputEl(ctx2),
            isValidKey: (event) => event.key === " ",
            onPress: () => ctx2.active = false,
            onPressStart: () => ctx2.active = true,
            onPressEnd: () => ctx2.active = false
          });
        },
        trackFocusVisible(ctx2) {
          if (ctx2.isDisabled) return;
          return trackFocusVisible({ root: dom16.getRootNode(ctx2) });
        },
        trackFormControlState(ctx2, _evt, { send, initialContext }) {
          return trackFormControl(dom16.getHiddenInputEl(ctx2), {
            onFieldsetDisabledChange(disabled) {
              ctx2.fieldsetDisabled = disabled;
            },
            onFormReset() {
              send({ type: "CHECKED.SET", checked: !!initialContext.checked });
            }
          });
        }
      },
      actions: {
        setContext(ctx2, evt) {
          Object.assign(ctx2, evt.context);
        },
        syncInputElement(ctx2) {
          const inputEl = dom16.getHiddenInputEl(ctx2);
          if (!inputEl) return;
          setElementChecked(inputEl, ctx2.isChecked);
          inputEl.indeterminate = ctx2.isIndeterminate;
        },
        removeFocusIfNeeded(ctx2) {
          if (ctx2.disabled && ctx2.focused) {
            ctx2.focused = false;
            ctx2.focusVisible = false;
          }
        },
        setChecked(ctx2, evt) {
          set14.checked(ctx2, evt.checked);
        },
        toggleChecked(ctx2) {
          const checked = isIndeterminate(ctx2.checked) ? true : !ctx2.checked;
          set14.checked(ctx2, checked);
        },
        dispatchChangeEvent(ctx2) {
          const inputEl = dom16.getHiddenInputEl(ctx2);
          dispatchInputCheckedEvent(inputEl, { checked: isChecked(ctx2.checked) });
        }
      }
    }
  );
}
function isIndeterminate(checked) {
  return checked === "indeterminate";
}
function isChecked(checked) {
  return isIndeterminate(checked) ? false : !!checked;
}
var invoke11 = {
  change: (ctx) => {
    var _a8;
    (_a8 = ctx.onCheckedChange) == null ? void 0 : _a8.call(ctx, { checked: ctx.checked });
  }
};
var set14 = {
  checked: (ctx, checked) => {
    if (isEqual(ctx.checked, checked)) return;
    ctx.checked = checked;
    invoke11.change(ctx);
  }
};
var props16 = createProps2()([
  "checked",
  "dir",
  "disabled",
  "form",
  "getRootNode",
  "id",
  "ids",
  "invalid",
  "name",
  "onCheckedChange",
  "readOnly",
  "required",
  "value"
]);
var splitProps17 = createSplitProps(props16);

// node_modules/@ark-ui/react/dist/components/checkbox/checkbox.anatomy.js
var checkboxAnatomy = anatomy16.extendWith("group");

// node_modules/@ark-ui/react/dist/utils/use-controllable-state.js
var import_react312 = __toESM(require_react(), 1);
function useControllableState(props21) {
  const { value, onChange, defaultValue } = props21;
  const [uncontrolledValue, setUncontrolledValue] = (0, import_react312.useState)(defaultValue);
  const controlled = value !== void 0;
  const currentValue = controlled ? value : uncontrolledValue;
  const setValue = (0, import_react312.useCallback)(
    (value2) => {
      if (controlled) {
        return onChange == null ? void 0 : onChange(value2);
      }
      setUncontrolledValue(value2);
      return onChange == null ? void 0 : onChange(value2);
    },
    [controlled, onChange]
  );
  return [currentValue, setValue];
}

// node_modules/@ark-ui/react/dist/components/checkbox/use-checkbox-group.js
function useCheckboxGroup(props21 = {}) {
  const {
    defaultValue,
    value: controlledValue,
    onValueChange,
    disabled,
    readOnly,
    name,
    invalid
  } = props21;
  const interactive = !(disabled || readOnly);
  const onChangeProp = useEvent(onValueChange, { sync: true });
  const [value, setValue] = useControllableState({
    value: controlledValue,
    defaultValue: defaultValue || [],
    onChange: onChangeProp
  });
  const isChecked2 = (val) => {
    return value.some((v) => String(v) === String(val));
  };
  const toggleValue = (val) => {
    isChecked2(val) ? removeValue(val) : addValue(val);
  };
  const addValue = (val) => {
    if (!interactive) return;
    if (isChecked2(val)) return;
    setValue(value.concat(val));
  };
  const removeValue = (val) => {
    if (!interactive) return;
    setValue(value.filter((v) => String(v) !== String(val)));
  };
  const getItemProps = (props22) => {
    return {
      checked: props22.value != null ? isChecked2(props22.value) : void 0,
      onCheckedChange() {
        if (props22.value != null) {
          toggleValue(props22.value);
        }
      },
      name,
      disabled,
      readOnly,
      invalid
    };
  };
  return {
    isChecked: isChecked2,
    value,
    name,
    disabled: !!disabled,
    readOnly: !!readOnly,
    invalid: !!invalid,
    setValue,
    addValue,
    toggleValue,
    getItemProps
  };
}

// node_modules/@ark-ui/react/dist/components/checkbox/use-checkbox-group-context.js
var [CheckboxGroupContextProvider, useCheckboxGroupContext] = createContext({
  name: "CheckboxGroupContext",
  hookName: "useCheckboxGroupContext",
  providerName: "<CheckboxGroupProvider />",
  strict: false
});

// node_modules/@ark-ui/react/dist/components/checkbox/checkbox-group.js
var CheckboxGroup = (0, import_react313.forwardRef)((props21, ref2) => {
  const [checkboxGroupProps, localProps] = createSplitProps2()(props21, [
    "defaultValue",
    "value",
    "onValueChange",
    "disabled",
    "invalid",
    "readOnly",
    "name"
  ]);
  const checkboxGroup = useCheckboxGroup(checkboxGroupProps);
  return (0, import_jsx_runtime142.jsx)(CheckboxGroupContextProvider, { value: checkboxGroup, children: (0, import_jsx_runtime142.jsx)(ark.div, { ref: ref2, role: "group", ...localProps, ...checkboxAnatomy.build().group.attrs }) });
});
CheckboxGroup.displayName = "CheckboxGroup";

// node_modules/@ark-ui/react/dist/components/checkbox/checkbox-hidden-input.js
var import_jsx_runtime143 = __toESM(require_jsx_runtime(), 1);
var import_react315 = __toESM(require_react(), 1);
var CheckboxHiddenInput = (0, import_react315.forwardRef)(
  (props21, ref2) => {
    const checkbox = useCheckboxContext();
    const mergedProps = mergeProps(checkbox.getHiddenInputProps(), props21);
    const field = useFieldContext();
    return (0, import_jsx_runtime143.jsx)(ark.input, { "aria-describedby": field == null ? void 0 : field.ariaDescribedby, ...mergedProps, ref: ref2 });
  }
);
CheckboxHiddenInput.displayName = "CheckboxHiddenInput";

// node_modules/@ark-ui/react/dist/components/checkbox/checkbox-indicator.js
var import_jsx_runtime144 = __toESM(require_jsx_runtime(), 1);
var import_react317 = __toESM(require_react(), 1);
var CheckboxIndicator = (0, import_react317.forwardRef)(
  (props21, ref2) => {
    const { indeterminate, ...rest } = props21;
    const checkbox = useCheckboxContext();
    const mergedProps = mergeProps(checkbox.getIndicatorProps(), rest);
    const isVisible = indeterminate ? checkbox.indeterminate : checkbox.checked;
    return (0, import_jsx_runtime144.jsx)(ark.div, { ...mergedProps, hidden: !isVisible, ref: ref2 });
  }
);
CheckboxIndicator.displayName = "CheckboxIndicator";

// node_modules/@ark-ui/react/dist/components/checkbox/checkbox-label.js
var import_jsx_runtime145 = __toESM(require_jsx_runtime(), 1);
var import_react319 = __toESM(require_react(), 1);
var CheckboxLabel = (0, import_react319.forwardRef)((props21, ref2) => {
  const checkbox = useCheckboxContext();
  const mergedProps = mergeProps(checkbox.getLabelProps(), props21);
  return (0, import_jsx_runtime145.jsx)(ark.span, { ...mergedProps, ref: ref2 });
});
CheckboxLabel.displayName = "CheckboxLabel";

// node_modules/@ark-ui/react/dist/components/checkbox/checkbox-root.js
var import_jsx_runtime146 = __toESM(require_jsx_runtime(), 1);
var import_react323 = __toESM(require_react(), 1);

// node_modules/@ark-ui/react/dist/components/checkbox/use-checkbox.js
var import_react321 = __toESM(require_react(), 1);
var useCheckbox = (ownProps = {}) => {
  const checkboxGroup = useCheckboxGroupContext();
  const field = useFieldContext();
  const props21 = (0, import_react321.useMemo)(() => {
    return mergeProps(ownProps, (checkboxGroup == null ? void 0 : checkboxGroup.getItemProps({ value: ownProps.value })) ?? {});
  }, [ownProps, checkboxGroup]);
  const { getRootNode } = useEnvironmentContext();
  const { dir } = useLocaleContext();
  const initialContext = {
    id: (0, import_react321.useId)(),
    ids: {
      label: field == null ? void 0 : field.ids.label,
      hiddenInput: field == null ? void 0 : field.ids.control
    },
    dir,
    disabled: field == null ? void 0 : field.disabled,
    readOnly: field == null ? void 0 : field.readOnly,
    invalid: field == null ? void 0 : field.invalid,
    required: field == null ? void 0 : field.required,
    getRootNode,
    checked: props21.defaultChecked,
    ...props21
  };
  const context = {
    ...initialContext,
    checked: props21.checked,
    onCheckedChange: useEvent(props21.onCheckedChange, { sync: true })
  };
  const [state2, send] = useMachine(machine17(initialContext), { context });
  return connect17(state2, send, normalizeProps);
};

// node_modules/@ark-ui/react/dist/components/checkbox/checkbox-root.js
var CheckboxRoot = (0, import_react323.forwardRef)((props21, ref2) => {
  const [useCheckboxProps, localProps] = createSplitProps2()(props21, [
    "checked",
    "defaultChecked",
    "disabled",
    "form",
    "id",
    "ids",
    "invalid",
    "name",
    "onCheckedChange",
    "readOnly",
    "required",
    "value"
  ]);
  const checkbox = useCheckbox(useCheckboxProps);
  const mergedProps = mergeProps(checkbox.getRootProps(), localProps);
  return (0, import_jsx_runtime146.jsx)(CheckboxProvider, { value: checkbox, children: (0, import_jsx_runtime146.jsx)(ark.label, { ...mergedProps, ref: ref2 }) });
});
CheckboxRoot.displayName = "CheckboxRoot";

// node_modules/@ark-ui/react/dist/components/checkbox/checkbox-root-provider.js
var import_jsx_runtime147 = __toESM(require_jsx_runtime(), 1);
var import_react325 = __toESM(require_react(), 1);
var CheckboxRootProvider = (0, import_react325.forwardRef)(
  (props21, ref2) => {
    const [{ value: checkbox }, localProps] = createSplitProps2()(props21, [
      "value"
    ]);
    const mergedProps = mergeProps(checkbox.getRootProps(), localProps);
    return (0, import_jsx_runtime147.jsx)(CheckboxProvider, { value: checkbox, children: (0, import_jsx_runtime147.jsx)(ark.label, { ...mergedProps, ref: ref2 }) });
  }
);
CheckboxRootProvider.displayName = "CheckboxRootProvider";

// node_modules/@ark-ui/react/dist/components/checkbox/checkbox.js
var checkbox_exports = {};
__export(checkbox_exports, {
  Context: () => CheckboxContext,
  Control: () => CheckboxControl,
  Group: () => CheckboxGroup,
  HiddenInput: () => CheckboxHiddenInput,
  Indicator: () => CheckboxIndicator,
  Label: () => CheckboxLabel,
  Root: () => CheckboxRoot,
  RootProvider: () => CheckboxRootProvider
});

// node_modules/@ark-ui/react/dist/components/collapsible/collapsible-context.js
var CollapsibleContext = (props21) => props21.children(useCollapsibleContext());

// node_modules/@ark-ui/react/dist/components/collapsible/collapsible-root-provider.js
var import_jsx_runtime148 = __toESM(require_jsx_runtime(), 1);
var import_react327 = __toESM(require_react(), 1);
var CollapsibleRootProvider = (0, import_react327.forwardRef)(
  (props21, ref2) => {
    const [{ value: collapsible }, localProps] = createSplitProps2()(props21, [
      "value"
    ]);
    const mergedProps = mergeProps(collapsible.getRootProps(), localProps);
    return (0, import_jsx_runtime148.jsx)(CollapsibleProvider, { value: collapsible, children: (0, import_jsx_runtime148.jsx)(ark.div, { ...mergedProps, ref: ref2 }) });
  }
);
CollapsibleRootProvider.displayName = "CollapsibleRootProvider";

// node_modules/@ark-ui/react/dist/components/collapsible/collapsible-trigger.js
var import_jsx_runtime149 = __toESM(require_jsx_runtime(), 1);
var import_react329 = __toESM(require_react(), 1);
var CollapsibleTrigger = (0, import_react329.forwardRef)(
  (props21, ref2) => {
    const collapsible = useCollapsibleContext();
    const mergedProps = mergeProps(collapsible.getTriggerProps(), props21);
    return (0, import_jsx_runtime149.jsx)(ark.button, { ...mergedProps, ref: ref2 });
  }
);
CollapsibleTrigger.displayName = "CollapsibleTrigger";

// node_modules/@ark-ui/react/dist/components/collapsible/collapsible.js
var collapsible_exports = {};
__export(collapsible_exports, {
  Content: () => CollapsibleContent,
  Context: () => CollapsibleContext,
  Root: () => CollapsibleRoot,
  RootProvider: () => CollapsibleRootProvider,
  Trigger: () => CollapsibleTrigger
});

// node_modules/@ark-ui/react/dist/components/color-picker/color-picker-area.js
var import_jsx_runtime150 = __toESM(require_jsx_runtime(), 1);
var import_react331 = __toESM(require_react(), 1);

// node_modules/@ark-ui/react/dist/components/color-picker/use-color-picker-area-props-context.js
var [ColorPickerAreaPropsProvider, useColorPickerAreaPropsContext] = createContext({
  name: "ColorPickerAreaContext",
  hookName: "useColorPickerAreaContext",
  providerName: "<ColorPickerAreaProvider />"
});

// node_modules/@ark-ui/react/dist/components/color-picker/use-color-picker-context.js
var [ColorPickerProvider, useColorPickerContext] = createContext({
  name: "ColorPickerContext",
  hookName: "useColorPickerContext",
  providerName: "<ColorPickerProvider />"
});

// node_modules/@ark-ui/react/dist/components/color-picker/color-picker-area.js
var ColorPickerArea = (0, import_react331.forwardRef)((props21, ref2) => {
  const [areaProps, localProps] = createSplitProps2()(props21, ["xChannel", "yChannel"]);
  const colorPicker = useColorPickerContext();
  const mergedProps = mergeProps(colorPicker.getAreaProps(areaProps), localProps);
  return (0, import_jsx_runtime150.jsx)(ColorPickerAreaPropsProvider, { value: areaProps, children: (0, import_jsx_runtime150.jsx)(ark.div, { ...mergedProps, ref: ref2 }) });
});
ColorPickerArea.displayName = "ColorPickerArea";

// node_modules/@ark-ui/react/dist/components/color-picker/color-picker-area-background.js
var import_jsx_runtime151 = __toESM(require_jsx_runtime(), 1);
var import_react333 = __toESM(require_react(), 1);
var ColorPickerAreaBackground = (0, import_react333.forwardRef)(
  (props21, ref2) => {
    const colorPicker = useColorPickerContext();
    const areaProps = useColorPickerAreaPropsContext();
    const mergedProps = mergeProps(colorPicker.getAreaBackgroundProps(areaProps), props21);
    return (0, import_jsx_runtime151.jsx)(ark.div, { ...mergedProps, ref: ref2 });
  }
);
ColorPickerAreaBackground.displayName = "ColorPickerAreaBackground";

// node_modules/@ark-ui/react/dist/components/color-picker/color-picker-area-thumb.js
var import_jsx_runtime152 = __toESM(require_jsx_runtime(), 1);
var import_react335 = __toESM(require_react(), 1);
var ColorPickerAreaThumb = (0, import_react335.forwardRef)(
  (props21, ref2) => {
    const colorPicker = useColorPickerContext();
    const areaProps = useColorPickerAreaPropsContext();
    const mergedProps = mergeProps(colorPicker.getAreaThumbProps(areaProps), props21);
    return (0, import_jsx_runtime152.jsx)(ark.div, { ...mergedProps, ref: ref2 });
  }
);
ColorPickerAreaThumb.displayName = "ColorPickerAreaThumb";

// node_modules/@ark-ui/react/dist/components/color-picker/color-picker-channel-input.js
var import_jsx_runtime153 = __toESM(require_jsx_runtime(), 1);
var import_react337 = __toESM(require_react(), 1);
var ColorPickerChannelInput = (0, import_react337.forwardRef)(
  (props21, ref2) => {
    const [channelProps, localProps] = createSplitProps2()(props21, [
      "channel",
      "orientation"
    ]);
    const colorPicker = useColorPickerContext();
    const mergedProps = mergeProps(colorPicker.getChannelInputProps(channelProps), localProps);
    return (0, import_jsx_runtime153.jsx)(ark.input, { ...mergedProps, ref: ref2 });
  }
);
ColorPickerChannelInput.displayName = "ColorPickerChannelInput";

// node_modules/@ark-ui/react/dist/components/color-picker/color-picker-channel-slider.js
var import_jsx_runtime154 = __toESM(require_jsx_runtime(), 1);
var import_react339 = __toESM(require_react(), 1);

// node_modules/@ark-ui/react/dist/components/color-picker/use-color-picker-channel-props-context.js
var [ColorPickerChannelPropsProvider, useColorPickerChannelPropsContext] = createContext({
  name: "ColorPickerChannelSliderContext",
  hookName: "useColorPickerChannelSliderContext",
  providerName: "<ColorPickerChannelSliderProvider />"
});

// node_modules/@ark-ui/react/dist/components/color-picker/use-color-picker-format-context.js
var [ColorPickerFormatPropsProvider, useColorPickerFormatPropsContext] = createContext({
  name: "ColorPickerFormatContext",
  hookName: "useColorPickerFormatPropsContext",
  providerName: "<ColorPickerFormatPropsProvider />",
  strict: false
});

// node_modules/@ark-ui/react/dist/components/color-picker/color-picker-channel-slider.js
var ColorPickerChannelSlider = (0, import_react339.forwardRef)(
  (props21, ref2) => {
    const [channelProps, localProps] = createSplitProps2()(props21, [
      "channel",
      "orientation"
    ]);
    const colorPicker = useColorPickerContext();
    const formatProps = useColorPickerFormatPropsContext();
    const channelSliderProps = { ...channelProps, ...formatProps };
    const mergedProps = mergeProps(
      colorPicker.getChannelSliderProps(channelSliderProps),
      localProps
    );
    return (0, import_jsx_runtime154.jsx)(ColorPickerChannelPropsProvider, { value: channelProps, children: (0, import_jsx_runtime154.jsx)(ark.div, { ...mergedProps, ref: ref2 }) });
  }
);
ColorPickerChannelSlider.displayName = "ColorPickerChannelSlider";

// node_modules/@ark-ui/react/dist/components/color-picker/color-picker-channel-slider-label.js
var import_jsx_runtime155 = __toESM(require_jsx_runtime(), 1);
var import_react341 = __toESM(require_react(), 1);
var ColorPickerChannelSliderLabel = (0, import_react341.forwardRef)((props21, ref2) => {
  const colorPicker = useColorPickerContext();
  const channelProps = useColorPickerChannelPropsContext();
  const mergedProps = mergeProps(colorPicker.getChannelSliderLabelProps(channelProps), props21);
  return (0, import_jsx_runtime155.jsx)(ark.label, { ...mergedProps, ref: ref2 });
});
ColorPickerChannelSliderLabel.displayName = "ColorPickerChannelSliderLabel";

// node_modules/@ark-ui/react/dist/components/color-picker/color-picker-channel-slider-thumb.js
var import_jsx_runtime156 = __toESM(require_jsx_runtime(), 1);
var import_react343 = __toESM(require_react(), 1);
var ColorPickerChannelSliderThumb = (0, import_react343.forwardRef)((props21, ref2) => {
  const colorPicker = useColorPickerContext();
  const channelProps = useColorPickerChannelPropsContext();
  const formatProps = useColorPickerFormatPropsContext();
  const channelSliderProps = { ...channelProps, ...formatProps };
  const mergedProps = mergeProps(colorPicker.getChannelSliderThumbProps(channelSliderProps), props21);
  return (0, import_jsx_runtime156.jsx)(ark.div, { ...mergedProps, ref: ref2 });
});
ColorPickerChannelSliderThumb.displayName = "ColorPickerChannelSliderThumb";

// node_modules/@ark-ui/react/dist/components/color-picker/color-picker-channel-slider-track.js
var import_jsx_runtime157 = __toESM(require_jsx_runtime(), 1);
var import_react345 = __toESM(require_react(), 1);
var ColorPickerChannelSliderTrack = (0, import_react345.forwardRef)((props21, ref2) => {
  const colorPicker = useColorPickerContext();
  const channelProps = useColorPickerChannelPropsContext();
  const formatProps = useColorPickerFormatPropsContext();
  const channelSliderProps = { ...channelProps, ...formatProps };
  const mergedProps = mergeProps(colorPicker.getChannelSliderTrackProps(channelSliderProps), props21);
  return (0, import_jsx_runtime157.jsx)(ark.div, { ...mergedProps, ref: ref2 });
});
ColorPickerChannelSliderTrack.displayName = "ColorPickerChannelSliderTrack";

// node_modules/@ark-ui/react/dist/components/color-picker/color-picker-channel-slider-value-text.js
var import_jsx_runtime158 = __toESM(require_jsx_runtime(), 1);
var import_react347 = __toESM(require_react(), 1);
var ColorPickerChannelSliderValueText = (0, import_react347.forwardRef)((props21, ref2) => {
  const { locale } = useLocaleContext();
  const colorPicker = useColorPickerContext();
  const channelProps = useColorPickerChannelPropsContext();
  const mergedProps = mergeProps(colorPicker.getChannelSliderValueTextProps(channelProps), props21);
  return (0, import_jsx_runtime158.jsx)(ark.span, { ...mergedProps, ref: ref2, children: props21.children || colorPicker.getChannelValueText(channelProps.channel, locale) });
});
ColorPickerChannelSliderValueText.displayName = "ColorPickerChannelSliderValueText";

// node_modules/@ark-ui/react/dist/components/color-picker/color-picker-content.js
var import_jsx_runtime159 = __toESM(require_jsx_runtime(), 1);
var import_react349 = __toESM(require_react(), 1);
var ColorPickerContent = (0, import_react349.forwardRef)(
  (props21, ref2) => {
    const colorPicker = useColorPickerContext();
    const presence = usePresenceContext();
    const mergedProps = mergeProps(
      colorPicker.getContentProps(),
      presence.getPresenceProps(),
      props21
    );
    if (presence.unmounted) {
      return null;
    }
    return (0, import_jsx_runtime159.jsx)(ark.div, { ...mergedProps, ref: composeRefs(presence.ref, ref2) });
  }
);
ColorPickerContent.displayName = "ColorPickerContent";

// node_modules/@ark-ui/react/dist/components/color-picker/color-picker-context.js
var ColorPickerContext = (props21) => props21.children(useColorPickerContext());

// node_modules/@ark-ui/react/dist/components/color-picker/color-picker-control.js
var import_jsx_runtime160 = __toESM(require_jsx_runtime(), 1);
var import_react351 = __toESM(require_react(), 1);
var ColorPickerControl = (0, import_react351.forwardRef)(
  (props21, ref2) => {
    const colorPicker = useColorPickerContext();
    const mergedProps = mergeProps(colorPicker.getControlProps(), props21);
    return (0, import_jsx_runtime160.jsx)(ark.div, { ...mergedProps, ref: ref2 });
  }
);
ColorPickerControl.displayName = "ColorPickerControl";

// node_modules/@ark-ui/react/dist/components/color-picker/color-picker-eye-dropper-trigger.js
var import_jsx_runtime161 = __toESM(require_jsx_runtime(), 1);
var import_react353 = __toESM(require_react(), 1);
var ColorPickerEyeDropperTrigger = (0, import_react353.forwardRef)((props21, ref2) => {
  const colorPicker = useColorPickerContext();
  const mergedProps = mergeProps(colorPicker.getEyeDropperTriggerProps(), props21);
  return (0, import_jsx_runtime161.jsx)(ark.button, { ...mergedProps, ref: ref2 });
});
ColorPickerEyeDropperTrigger.displayName = "ColorPickerEyeDropperTrigger";

// node_modules/@ark-ui/react/dist/components/color-picker/color-picker-format-select.js
var import_jsx_runtime162 = __toESM(require_jsx_runtime(), 1);
var import_react355 = __toESM(require_react(), 1);
var ColorPickerFormatSelect = (0, import_react355.forwardRef)(
  (props21, ref2) => {
    const colorPicker = useColorPickerContext();
    const mergedProps = mergeProps(colorPicker.getFormatSelectProps(), props21);
    return (0, import_jsx_runtime162.jsx)(ark.select, { ...mergedProps, ref: ref2, children: ["rgba", "hsla", "hsba"].map((format) => (0, import_jsx_runtime162.jsx)(ark.option, { value: format, children: format }, format)) });
  }
);
ColorPickerFormatSelect.displayName = "ColorPickerFormatSelect";

// node_modules/@ark-ui/react/dist/components/color-picker/color-picker-format-trigger.js
var import_jsx_runtime163 = __toESM(require_jsx_runtime(), 1);
var import_react357 = __toESM(require_react(), 1);
var ColorPickerFormatTrigger = (0, import_react357.forwardRef)((props21, ref2) => {
  const colorPicker = useColorPickerContext();
  const mergedProps = mergeProps(colorPicker.getFormatTriggerProps(), props21);
  return (0, import_jsx_runtime163.jsx)(ark.button, { ...mergedProps, ref: ref2 });
});
ColorPickerFormatTrigger.displayName = "ColorPickerFormatTrigger";

// node_modules/@ark-ui/react/dist/components/color-picker/color-picker-hidden-input.js
var import_jsx_runtime164 = __toESM(require_jsx_runtime(), 1);
var import_react359 = __toESM(require_react(), 1);
var ColorPickerHiddenInput = (0, import_react359.forwardRef)(
  (props21, ref2) => {
    const colorPicker = useColorPickerContext();
    const mergedProps = mergeProps(colorPicker.getHiddenInputProps(), props21);
    const field = useFieldContext();
    return (0, import_jsx_runtime164.jsx)(ark.input, { "aria-describedby": field == null ? void 0 : field.ariaDescribedby, ...mergedProps, ref: ref2 });
  }
);
ColorPickerHiddenInput.displayName = "ColorPickerHiddenInput";

// node_modules/@ark-ui/react/dist/components/color-picker/color-picker-label.js
var import_jsx_runtime165 = __toESM(require_jsx_runtime(), 1);
var import_react361 = __toESM(require_react(), 1);
var ColorPickerLabel = (0, import_react361.forwardRef)(
  (props21, ref2) => {
    const colorPicker = useColorPickerContext();
    const mergedProps = mergeProps(colorPicker.getLabelProps(), props21);
    return (0, import_jsx_runtime165.jsx)(ark.label, { ...mergedProps, ref: ref2 });
  }
);
ColorPickerLabel.displayName = "ColorPickerLabel";

// node_modules/@ark-ui/react/dist/components/color-picker/color-picker-positioner.js
var import_jsx_runtime166 = __toESM(require_jsx_runtime(), 1);
var import_react363 = __toESM(require_react(), 1);
var ColorPickerPositioner = (0, import_react363.forwardRef)(
  (props21, ref2) => {
    const colorPicker = useColorPickerContext();
    const mergedProps = mergeProps(colorPicker.getPositionerProps(), props21);
    const presence = usePresenceContext();
    if (presence.unmounted) {
      return null;
    }
    return (0, import_jsx_runtime166.jsx)(ark.div, { ...mergedProps, ref: ref2 });
  }
);
ColorPickerPositioner.displayName = "ColorPickerPositioner";

// node_modules/@ark-ui/react/dist/components/color-picker/color-picker-root.js
var import_jsx_runtime167 = __toESM(require_jsx_runtime(), 1);
var import_react367 = __toESM(require_react(), 1);

// node_modules/@ark-ui/react/dist/components/color-picker/use-color-picker.js
var import_react365 = __toESM(require_react(), 1);
var useColorPicker = (props21 = {}) => {
  const { getRootNode } = useEnvironmentContext();
  const { dir } = useLocaleContext();
  const field = useFieldContext();
  const initialContext = {
    id: (0, import_react365.useId)(),
    ids: {
      label: field == null ? void 0 : field.ids.label,
      input: field == null ? void 0 : field.ids.control
    },
    dir,
    disabled: field == null ? void 0 : field.disabled,
    invalid: field == null ? void 0 : field.invalid,
    readOnly: field == null ? void 0 : field.readOnly,
    required: field == null ? void 0 : field.required,
    getRootNode,
    open: props21.defaultOpen,
    "open.controlled": props21.open !== void 0,
    value: props21.defaultValue,
    ...props21
  };
  const context = {
    ...initialContext,
    value: props21.value,
    onValueChange: useEvent(props21.onValueChange, { sync: true }),
    onValueChangeEnd: useEvent(props21.onValueChangeEnd)
  };
  const [state2, send] = useMachine(machine3(initialContext), { context });
  return connect3(state2, send, normalizeProps);
};

// node_modules/@ark-ui/react/dist/components/color-picker/color-picker-root.js
var ColorPickerRoot = (0, import_react367.forwardRef)((props21, ref2) => {
  const [presenceProps, colorPickerProps] = splitPresenceProps(props21);
  const [useColorPickerProps, localProps] = createSplitProps2()(
    colorPickerProps,
    [
      "closeOnSelect",
      "defaultOpen",
      "defaultValue",
      "disabled",
      "format",
      "id",
      "ids",
      "initialFocusEl",
      "invalid",
      "name",
      "name",
      "onFocusOutside",
      "onFormatChange",
      "onInteractOutside",
      "onOpenChange",
      "onPointerDownOutside",
      "onValueChange",
      "onValueChangeEnd",
      "open",
      "openAutoFocus",
      "positioning",
      "readOnly",
      "required",
      "value"
    ]
  );
  const colorPicker = useColorPicker(useColorPickerProps);
  const presence = usePresence(mergeProps({ present: colorPicker.open }, presenceProps));
  const mergedProps = mergeProps(colorPicker.getRootProps(), localProps);
  return (0, import_jsx_runtime167.jsx)(ColorPickerProvider, { value: colorPicker, children: (0, import_jsx_runtime167.jsx)(PresenceProvider, { value: presence, children: (0, import_jsx_runtime167.jsx)(ark.div, { ...mergedProps, ref: ref2 }) }) });
});
ColorPickerRoot.displayName = "ColorPickerRoot";

// node_modules/@ark-ui/react/dist/components/color-picker/color-picker-root-provider.js
var import_jsx_runtime168 = __toESM(require_jsx_runtime(), 1);
var import_react369 = __toESM(require_react(), 1);
var ColorPickerRootProvider = (0, import_react369.forwardRef)(
  (props21, ref2) => {
    const [presenceProps, colorPickerProps] = splitPresenceProps(props21);
    const [{ value: colorPicker }, localProps] = createSplitProps2()(
      colorPickerProps,
      ["value"]
    );
    const presence = usePresence(mergeProps({ present: colorPicker.open }, presenceProps));
    const mergedProps = mergeProps(colorPicker.getRootProps(), localProps);
    return (0, import_jsx_runtime168.jsx)(ColorPickerProvider, { value: colorPicker, children: (0, import_jsx_runtime168.jsx)(PresenceProvider, { value: presence, children: (0, import_jsx_runtime168.jsx)(ark.div, { ...mergedProps, ref: ref2 }) }) });
  }
);
ColorPickerRootProvider.displayName = "ColorPickerRootProvider";

// node_modules/@ark-ui/react/dist/components/color-picker/color-picker-swatch.js
var import_jsx_runtime169 = __toESM(require_jsx_runtime(), 1);
var import_react371 = __toESM(require_react(), 1);

// node_modules/@ark-ui/react/dist/components/color-picker/use-color-picker-swatch-props-context.js
var [ColorPickerSwatchPropsProvider, useColorPickerSwatchPropsContext] = createContext({
  name: "ColorPickerSwatchContext",
  hookName: "useColorPickerSwatchContext",
  providerName: "<ColorPickerSwatchProvider />"
});

// node_modules/@ark-ui/react/dist/components/color-picker/color-picker-swatch.js
var ColorPickerSwatch = (0, import_react371.forwardRef)(
  (props21, ref2) => {
    const [swatwchProps, localProps] = createSplitProps2()(props21, [
      "respectAlpha",
      "value"
    ]);
    const colorPicker = useColorPickerContext();
    const mergedProps = mergeProps(colorPicker.getSwatchProps(swatwchProps), localProps);
    return (0, import_jsx_runtime169.jsx)(ColorPickerSwatchPropsProvider, { value: swatwchProps, children: (0, import_jsx_runtime169.jsx)(ark.div, { ...mergedProps, ref: ref2 }) });
  }
);
ColorPickerSwatch.displayName = "ColorPickerSwatch";

// node_modules/@ark-ui/react/dist/components/color-picker/color-picker-swatch-group.js
var import_jsx_runtime170 = __toESM(require_jsx_runtime(), 1);
var import_react373 = __toESM(require_react(), 1);
var ColorPickerSwatchGroup = (0, import_react373.forwardRef)(
  (props21, ref2) => {
    const colorPicker = useColorPickerContext();
    const mergedProps = mergeProps(colorPicker.getSwatchGroupProps(), props21);
    return (0, import_jsx_runtime170.jsx)(ark.div, { ...mergedProps, ref: ref2 });
  }
);
ColorPickerSwatchGroup.displayName = "ColorPickerSwatchGroup";

// node_modules/@ark-ui/react/dist/components/color-picker/color-picker-swatch-indicator.js
var import_jsx_runtime171 = __toESM(require_jsx_runtime(), 1);
var import_react375 = __toESM(require_react(), 1);
var ColorPickerSwatchIndicator = (0, import_react375.forwardRef)((props21, ref2) => {
  const colorPicker = useColorPickerContext();
  const swatchProps = useColorPickerSwatchPropsContext();
  const mergedProps = mergeProps(colorPicker.getSwatchIndicatorProps(swatchProps), props21);
  return (0, import_jsx_runtime171.jsx)(ark.div, { ...mergedProps, ref: ref2 });
});
ColorPickerSwatchIndicator.displayName = "ColorPickerSwatchIndicator";

// node_modules/@ark-ui/react/dist/components/color-picker/color-picker-swatch-trigger.js
var import_jsx_runtime172 = __toESM(require_jsx_runtime(), 1);
var import_react377 = __toESM(require_react(), 1);
var ColorPickerSwatchTrigger = (0, import_react377.forwardRef)((props21, ref2) => {
  const [triggerProps, localProps] = createSplitProps2()(props21, [
    "value",
    "disabled"
  ]);
  const colorPicker = useColorPickerContext();
  const mergedProps = mergeProps(colorPicker.getSwatchTriggerProps(triggerProps), localProps);
  return (0, import_jsx_runtime172.jsx)(ark.button, { ...mergedProps, ref: ref2 });
});
ColorPickerSwatchTrigger.displayName = "ColorPickerSwatchTrigger";

// node_modules/@ark-ui/react/dist/components/color-picker/color-picker-transparency-grid.js
var import_jsx_runtime173 = __toESM(require_jsx_runtime(), 1);
var import_react379 = __toESM(require_react(), 1);
var ColorPickerTransparencyGrid = (0, import_react379.forwardRef)((props21, ref2) => {
  const [gridProps, localProps] = createSplitProps2()(props21, ["size"]);
  const colorPicker = useColorPickerContext();
  const mergedProps = mergeProps(colorPicker.getTransparencyGridProps(gridProps), localProps);
  return (0, import_jsx_runtime173.jsx)(ark.div, { ...mergedProps, ref: ref2 });
});
ColorPickerTransparencyGrid.displayName = "ColorPickerTransparencyGrid";

// node_modules/@ark-ui/react/dist/components/color-picker/color-picker-trigger.js
var import_jsx_runtime174 = __toESM(require_jsx_runtime(), 1);
var import_react381 = __toESM(require_react(), 1);
var ColorPickerTrigger = (0, import_react381.forwardRef)(
  (props21, ref2) => {
    const colorPicker = useColorPickerContext();
    const mergedProps = mergeProps(colorPicker.getTriggerProps(), props21);
    return (0, import_jsx_runtime174.jsx)(ark.button, { ...mergedProps, ref: ref2 });
  }
);
ColorPickerTrigger.displayName = "ColorPickerTrigger";

// node_modules/@ark-ui/react/dist/components/color-picker/color-picker-value-swatch.js
var import_jsx_runtime175 = __toESM(require_jsx_runtime(), 1);
var import_react383 = __toESM(require_react(), 1);
var ColorPickerValueSwatch = (0, import_react383.forwardRef)(
  (props21, ref2) => {
    const [{ respectAlpha }, localProps] = createSplitProps2()(props21, [
      "respectAlpha"
    ]);
    const colorPicker = useColorPickerContext();
    const swatchProps = {
      respectAlpha,
      value: colorPicker.valueAsString
    };
    const mergedProps = mergeProps(colorPicker.getSwatchProps(swatchProps), localProps);
    return (0, import_jsx_runtime175.jsx)(ColorPickerSwatchPropsProvider, { value: swatchProps, children: (0, import_jsx_runtime175.jsx)(ark.div, { ...mergedProps, ref: ref2 }) });
  }
);
ColorPickerValueSwatch.displayName = "ColorPickerValueSwatch";

// node_modules/@ark-ui/react/dist/components/color-picker/color-picker-value-text.js
var import_jsx_runtime176 = __toESM(require_jsx_runtime(), 1);
var import_react385 = __toESM(require_react(), 1);
var ColorPickerValueText = (0, import_react385.forwardRef)(
  (props21, ref2) => {
    const { children, ...localprops } = props21;
    const colorPicker = useColorPickerContext();
    const mergedProps = mergeProps(colorPicker.getValueTextProps(), localprops);
    return (0, import_jsx_runtime176.jsx)(ark.span, { ...mergedProps, ref: ref2, children: props21.children || colorPicker.valueAsString });
  }
);
ColorPickerValueText.displayName = "ColorPickerValueText";

// node_modules/@ark-ui/react/dist/components/color-picker/color-picker-view.js
var import_jsx_runtime177 = __toESM(require_jsx_runtime(), 1);
var import_react386 = __toESM(require_react(), 1);

// node_modules/@ark-ui/react/dist/components/color-picker/color-picker.anatomy.js
var colorPickerAnatomy = anatomy3.extendWith("view");

// node_modules/@ark-ui/react/dist/components/color-picker/color-picker-view.js
var ColorPickerView = (0, import_react386.forwardRef)((props21, ref2) => {
  const colorPicker = useColorPickerContext();
  const [formatProps, restProps] = createSplitProps2()(props21, ["format"]);
  if (colorPicker.format !== formatProps.format) {
    return null;
  }
  return (0, import_jsx_runtime177.jsx)(ColorPickerFormatPropsProvider, { value: formatProps, children: (0, import_jsx_runtime177.jsx)(
    ark.div,
    {
      ref: ref2,
      "data-format": props21.format,
      ...colorPickerAnatomy.build().view.attrs,
      ...restProps
    }
  ) });
});
ColorPickerView.displayName = "ColorPickerView";

// node_modules/@ark-ui/react/dist/components/color-picker/color-picker.js
var color_picker_exports = {};
__export(color_picker_exports, {
  Area: () => ColorPickerArea,
  AreaBackground: () => ColorPickerAreaBackground,
  AreaThumb: () => ColorPickerAreaThumb,
  ChannelInput: () => ColorPickerChannelInput,
  ChannelSlider: () => ColorPickerChannelSlider,
  ChannelSliderLabel: () => ColorPickerChannelSliderLabel,
  ChannelSliderThumb: () => ColorPickerChannelSliderThumb,
  ChannelSliderTrack: () => ColorPickerChannelSliderTrack,
  ChannelSliderValueText: () => ColorPickerChannelSliderValueText,
  Content: () => ColorPickerContent,
  Context: () => ColorPickerContext,
  Control: () => ColorPickerControl,
  EyeDropperTrigger: () => ColorPickerEyeDropperTrigger,
  FormatSelect: () => ColorPickerFormatSelect,
  FormatTrigger: () => ColorPickerFormatTrigger,
  HiddenInput: () => ColorPickerHiddenInput,
  Label: () => ColorPickerLabel,
  Positioner: () => ColorPickerPositioner,
  Root: () => ColorPickerRoot,
  RootProvider: () => ColorPickerRootProvider,
  Swatch: () => ColorPickerSwatch,
  SwatchGroup: () => ColorPickerSwatchGroup,
  SwatchIndicator: () => ColorPickerSwatchIndicator,
  SwatchTrigger: () => ColorPickerSwatchTrigger,
  TransparencyGrid: () => ColorPickerTransparencyGrid,
  Trigger: () => ColorPickerTrigger,
  ValueSwatch: () => ColorPickerValueSwatch,
  ValueText: () => ColorPickerValueText,
  View: () => ColorPickerView
});

// node_modules/@ark-ui/react/dist/components/hover-card/hover-card-arrow.js
var import_jsx_runtime178 = __toESM(require_jsx_runtime(), 1);
var import_react388 = __toESM(require_react(), 1);

// node_modules/@ark-ui/react/dist/components/hover-card/use-hover-card-context.js
var [HoverCardProvider, useHoverCardContext] = createContext({
  name: "HoverCardContext",
  hookName: "useHoverCardContext",
  providerName: "<HoverCardProvider />"
});

// node_modules/@ark-ui/react/dist/components/hover-card/hover-card-arrow.js
var HoverCardArrow = (0, import_react388.forwardRef)((props21, ref2) => {
  const hoverCard = useHoverCardContext();
  const mergedProps = mergeProps(hoverCard.getArrowProps(), props21);
  return (0, import_jsx_runtime178.jsx)(ark.div, { ...mergedProps, ref: ref2 });
});
HoverCardArrow.displayName = "HoverCardArrow";

// node_modules/@ark-ui/react/dist/components/hover-card/hover-card-arrow-tip.js
var import_jsx_runtime179 = __toESM(require_jsx_runtime(), 1);
var import_react390 = __toESM(require_react(), 1);
var HoverCardArrowTip = (0, import_react390.forwardRef)(
  (props21, ref2) => {
    const hoverCard = useHoverCardContext();
    const mergedProps = mergeProps(hoverCard.getArrowTipProps(), props21);
    return (0, import_jsx_runtime179.jsx)(ark.div, { ...mergedProps, ref: ref2 });
  }
);
HoverCardArrowTip.displayName = "HoverCardArrowTip";

// node_modules/@ark-ui/react/dist/components/hover-card/hover-card-content.js
var import_jsx_runtime180 = __toESM(require_jsx_runtime(), 1);
var import_react392 = __toESM(require_react(), 1);
var HoverCardContent = (0, import_react392.forwardRef)((props21, ref2) => {
  const hoverCard = useHoverCardContext();
  const presence = usePresenceContext();
  const mergedProps = mergeProps(hoverCard.getContentProps(), presence.getPresenceProps(), props21);
  if (presence.unmounted) {
    return null;
  }
  return (0, import_jsx_runtime180.jsx)(ark.div, { ...mergedProps, ref: composeRefs(presence.ref, ref2) });
});
HoverCardContent.displayName = "HoverCardContent";

// node_modules/@ark-ui/react/dist/components/hover-card/hover-card-context.js
var HoverCardContext = (props21) => props21.children(useHoverCardContext());

// node_modules/@ark-ui/react/dist/components/hover-card/hover-card-positioner.js
var import_jsx_runtime181 = __toESM(require_jsx_runtime(), 1);
var import_react394 = __toESM(require_react(), 1);
var HoverCardPositioner = (0, import_react394.forwardRef)(
  (props21, ref2) => {
    const hoverCard = useHoverCardContext();
    const mergedProps = mergeProps(hoverCard.getPositionerProps(), props21);
    const presence = usePresenceContext();
    if (presence.unmounted) {
      return null;
    }
    return (0, import_jsx_runtime181.jsx)(ark.div, { ...mergedProps, ref: ref2 });
  }
);
HoverCardPositioner.displayName = "HoverCardPositioner";

// node_modules/@ark-ui/react/dist/components/hover-card/hover-card-root.js
var import_jsx_runtime182 = __toESM(require_jsx_runtime(), 1);

// node_modules/@zag-js/hover-card/dist/index.mjs
var anatomy17 = createAnatomy("hoverCard").parts("arrow", "arrowTip", "trigger", "positioner", "content");
var parts19 = anatomy17.build();
var dom17 = createScope({
  getTriggerId: (ctx) => {
    var _a8;
    return ((_a8 = ctx.ids) == null ? void 0 : _a8.trigger) ?? `hover-card:${ctx.id}:trigger`;
  },
  getContentId: (ctx) => {
    var _a8;
    return ((_a8 = ctx.ids) == null ? void 0 : _a8.content) ?? `hover-card:${ctx.id}:content`;
  },
  getPositionerId: (ctx) => {
    var _a8;
    return ((_a8 = ctx.ids) == null ? void 0 : _a8.positioner) ?? `hover-card:${ctx.id}:popper`;
  },
  getArrowId: (ctx) => {
    var _a8;
    return ((_a8 = ctx.ids) == null ? void 0 : _a8.arrow) ?? `hover-card:${ctx.id}:arrow`;
  },
  getTriggerEl: (ctx) => dom17.getById(ctx, dom17.getTriggerId(ctx)),
  getContentEl: (ctx) => dom17.getById(ctx, dom17.getContentId(ctx)),
  getPositionerEl: (ctx) => dom17.getById(ctx, dom17.getPositionerId(ctx))
});
function connect18(state2, send, normalize2) {
  const open = state2.hasTag("open");
  const popperStyles = getPlacementStyles({
    ...state2.context.positioning,
    placement: state2.context.currentPlacement
  });
  return {
    open,
    setOpen(nextOpen) {
      if (nextOpen === open) return;
      send(nextOpen ? "OPEN" : "CLOSE");
    },
    reposition(options = {}) {
      send({ type: "POSITIONING.SET", options });
    },
    getArrowProps() {
      return normalize2.element({
        id: dom17.getArrowId(state2.context),
        ...parts19.arrow.attrs,
        dir: state2.context.dir,
        style: popperStyles.arrow
      });
    },
    getArrowTipProps() {
      return normalize2.element({
        ...parts19.arrowTip.attrs,
        dir: state2.context.dir,
        style: popperStyles.arrowTip
      });
    },
    getTriggerProps() {
      return normalize2.element({
        ...parts19.trigger.attrs,
        dir: state2.context.dir,
        "data-placement": state2.context.currentPlacement,
        id: dom17.getTriggerId(state2.context),
        "data-state": open ? "open" : "closed",
        onPointerEnter(event) {
          if (event.pointerType === "touch") return;
          send({ type: "POINTER_ENTER", src: "trigger" });
        },
        onPointerLeave(event) {
          if (event.pointerType === "touch") return;
          send({ type: "POINTER_LEAVE", src: "trigger" });
        },
        onFocus() {
          send("TRIGGER_FOCUS");
        },
        onBlur() {
          send("TRIGGER_BLUR");
        }
      });
    },
    getPositionerProps() {
      return normalize2.element({
        id: dom17.getPositionerId(state2.context),
        ...parts19.positioner.attrs,
        dir: state2.context.dir,
        style: popperStyles.floating
      });
    },
    getContentProps() {
      return normalize2.element({
        ...parts19.content.attrs,
        dir: state2.context.dir,
        id: dom17.getContentId(state2.context),
        hidden: !open,
        "data-state": open ? "open" : "closed",
        "data-placement": state2.context.currentPlacement,
        onPointerEnter(event) {
          if (event.pointerType === "touch") return;
          send({ type: "POINTER_ENTER", src: "content" });
        },
        onPointerLeave(event) {
          if (event.pointerType === "touch") return;
          send({ type: "POINTER_LEAVE", src: "content" });
        }
      });
    }
  };
}
var { not: not8, and: and7 } = guards;
function machine18(userContext) {
  const ctx = compact2(userContext);
  return createMachine(
    {
      id: "hover-card",
      initial: ctx.open ? "open" : "closed",
      context: {
        openDelay: 700,
        closeDelay: 300,
        currentPlacement: void 0,
        ...ctx,
        positioning: {
          placement: "bottom",
          ...ctx.positioning
        }
      },
      watch: {
        open: ["toggleVisibility"]
      },
      states: {
        closed: {
          tags: ["closed"],
          entry: ["clearIsPointer"],
          on: {
            "CONTROLLED.OPEN": "open",
            POINTER_ENTER: {
              target: "opening",
              actions: ["setIsPointer"]
            },
            TRIGGER_FOCUS: "opening",
            OPEN: "opening"
          }
        },
        opening: {
          tags: ["closed"],
          after: {
            OPEN_DELAY: [
              {
                guard: "isOpenControlled",
                actions: ["invokeOnOpen"]
              },
              {
                target: "open",
                actions: ["invokeOnOpen"]
              }
            ]
          },
          on: {
            "CONTROLLED.OPEN": "open",
            "CONTROLLED.CLOSE": "closed",
            POINTER_LEAVE: [
              {
                guard: "isOpenControlled",
                // We trigger toggleVisibility manually since the `ctx.open` has not changed yet (at this point)
                actions: ["invokeOnClose", "toggleVisibility"]
              },
              {
                target: "closed",
                actions: ["invokeOnClose"]
              }
            ],
            TRIGGER_BLUR: [
              {
                guard: and7("isOpenControlled", not8("isPointer")),
                // We trigger toggleVisibility manually since the `ctx.open` has not changed yet (at this point)
                actions: ["invokeOnClose", "toggleVisibility"]
              },
              {
                guard: not8("isPointer"),
                target: "closed",
                actions: ["invokeOnClose"]
              }
            ],
            CLOSE: [
              {
                guard: "isOpenControlled",
                // We trigger toggleVisibility manually since the `ctx.open` has not changed yet (at this point)
                actions: ["invokeOnClose", "toggleVisibility"]
              },
              {
                target: "closed",
                actions: ["invokeOnClose"]
              }
            ]
          }
        },
        open: {
          tags: ["open"],
          activities: ["trackDismissableElement", "trackPositioning"],
          on: {
            "CONTROLLED.CLOSE": "closed",
            POINTER_ENTER: {
              actions: ["setIsPointer"]
            },
            POINTER_LEAVE: "closing",
            CLOSE: [
              {
                guard: "isOpenControlled",
                actions: ["invokeOnClose"]
              },
              {
                target: "closed",
                actions: ["invokeOnClose"]
              }
            ],
            TRIGGER_BLUR: [
              {
                guard: and7("isOpenControlled", not8("isPointer")),
                actions: ["invokeOnClose"]
              },
              {
                guard: not8("isPointer"),
                target: "closed",
                actions: ["invokeOnClose"]
              }
            ],
            "POSITIONING.SET": {
              actions: "reposition"
            }
          }
        },
        closing: {
          tags: ["open"],
          activities: ["trackPositioning"],
          after: {
            CLOSE_DELAY: [
              {
                guard: "isOpenControlled",
                actions: ["invokeOnClose"]
              },
              {
                target: "closed",
                actions: ["invokeOnClose"]
              }
            ]
          },
          on: {
            "CONTROLLED.CLOSE": "closed",
            "CONTROLLED.OPEN": "open",
            POINTER_ENTER: {
              target: "open",
              // no need to invokeOnOpen here because it's still open (but about to close)
              actions: ["setIsPointer"]
            }
          }
        }
      }
    },
    {
      delays: {
        OPEN_DELAY: (ctx2) => ctx2.openDelay,
        CLOSE_DELAY: (ctx2) => ctx2.closeDelay
      },
      guards: {
        isPointer: (ctx2) => !!ctx2.isPointer,
        isOpenControlled: (ctx2) => !!ctx2["open.controlled"]
      },
      activities: {
        trackPositioning(ctx2) {
          ctx2.currentPlacement || (ctx2.currentPlacement = ctx2.positioning.placement);
          const getPositionerEl = () => dom17.getPositionerEl(ctx2);
          return getPlacement(dom17.getTriggerEl(ctx2), getPositionerEl, {
            ...ctx2.positioning,
            defer: true,
            onComplete(data) {
              ctx2.currentPlacement = data.placement;
            }
          });
        },
        trackDismissableElement(ctx2, _evt, { send }) {
          const getContentEl = () => dom17.getContentEl(ctx2);
          return trackDismissableElement(getContentEl, {
            defer: true,
            exclude: [dom17.getTriggerEl(ctx2)],
            onDismiss() {
              send({ type: "CLOSE", src: "interact-outside" });
            },
            onFocusOutside(event) {
              event.preventDefault();
            }
          });
        }
      },
      actions: {
        invokeOnClose(ctx2) {
          var _a8;
          (_a8 = ctx2.onOpenChange) == null ? void 0 : _a8.call(ctx2, { open: false });
        },
        invokeOnOpen(ctx2) {
          var _a8;
          (_a8 = ctx2.onOpenChange) == null ? void 0 : _a8.call(ctx2, { open: true });
        },
        setIsPointer(ctx2) {
          ctx2.isPointer = true;
        },
        clearIsPointer(ctx2) {
          ctx2.isPointer = false;
        },
        reposition(ctx2, evt) {
          const getPositionerEl = () => dom17.getPositionerEl(ctx2);
          getPlacement(dom17.getTriggerEl(ctx2), getPositionerEl, {
            ...ctx2.positioning,
            ...evt.options,
            defer: true,
            listeners: false,
            onComplete(data) {
              ctx2.currentPlacement = data.placement;
            }
          });
        },
        toggleVisibility(ctx2, evt, { send }) {
          queueMicrotask(() => {
            send({ type: ctx2.open ? "CONTROLLED.OPEN" : "CONTROLLED.CLOSE", previousEvent: evt });
          });
        }
      }
    }
  );
}
var props17 = createProps2()([
  "closeDelay",
  "dir",
  "getRootNode",
  "id",
  "ids",
  "onOpenChange",
  "open.controlled",
  "open",
  "openDelay",
  "positioning"
]);
var splitProps18 = createSplitProps(props17);

// node_modules/@ark-ui/react/dist/components/hover-card/use-hover-card.js
var import_react396 = __toESM(require_react(), 1);
var useHoverCard = (props21 = {}) => {
  const { getRootNode } = useEnvironmentContext();
  const { dir } = useLocaleContext();
  const initialContext = {
    id: (0, import_react396.useId)(),
    dir,
    getRootNode,
    open: props21.defaultOpen,
    "open.controlled": props21.open !== void 0,
    ...props21
  };
  const context = {
    ...initialContext,
    open: props21.open,
    onOpenChange: useEvent(props21.onOpenChange, { sync: true })
  };
  const [state2, send] = useMachine(machine18(initialContext), { context });
  return connect18(state2, send, normalizeProps);
};

// node_modules/@ark-ui/react/dist/components/hover-card/hover-card-root.js
var HoverCardRoot = (props21) => {
  const [presenceProps, { children, ...localProps }] = splitPresenceProps(props21);
  const hoverCard = useHoverCard(localProps);
  const presence = usePresence(mergeProps({ present: hoverCard.open }, presenceProps));
  return (0, import_jsx_runtime182.jsx)(HoverCardProvider, { value: hoverCard, children: (0, import_jsx_runtime182.jsx)(PresenceProvider, { value: presence, children }) });
};

// node_modules/@ark-ui/react/dist/components/hover-card/hover-card-root-provider.js
var import_jsx_runtime183 = __toESM(require_jsx_runtime(), 1);
var HoverCardRootProvider = (props21) => {
  const [presenceProps, { value: hoverCard, children }] = splitPresenceProps(props21);
  const presence = usePresence(mergeProps({ present: hoverCard.open }, presenceProps));
  return (0, import_jsx_runtime183.jsx)(HoverCardProvider, { value: hoverCard, children: (0, import_jsx_runtime183.jsx)(PresenceProvider, { value: presence, children }) });
};

// node_modules/@ark-ui/react/dist/components/hover-card/hover-card-trigger.js
var import_jsx_runtime184 = __toESM(require_jsx_runtime(), 1);
var import_react400 = __toESM(require_react(), 1);
var HoverCardTrigger = (0, import_react400.forwardRef)(
  (props21, ref2) => {
    const hoverCard = useHoverCardContext();
    const mergedProps = mergeProps(hoverCard.getTriggerProps(), props21);
    return (0, import_jsx_runtime184.jsx)(ark.button, { ...mergedProps, ref: ref2 });
  }
);
HoverCardTrigger.displayName = "HoverCardTrigger";

// node_modules/@ark-ui/react/dist/components/hover-card/hover-card.js
var hover_card_exports = {};
__export(hover_card_exports, {
  Arrow: () => HoverCardArrow,
  ArrowTip: () => HoverCardArrowTip,
  Content: () => HoverCardContent,
  Context: () => HoverCardContext,
  Positioner: () => HoverCardPositioner,
  Root: () => HoverCardRoot,
  RootProvider: () => HoverCardRootProvider,
  Trigger: () => HoverCardTrigger
});

// node_modules/@ark-ui/react/dist/components/number-input/use-number-input-context.js
var [NumberInputProvider, useNumberInputContext] = createContext({
  name: "NumberInputContext",
  hookName: "useNumberInputContext",
  providerName: "<NumberInputProvider />"
});

// node_modules/@ark-ui/react/dist/components/number-input/number-input-context.js
var NumberInputContext = (props21) => props21.children(useNumberInputContext());

// node_modules/@ark-ui/react/dist/components/number-input/number-input-control.js
var import_jsx_runtime185 = __toESM(require_jsx_runtime(), 1);
var import_react402 = __toESM(require_react(), 1);
var NumberInputControl = (0, import_react402.forwardRef)(
  (props21, ref2) => {
    const numberInput = useNumberInputContext();
    const mergedProps = mergeProps(numberInput.getControlProps(), props21);
    return (0, import_jsx_runtime185.jsx)(ark.div, { ...mergedProps, ref: ref2 });
  }
);
NumberInputControl.displayName = "NumberInputControl";

// node_modules/@ark-ui/react/dist/components/number-input/number-input-decrement-trigger.js
var import_jsx_runtime186 = __toESM(require_jsx_runtime(), 1);
var import_react404 = __toESM(require_react(), 1);
var NumberInputDecrementTrigger = (0, import_react404.forwardRef)((props21, ref2) => {
  const numberInput = useNumberInputContext();
  const mergedProps = mergeProps(numberInput.getDecrementTriggerProps(), props21);
  return (0, import_jsx_runtime186.jsx)(ark.button, { ...mergedProps, ref: ref2 });
});
NumberInputDecrementTrigger.displayName = "NumberInputDecrementTrigger";

// node_modules/@ark-ui/react/dist/components/number-input/number-input-increment-trigger.js
var import_jsx_runtime187 = __toESM(require_jsx_runtime(), 1);
var import_react406 = __toESM(require_react(), 1);
var NumberInputIncrementTrigger = (0, import_react406.forwardRef)((props21, ref2) => {
  const numberInput = useNumberInputContext();
  const mergedProps = mergeProps(numberInput.getIncrementTriggerProps(), props21);
  return (0, import_jsx_runtime187.jsx)(ark.button, { ...mergedProps, ref: ref2 });
});
NumberInputIncrementTrigger.displayName = "NumberInputIncrementTrigger";

// node_modules/@ark-ui/react/dist/components/number-input/number-input-input.js
var import_jsx_runtime188 = __toESM(require_jsx_runtime(), 1);
var import_react408 = __toESM(require_react(), 1);
var NumberInputInput = (0, import_react408.forwardRef)(
  (props21, ref2) => {
    const numberInput = useNumberInputContext();
    const mergedProps = mergeProps(numberInput.getInputProps(), props21);
    const field = useFieldContext();
    return (0, import_jsx_runtime188.jsx)(ark.input, { "aria-describedby": field == null ? void 0 : field.ariaDescribedby, ...mergedProps, ref: ref2 });
  }
);
NumberInputInput.displayName = "NumberInputInput";

// node_modules/@ark-ui/react/dist/components/number-input/number-input-label.js
var import_jsx_runtime189 = __toESM(require_jsx_runtime(), 1);
var import_react410 = __toESM(require_react(), 1);
var NumberInputLabel = (0, import_react410.forwardRef)(
  (props21, ref2) => {
    const numberInput = useNumberInputContext();
    const mergedProps = mergeProps(numberInput.getLabelProps(), props21);
    return (0, import_jsx_runtime189.jsx)(ark.label, { ...mergedProps, ref: ref2 });
  }
);
NumberInputLabel.displayName = "NumberInputLabel";

// node_modules/@ark-ui/react/dist/components/number-input/number-input-root.js
var import_jsx_runtime190 = __toESM(require_jsx_runtime(), 1);
var import_react414 = __toESM(require_react(), 1);

// node_modules/@internationalized/number/dist/NumberFormatter.mjs
var $488c6ddbf4ef74c2$var$formatterCache = /* @__PURE__ */ new Map();
var $488c6ddbf4ef74c2$var$supportsSignDisplay = false;
try {
  $488c6ddbf4ef74c2$var$supportsSignDisplay = new Intl.NumberFormat("de-DE", {
    signDisplay: "exceptZero"
  }).resolvedOptions().signDisplay === "exceptZero";
} catch {
}
var $488c6ddbf4ef74c2$var$supportsUnit = false;
try {
  $488c6ddbf4ef74c2$var$supportsUnit = new Intl.NumberFormat("de-DE", {
    style: "unit",
    unit: "degree"
  }).resolvedOptions().style === "unit";
} catch {
}
var $488c6ddbf4ef74c2$var$UNITS = {
  degree: {
    narrow: {
      default: "°",
      "ja-JP": " 度",
      "zh-TW": "度",
      "sl-SI": " °"
    }
  }
};
var $488c6ddbf4ef74c2$export$cc77c4ff7e8673c5 = class {
  /** Formats a number value as a string, according to the locale and options provided to the constructor. */
  format(value) {
    let res = "";
    if (!$488c6ddbf4ef74c2$var$supportsSignDisplay && this.options.signDisplay != null) res = $488c6ddbf4ef74c2$export$711b50b3c525e0f2(this.numberFormatter, this.options.signDisplay, value);
    else res = this.numberFormatter.format(value);
    if (this.options.style === "unit" && !$488c6ddbf4ef74c2$var$supportsUnit) {
      var _UNITS_unit;
      let { unit, unitDisplay = "short", locale } = this.resolvedOptions();
      if (!unit) return res;
      let values = (_UNITS_unit = $488c6ddbf4ef74c2$var$UNITS[unit]) === null || _UNITS_unit === void 0 ? void 0 : _UNITS_unit[unitDisplay];
      res += values[locale] || values.default;
    }
    return res;
  }
  /** Formats a number to an array of parts such as separators, digits, punctuation, and more. */
  formatToParts(value) {
    return this.numberFormatter.formatToParts(value);
  }
  /** Formats a number range as a string. */
  formatRange(start, end) {
    if (typeof this.numberFormatter.formatRange === "function") return this.numberFormatter.formatRange(start, end);
    if (end < start) throw new RangeError("End date must be >= start date");
    return `${this.format(start)} – ${this.format(end)}`;
  }
  /** Formats a number range as an array of parts. */
  formatRangeToParts(start, end) {
    if (typeof this.numberFormatter.formatRangeToParts === "function") return this.numberFormatter.formatRangeToParts(start, end);
    if (end < start) throw new RangeError("End date must be >= start date");
    let startParts = this.numberFormatter.formatToParts(start);
    let endParts = this.numberFormatter.formatToParts(end);
    return [
      ...startParts.map((p) => ({
        ...p,
        source: "startRange"
      })),
      {
        type: "literal",
        value: " – ",
        source: "shared"
      },
      ...endParts.map((p) => ({
        ...p,
        source: "endRange"
      }))
    ];
  }
  /** Returns the resolved formatting options based on the values passed to the constructor. */
  resolvedOptions() {
    let options = this.numberFormatter.resolvedOptions();
    if (!$488c6ddbf4ef74c2$var$supportsSignDisplay && this.options.signDisplay != null) options = {
      ...options,
      signDisplay: this.options.signDisplay
    };
    if (!$488c6ddbf4ef74c2$var$supportsUnit && this.options.style === "unit") options = {
      ...options,
      style: "unit",
      unit: this.options.unit,
      unitDisplay: this.options.unitDisplay
    };
    return options;
  }
  constructor(locale, options = {}) {
    this.numberFormatter = $488c6ddbf4ef74c2$var$getCachedNumberFormatter(locale, options);
    this.options = options;
  }
};
function $488c6ddbf4ef74c2$var$getCachedNumberFormatter(locale, options = {}) {
  let { numberingSystem } = options;
  if (numberingSystem && locale.includes("-nu-")) {
    if (!locale.includes("-u-")) locale += "-u-";
    locale += `-nu-${numberingSystem}`;
  }
  if (options.style === "unit" && !$488c6ddbf4ef74c2$var$supportsUnit) {
    var _UNITS_unit;
    let { unit, unitDisplay = "short" } = options;
    if (!unit) throw new Error('unit option must be provided with style: "unit"');
    if (!((_UNITS_unit = $488c6ddbf4ef74c2$var$UNITS[unit]) === null || _UNITS_unit === void 0 ? void 0 : _UNITS_unit[unitDisplay])) throw new Error(`Unsupported unit ${unit} with unitDisplay = ${unitDisplay}`);
    options = {
      ...options,
      style: "decimal"
    };
  }
  let cacheKey = locale + (options ? Object.entries(options).sort((a, b) => a[0] < b[0] ? -1 : 1).join() : "");
  if ($488c6ddbf4ef74c2$var$formatterCache.has(cacheKey)) return $488c6ddbf4ef74c2$var$formatterCache.get(cacheKey);
  let numberFormatter = new Intl.NumberFormat(locale, options);
  $488c6ddbf4ef74c2$var$formatterCache.set(cacheKey, numberFormatter);
  return numberFormatter;
}
function $488c6ddbf4ef74c2$export$711b50b3c525e0f2(numberFormat, signDisplay, num) {
  if (signDisplay === "auto") return numberFormat.format(num);
  else if (signDisplay === "never") return numberFormat.format(Math.abs(num));
  else {
    let needsPositiveSign = false;
    if (signDisplay === "always") needsPositiveSign = num > 0 || Object.is(num, 0);
    else if (signDisplay === "exceptZero") {
      if (Object.is(num, -0) || Object.is(num, 0)) num = Math.abs(num);
      else needsPositiveSign = num > 0;
    }
    if (needsPositiveSign) {
      let negative = numberFormat.format(-num);
      let noSign = numberFormat.format(num);
      let minus = negative.replace(noSign, "").replace(/\u200e|\u061C/, "");
      if ([
        ...minus
      ].length !== 1) console.warn("@react-aria/i18n polyfill for NumberFormat signDisplay: Unsupported case");
      let positive = negative.replace(noSign, "!!!").replace(minus, "+").replace("!!!", noSign);
      return positive;
    } else return numberFormat.format(num);
  }
}

// node_modules/@internationalized/number/dist/NumberParser.mjs
var $6c7bd7858deea686$var$CURRENCY_SIGN_REGEX = new RegExp("^.*\\(.*\\).*$");
var $6c7bd7858deea686$var$NUMBERING_SYSTEMS = [
  "latn",
  "arab",
  "hanidec",
  "deva",
  "beng"
];
var $6c7bd7858deea686$export$cd11ab140839f11d = class {
  /**
  * Parses the given string to a number. Returns NaN if a valid number could not be parsed.
  */
  parse(value) {
    return $6c7bd7858deea686$var$getNumberParserImpl(this.locale, this.options, value).parse(value);
  }
  /**
  * Returns whether the given string could potentially be a valid number. This should be used to
  * validate user input as the user types. If a `minValue` or `maxValue` is provided, the validity
  * of the minus/plus sign characters can be checked.
  */
  isValidPartialNumber(value, minValue, maxValue2) {
    return $6c7bd7858deea686$var$getNumberParserImpl(this.locale, this.options, value).isValidPartialNumber(value, minValue, maxValue2);
  }
  /**
  * Returns a numbering system for which the given string is valid in the current locale.
  * If no numbering system could be detected, the default numbering system for the current
  * locale is returned.
  */
  getNumberingSystem(value) {
    return $6c7bd7858deea686$var$getNumberParserImpl(this.locale, this.options, value).options.numberingSystem;
  }
  constructor(locale, options = {}) {
    this.locale = locale;
    this.options = options;
  }
};
var $6c7bd7858deea686$var$numberParserCache = /* @__PURE__ */ new Map();
function $6c7bd7858deea686$var$getNumberParserImpl(locale, options, value) {
  let defaultParser = $6c7bd7858deea686$var$getCachedNumberParser(locale, options);
  if (!locale.includes("-nu-") && !defaultParser.isValidPartialNumber(value)) {
    for (let numberingSystem of $6c7bd7858deea686$var$NUMBERING_SYSTEMS) if (numberingSystem !== defaultParser.options.numberingSystem) {
      let parser = $6c7bd7858deea686$var$getCachedNumberParser(locale + (locale.includes("-u-") ? "-nu-" : "-u-nu-") + numberingSystem, options);
      if (parser.isValidPartialNumber(value)) return parser;
    }
  }
  return defaultParser;
}
function $6c7bd7858deea686$var$getCachedNumberParser(locale, options) {
  let cacheKey = locale + (options ? Object.entries(options).sort((a, b) => a[0] < b[0] ? -1 : 1).join() : "");
  let parser = $6c7bd7858deea686$var$numberParserCache.get(cacheKey);
  if (!parser) {
    parser = new $6c7bd7858deea686$var$NumberParserImpl(locale, options);
    $6c7bd7858deea686$var$numberParserCache.set(cacheKey, parser);
  }
  return parser;
}
var $6c7bd7858deea686$var$NumberParserImpl = class {
  parse(value) {
    let fullySanitizedValue = this.sanitize(value);
    if (this.symbols.group)
      fullySanitizedValue = $6c7bd7858deea686$var$replaceAll(fullySanitizedValue, this.symbols.group, "");
    if (this.symbols.decimal) fullySanitizedValue = fullySanitizedValue.replace(this.symbols.decimal, ".");
    if (this.symbols.minusSign) fullySanitizedValue = fullySanitizedValue.replace(this.symbols.minusSign, "-");
    fullySanitizedValue = fullySanitizedValue.replace(this.symbols.numeral, this.symbols.index);
    if (this.options.style === "percent") {
      let isNegative = fullySanitizedValue.indexOf("-");
      fullySanitizedValue = fullySanitizedValue.replace("-", "");
      let index = fullySanitizedValue.indexOf(".");
      if (index === -1) index = fullySanitizedValue.length;
      fullySanitizedValue = fullySanitizedValue.replace(".", "");
      if (index - 2 === 0) fullySanitizedValue = `0.${fullySanitizedValue}`;
      else if (index - 2 === -1) fullySanitizedValue = `0.0${fullySanitizedValue}`;
      else if (index - 2 === -2) fullySanitizedValue = "0.00";
      else fullySanitizedValue = `${fullySanitizedValue.slice(0, index - 2)}.${fullySanitizedValue.slice(index - 2)}`;
      if (isNegative > -1) fullySanitizedValue = `-${fullySanitizedValue}`;
    }
    let newValue = fullySanitizedValue ? +fullySanitizedValue : NaN;
    if (isNaN(newValue)) return NaN;
    if (this.options.style === "percent") {
      var _this_options_minimumFractionDigits, _this_options_maximumFractionDigits;
      let options = {
        ...this.options,
        style: "decimal",
        minimumFractionDigits: Math.min(((_this_options_minimumFractionDigits = this.options.minimumFractionDigits) !== null && _this_options_minimumFractionDigits !== void 0 ? _this_options_minimumFractionDigits : 0) + 2, 20),
        maximumFractionDigits: Math.min(((_this_options_maximumFractionDigits = this.options.maximumFractionDigits) !== null && _this_options_maximumFractionDigits !== void 0 ? _this_options_maximumFractionDigits : 0) + 2, 20)
      };
      return new $6c7bd7858deea686$export$cd11ab140839f11d(this.locale, options).parse(new (0, $488c6ddbf4ef74c2$export$cc77c4ff7e8673c5)(this.locale, options).format(newValue));
    }
    if (this.options.currencySign === "accounting" && $6c7bd7858deea686$var$CURRENCY_SIGN_REGEX.test(value)) newValue = -1 * newValue;
    return newValue;
  }
  sanitize(value) {
    value = value.replace(this.symbols.literals, "");
    if (this.symbols.minusSign) value = value.replace("-", this.symbols.minusSign);
    if (this.options.numberingSystem === "arab") {
      if (this.symbols.decimal) {
        value = value.replace(",", this.symbols.decimal);
        value = value.replace(String.fromCharCode(1548), this.symbols.decimal);
      }
      if (this.symbols.group) value = $6c7bd7858deea686$var$replaceAll(value, ".", this.symbols.group);
    }
    if (this.options.locale === "fr-FR") value = $6c7bd7858deea686$var$replaceAll(value, ".", String.fromCharCode(8239));
    return value;
  }
  isValidPartialNumber(value, minValue = -Infinity, maxValue2 = Infinity) {
    value = this.sanitize(value);
    if (this.symbols.minusSign && value.startsWith(this.symbols.minusSign) && minValue < 0) value = value.slice(this.symbols.minusSign.length);
    else if (this.symbols.plusSign && value.startsWith(this.symbols.plusSign) && maxValue2 > 0) value = value.slice(this.symbols.plusSign.length);
    if (this.symbols.group && value.startsWith(this.symbols.group)) return false;
    if (this.symbols.decimal && value.indexOf(this.symbols.decimal) > -1 && this.options.maximumFractionDigits === 0) return false;
    if (this.symbols.group) value = $6c7bd7858deea686$var$replaceAll(value, this.symbols.group, "");
    value = value.replace(this.symbols.numeral, "");
    if (this.symbols.decimal) value = value.replace(this.symbols.decimal, "");
    return value.length === 0;
  }
  constructor(locale, options = {}) {
    this.locale = locale;
    this.formatter = new Intl.NumberFormat(locale, options);
    this.options = this.formatter.resolvedOptions();
    this.symbols = $6c7bd7858deea686$var$getSymbols(locale, this.formatter, this.options, options);
    var _this_options_minimumFractionDigits, _this_options_maximumFractionDigits;
    if (this.options.style === "percent" && (((_this_options_minimumFractionDigits = this.options.minimumFractionDigits) !== null && _this_options_minimumFractionDigits !== void 0 ? _this_options_minimumFractionDigits : 0) > 18 || ((_this_options_maximumFractionDigits = this.options.maximumFractionDigits) !== null && _this_options_maximumFractionDigits !== void 0 ? _this_options_maximumFractionDigits : 0) > 18)) console.warn("NumberParser cannot handle percentages with greater than 18 decimal places, please reduce the number in your options.");
  }
};
var $6c7bd7858deea686$var$nonLiteralParts = /* @__PURE__ */ new Set([
  "decimal",
  "fraction",
  "integer",
  "minusSign",
  "plusSign",
  "group"
]);
var $6c7bd7858deea686$var$pluralNumbers = [
  0,
  4,
  2,
  1,
  11,
  20,
  3,
  7,
  100,
  21,
  0.1,
  1.1
];
function $6c7bd7858deea686$var$getSymbols(locale, formatter, intlOptions, originalOptions) {
  var _allParts_find, _posAllParts_find, _decimalParts_find, _allParts_find1;
  let symbolFormatter = new Intl.NumberFormat(locale, {
    ...intlOptions,
    // Resets so we get the full range of symbols
    minimumSignificantDigits: 1,
    maximumSignificantDigits: 21,
    roundingIncrement: 1,
    roundingPriority: "auto",
    roundingMode: "halfExpand"
  });
  let allParts = symbolFormatter.formatToParts(-10000.111);
  let posAllParts = symbolFormatter.formatToParts(10000.111);
  let pluralParts = $6c7bd7858deea686$var$pluralNumbers.map((n) => symbolFormatter.formatToParts(n));
  var _allParts_find_value;
  let minusSign = (_allParts_find_value = (_allParts_find = allParts.find((p) => p.type === "minusSign")) === null || _allParts_find === void 0 ? void 0 : _allParts_find.value) !== null && _allParts_find_value !== void 0 ? _allParts_find_value : "-";
  let plusSign = (_posAllParts_find = posAllParts.find((p) => p.type === "plusSign")) === null || _posAllParts_find === void 0 ? void 0 : _posAllParts_find.value;
  if (!plusSign && ((originalOptions === null || originalOptions === void 0 ? void 0 : originalOptions.signDisplay) === "exceptZero" || (originalOptions === null || originalOptions === void 0 ? void 0 : originalOptions.signDisplay) === "always")) plusSign = "+";
  let decimalParts = new Intl.NumberFormat(locale, {
    ...intlOptions,
    minimumFractionDigits: 2,
    maximumFractionDigits: 2
  }).formatToParts(1e-3);
  let decimal = (_decimalParts_find = decimalParts.find((p) => p.type === "decimal")) === null || _decimalParts_find === void 0 ? void 0 : _decimalParts_find.value;
  let group = (_allParts_find1 = allParts.find((p) => p.type === "group")) === null || _allParts_find1 === void 0 ? void 0 : _allParts_find1.value;
  let allPartsLiterals = allParts.filter((p) => !$6c7bd7858deea686$var$nonLiteralParts.has(p.type)).map((p) => $6c7bd7858deea686$var$escapeRegex(p.value));
  let pluralPartsLiterals = pluralParts.flatMap((p) => p.filter((p2) => !$6c7bd7858deea686$var$nonLiteralParts.has(p2.type)).map((p2) => $6c7bd7858deea686$var$escapeRegex(p2.value)));
  let sortedLiterals = [
    .../* @__PURE__ */ new Set([
      ...allPartsLiterals,
      ...pluralPartsLiterals
    ])
  ].sort((a, b) => b.length - a.length);
  let literals = sortedLiterals.length === 0 ? new RegExp("[\\p{White_Space}]", "gu") : new RegExp(`${sortedLiterals.join("|")}|[\\p{White_Space}]`, "gu");
  let numerals = [
    ...new Intl.NumberFormat(intlOptions.locale, {
      useGrouping: false
    }).format(9876543210)
  ].reverse();
  let indexes = new Map(numerals.map((d, i) => [
    d,
    i
  ]));
  let numeral = new RegExp(`[${numerals.join("")}]`, "g");
  let index = (d) => String(indexes.get(d));
  return {
    minusSign,
    plusSign,
    decimal,
    group,
    literals,
    numeral,
    index
  };
}
function $6c7bd7858deea686$var$replaceAll(str, find2, replace2) {
  if (str.replaceAll) return str.replaceAll(find2, replace2);
  return str.split(find2).join(replace2);
}
function $6c7bd7858deea686$var$escapeRegex(string) {
  return string.replace(/[.*+?^${}()|[\]\\]/g, "\\$&");
}

// node_modules/@zag-js/number-input/dist/index.mjs
var anatomy18 = createAnatomy("numberInput").parts(
  "root",
  "label",
  "input",
  "control",
  "valueText",
  "incrementTrigger",
  "decrementTrigger",
  "scrubber"
);
var parts20 = anatomy18.build();
var dom18 = createScope({
  getRootId: (ctx) => {
    var _a8;
    return ((_a8 = ctx.ids) == null ? void 0 : _a8.root) ?? `number-input:${ctx.id}`;
  },
  getInputId: (ctx) => {
    var _a8;
    return ((_a8 = ctx.ids) == null ? void 0 : _a8.input) ?? `number-input:${ctx.id}:input`;
  },
  getIncrementTriggerId: (ctx) => {
    var _a8;
    return ((_a8 = ctx.ids) == null ? void 0 : _a8.incrementTrigger) ?? `number-input:${ctx.id}:inc`;
  },
  getDecrementTriggerId: (ctx) => {
    var _a8;
    return ((_a8 = ctx.ids) == null ? void 0 : _a8.decrementTrigger) ?? `number-input:${ctx.id}:dec`;
  },
  getScrubberId: (ctx) => {
    var _a8;
    return ((_a8 = ctx.ids) == null ? void 0 : _a8.scrubber) ?? `number-input:${ctx.id}:scrubber`;
  },
  getCursorId: (ctx) => `number-input:${ctx.id}:cursor`,
  getLabelId: (ctx) => {
    var _a8;
    return ((_a8 = ctx.ids) == null ? void 0 : _a8.label) ?? `number-input:${ctx.id}:label`;
  },
  getInputEl: (ctx) => dom18.getById(ctx, dom18.getInputId(ctx)),
  getIncrementTriggerEl: (ctx) => dom18.getById(ctx, dom18.getIncrementTriggerId(ctx)),
  getDecrementTriggerEl: (ctx) => dom18.getById(ctx, dom18.getDecrementTriggerId(ctx)),
  getScrubberEl: (ctx) => dom18.getById(ctx, dom18.getScrubberId(ctx)),
  getCursorEl: (ctx) => dom18.getDoc(ctx).getElementById(dom18.getCursorId(ctx)),
  getPressedTriggerEl: (ctx, hint = ctx.hint) => {
    let btnEl = null;
    if (hint === "increment") {
      btnEl = dom18.getIncrementTriggerEl(ctx);
    }
    if (hint === "decrement") {
      btnEl = dom18.getDecrementTriggerEl(ctx);
    }
    return btnEl;
  },
  setupVirtualCursor(ctx) {
    if (isSafari()) return;
    dom18.createVirtualCursor(ctx);
    return () => {
      var _a8;
      (_a8 = dom18.getCursorEl(ctx)) == null ? void 0 : _a8.remove();
    };
  },
  preventTextSelection(ctx) {
    const doc = dom18.getDoc(ctx);
    const html = doc.documentElement;
    const body = doc.body;
    body.style.pointerEvents = "none";
    html.style.userSelect = "none";
    html.style.cursor = "ew-resize";
    return () => {
      body.style.pointerEvents = "";
      html.style.userSelect = "";
      html.style.cursor = "";
      if (!html.style.length) {
        html.removeAttribute("style");
      }
      if (!body.style.length) {
        body.removeAttribute("style");
      }
    };
  },
  getMousemoveValue(ctx, event) {
    const win = dom18.getWin(ctx);
    const x = roundToDpr(event.movementX, win.devicePixelRatio);
    const y = roundToDpr(event.movementY, win.devicePixelRatio);
    let hint = x > 0 ? "increment" : x < 0 ? "decrement" : null;
    if (ctx.isRtl && hint === "increment") hint = "decrement";
    if (ctx.isRtl && hint === "decrement") hint = "increment";
    const point = {
      x: ctx.scrubberCursorPoint.x + x,
      y: ctx.scrubberCursorPoint.y + y
    };
    const width = win.innerWidth;
    const half = roundToDpr(7.5, win.devicePixelRatio);
    point.x = wrap3(point.x + half, width) - half;
    return { hint, point };
  },
  createVirtualCursor(ctx) {
    const doc = dom18.getDoc(ctx);
    const el = doc.createElement("div");
    el.className = "scrubber--cursor";
    el.id = dom18.getCursorId(ctx);
    Object.assign(el.style, {
      width: "15px",
      height: "15px",
      position: "fixed",
      pointerEvents: "none",
      left: "0px",
      top: "0px",
      zIndex: MAX_Z_INDEX,
      transform: ctx.scrubberCursorPoint ? `translate3d(${ctx.scrubberCursorPoint.x}px, ${ctx.scrubberCursorPoint.y}px, 0px)` : void 0,
      willChange: "transform"
    });
    el.innerHTML = `
        <svg width="46" height="15" style="left: -15.5px; position: absolute; top: 0; filter: drop-shadow(rgba(0, 0, 0, 0.4) 0px 1px 1.1px);">
          <g transform="translate(2 3)">
            <path fill-rule="evenodd" d="M 15 4.5L 15 2L 11.5 5.5L 15 9L 15 6.5L 31 6.5L 31 9L 34.5 5.5L 31 2L 31 4.5Z" style="stroke-width: 2px; stroke: white;"></path>
            <path fill-rule="evenodd" d="M 15 4.5L 15 2L 11.5 5.5L 15 9L 15 6.5L 31 6.5L 31 9L 34.5 5.5L 31 2L 31 4.5Z"></path>
          </g>
        </svg>`;
    doc.body.appendChild(el);
  }
});
function connect19(state2, send, normalize2) {
  const focused = state2.hasTag("focus");
  const disabled = state2.context.isDisabled;
  const readOnly = state2.context.readOnly;
  const empty2 = state2.context.isValueEmpty;
  const invalid = state2.context.isOutOfRange || !!state2.context.invalid;
  const isIncrementDisabled = disabled || !state2.context.canIncrement || readOnly;
  const isDecrementDisabled = disabled || !state2.context.canDecrement || readOnly;
  const translations = state2.context.translations;
  return {
    focused,
    invalid,
    empty: empty2,
    value: state2.context.formattedValue,
    valueAsNumber: state2.context.valueAsNumber,
    setValue(value) {
      send({ type: "VALUE.SET", value });
    },
    clearValue() {
      send("VALUE.CLEAR");
    },
    increment() {
      send("VALUE.INCREMENT");
    },
    decrement() {
      send("VALUE.DECREMENT");
    },
    setToMax() {
      send({ type: "VALUE.SET", value: state2.context.max });
    },
    setToMin() {
      send({ type: "VALUE.SET", value: state2.context.min });
    },
    focus() {
      var _a8;
      (_a8 = dom18.getInputEl(state2.context)) == null ? void 0 : _a8.focus();
    },
    getRootProps() {
      return normalize2.element({
        id: dom18.getRootId(state2.context),
        ...parts20.root.attrs,
        dir: state2.context.dir,
        "data-disabled": dataAttr(disabled),
        "data-focus": dataAttr(focused),
        "data-invalid": dataAttr(invalid)
      });
    },
    getLabelProps() {
      return normalize2.label({
        ...parts20.label.attrs,
        dir: state2.context.dir,
        "data-disabled": dataAttr(disabled),
        "data-focus": dataAttr(focused),
        "data-invalid": dataAttr(invalid),
        id: dom18.getLabelId(state2.context),
        htmlFor: dom18.getInputId(state2.context)
      });
    },
    getControlProps() {
      return normalize2.element({
        ...parts20.control.attrs,
        dir: state2.context.dir,
        role: "group",
        "aria-disabled": disabled,
        "data-focus": dataAttr(focused),
        "data-disabled": dataAttr(disabled),
        "data-invalid": dataAttr(invalid),
        "aria-invalid": ariaAttr(state2.context.invalid)
      });
    },
    getValueTextProps() {
      return normalize2.element({
        ...parts20.valueText.attrs,
        dir: state2.context.dir,
        "data-disabled": dataAttr(disabled),
        "data-invalid": dataAttr(invalid),
        "data-focus": dataAttr(focused)
      });
    },
    getInputProps() {
      return normalize2.input({
        ...parts20.input.attrs,
        dir: state2.context.dir,
        name: state2.context.name,
        form: state2.context.form,
        id: dom18.getInputId(state2.context),
        role: "spinbutton",
        defaultValue: state2.context.formattedValue,
        pattern: state2.context.pattern,
        inputMode: state2.context.inputMode,
        "aria-invalid": ariaAttr(invalid),
        "data-invalid": dataAttr(invalid),
        disabled,
        "data-disabled": dataAttr(disabled),
        readOnly: state2.context.readOnly,
        required: state2.context.required,
        autoComplete: "off",
        autoCorrect: "off",
        spellCheck: "false",
        type: "text",
        "aria-roledescription": "numberfield",
        "aria-valuemin": state2.context.min,
        "aria-valuemax": state2.context.max,
        "aria-valuenow": Number.isNaN(state2.context.valueAsNumber) ? void 0 : state2.context.valueAsNumber,
        "aria-valuetext": state2.context.valueText,
        onFocus() {
          send("INPUT.FOCUS");
        },
        onBlur() {
          send("INPUT.BLUR");
        },
        onInput(event) {
          send({ type: "INPUT.CHANGE", target: event.currentTarget, hint: "set" });
        },
        onBeforeInput(event) {
          try {
            const { selectionStart, selectionEnd, value } = event.currentTarget;
            const nextValue = value.slice(0, selectionStart) + (event.data ?? "") + value.slice(selectionEnd);
            const isValid = state2.context.parser.isValidPartialNumber(nextValue);
            if (!isValid) {
              event.preventDefault();
            }
          } catch {
          }
        },
        onKeyDown(event) {
          if (event.defaultPrevented) return;
          if (readOnly) return;
          if (isComposingEvent(event)) return;
          const step = getEventStep(event) * state2.context.step;
          const keyMap2 = {
            ArrowUp() {
              send({ type: "INPUT.ARROW_UP", step });
              event.preventDefault();
            },
            ArrowDown() {
              send({ type: "INPUT.ARROW_DOWN", step });
              event.preventDefault();
            },
            Home() {
              if (isModifierKey(event)) return;
              send("INPUT.HOME");
              event.preventDefault();
            },
            End() {
              if (isModifierKey(event)) return;
              send("INPUT.END");
              event.preventDefault();
            },
            Enter() {
              send("INPUT.ENTER");
            }
          };
          const exec2 = keyMap2[event.key];
          exec2 == null ? void 0 : exec2(event);
        }
      });
    },
    getDecrementTriggerProps() {
      return normalize2.button({
        ...parts20.decrementTrigger.attrs,
        dir: state2.context.dir,
        id: dom18.getDecrementTriggerId(state2.context),
        disabled: isDecrementDisabled,
        "data-disabled": dataAttr(isDecrementDisabled),
        "aria-label": translations.decrementLabel,
        type: "button",
        tabIndex: -1,
        "aria-controls": dom18.getInputId(state2.context),
        onPointerDown(event) {
          var _a8;
          if (isDecrementDisabled || !isLeftClick(event)) return;
          send({ type: "TRIGGER.PRESS_DOWN", hint: "decrement", pointerType: event.pointerType });
          if (event.pointerType === "mouse") {
            event.preventDefault();
          }
          if (event.pointerType === "touch") {
            (_a8 = event.currentTarget) == null ? void 0 : _a8.focus({ preventScroll: true });
          }
        },
        onPointerUp(event) {
          send({ type: "TRIGGER.PRESS_UP", hint: "decrement", pointerType: event.pointerType });
        },
        onPointerLeave() {
          if (isDecrementDisabled) return;
          send({ type: "TRIGGER.PRESS_UP", hint: "decrement" });
        }
      });
    },
    getIncrementTriggerProps() {
      return normalize2.button({
        ...parts20.incrementTrigger.attrs,
        dir: state2.context.dir,
        id: dom18.getIncrementTriggerId(state2.context),
        disabled: isIncrementDisabled,
        "data-disabled": dataAttr(isIncrementDisabled),
        "aria-label": translations.incrementLabel,
        type: "button",
        tabIndex: -1,
        "aria-controls": dom18.getInputId(state2.context),
        onPointerDown(event) {
          var _a8;
          if (isIncrementDisabled || !isLeftClick(event)) return;
          send({ type: "TRIGGER.PRESS_DOWN", hint: "increment", pointerType: event.pointerType });
          if (event.pointerType === "mouse") {
            event.preventDefault();
          }
          if (event.pointerType === "touch") {
            (_a8 = event.currentTarget) == null ? void 0 : _a8.focus({ preventScroll: true });
          }
        },
        onPointerUp(event) {
          send({ type: "TRIGGER.PRESS_UP", hint: "increment", pointerType: event.pointerType });
        },
        onPointerLeave(event) {
          send({ type: "TRIGGER.PRESS_UP", hint: "increment", pointerType: event.pointerType });
        }
      });
    },
    getScrubberProps() {
      return normalize2.element({
        ...parts20.scrubber.attrs,
        dir: state2.context.dir,
        "data-disabled": dataAttr(disabled),
        id: dom18.getScrubberId(state2.context),
        role: "presentation",
        onMouseDown(event) {
          if (disabled) return;
          const point = getEventPoint(event);
          const win = getWindow(event.currentTarget);
          const dpr = win.devicePixelRatio;
          point.x = point.x - roundToDpr(7.5, dpr);
          point.y = point.y - roundToDpr(7.5, dpr);
          send({ type: "SCRUBBER.PRESS_DOWN", point });
          event.preventDefault();
        },
        style: {
          cursor: disabled ? void 0 : "ew-resize"
        }
      });
    }
  };
}
function recordCursor(inputEl) {
  if (inputEl.ownerDocument.activeElement !== inputEl) return;
  try {
    const { selectionStart: start, selectionEnd: end, value } = inputEl;
    const beforeTxt = value.substring(0, start);
    const afterTxt = value.substring(end);
    return {
      start,
      end,
      value,
      beforeTxt,
      afterTxt
    };
  } catch {
  }
}
function restoreCursor(inputEl, selection) {
  if (inputEl.ownerDocument.activeElement !== inputEl) return;
  if (!selection) {
    inputEl.setSelectionRange(inputEl.value.length, inputEl.value.length);
    return;
  }
  try {
    const { value } = inputEl;
    const { beforeTxt = "", afterTxt = "", start } = selection;
    let startPos = value.length;
    if (value.endsWith(afterTxt)) {
      startPos = value.length - afterTxt.length;
    } else if (value.startsWith(beforeTxt)) {
      startPos = beforeTxt.length;
    } else if (start != null) {
      const beforeLastChar = beforeTxt[start - 1];
      const newIndex = value.indexOf(beforeLastChar, start - 1);
      if (newIndex !== -1) {
        startPos = newIndex + 1;
      }
    }
    inputEl.setSelectionRange(startPos, startPos);
  } catch {
  }
}
var createFormatter = (locale, options = {}) => {
  return ref(new Intl.NumberFormat(locale, options));
};
var createParser = (locale, options = {}) => {
  return ref(new $6c7bd7858deea686$export$cd11ab140839f11d(locale, options));
};
var parseValue = (ctx, value) => {
  if (!ctx.formatOptions) return parseFloat(value);
  return ctx.parser.parse(String(value));
};
var formatValue = (ctx, value) => {
  if (Number.isNaN(value)) return "";
  if (!ctx.formatOptions) return value.toString();
  return ctx.formatter.format(value);
};
var { not: not9, and: and8 } = guards;
function machine19(userContext) {
  const ctx = compact2(userContext);
  return createMachine(
    {
      id: "number-input",
      initial: "idle",
      context: {
        dir: "ltr",
        locale: "en-US",
        focusInputOnChange: true,
        clampValueOnBlur: true,
        allowOverflow: false,
        inputMode: "decimal",
        pattern: "[0-9]*(.[0-9]+)?",
        value: "",
        step: 1,
        min: Number.MIN_SAFE_INTEGER,
        max: Number.MAX_SAFE_INTEGER,
        invalid: false,
        spinOnPress: true,
        disabled: false,
        readOnly: false,
        ...ctx,
        hint: null,
        scrubberCursorPoint: null,
        fieldsetDisabled: false,
        formatter: createFormatter(ctx.locale || "en-US", ctx.formatOptions),
        parser: createParser(ctx.locale || "en-US", ctx.formatOptions),
        translations: {
          incrementLabel: "increment value",
          decrementLabel: "decrease value",
          ...ctx.translations
        }
      },
      computed: {
        isRtl: (ctx2) => ctx2.dir === "rtl",
        valueAsNumber: (ctx2) => parseValue(ctx2, ctx2.value),
        formattedValue: (ctx2) => formatValue(ctx2, ctx2.valueAsNumber),
        isAtMin: (ctx2) => isValueAtMin(ctx2.valueAsNumber, ctx2.min),
        isAtMax: (ctx2) => isValueAtMax(ctx2.valueAsNumber, ctx2.max),
        isOutOfRange: (ctx2) => !isValueWithinRange(ctx2.valueAsNumber, ctx2.min, ctx2.max),
        isValueEmpty: (ctx2) => ctx2.value === "",
        isDisabled: (ctx2) => !!ctx2.disabled || ctx2.fieldsetDisabled,
        canIncrement: (ctx2) => ctx2.allowOverflow || !ctx2.isAtMax,
        canDecrement: (ctx2) => ctx2.allowOverflow || !ctx2.isAtMin,
        valueText: (ctx2) => {
          var _a8, _b7;
          return (_b7 = (_a8 = ctx2.translations).valueText) == null ? void 0 : _b7.call(_a8, ctx2.value);
        }
      },
      watch: {
        formatOptions: ["setFormatterAndParser", "syncInputElement"],
        locale: ["setFormatterAndParser", "syncInputElement"],
        value: ["syncInputElement"],
        isOutOfRange: ["invokeOnInvalid"],
        scrubberCursorPoint: ["setVirtualCursorPosition"]
      },
      activities: ["trackFormControl"],
      on: {
        "VALUE.SET": {
          actions: ["setRawValue", "setHintToSet"]
        },
        "VALUE.CLEAR": {
          actions: ["clearValue"]
        },
        "VALUE.INCREMENT": {
          actions: ["increment"]
        },
        "VALUE.DECREMENT": {
          actions: ["decrement"]
        }
      },
      states: {
        idle: {
          on: {
            "TRIGGER.PRESS_DOWN": [
              { guard: "isTouchPointer", target: "before:spin", actions: ["setHint"] },
              {
                target: "before:spin",
                actions: ["focusInput", "invokeOnFocus", "setHint"]
              }
            ],
            "SCRUBBER.PRESS_DOWN": {
              target: "scrubbing",
              actions: ["focusInput", "invokeOnFocus", "setHint", "setCursorPoint"]
            },
            "INPUT.FOCUS": {
              target: "focused",
              actions: ["focusInput", "invokeOnFocus"]
            }
          }
        },
        focused: {
          tags: "focus",
          activities: "attachWheelListener",
          on: {
            "TRIGGER.PRESS_DOWN": [
              { guard: "isTouchPointer", target: "before:spin", actions: ["setHint"] },
              { target: "before:spin", actions: ["focusInput", "setHint"] }
            ],
            "SCRUBBER.PRESS_DOWN": {
              target: "scrubbing",
              actions: ["focusInput", "setHint", "setCursorPoint"]
            },
            "INPUT.ARROW_UP": {
              actions: "increment"
            },
            "INPUT.ARROW_DOWN": {
              actions: "decrement"
            },
            "INPUT.HOME": {
              actions: "decrementToMin"
            },
            "INPUT.END": {
              actions: "incrementToMax"
            },
            "INPUT.CHANGE": {
              actions: ["setValue", "setHint"]
            },
            "INPUT.BLUR": [
              {
                guard: and8("clampValueOnBlur", not9("isInRange")),
                target: "idle",
                actions: ["setClampedValue", "clearHint", "invokeOnBlur"]
              },
              {
                target: "idle",
                actions: ["setFormattedValue", "clearHint", "invokeOnBlur"]
              }
            ],
            "INPUT.ENTER": {
              actions: ["setFormattedValue", "clearHint", "invokeOnBlur"]
            }
          }
        },
        "before:spin": {
          tags: "focus",
          activities: "trackButtonDisabled",
          entry: choose([
            { guard: "isIncrementHint", actions: "increment" },
            { guard: "isDecrementHint", actions: "decrement" }
          ]),
          after: {
            CHANGE_DELAY: {
              target: "spinning",
              guard: and8("isInRange", "spinOnPress")
            }
          },
          on: {
            "TRIGGER.PRESS_UP": [
              { guard: "isTouchPointer", target: "focused", actions: "clearHint" },
              { target: "focused", actions: ["focusInput", "clearHint"] }
            ]
          }
        },
        spinning: {
          tags: "focus",
          activities: "trackButtonDisabled",
          every: [
            {
              delay: "CHANGE_INTERVAL",
              guard: and8(not9("isAtMin"), "isIncrementHint"),
              actions: "increment"
            },
            {
              delay: "CHANGE_INTERVAL",
              guard: and8(not9("isAtMax"), "isDecrementHint"),
              actions: "decrement"
            }
          ],
          on: {
            "TRIGGER.PRESS_UP": {
              target: "focused",
              actions: ["focusInput", "clearHint"]
            }
          }
        },
        scrubbing: {
          tags: "focus",
          activities: ["activatePointerLock", "trackMousemove", "setupVirtualCursor", "preventTextSelection"],
          on: {
            "SCRUBBER.POINTER_UP": {
              target: "focused",
              actions: ["focusInput", "clearCursorPoint"]
            },
            "SCRUBBER.POINTER_MOVE": [
              {
                guard: "isIncrementHint",
                actions: ["increment", "setCursorPoint"]
              },
              {
                guard: "isDecrementHint",
                actions: ["decrement", "setCursorPoint"]
              }
            ]
          }
        }
      }
    },
    {
      delays: {
        CHANGE_INTERVAL: 50,
        CHANGE_DELAY: 300
      },
      guards: {
        clampValueOnBlur: (ctx2) => ctx2.clampValueOnBlur,
        isAtMin: (ctx2) => ctx2.isAtMin,
        spinOnPress: (ctx2) => !!ctx2.spinOnPress,
        isAtMax: (ctx2) => ctx2.isAtMax,
        isInRange: (ctx2) => !ctx2.isOutOfRange,
        isDecrementHint: (ctx2, evt) => (evt.hint ?? ctx2.hint) === "decrement",
        isIncrementHint: (ctx2, evt) => (evt.hint ?? ctx2.hint) === "increment",
        isTouchPointer: (_ctx, evt) => evt.pointerType === "touch"
      },
      activities: {
        trackFormControl(ctx2, _evt, { initialContext }) {
          const inputEl = dom18.getInputEl(ctx2);
          return trackFormControl(inputEl, {
            onFieldsetDisabledChange(disabled) {
              ctx2.fieldsetDisabled = disabled;
            },
            onFormReset() {
              set15.value(ctx2, initialContext.value);
            }
          });
        },
        setupVirtualCursor(ctx2) {
          return dom18.setupVirtualCursor(ctx2);
        },
        preventTextSelection(ctx2) {
          return dom18.preventTextSelection(ctx2);
        },
        trackButtonDisabled(ctx2, _evt, { send }) {
          const btn = dom18.getPressedTriggerEl(ctx2, ctx2.hint);
          return observeAttributes(btn, {
            attributes: ["disabled"],
            callback() {
              send({ type: "TRIGGER.PRESS_UP", src: "attr" });
            }
          });
        },
        attachWheelListener(ctx2, _evt, { send }) {
          const inputEl = dom18.getInputEl(ctx2);
          if (!inputEl || !dom18.isActiveElement(ctx2, inputEl) || !ctx2.allowMouseWheel) return;
          function onWheel(event) {
            event.preventDefault();
            const dir = Math.sign(event.deltaY) * -1;
            if (dir === 1) {
              send("VALUE.INCREMENT");
            } else if (dir === -1) {
              send("VALUE.DECREMENT");
            }
          }
          return addDomEvent(inputEl, "wheel", onWheel, { passive: false });
        },
        activatePointerLock(ctx2) {
          if (isSafari()) return;
          return requestPointerLock(dom18.getDoc(ctx2));
        },
        trackMousemove(ctx2, _evt, { send }) {
          const doc = dom18.getDoc(ctx2);
          function onMousemove(event) {
            if (!ctx2.scrubberCursorPoint) return;
            const value = dom18.getMousemoveValue(ctx2, event);
            if (!value.hint) return;
            send({
              type: "SCRUBBER.POINTER_MOVE",
              hint: value.hint,
              point: value.point
            });
          }
          function onMouseup() {
            send("SCRUBBER.POINTER_UP");
          }
          return callAll(
            addDomEvent(doc, "mousemove", onMousemove, false),
            addDomEvent(doc, "mouseup", onMouseup, false)
          );
        }
      },
      actions: {
        focusInput(ctx2) {
          if (!ctx2.focusInputOnChange) return;
          const inputEl = dom18.getInputEl(ctx2);
          if (dom18.isActiveElement(ctx2, inputEl)) return;
          raf(() => inputEl == null ? void 0 : inputEl.focus({ preventScroll: true }));
        },
        increment(ctx2, evt) {
          const nextValue = incrementValue(ctx2.valueAsNumber, evt.step ?? ctx2.step);
          const value = formatValue(ctx2, clampValue(nextValue, ctx2.min, ctx2.max));
          set15.value(ctx2, value);
        },
        decrement(ctx2, evt) {
          const nextValue = decrementValue(ctx2.valueAsNumber, evt.step ?? ctx2.step);
          const value = formatValue(ctx2, clampValue(nextValue, ctx2.min, ctx2.max));
          set15.value(ctx2, value);
        },
        setClampedValue(ctx2) {
          const nextValue = clampValue(ctx2.valueAsNumber, ctx2.min, ctx2.max);
          set15.value(ctx2, formatValue(ctx2, nextValue));
        },
        setRawValue(ctx2, evt) {
          const parsedValue = parseValue(ctx2, evt.value);
          const value = formatValue(ctx2, clampValue(parsedValue, ctx2.min, ctx2.max));
          set15.value(ctx2, value);
        },
        setValue(ctx2, evt) {
          var _a8;
          const value = ((_a8 = evt.target) == null ? void 0 : _a8.value) ?? evt.value;
          set15.value(ctx2, value);
        },
        clearValue(ctx2) {
          set15.value(ctx2, "");
        },
        incrementToMax(ctx2) {
          const value = formatValue(ctx2, ctx2.max);
          set15.value(ctx2, value);
        },
        decrementToMin(ctx2) {
          const value = formatValue(ctx2, ctx2.min);
          set15.value(ctx2, value);
        },
        setHint(ctx2, evt) {
          ctx2.hint = evt.hint;
        },
        clearHint(ctx2) {
          ctx2.hint = null;
        },
        setHintToSet(ctx2) {
          ctx2.hint = "set";
        },
        invokeOnFocus(ctx2) {
          var _a8;
          (_a8 = ctx2.onFocusChange) == null ? void 0 : _a8.call(ctx2, {
            focused: true,
            value: ctx2.formattedValue,
            valueAsNumber: ctx2.valueAsNumber
          });
        },
        invokeOnBlur(ctx2) {
          var _a8;
          (_a8 = ctx2.onFocusChange) == null ? void 0 : _a8.call(ctx2, {
            focused: false,
            value: ctx2.formattedValue,
            valueAsNumber: ctx2.valueAsNumber
          });
        },
        invokeOnInvalid(ctx2) {
          var _a8;
          if (!ctx2.isOutOfRange) return;
          const reason = ctx2.valueAsNumber > ctx2.max ? "rangeOverflow" : "rangeUnderflow";
          (_a8 = ctx2.onValueInvalid) == null ? void 0 : _a8.call(ctx2, {
            reason,
            value: ctx2.formattedValue,
            valueAsNumber: ctx2.valueAsNumber
          });
        },
        syncInputElement(ctx2, evt) {
          const value = evt.type.endsWith("CHANGE") ? ctx2.value : ctx2.formattedValue;
          sync4.input(ctx2, value);
        },
        setFormattedValue(ctx2) {
          set15.value(ctx2, ctx2.formattedValue);
        },
        setCursorPoint(ctx2, evt) {
          ctx2.scrubberCursorPoint = evt.point;
        },
        clearCursorPoint(ctx2) {
          ctx2.scrubberCursorPoint = null;
        },
        setVirtualCursorPosition(ctx2) {
          const cursorEl = dom18.getCursorEl(ctx2);
          if (!cursorEl || !ctx2.scrubberCursorPoint) return;
          const { x, y } = ctx2.scrubberCursorPoint;
          cursorEl.style.transform = `translate3d(${x}px, ${y}px, 0px)`;
        },
        setFormatterAndParser(ctx2) {
          if (!ctx2.locale) return;
          ctx2.formatter = createFormatter(ctx2.locale, ctx2.formatOptions);
          ctx2.parser = createParser(ctx2.locale, ctx2.formatOptions);
        }
      },
      compareFns: {
        formatOptions: (a, b) => isEqual(a, b),
        scrubberCursorPoint: (a, b) => isEqual(a, b)
      }
    }
  );
}
var sync4 = {
  input(ctx, value) {
    const inputEl = dom18.getInputEl(ctx);
    if (!inputEl) return;
    const sel = recordCursor(inputEl);
    raf(() => {
      setElementValue(inputEl, value);
      restoreCursor(inputEl, sel);
    });
  }
};
var invoke12 = {
  onChange: (ctx) => {
    var _a8;
    (_a8 = ctx.onValueChange) == null ? void 0 : _a8.call(ctx, {
      value: ctx.value,
      valueAsNumber: ctx.valueAsNumber
    });
  }
};
var set15 = {
  value: (ctx, value) => {
    if (isEqual(ctx.value, value)) return;
    ctx.value = value;
    invoke12.onChange(ctx);
  }
};

// node_modules/@ark-ui/react/dist/components/number-input/use-number-input.js
var import_react412 = __toESM(require_react(), 1);
var useNumberInput = (props21 = {}) => {
  const { getRootNode } = useEnvironmentContext();
  const { dir, locale } = useLocaleContext();
  const field = useFieldContext();
  const initialContext = {
    id: (0, import_react412.useId)(),
    ids: {
      label: field == null ? void 0 : field.ids.label,
      input: field == null ? void 0 : field.ids.control
    },
    disabled: field == null ? void 0 : field.disabled,
    readOnly: field == null ? void 0 : field.readOnly,
    required: field == null ? void 0 : field.required,
    invalid: field == null ? void 0 : field.invalid,
    dir,
    locale,
    getRootNode,
    value: props21.defaultValue,
    ...props21
  };
  const context = {
    ...initialContext,
    value: props21.value,
    onValueChange: useEvent(props21.onValueChange, { sync: true }),
    onValueInvalid: useEvent(props21.onValueInvalid),
    onFocusChange: useEvent(props21.onFocusChange)
  };
  const [state2, send] = useMachine(machine19(initialContext), { context });
  return connect19(state2, send, normalizeProps);
};

// node_modules/@ark-ui/react/dist/components/number-input/number-input-root.js
var NumberInputRoot = (0, import_react414.forwardRef)((props21, ref2) => {
  const [useNumberInputProps, localProps] = createSplitProps2()(props21, [
    "allowMouseWheel",
    "allowOverflow",
    "clampValueOnBlur",
    "defaultValue",
    "disabled",
    "focusInputOnChange",
    "form",
    "formatOptions",
    "id",
    "ids",
    "inputMode",
    "invalid",
    "locale",
    "max",
    "min",
    "name",
    "onFocusChange",
    "onValueChange",
    "onValueInvalid",
    "pattern",
    "readOnly",
    "required",
    "spinOnPress",
    "step",
    "translations",
    "value"
  ]);
  const numberInput = useNumberInput(useNumberInputProps);
  const mergedProps = mergeProps(numberInput.getRootProps(), localProps);
  return (0, import_jsx_runtime190.jsx)(NumberInputProvider, { value: numberInput, children: (0, import_jsx_runtime190.jsx)(ark.div, { ...mergedProps, ref: ref2 }) });
});
NumberInputRoot.displayName = "NumberInputRoot";

// node_modules/@ark-ui/react/dist/components/number-input/number-input-root-provider.js
var import_jsx_runtime191 = __toESM(require_jsx_runtime(), 1);
var import_react416 = __toESM(require_react(), 1);
var NumberInputRootProvider = (0, import_react416.forwardRef)(
  (props21, ref2) => {
    const [{ value: numberInput }, localProps] = createSplitProps2()(props21, [
      "value"
    ]);
    const mergedProps = mergeProps(numberInput.getRootProps(), localProps);
    return (0, import_jsx_runtime191.jsx)(NumberInputProvider, { value: numberInput, children: (0, import_jsx_runtime191.jsx)(ark.div, { ...mergedProps, ref: ref2 }) });
  }
);
NumberInputRootProvider.displayName = "NumberInputRootProvider";

// node_modules/@ark-ui/react/dist/components/number-input/number-input-scrubber.js
var import_jsx_runtime192 = __toESM(require_jsx_runtime(), 1);
var import_react418 = __toESM(require_react(), 1);
var NumberInputScrubber = (0, import_react418.forwardRef)(
  (props21, ref2) => {
    const numberInput = useNumberInputContext();
    const mergedProps = mergeProps(numberInput.getScrubberProps(), props21);
    return (0, import_jsx_runtime192.jsx)(ark.div, { ...mergedProps, ref: ref2 });
  }
);
NumberInputScrubber.displayName = "NumberInputScrubber";

// node_modules/@ark-ui/react/dist/components/number-input/number-input-value-text.js
var import_jsx_runtime193 = __toESM(require_jsx_runtime(), 1);
var import_react420 = __toESM(require_react(), 1);
var NumberInputValueText = (0, import_react420.forwardRef)(
  (props21, ref2) => {
    const { children, ...localProps } = props21;
    const numberInput = useNumberInputContext();
    const mergedProps = mergeProps(numberInput.getValueTextProps(), localProps);
    return (0, import_jsx_runtime193.jsx)(ark.span, { ...mergedProps, ref: ref2, children: children || numberInput.value });
  }
);
NumberInputValueText.displayName = "NumberInputValueText";

// node_modules/@ark-ui/react/dist/components/number-input/number-input.js
var number_input_exports = {};
__export(number_input_exports, {
  Context: () => NumberInputContext,
  Control: () => NumberInputControl,
  DecrementTrigger: () => NumberInputDecrementTrigger,
  IncrementTrigger: () => NumberInputIncrementTrigger,
  Input: () => NumberInputInput,
  Label: () => NumberInputLabel,
  Root: () => NumberInputRoot,
  RootProvider: () => NumberInputRootProvider,
  Scrubber: () => NumberInputScrubber,
  ValueText: () => NumberInputValueText
});

// node_modules/@ark-ui/react/dist/components/pin-input/use-pin-input-context.js
var [PinInputProvider, usePinInputContext] = createContext({
  name: "PinInputContext",
  hookName: "usePinInputContext",
  providerName: "<PinInputProvider />"
});

// node_modules/@ark-ui/react/dist/components/pin-input/pin-input-context.js
var PinInputContext = (props21) => props21.children(usePinInputContext());

// node_modules/@ark-ui/react/dist/components/pin-input/pin-input-control.js
var import_jsx_runtime194 = __toESM(require_jsx_runtime(), 1);
var import_react422 = __toESM(require_react(), 1);
var PinInputControl = (0, import_react422.forwardRef)((props21, ref2) => {
  const pinInput = usePinInputContext();
  const mergedProps = mergeProps(pinInput.getControlProps(), props21);
  return (0, import_jsx_runtime194.jsx)(ark.div, { ...mergedProps, ref: ref2 });
});
PinInputControl.displayName = "PinInputControl";

// node_modules/@ark-ui/react/dist/components/pin-input/pin-input-hidden-input.js
var import_jsx_runtime195 = __toESM(require_jsx_runtime(), 1);
var import_react424 = __toESM(require_react(), 1);
var PinInputHiddenInput = (0, import_react424.forwardRef)(
  (props21, ref2) => {
    const pinInput = usePinInputContext();
    const mergedProps = mergeProps(pinInput.getHiddenInputProps(), props21);
    const field = useFieldContext();
    return (0, import_jsx_runtime195.jsx)(ark.input, { "aria-describedby": field == null ? void 0 : field.ariaDescribedby, ...mergedProps, ref: ref2 });
  }
);
PinInputHiddenInput.displayName = "PinInputHiddenInput";

// node_modules/@ark-ui/react/dist/components/pin-input/pin-input-input.js
var import_jsx_runtime196 = __toESM(require_jsx_runtime(), 1);
var import_react426 = __toESM(require_react(), 1);
var PinInputInput = (0, import_react426.forwardRef)((props21, ref2) => {
  const [inputProps2, localProps] = createSplitProps2()(props21, ["index"]);
  const pinInput = usePinInputContext();
  const mergedProps = mergeProps(pinInput.getInputProps(inputProps2), localProps);
  return (0, import_jsx_runtime196.jsx)(ark.input, { ...mergedProps, ref: ref2 });
});
PinInputInput.displayName = "PinInputInput";

// node_modules/@ark-ui/react/dist/components/pin-input/pin-input-label.js
var import_jsx_runtime197 = __toESM(require_jsx_runtime(), 1);
var import_react428 = __toESM(require_react(), 1);
var PinInputLabel = (0, import_react428.forwardRef)((props21, ref2) => {
  const pinInput = usePinInputContext();
  const mergedProps = mergeProps(pinInput.getLabelProps(), props21);
  return (0, import_jsx_runtime197.jsx)(ark.label, { ...mergedProps, ref: ref2 });
});
PinInputLabel.displayName = "PinInputLabel";

// node_modules/@ark-ui/react/dist/components/pin-input/pin-input-root.js
var import_jsx_runtime198 = __toESM(require_jsx_runtime(), 1);
var import_react432 = __toESM(require_react(), 1);

// node_modules/@zag-js/pin-input/dist/index.mjs
var anatomy19 = createAnatomy("pinInput").parts("root", "label", "input", "control");
var parts21 = anatomy19.build();
var dom19 = createScope({
  getRootId: (ctx) => {
    var _a8;
    return ((_a8 = ctx.ids) == null ? void 0 : _a8.root) ?? `pin-input:${ctx.id}`;
  },
  getInputId: (ctx, id) => {
    var _a8, _b7;
    return ((_b7 = (_a8 = ctx.ids) == null ? void 0 : _a8.input) == null ? void 0 : _b7.call(_a8, id)) ?? `pin-input:${ctx.id}:${id}`;
  },
  getHiddenInputId: (ctx) => {
    var _a8;
    return ((_a8 = ctx.ids) == null ? void 0 : _a8.hiddenInput) ?? `pin-input:${ctx.id}:hidden`;
  },
  getLabelId: (ctx) => {
    var _a8;
    return ((_a8 = ctx.ids) == null ? void 0 : _a8.label) ?? `pin-input:${ctx.id}:label`;
  },
  getControlId: (ctx) => {
    var _a8;
    return ((_a8 = ctx.ids) == null ? void 0 : _a8.control) ?? `pin-input:${ctx.id}:control`;
  },
  getRootEl: (ctx) => dom19.getById(ctx, dom19.getRootId(ctx)),
  getInputEls: (ctx) => {
    const ownerId = CSS.escape(dom19.getRootId(ctx));
    const selector = `input[data-ownedby=${ownerId}]`;
    return queryAll(dom19.getRootEl(ctx), selector);
  },
  getInputEl: (ctx, id) => dom19.getById(ctx, dom19.getInputId(ctx, id)),
  getFocusedInputEl: (ctx) => dom19.getInputEls(ctx)[ctx.focusedIndex],
  getFirstInputEl: (ctx) => dom19.getInputEls(ctx)[0],
  getHiddenInputEl: (ctx) => dom19.getById(ctx, dom19.getHiddenInputId(ctx))
});
var REGEX = {
  numeric: /^[0-9]+$/,
  alphabetic: /^[A-Za-z]+$/,
  alphanumeric: /^[a-zA-Z0-9]+$/i
};
function isValidType(ctx, value) {
  var _a8;
  if (!ctx.type) return true;
  return !!((_a8 = REGEX[ctx.type]) == null ? void 0 : _a8.test(value));
}
function isValidValue(ctx, value) {
  if (!ctx.pattern) return isValidType(ctx, value);
  const regex = new RegExp(ctx.pattern, "g");
  return regex.test(value);
}
function connect20(state2, send, normalize2) {
  const complete = state2.context.isValueComplete;
  const invalid = state2.context.invalid;
  const focusedIndex = state2.context.focusedIndex;
  const translations = state2.context.translations;
  function focus() {
    var _a8;
    (_a8 = dom19.getFirstInputEl(state2.context)) == null ? void 0 : _a8.focus();
  }
  return {
    focus,
    value: state2.context.value,
    valueAsString: state2.context.valueAsString,
    complete,
    setValue(value) {
      if (!Array.isArray(value)) {
        invariant("[pin-input/setValue] value must be an array");
      }
      send({ type: "VALUE.SET", value });
    },
    clearValue() {
      send({ type: "VALUE.CLEAR" });
    },
    setValueAtIndex(index, value) {
      send({ type: "VALUE.SET", value, index });
    },
    getRootProps() {
      return normalize2.element({
        dir: state2.context.dir,
        ...parts21.root.attrs,
        id: dom19.getRootId(state2.context),
        "data-invalid": dataAttr(invalid),
        "data-disabled": dataAttr(state2.context.disabled),
        "data-complete": dataAttr(complete),
        "data-readonly": dataAttr(state2.context.readOnly)
      });
    },
    getLabelProps() {
      return normalize2.label({
        ...parts21.label.attrs,
        dir: state2.context.dir,
        htmlFor: dom19.getHiddenInputId(state2.context),
        id: dom19.getLabelId(state2.context),
        "data-invalid": dataAttr(invalid),
        "data-disabled": dataAttr(state2.context.disabled),
        "data-complete": dataAttr(complete),
        "data-readonly": dataAttr(state2.context.readOnly),
        onClick(event) {
          event.preventDefault();
          focus();
        }
      });
    },
    getHiddenInputProps() {
      return normalize2.input({
        "aria-hidden": true,
        type: "text",
        tabIndex: -1,
        id: dom19.getHiddenInputId(state2.context),
        readOnly: state2.context.readOnly,
        disabled: state2.context.disabled,
        required: state2.context.required,
        name: state2.context.name,
        form: state2.context.form,
        style: visuallyHiddenStyle,
        maxLength: state2.context.valueLength,
        defaultValue: state2.context.valueAsString
      });
    },
    getControlProps() {
      return normalize2.element({
        ...parts21.control.attrs,
        dir: state2.context.dir,
        id: dom19.getControlId(state2.context)
      });
    },
    getInputProps(props21) {
      const { index } = props21;
      const inputType = state2.context.type === "numeric" ? "tel" : "text";
      return normalize2.input({
        ...parts21.input.attrs,
        dir: state2.context.dir,
        disabled: state2.context.disabled,
        "data-disabled": dataAttr(state2.context.disabled),
        "data-complete": dataAttr(complete),
        id: dom19.getInputId(state2.context, index.toString()),
        "data-ownedby": dom19.getRootId(state2.context),
        "aria-label": translations.inputLabel(index, state2.context.valueLength),
        inputMode: state2.context.otp || state2.context.type === "numeric" ? "numeric" : "text",
        "aria-invalid": ariaAttr(invalid),
        "data-invalid": dataAttr(invalid),
        type: state2.context.mask ? "password" : inputType,
        defaultValue: state2.context.value[index] || "",
        readOnly: state2.context.readOnly,
        autoCapitalize: "none",
        autoComplete: state2.context.otp ? "one-time-code" : "off",
        placeholder: focusedIndex === index ? "" : state2.context.placeholder,
        onBeforeInput(event) {
          try {
            const value = getBeforeInputValue(event);
            const isValid = isValidValue(state2.context, value);
            if (!isValid) {
              send({ type: "VALUE.INVALID", value });
              event.preventDefault();
            }
            if (value.length > 2) {
              event.currentTarget.setSelectionRange(0, 1, "forward");
            }
          } catch {
          }
        },
        onChange(event) {
          const evt = getNativeEvent(event);
          const { value } = event.currentTarget;
          if (evt.inputType === "insertFromPaste" || value.length > 2) {
            send({ type: "INPUT.PASTE", value });
            event.currentTarget.value = value[0];
            event.preventDefault();
            return;
          }
          if (evt.inputType === "deleteContentBackward") {
            send("INPUT.BACKSPACE");
            return;
          }
          send({ type: "INPUT.CHANGE", value, index });
        },
        onKeyDown(event) {
          if (event.defaultPrevented) return;
          if (isComposingEvent(event)) return;
          if (isModifierKey(event)) return;
          const keyMap2 = {
            Backspace() {
              send("INPUT.BACKSPACE");
            },
            Delete() {
              send("INPUT.DELETE");
            },
            ArrowLeft() {
              send("INPUT.ARROW_LEFT");
            },
            ArrowRight() {
              send("INPUT.ARROW_RIGHT");
            },
            Enter() {
              send("INPUT.ENTER");
            }
          };
          const exec2 = keyMap2[getEventKey(event, state2.context)];
          if (exec2) {
            exec2(event);
            event.preventDefault();
          }
        },
        onFocus() {
          send({ type: "INPUT.FOCUS", index });
        },
        onBlur() {
          send({ type: "INPUT.BLUR", index });
        }
      });
    }
  };
}
function machine20(userContext) {
  const ctx = compact2(userContext);
  return createMachine(
    {
      id: "pin-input",
      initial: "idle",
      context: {
        value: [],
        placeholder: "○",
        otp: false,
        type: "numeric",
        ...ctx,
        focusedIndex: -1,
        translations: {
          inputLabel: (index, length) => `pin code ${index + 1} of ${length}`,
          ...ctx.translations
        }
      },
      computed: {
        valueLength: (ctx2) => ctx2.value.length,
        filledValueLength: (ctx2) => ctx2.value.filter((v) => (v == null ? void 0 : v.trim()) !== "").length,
        isValueComplete: (ctx2) => ctx2.valueLength === ctx2.filledValueLength,
        valueAsString: (ctx2) => ctx2.value.join(""),
        focusedValue: (ctx2) => ctx2.value[ctx2.focusedIndex] || ""
      },
      entry: choose([
        {
          guard: "autoFocus",
          actions: ["setupValue", "setFocusIndexToFirst"]
        },
        { actions: ["setupValue"] }
      ]),
      watch: {
        focusedIndex: ["focusInput", "selectInputIfNeeded"],
        value: ["syncInputElements"],
        isValueComplete: ["invokeOnComplete", "blurFocusedInputIfNeeded"]
      },
      on: {
        "VALUE.SET": [
          {
            guard: "hasIndex",
            actions: ["setValueAtIndex"]
          },
          { actions: ["setValue"] }
        ],
        "VALUE.CLEAR": {
          actions: ["clearValue", "setFocusIndexToFirst"]
        }
      },
      states: {
        idle: {
          on: {
            "INPUT.FOCUS": {
              target: "focused",
              actions: "setFocusedIndex"
            }
          }
        },
        focused: {
          on: {
            "INPUT.CHANGE": [
              {
                guard: "isFinalValue",
                actions: ["setFocusedValue", "syncInputValue"]
              },
              {
                actions: ["setFocusedValue", "setNextFocusedIndex", "syncInputValue"]
              }
            ],
            "INPUT.PASTE": {
              actions: ["setPastedValue", "setLastValueFocusIndex"]
            },
            "INPUT.BLUR": {
              target: "idle",
              actions: "clearFocusedIndex"
            },
            "INPUT.DELETE": {
              guard: "hasValue",
              actions: "clearFocusedValue"
            },
            "INPUT.ARROW_LEFT": {
              actions: "setPrevFocusedIndex"
            },
            "INPUT.ARROW_RIGHT": {
              actions: "setNextFocusedIndex"
            },
            "INPUT.BACKSPACE": [
              {
                guard: "hasValue",
                actions: ["clearFocusedValue"]
              },
              {
                actions: ["setPrevFocusedIndex", "clearFocusedValue"]
              }
            ],
            "INPUT.ENTER": {
              guard: "isValueComplete",
              actions: "requestFormSubmit"
            },
            "VALUE.INVALID": {
              actions: "invokeOnInvalid"
            }
          }
        }
      }
    },
    {
      guards: {
        autoFocus: (ctx2) => !!ctx2.autoFocus,
        isValueEmpty: (_ctx, evt) => evt.value === "",
        hasValue: (ctx2) => ctx2.value[ctx2.focusedIndex] !== "",
        isValueComplete: (ctx2) => ctx2.isValueComplete,
        isFinalValue: (ctx2) => ctx2.filledValueLength + 1 === ctx2.valueLength && ctx2.value.findIndex((v) => v.trim() === "") === ctx2.focusedIndex,
        hasIndex: (_ctx, evt) => evt.index !== void 0,
        isDisabled: (ctx2) => !!ctx2.disabled
      },
      actions: {
        setupValue(ctx2) {
          if (ctx2.value.length) return;
          const inputEls = dom19.getInputEls(ctx2);
          const emptyValues = Array.from({ length: inputEls.length }).fill("");
          assignValue(ctx2, emptyValues);
        },
        focusInput(ctx2) {
          var _a8;
          if (ctx2.focusedIndex === -1) return;
          (_a8 = dom19.getFocusedInputEl(ctx2)) == null ? void 0 : _a8.focus({ preventScroll: true });
        },
        selectInputIfNeeded(ctx2) {
          if (!ctx2.selectOnFocus || ctx2.focusedIndex === -1) return;
          raf(() => {
            var _a8;
            (_a8 = dom19.getFocusedInputEl(ctx2)) == null ? void 0 : _a8.select();
          });
        },
        invokeOnComplete(ctx2) {
          var _a8;
          if (!ctx2.isValueComplete) return;
          (_a8 = ctx2.onValueComplete) == null ? void 0 : _a8.call(ctx2, {
            value: Array.from(ctx2.value),
            valueAsString: ctx2.valueAsString
          });
        },
        invokeOnInvalid(ctx2, evt) {
          var _a8;
          (_a8 = ctx2.onValueInvalid) == null ? void 0 : _a8.call(ctx2, {
            value: evt.value,
            index: ctx2.focusedIndex
          });
        },
        clearFocusedIndex(ctx2) {
          ctx2.focusedIndex = -1;
        },
        setFocusedIndex(ctx2, evt) {
          ctx2.focusedIndex = evt.index;
        },
        setValue(ctx2, evt) {
          set16.value(ctx2, evt.value);
        },
        setFocusedValue(ctx2, evt) {
          const nextValue = getNextValue(ctx2.focusedValue, evt.value);
          set16.valueAtIndex(ctx2, ctx2.focusedIndex, nextValue);
        },
        revertInputValue(ctx2) {
          const inputEl = dom19.getFocusedInputEl(ctx2);
          dom19.setValue(inputEl, ctx2.focusedValue);
        },
        syncInputValue(ctx2, evt) {
          const inputEl = dom19.getInputEl(ctx2, evt.index.toString());
          dom19.setValue(inputEl, ctx2.value[evt.index]);
        },
        syncInputElements(ctx2) {
          const inputEls = dom19.getInputEls(ctx2);
          inputEls.forEach((inputEl, index) => {
            dom19.setValue(inputEl, ctx2.value[index]);
          });
        },
        setPastedValue(ctx2, evt) {
          raf(() => {
            const startIndex = Math.min(ctx2.focusedIndex, ctx2.filledValueLength);
            const left = startIndex > 0 ? ctx2.valueAsString.substring(0, ctx2.focusedIndex) : "";
            const right = evt.value.substring(0, ctx2.valueLength - startIndex);
            const value = left + right;
            set16.value(ctx2, value.split(""));
          });
        },
        setValueAtIndex(ctx2, evt) {
          const nextValue = getNextValue(ctx2.focusedValue, evt.value);
          set16.valueAtIndex(ctx2, evt.index, nextValue);
        },
        clearValue(ctx2) {
          const nextValue = Array.from({ length: ctx2.valueLength }).fill("");
          set16.value(ctx2, nextValue);
        },
        clearFocusedValue(ctx2) {
          set16.valueAtIndex(ctx2, ctx2.focusedIndex, "");
        },
        setFocusIndexToFirst(ctx2) {
          ctx2.focusedIndex = 0;
        },
        setNextFocusedIndex(ctx2) {
          ctx2.focusedIndex = Math.min(ctx2.focusedIndex + 1, ctx2.valueLength - 1);
        },
        setPrevFocusedIndex(ctx2) {
          ctx2.focusedIndex = Math.max(ctx2.focusedIndex - 1, 0);
        },
        setLastValueFocusIndex(ctx2) {
          raf(() => {
            ctx2.focusedIndex = Math.min(ctx2.filledValueLength, ctx2.valueLength - 1);
          });
        },
        blurFocusedInputIfNeeded(ctx2) {
          if (!ctx2.blurOnComplete) return;
          raf(() => {
            var _a8;
            (_a8 = dom19.getFocusedInputEl(ctx2)) == null ? void 0 : _a8.blur();
          });
        },
        requestFormSubmit(ctx2) {
          var _a8;
          if (!ctx2.name || !ctx2.isValueComplete) return;
          const inputEl = dom19.getHiddenInputEl(ctx2);
          (_a8 = inputEl == null ? void 0 : inputEl.form) == null ? void 0 : _a8.requestSubmit();
        }
      }
    }
  );
}
function assignValue(ctx, value) {
  const arr = Array.isArray(value) ? value : value.split("").filter(Boolean);
  arr.forEach((value2, index) => {
    ctx.value[index] = value2;
  });
}
function getNextValue(current, next2) {
  let nextValue = next2;
  if (current[0] === next2[0]) nextValue = next2[1];
  else if (current[0] === next2[1]) nextValue = next2[0];
  return nextValue.split("")[nextValue.length - 1];
}
var invoke13 = {
  change(ctx) {
    var _a8;
    (_a8 = ctx.onValueChange) == null ? void 0 : _a8.call(ctx, {
      value: Array.from(ctx.value),
      valueAsString: ctx.valueAsString
    });
    const inputEl = dom19.getHiddenInputEl(ctx);
    dispatchInputValueEvent(inputEl, { value: ctx.valueAsString });
  }
};
var set16 = {
  value(ctx, value) {
    if (isEqual(ctx.value, value)) return;
    assignValue(ctx, value);
    invoke13.change(ctx);
  },
  valueAtIndex(ctx, index, value) {
    if (isEqual(ctx.value[index], value)) return;
    ctx.value[index] = value;
    invoke13.change(ctx);
  }
};

// node_modules/@ark-ui/react/dist/components/pin-input/use-pin-input.js
var import_react430 = __toESM(require_react(), 1);
var usePinInput = (props21 = {}) => {
  const { getRootNode } = useEnvironmentContext();
  const { dir } = useLocaleContext();
  const field = useFieldContext();
  const initialContext = {
    id: (0, import_react430.useId)(),
    ids: {
      label: field == null ? void 0 : field.ids.label,
      hiddenInput: field == null ? void 0 : field.ids.control
    },
    disabled: field == null ? void 0 : field.disabled,
    readOnly: field == null ? void 0 : field.readOnly,
    required: field == null ? void 0 : field.required,
    invalid: field == null ? void 0 : field.invalid,
    dir,
    getRootNode,
    value: props21.defaultValue,
    ...props21
  };
  const context = {
    ...initialContext,
    value: props21.value,
    onValueChange: useEvent(props21.onValueChange, { sync: true }),
    onValueComplete: useEvent(props21.onValueComplete),
    onValueInvalid: useEvent(props21.onValueInvalid)
  };
  const [state2, send] = useMachine(machine20(initialContext), { context });
  return connect20(state2, send, normalizeProps);
};

// node_modules/@ark-ui/react/dist/components/pin-input/pin-input-root.js
var PinInputRoot = (0, import_react432.forwardRef)((props21, ref2) => {
  const [usePinInputProps, localProps] = createSplitProps2()(props21, [
    "autoFocus",
    "blurOnComplete",
    "defaultValue",
    "disabled",
    "form",
    "id",
    "ids",
    "invalid",
    "mask",
    "name",
    "onValueChange",
    "onValueComplete",
    "onValueInvalid",
    "otp",
    "pattern",
    "placeholder",
    "readOnly",
    "required",
    "selectOnFocus",
    "translations",
    "type",
    "value"
  ]);
  const pinInput = usePinInput(usePinInputProps);
  const mergedProps = mergeProps(pinInput.getRootProps(), localProps);
  return (0, import_jsx_runtime198.jsx)(PinInputProvider, { value: pinInput, children: (0, import_jsx_runtime198.jsx)(ark.div, { ...mergedProps, ref: ref2 }) });
});
PinInputRoot.displayName = "PinInputRoot";

// node_modules/@ark-ui/react/dist/components/pin-input/pin-input-root-provider.js
var import_jsx_runtime199 = __toESM(require_jsx_runtime(), 1);
var import_react434 = __toESM(require_react(), 1);
var PinInputRootProvider = (0, import_react434.forwardRef)(
  (props21, ref2) => {
    const [{ value: pinInput }, localProps] = createSplitProps2()(props21, [
      "value"
    ]);
    const mergedProps = mergeProps(pinInput.getRootProps(), localProps);
    return (0, import_jsx_runtime199.jsx)(PinInputProvider, { value: pinInput, children: (0, import_jsx_runtime199.jsx)(ark.div, { ...mergedProps, ref: ref2 }) });
  }
);
PinInputRootProvider.displayName = "PinInputRootProvider";

// node_modules/@ark-ui/react/dist/components/pin-input/pin-input.js
var pin_input_exports = {};
__export(pin_input_exports, {
  Context: () => PinInputContext,
  Control: () => PinInputControl,
  HiddenInput: () => PinInputHiddenInput,
  Input: () => PinInputInput,
  Label: () => PinInputLabel,
  Root: () => PinInputRoot,
  RootProvider: () => PinInputRootProvider
});

// node_modules/@ark-ui/react/dist/components/progress/progress-circle.js
var import_jsx_runtime200 = __toESM(require_jsx_runtime(), 1);
var import_react436 = __toESM(require_react(), 1);

// node_modules/@ark-ui/react/dist/components/progress/use-progress-context.js
var [ProgressProvider, useProgressContext] = createContext({
  name: "ProgressContext",
  hookName: "useProgressContext",
  providerName: "<ProgressProvider />"
});

// node_modules/@ark-ui/react/dist/components/progress/progress-circle.js
var ProgressCircle = (0, import_react436.forwardRef)((props21, ref2) => {
  const progress = useProgressContext();
  const mergedProps = mergeProps(progress.getCircleProps(), props21);
  return (0, import_jsx_runtime200.jsx)(ark.svg, { ref: ref2, ...mergedProps });
});
ProgressCircle.displayName = "ProgressCircle";

// node_modules/@ark-ui/react/dist/components/progress/progress-circle-range.js
var import_jsx_runtime201 = __toESM(require_jsx_runtime(), 1);
var import_react438 = __toESM(require_react(), 1);
var ProgressCircleRange = (0, import_react438.forwardRef)(
  (props21, ref2) => {
    const progress = useProgressContext();
    const mergedProps = mergeProps(progress.getCircleRangeProps(), props21);
    return (0, import_jsx_runtime201.jsx)(ark.circle, { ref: ref2, ...mergedProps });
  }
);
ProgressCircleRange.displayName = "ProgressCircleRange";

// node_modules/@ark-ui/react/dist/components/progress/progress-circle-track.js
var import_jsx_runtime202 = __toESM(require_jsx_runtime(), 1);
var import_react440 = __toESM(require_react(), 1);
var ProgressCircleTrack = (0, import_react440.forwardRef)(
  (props21, ref2) => {
    const progress = useProgressContext();
    const mergedProps = mergeProps(progress.getCircleTrackProps(), props21);
    return (0, import_jsx_runtime202.jsx)(ark.circle, { ref: ref2, ...mergedProps });
  }
);
ProgressCircleTrack.displayName = "ProgressCircleTrack";

// node_modules/@ark-ui/react/dist/components/progress/progress-context.js
var ProgressContext = (props21) => props21.children(useProgressContext());

// node_modules/@ark-ui/react/dist/components/progress/progress-label.js
var import_jsx_runtime203 = __toESM(require_jsx_runtime(), 1);
var import_react442 = __toESM(require_react(), 1);
var ProgressLabel = (0, import_react442.forwardRef)((props21, ref2) => {
  const progress = useProgressContext();
  const mergedProps = mergeProps(progress.getLabelProps(), props21);
  return (0, import_jsx_runtime203.jsx)(ark.label, { ...mergedProps, ref: ref2 });
});
ProgressLabel.displayName = "ProgressLabel";

// node_modules/@ark-ui/react/dist/components/progress/progress-range.js
var import_jsx_runtime204 = __toESM(require_jsx_runtime(), 1);
var import_react444 = __toESM(require_react(), 1);
var ProgressRange = (0, import_react444.forwardRef)((props21, ref2) => {
  const progress = useProgressContext();
  const mergedProps = mergeProps(progress.getRangeProps(), props21);
  return (0, import_jsx_runtime204.jsx)(ark.div, { ...mergedProps, ref: ref2 });
});
ProgressRange.displayName = "ProgressRange";

// node_modules/@ark-ui/react/dist/components/progress/progress-root.js
var import_jsx_runtime205 = __toESM(require_jsx_runtime(), 1);
var import_react448 = __toESM(require_react(), 1);

// node_modules/@zag-js/progress/dist/index.mjs
var anatomy20 = createAnatomy("progress").parts(
  "root",
  "label",
  "track",
  "range",
  "valueText",
  "view",
  "circle",
  "circleTrack",
  "circleRange"
);
var parts22 = anatomy20.build();
var dom20 = createScope({
  getRootId: (ctx) => {
    var _a8;
    return ((_a8 = ctx.ids) == null ? void 0 : _a8.root) ?? `progress-${ctx.id}`;
  },
  getTrackId: (ctx) => {
    var _a8;
    return ((_a8 = ctx.ids) == null ? void 0 : _a8.track) ?? `progress-${ctx.id}-track`;
  },
  getLabelId: (ctx) => {
    var _a8;
    return ((_a8 = ctx.ids) == null ? void 0 : _a8.label) ?? `progress-${ctx.id}-label`;
  },
  getCircleId: (ctx) => {
    var _a8;
    return ((_a8 = ctx.ids) == null ? void 0 : _a8.circle) ?? `progress-${ctx.id}-circle`;
  }
});
function connect21(state2, send, normalize2) {
  const percent = state2.context.percent;
  const percentAsString = state2.context.isIndeterminate ? "" : `${percent}%`;
  const max4 = state2.context.max;
  const min4 = state2.context.min;
  const orientation = state2.context.orientation;
  const translations = state2.context.translations;
  const indeterminate = state2.context.isIndeterminate;
  const value = state2.context.value;
  const valueAsString = translations.value({ value, max: max4, percent, min: min4 });
  const progressState = getProgressState(value, max4);
  const progressbarProps = {
    role: "progressbar",
    "aria-label": valueAsString,
    "data-max": max4,
    "aria-valuemin": min4,
    "aria-valuemax": max4,
    "aria-valuenow": value ?? void 0,
    "data-orientation": orientation,
    "data-state": progressState
  };
  const circleProps = getCircleProps(state2.context);
  return {
    value,
    valueAsString,
    min: min4,
    max: max4,
    percent,
    percentAsString,
    indeterminate,
    setValue(value2) {
      send({ type: "VALUE.SET", value: value2 });
    },
    setToMax() {
      send({ type: "VALUE.SET", value: max4 });
    },
    setToMin() {
      send({ type: "VALUE.SET", value: min4 });
    },
    getRootProps() {
      return normalize2.element({
        dir: state2.context.dir,
        ...parts22.root.attrs,
        id: dom20.getRootId(state2.context),
        "data-max": max4,
        "data-value": value ?? void 0,
        "data-state": progressState,
        "data-orientation": orientation,
        style: {
          "--percent": indeterminate ? void 0 : percent
        }
      });
    },
    getLabelProps() {
      return normalize2.element({
        dir: state2.context.dir,
        id: dom20.getLabelId(state2.context),
        ...parts22.label.attrs,
        "data-orientation": orientation
      });
    },
    getValueTextProps() {
      return normalize2.element({
        dir: state2.context.dir,
        "aria-live": "polite",
        ...parts22.valueText.attrs
      });
    },
    getTrackProps() {
      return normalize2.element({
        dir: state2.context.dir,
        id: dom20.getTrackId(state2.context),
        ...parts22.track.attrs,
        ...progressbarProps
      });
    },
    getRangeProps() {
      return normalize2.element({
        dir: state2.context.dir,
        ...parts22.range.attrs,
        "data-orientation": orientation,
        "data-state": progressState,
        style: {
          [state2.context.isHorizontal ? "width" : "height"]: indeterminate ? void 0 : `${percent}%`
        }
      });
    },
    getCircleProps() {
      return normalize2.element({
        dir: state2.context.dir,
        id: dom20.getCircleId(state2.context),
        ...parts22.circle.attrs,
        ...progressbarProps,
        ...circleProps.root
      });
    },
    getCircleTrackProps() {
      return normalize2.element({
        dir: state2.context.dir,
        "data-orientation": orientation,
        ...parts22.circleTrack.attrs,
        ...circleProps.track
      });
    },
    getCircleRangeProps() {
      return normalize2.element({
        dir: state2.context.dir,
        ...parts22.circleRange.attrs,
        ...circleProps.range,
        "data-state": progressState
      });
    },
    getViewProps(props22) {
      return normalize2.element({
        dir: state2.context.dir,
        ...parts22.view.attrs,
        "data-state": props22.state,
        hidden: props22.state !== progressState
      });
    }
  };
}
function getProgressState(value, maxValue2) {
  return value == null ? "indeterminate" : value === maxValue2 ? "complete" : "loading";
}
function getCircleProps(ctx) {
  const circleProps = {
    style: {
      "--radius": "calc(var(--size) / 2 - var(--thickness) / 2)",
      cx: "calc(var(--size) / 2)",
      cy: "calc(var(--size) / 2)",
      r: "var(--radius)",
      fill: "transparent",
      strokeWidth: "var(--thickness)"
    }
  };
  return {
    root: {
      style: {
        width: "var(--size)",
        height: "var(--size)"
      }
    },
    track: circleProps,
    range: {
      opacity: ctx.value === 0 ? 0 : void 0,
      style: {
        ...circleProps.style,
        "--percent": ctx.percent,
        "--circumference": `calc(2 * 3.14159 * var(--radius))`,
        "--offset": `calc(var(--circumference) * (100 - var(--percent)) / 100)`,
        strokeDashoffset: `calc(var(--circumference) * ((100 - var(--percent)) / 100))`,
        strokeDasharray: ctx.isIndeterminate ? void 0 : `var(--circumference)`,
        transformOrigin: "center",
        transform: "rotate(-90deg)"
      }
    }
  };
}
function midValue(min4, max4) {
  return min4 + (max4 - min4) / 2;
}
function machine21(userContext) {
  const ctx = compact2(userContext);
  return createMachine(
    {
      id: "progress",
      initial: "idle",
      context: {
        max: ctx.max ?? 100,
        min: ctx.min ?? 0,
        value: midValue(ctx.min ?? 0, ctx.max ?? 100),
        orientation: "horizontal",
        translations: {
          value: ({ percent }) => percent === -1 ? "loading..." : `${percent} percent`,
          ...ctx.translations
        },
        ...ctx
      },
      created: ["validateContext"],
      computed: {
        isIndeterminate: (ctx2) => ctx2.value === null,
        percent(ctx2) {
          if (!isNumber(ctx2.value)) return -1;
          return Math.round((ctx2.value - ctx2.min) / (ctx2.max - ctx2.min) * 100);
        },
        isAtMax: (ctx2) => ctx2.value === ctx2.max,
        isHorizontal: (ctx2) => ctx2.orientation === "horizontal",
        isRtl: (ctx2) => ctx2.dir === "rtl"
      },
      states: {
        idle: {
          on: {
            "VALUE.SET": {
              actions: ["setValue"]
            }
          }
        }
      }
    },
    {
      actions: {
        setValue: (ctx2, evt) => {
          set17.value(ctx2, evt.value);
        },
        validateContext: (ctx2) => {
          if (ctx2.value == null) return;
          if (!isValidNumber(ctx2.max)) {
            throw new Error(`[progress] The max value passed \`${ctx2.max}\` is not a valid number`);
          }
          if (!isValidMax(ctx2.value, ctx2.max)) {
            throw new Error(`[progress] The value passed \`${ctx2.value}\` exceeds the max value \`${ctx2.max}\``);
          }
          if (!isValidMin(ctx2.value, ctx2.min)) {
            throw new Error(`[progress] The value passed \`${ctx2.value}\` exceeds the min value \`${ctx2.min}\``);
          }
        }
      }
    }
  );
}
function isValidNumber(max4) {
  return isNumber(max4) && !isNaN(max4);
}
function isValidMax(value, max4) {
  return isValidNumber(value) && value <= max4;
}
function isValidMin(value, min4) {
  return isValidNumber(value) && value >= min4;
}
var set17 = {
  value(ctx, value) {
    var _a8;
    if (isEqual(ctx.value, value)) return;
    ctx.value = value === null ? null : Math.max(0, Math.min(value, ctx.max));
    (_a8 = ctx.onValueChange) == null ? void 0 : _a8.call(ctx, { value });
  }
};
var props18 = createProps2()([
  "dir",
  "getRootNode",
  "id",
  "ids",
  "max",
  "min",
  "orientation",
  "translations",
  "value",
  "onValueChange"
]);
var splitProps19 = createSplitProps(props18);

// node_modules/@ark-ui/react/dist/components/progress/use-progress.js
var import_react446 = __toESM(require_react(), 1);
var useProgress = (props21 = {}) => {
  const { getRootNode } = useEnvironmentContext();
  const { dir } = useLocaleContext();
  const initialContext = {
    id: (0, import_react446.useId)(),
    dir,
    getRootNode,
    value: props21.defaultValue,
    ...props21
  };
  const context = {
    ...initialContext,
    value: props21.value,
    onValueChange: useEvent(props21.onValueChange, { sync: true })
  };
  const [state2, send] = useMachine(machine21(initialContext), { context });
  return connect21(state2, send, normalizeProps);
};

// node_modules/@ark-ui/react/dist/components/progress/progress-root.js
var ProgressRoot = (0, import_react448.forwardRef)((props21, ref2) => {
  const [progressProps, localProps] = createSplitProps2()(props21, [
    "defaultValue",
    "id",
    "ids",
    "max",
    "min",
    "onValueChange",
    "orientation",
    "translations",
    "value"
  ]);
  const progress = useProgress(progressProps);
  const mergedProps = mergeProps(progress.getRootProps(), localProps);
  return (0, import_jsx_runtime205.jsx)(ProgressProvider, { value: progress, children: (0, import_jsx_runtime205.jsx)(ark.div, { ...mergedProps, ref: ref2 }) });
});
ProgressRoot.displayName = "ProgressRoot";

// node_modules/@ark-ui/react/dist/components/progress/progress-root-provider.js
var import_jsx_runtime206 = __toESM(require_jsx_runtime(), 1);
var import_react450 = __toESM(require_react(), 1);
var ProgressRootProvider = (0, import_react450.forwardRef)(
  (props21, ref2) => {
    const [{ value: progress }, localProps] = createSplitProps2()(props21, [
      "value"
    ]);
    const mergedProps = mergeProps(progress.getRootProps(), localProps);
    return (0, import_jsx_runtime206.jsx)(ProgressProvider, { value: progress, children: (0, import_jsx_runtime206.jsx)(ark.div, { ...mergedProps, ref: ref2 }) });
  }
);
ProgressRootProvider.displayName = "ProgressRootProvider";

// node_modules/@ark-ui/react/dist/components/progress/progress-track.js
var import_jsx_runtime207 = __toESM(require_jsx_runtime(), 1);
var import_react452 = __toESM(require_react(), 1);
var ProgressTrack = (0, import_react452.forwardRef)((props21, ref2) => {
  const progress = useProgressContext();
  const mergedProps = mergeProps(progress.getTrackProps(), props21);
  return (0, import_jsx_runtime207.jsx)(ark.div, { ...mergedProps, ref: ref2 });
});
ProgressTrack.displayName = "ProgressTrack";

// node_modules/@ark-ui/react/dist/components/progress/progress-value-text.js
var import_jsx_runtime208 = __toESM(require_jsx_runtime(), 1);
var import_react454 = __toESM(require_react(), 1);
var ProgressValueText = (0, import_react454.forwardRef)(
  (props21, ref2) => {
    const { children, ...rest } = props21;
    const progress = useProgressContext();
    const mergedProps = mergeProps(progress.getValueTextProps(), rest);
    return (0, import_jsx_runtime208.jsx)(ark.span, { ...mergedProps, ref: ref2, children: children || progress.percentAsString });
  }
);
ProgressValueText.displayName = "ProgressValueText";

// node_modules/@ark-ui/react/dist/components/progress/progress-view.js
var import_jsx_runtime209 = __toESM(require_jsx_runtime(), 1);
var import_react456 = __toESM(require_react(), 1);
var ProgressView = (0, import_react456.forwardRef)((props21, ref2) => {
  const [viewProps2, localProps] = createSplitProps2()(props21, ["state"]);
  const progress = useProgressContext();
  const mergedProps = mergeProps(progress.getViewProps(viewProps2), localProps);
  return (0, import_jsx_runtime209.jsx)(ark.span, { ...mergedProps, ref: ref2 });
});
ProgressView.displayName = "ProgressView";

// node_modules/@ark-ui/react/dist/components/progress/progress.js
var progress_exports = {};
__export(progress_exports, {
  Circle: () => ProgressCircle,
  CircleRange: () => ProgressCircleRange,
  CircleTrack: () => ProgressCircleTrack,
  Context: () => ProgressContext,
  Label: () => ProgressLabel,
  Range: () => ProgressRange,
  Root: () => ProgressRoot,
  RootProvider: () => ProgressRootProvider,
  Track: () => ProgressTrack,
  ValueText: () => ProgressValueText,
  View: () => ProgressView
});

// node_modules/@ark-ui/react/dist/components/qr-code/use-qr-code-context.js
var [QrCodeProvider, useQrCodeContext] = createContext({
  name: "QrCodeContext",
  hookName: "useQrCodeContext",
  providerName: "<QrCodeProvider />"
});

// node_modules/@ark-ui/react/dist/components/qr-code/qr-code-context.js
var QrCodeContext = (props21) => props21.children(useQrCodeContext());

// node_modules/@ark-ui/react/dist/components/qr-code/qr-code-download-trigger.js
var import_jsx_runtime210 = __toESM(require_jsx_runtime(), 1);
var import_react458 = __toESM(require_react(), 1);
var QrCodeDownloadTrigger = (0, import_react458.forwardRef)(
  (props21, ref2) => {
    const [downloadTriggerProps, localProps] = createSplitProps2()(props21, [
      "fileName",
      "mimeType",
      "quality"
    ]);
    const qrCode = useQrCodeContext();
    const mergedProps = mergeProps(qrCode.getDownloadTriggerProps(downloadTriggerProps), localProps);
    return (0, import_jsx_runtime210.jsx)(ark.button, { ...mergedProps, ref: ref2 });
  }
);
QrCodeDownloadTrigger.displayName = "QrCodeDownloadTrigger";

// node_modules/@ark-ui/react/dist/components/qr-code/qr-code-frame.js
var import_jsx_runtime211 = __toESM(require_jsx_runtime(), 1);
var import_react460 = __toESM(require_react(), 1);
var QrCodeFrame = (0, import_react460.forwardRef)((props21, ref2) => {
  const qrCode = useQrCodeContext();
  const mergedProps = mergeProps(qrCode.getFrameProps(), props21);
  return (0, import_jsx_runtime211.jsx)(ark.svg, { ...mergedProps, ref: ref2 });
});
QrCodeFrame.displayName = "QrCodeFrame";

// node_modules/@ark-ui/react/dist/components/qr-code/qr-code-overlay.js
var import_jsx_runtime212 = __toESM(require_jsx_runtime(), 1);
var import_react462 = __toESM(require_react(), 1);
var QrCodeOverlay = (0, import_react462.forwardRef)((props21, ref2) => {
  const qrCode = useQrCodeContext();
  const mergedProps = mergeProps(qrCode.getOverlayProps(), props21);
  return (0, import_jsx_runtime212.jsx)(ark.div, { ...mergedProps, ref: ref2 });
});
QrCodeOverlay.displayName = "QrCodeOverlay";

// node_modules/@ark-ui/react/dist/components/qr-code/qr-code-pattern.js
var import_jsx_runtime213 = __toESM(require_jsx_runtime(), 1);
var import_react464 = __toESM(require_react(), 1);
var QrCodePattern = (0, import_react464.forwardRef)((props21, ref2) => {
  const qrCode = useQrCodeContext();
  const mergedProps = mergeProps(qrCode.getPatternProps(), props21);
  return (0, import_jsx_runtime213.jsx)(ark.path, { ...mergedProps, ref: ref2 });
});
QrCodePattern.displayName = "QrCodePattern";

// node_modules/@ark-ui/react/dist/components/qr-code/qr-code-root.js
var import_jsx_runtime214 = __toESM(require_jsx_runtime(), 1);
var import_react468 = __toESM(require_react(), 1);

// node_modules/proxy-memoize/dist/memoize.js
var targetCache2 = /* @__PURE__ */ new WeakMap();
var HAS_KEY_PROPERTY2 = "h";
var ALL_OWN_KEYS_PROPERTY2 = "w";
var HAS_OWN_KEY_PROPERTY2 = "o";
var KEYS_PROPERTY2 = "k";
var trackMemoUntrackedObjSet = /* @__PURE__ */ new WeakSet();
var isObject6 = (x) => typeof x === "object" && x !== null;
var untrack = (x, seen) => {
  if (!isObject6(x))
    return x;
  const untrackedObj = getUntracked(x);
  if (untrackedObj) {
    trackMemo(x);
    trackMemoUntrackedObjSet.add(untrackedObj);
    return untrackedObj;
  }
  if (!seen.has(x)) {
    seen.add(x);
    Object.entries(x).forEach(([k, v]) => {
      const vv = untrack(v, seen);
      if (!Object.is(vv, v))
        x[k] = vv;
    });
  }
  return x;
};
var touchAffected = (dst, src, affected) => {
  var _a8, _b7, _c6;
  if (!isObject6(dst) || !isObject6(src))
    return;
  const untrackedObj = getUntracked(src);
  const used = affected.get(untrackedObj || src);
  if (!used) {
    if (trackMemoUntrackedObjSet.has(untrackedObj)) {
      trackMemo(dst);
    }
    return;
  }
  (_a8 = used[HAS_KEY_PROPERTY2]) === null || _a8 === void 0 ? void 0 : _a8.forEach((key) => {
    Reflect.has(dst, key);
  });
  if (used[ALL_OWN_KEYS_PROPERTY2] === true) {
    Reflect.ownKeys(dst);
  }
  (_b7 = used[HAS_OWN_KEY_PROPERTY2]) === null || _b7 === void 0 ? void 0 : _b7.forEach((key) => {
    Reflect.getOwnPropertyDescriptor(dst, key);
  });
  (_c6 = used[KEYS_PROPERTY2]) === null || _c6 === void 0 ? void 0 : _c6.forEach((key) => {
    touchAffected(dst[key], src[key], affected);
  });
};
var isOriginalEqual = (x, y) => {
  for (let xx = x; xx; x = xx, xx = getUntracked(xx))
    ;
  for (let yy = y; yy; y = yy, yy = getUntracked(yy))
    ;
  return Object.is(x, y);
};
var OBJ_PROPERTY = "o";
var RESULT_PROPERTY = "r";
var AFFECTED_PROPERTY2 = "a";
function memoize(fn, options) {
  var _a8;
  let memoListHead = 0;
  const size3 = (_a8 = options === null || options === void 0 ? void 0 : options.size) !== null && _a8 !== void 0 ? _a8 : 1;
  const memoList = [];
  const resultCache = (options === null || options === void 0 ? void 0 : options.noWeakMap) ? null : /* @__PURE__ */ new WeakMap();
  const memoizedFn = (obj) => {
    const cache = resultCache === null || resultCache === void 0 ? void 0 : resultCache.get(obj);
    if (cache) {
      return cache;
    }
    for (let i = 0; i < size3; i += 1) {
      const memo4 = memoList[(memoListHead + i) % size3];
      if (!memo4)
        break;
      const { [OBJ_PROPERTY]: memoObj, [AFFECTED_PROPERTY2]: memoAffected, [RESULT_PROPERTY]: memoResult } = memo4;
      if (!isChanged(memoObj, obj, memoAffected, /* @__PURE__ */ new WeakMap(), isOriginalEqual)) {
        touchAffected(obj, memoObj, memoAffected);
        resultCache === null || resultCache === void 0 ? void 0 : resultCache.set(obj, memoResult);
        return memoResult;
      }
    }
    const affected = /* @__PURE__ */ new WeakMap();
    const proxy2 = createProxy2(obj, affected, void 0, targetCache2);
    const result = untrack(fn(proxy2), /* @__PURE__ */ new WeakSet());
    touchAffected(obj, obj, affected);
    const entry = {
      [OBJ_PROPERTY]: obj,
      [RESULT_PROPERTY]: result,
      [AFFECTED_PROPERTY2]: affected
    };
    memoListHead = (memoListHead - 1 + size3) % size3;
    memoList[memoListHead] = entry;
    resultCache === null || resultCache === void 0 ? void 0 : resultCache.set(obj, result);
    return result;
  };
  return memoizedFn;
}

// node_modules/uqr/dist/index.mjs
var QrCodeDataType = ((QrCodeDataType2) => {
  QrCodeDataType2[QrCodeDataType2["Border"] = -1] = "Border";
  QrCodeDataType2[QrCodeDataType2["Data"] = 0] = "Data";
  QrCodeDataType2[QrCodeDataType2["Function"] = 1] = "Function";
  QrCodeDataType2[QrCodeDataType2["Position"] = 2] = "Position";
  QrCodeDataType2[QrCodeDataType2["Timing"] = 3] = "Timing";
  QrCodeDataType2[QrCodeDataType2["Alignment"] = 4] = "Alignment";
  return QrCodeDataType2;
})(QrCodeDataType || {});
var __defProp5 = Object.defineProperty;
var __defNormalProp5 = (obj, key, value) => key in obj ? __defProp5(obj, key, { enumerable: true, configurable: true, writable: true, value }) : obj[key] = value;
var __publicField5 = (obj, key, value) => {
  __defNormalProp5(obj, typeof key !== "symbol" ? key + "" : key, value);
  return value;
};
var LOW = [0, 1];
var MEDIUM = [1, 0];
var QUARTILE = [2, 3];
var HIGH = [3, 2];
var EccMap = {
  L: LOW,
  M: MEDIUM,
  Q: QUARTILE,
  H: HIGH
};
var NUMERIC_REGEX = /^[0-9]*$/;
var ALPHANUMERIC_REGEX = /^[A-Z0-9 $%*+.\/:-]*$/;
var ALPHANUMERIC_CHARSET = "0123456789ABCDEFGHIJKLMNOPQRSTUVWXYZ $%*+-./:";
var MIN_VERSION = 1;
var MAX_VERSION = 40;
var PENALTY_N1 = 3;
var PENALTY_N2 = 3;
var PENALTY_N3 = 40;
var PENALTY_N4 = 10;
var ECC_CODEWORDS_PER_BLOCK = [
  // Version: (note that index 0 is for padding, and is set to an illegal value)
  // 0,  1,  2,  3,  4,  5,  6,  7,  8,  9, 10, 11, 12, 13, 14, 15, 16, 17, 18, 19, 20, 21, 22, 23, 24, 25, 26, 27, 28, 29, 30, 31, 32, 33, 34, 35, 36, 37, 38, 39, 40    Error correction level
  [-1, 7, 10, 15, 20, 26, 18, 20, 24, 30, 18, 20, 24, 26, 30, 22, 24, 28, 30, 28, 28, 28, 28, 30, 30, 26, 28, 30, 30, 30, 30, 30, 30, 30, 30, 30, 30, 30, 30, 30, 30],
  // Low
  [-1, 10, 16, 26, 18, 24, 16, 18, 22, 22, 26, 30, 22, 22, 24, 24, 28, 28, 26, 26, 26, 26, 28, 28, 28, 28, 28, 28, 28, 28, 28, 28, 28, 28, 28, 28, 28, 28, 28, 28, 28],
  // Medium
  [-1, 13, 22, 18, 26, 18, 24, 18, 22, 20, 24, 28, 26, 24, 20, 30, 24, 28, 28, 26, 30, 28, 30, 30, 30, 30, 28, 30, 30, 30, 30, 30, 30, 30, 30, 30, 30, 30, 30, 30, 30],
  // Quartile
  [-1, 17, 28, 22, 16, 22, 28, 26, 26, 24, 28, 24, 28, 22, 24, 24, 30, 28, 28, 26, 28, 30, 24, 30, 30, 30, 30, 30, 30, 30, 30, 30, 30, 30, 30, 30, 30, 30, 30, 30, 30]
  // High
];
var NUM_ERROR_CORRECTION_BLOCKS = [
  // Version: (note that index 0 is for padding, and is set to an illegal value)
  // 0, 1, 2, 3, 4, 5, 6, 7, 8, 9,10, 11, 12, 13, 14, 15, 16, 17, 18, 19, 20, 21, 22, 23, 24, 25, 26, 27, 28, 29, 30, 31, 32, 33, 34, 35, 36, 37, 38, 39, 40    Error correction level
  [-1, 1, 1, 1, 1, 1, 2, 2, 2, 2, 4, 4, 4, 4, 4, 6, 6, 6, 6, 7, 8, 8, 9, 9, 10, 12, 12, 12, 13, 14, 15, 16, 17, 18, 19, 19, 20, 21, 22, 24, 25],
  // Low
  [-1, 1, 1, 1, 2, 2, 4, 4, 4, 5, 5, 5, 8, 9, 9, 10, 10, 11, 13, 14, 16, 17, 17, 18, 20, 21, 23, 25, 26, 28, 29, 31, 33, 35, 37, 38, 40, 43, 45, 47, 49],
  // Medium
  [-1, 1, 1, 2, 2, 4, 4, 6, 6, 8, 8, 8, 10, 12, 16, 12, 17, 16, 18, 21, 20, 23, 23, 25, 27, 29, 34, 34, 35, 38, 40, 43, 45, 48, 51, 53, 56, 59, 62, 65, 68],
  // Quartile
  [-1, 1, 1, 2, 4, 4, 4, 5, 6, 8, 8, 11, 11, 16, 16, 18, 16, 19, 21, 25, 25, 25, 34, 30, 32, 35, 37, 40, 42, 45, 48, 51, 54, 57, 60, 63, 66, 70, 74, 77, 81]
  // High
];
var QrCode = class {
  /* -- Constructor (low level) and fields -- */
  // Creates a new QR Code with the given version number,
  // error correction level, data codeword bytes, and mask number.
  // This is a low-level API that most users should not use directly.
  // A mid-level API is the encodeSegments() function.
  constructor(version, ecc, dataCodewords, msk) {
    this.version = version;
    this.ecc = ecc;
    __publicField5(this, "size");
    __publicField5(this, "mask");
    __publicField5(this, "modules", []);
    __publicField5(this, "types", []);
    if (version < MIN_VERSION || version > MAX_VERSION)
      throw new RangeError("Version value out of range");
    if (msk < -1 || msk > 7)
      throw new RangeError("Mask value out of range");
    this.size = version * 4 + 17;
    const row = Array.from({ length: this.size }, () => false);
    for (let i = 0; i < this.size; i++) {
      this.modules.push(row.slice());
      this.types.push(row.map(() => 0));
    }
    this.drawFunctionPatterns();
    const allCodewords = this.addEccAndInterleave(dataCodewords);
    this.drawCodewords(allCodewords);
    if (msk === -1) {
      let minPenalty = 1e9;
      for (let i = 0; i < 8; i++) {
        this.applyMask(i);
        this.drawFormatBits(i);
        const penalty = this.getPenaltyScore();
        if (penalty < minPenalty) {
          msk = i;
          minPenalty = penalty;
        }
        this.applyMask(i);
      }
    }
    this.mask = msk;
    this.applyMask(msk);
    this.drawFormatBits(msk);
  }
  /* -- Accessor methods -- */
  // Returns the color of the module (pixel) at the given coordinates, which is false
  // for light or true for dark. The top left corner has the coordinates (x=0, y=0).
  // If the given coordinates are out of bounds, then false (light) is returned.
  getModule(x, y) {
    return x >= 0 && x < this.size && y >= 0 && y < this.size && this.modules[y][x];
  }
  /* -- Private helper methods for constructor: Drawing function modules -- */
  // Reads this object's version field, and draws and marks all function modules.
  drawFunctionPatterns() {
    for (let i = 0; i < this.size; i++) {
      this.setFunctionModule(6, i, i % 2 === 0, QrCodeDataType.Timing);
      this.setFunctionModule(i, 6, i % 2 === 0, QrCodeDataType.Timing);
    }
    this.drawFinderPattern(3, 3);
    this.drawFinderPattern(this.size - 4, 3);
    this.drawFinderPattern(3, this.size - 4);
    const alignPatPos = this.getAlignmentPatternPositions();
    const numAlign = alignPatPos.length;
    for (let i = 0; i < numAlign; i++) {
      for (let j = 0; j < numAlign; j++) {
        if (!(i === 0 && j === 0 || i === 0 && j === numAlign - 1 || i === numAlign - 1 && j === 0))
          this.drawAlignmentPattern(alignPatPos[i], alignPatPos[j]);
      }
    }
    this.drawFormatBits(0);
    this.drawVersion();
  }
  // Draws two copies of the format bits (with its own error correction code)
  // based on the given mask and this object's error correction level field.
  drawFormatBits(mask) {
    const data = this.ecc[1] << 3 | mask;
    let rem = data;
    for (let i = 0; i < 10; i++)
      rem = rem << 1 ^ (rem >>> 9) * 1335;
    const bits = (data << 10 | rem) ^ 21522;
    for (let i = 0; i <= 5; i++)
      this.setFunctionModule(8, i, getBit(bits, i));
    this.setFunctionModule(8, 7, getBit(bits, 6));
    this.setFunctionModule(8, 8, getBit(bits, 7));
    this.setFunctionModule(7, 8, getBit(bits, 8));
    for (let i = 9; i < 15; i++)
      this.setFunctionModule(14 - i, 8, getBit(bits, i));
    for (let i = 0; i < 8; i++)
      this.setFunctionModule(this.size - 1 - i, 8, getBit(bits, i));
    for (let i = 8; i < 15; i++)
      this.setFunctionModule(8, this.size - 15 + i, getBit(bits, i));
    this.setFunctionModule(8, this.size - 8, true);
  }
  // Draws two copies of the version bits (with its own error correction code),
  // based on this object's version field, iff 7 <= version <= 40.
  drawVersion() {
    if (this.version < 7)
      return;
    let rem = this.version;
    for (let i = 0; i < 12; i++)
      rem = rem << 1 ^ (rem >>> 11) * 7973;
    const bits = this.version << 12 | rem;
    for (let i = 0; i < 18; i++) {
      const color = getBit(bits, i);
      const a = this.size - 11 + i % 3;
      const b = Math.floor(i / 3);
      this.setFunctionModule(a, b, color);
      this.setFunctionModule(b, a, color);
    }
  }
  // Draws a 9*9 finder pattern including the border separator,
  // with the center module at (x, y). Modules can be out of bounds.
  drawFinderPattern(x, y) {
    for (let dy = -4; dy <= 4; dy++) {
      for (let dx = -4; dx <= 4; dx++) {
        const dist = Math.max(Math.abs(dx), Math.abs(dy));
        const xx = x + dx;
        const yy = y + dy;
        if (xx >= 0 && xx < this.size && yy >= 0 && yy < this.size)
          this.setFunctionModule(xx, yy, dist !== 2 && dist !== 4, QrCodeDataType.Position);
      }
    }
  }
  // Draws a 5*5 alignment pattern, with the center module
  // at (x, y). All modules must be in bounds.
  drawAlignmentPattern(x, y) {
    for (let dy = -2; dy <= 2; dy++) {
      for (let dx = -2; dx <= 2; dx++) {
        this.setFunctionModule(
          x + dx,
          y + dy,
          Math.max(Math.abs(dx), Math.abs(dy)) !== 1,
          QrCodeDataType.Alignment
        );
      }
    }
  }
  // Sets the color of a module and marks it as a function module.
  // Only used by the constructor. Coordinates must be in bounds.
  setFunctionModule(x, y, isDark, type = QrCodeDataType.Function) {
    this.modules[y][x] = isDark;
    this.types[y][x] = type;
  }
  /* -- Private helper methods for constructor: Codewords and masking -- */
  // Returns a new byte string representing the given data with the appropriate error correction
  // codewords appended to it, based on this object's version and error correction level.
  addEccAndInterleave(data) {
    const ver = this.version;
    const ecl = this.ecc;
    if (data.length !== getNumDataCodewords(ver, ecl))
      throw new RangeError("Invalid argument");
    const numBlocks = NUM_ERROR_CORRECTION_BLOCKS[ecl[0]][ver];
    const blockEccLen = ECC_CODEWORDS_PER_BLOCK[ecl[0]][ver];
    const rawCodewords = Math.floor(getNumRawDataModules(ver) / 8);
    const numShortBlocks = numBlocks - rawCodewords % numBlocks;
    const shortBlockLen = Math.floor(rawCodewords / numBlocks);
    const blocks = [];
    const rsDiv = reedSolomonComputeDivisor(blockEccLen);
    for (let i = 0, k = 0; i < numBlocks; i++) {
      const dat = data.slice(k, k + shortBlockLen - blockEccLen + (i < numShortBlocks ? 0 : 1));
      k += dat.length;
      const ecc = reedSolomonComputeRemainder(dat, rsDiv);
      if (i < numShortBlocks)
        dat.push(0);
      blocks.push(dat.concat(ecc));
    }
    const result = [];
    for (let i = 0; i < blocks[0].length; i++) {
      blocks.forEach((block, j) => {
        if (i !== shortBlockLen - blockEccLen || j >= numShortBlocks)
          result.push(block[i]);
      });
    }
    return result;
  }
  // Draws the given sequence of 8-bit codewords (data and error correction) onto the entire
  // data area of this QR Code. Function modules need to be marked off before this is called.
  drawCodewords(data) {
    if (data.length !== Math.floor(getNumRawDataModules(this.version) / 8))
      throw new RangeError("Invalid argument");
    let i = 0;
    for (let right = this.size - 1; right >= 1; right -= 2) {
      if (right === 6)
        right = 5;
      for (let vert = 0; vert < this.size; vert++) {
        for (let j = 0; j < 2; j++) {
          const x = right - j;
          const upward = (right + 1 & 2) === 0;
          const y = upward ? this.size - 1 - vert : vert;
          if (!this.types[y][x] && i < data.length * 8) {
            this.modules[y][x] = getBit(data[i >>> 3], 7 - (i & 7));
            i++;
          }
        }
      }
    }
  }
  // XORs the codeword modules in this QR Code with the given mask pattern.
  // The function modules must be marked and the codeword bits must be drawn
  // before masking. Due to the arithmetic of XOR, calling applyMask() with
  // the same mask value a second time will undo the mask. A final well-formed
  // QR Code needs exactly one (not zero, two, etc.) mask applied.
  applyMask(mask) {
    if (mask < 0 || mask > 7)
      throw new RangeError("Mask value out of range");
    for (let y = 0; y < this.size; y++) {
      for (let x = 0; x < this.size; x++) {
        let invert;
        switch (mask) {
          case 0:
            invert = (x + y) % 2 === 0;
            break;
          case 1:
            invert = y % 2 === 0;
            break;
          case 2:
            invert = x % 3 === 0;
            break;
          case 3:
            invert = (x + y) % 3 === 0;
            break;
          case 4:
            invert = (Math.floor(x / 3) + Math.floor(y / 2)) % 2 === 0;
            break;
          case 5:
            invert = x * y % 2 + x * y % 3 === 0;
            break;
          case 6:
            invert = (x * y % 2 + x * y % 3) % 2 === 0;
            break;
          case 7:
            invert = ((x + y) % 2 + x * y % 3) % 2 === 0;
            break;
          default:
            throw new Error("Unreachable");
        }
        if (!this.types[y][x] && invert)
          this.modules[y][x] = !this.modules[y][x];
      }
    }
  }
  // Calculates and returns the penalty score based on state of this QR Code's current modules.
  // This is used by the automatic mask choice algorithm to find the mask pattern that yields the lowest score.
  getPenaltyScore() {
    let result = 0;
    for (let y = 0; y < this.size; y++) {
      let runColor = false;
      let runX = 0;
      const runHistory = [0, 0, 0, 0, 0, 0, 0];
      for (let x = 0; x < this.size; x++) {
        if (this.modules[y][x] === runColor) {
          runX++;
          if (runX === 5)
            result += PENALTY_N1;
          else if (runX > 5)
            result++;
        } else {
          this.finderPenaltyAddHistory(runX, runHistory);
          if (!runColor)
            result += this.finderPenaltyCountPatterns(runHistory) * PENALTY_N3;
          runColor = this.modules[y][x];
          runX = 1;
        }
      }
      result += this.finderPenaltyTerminateAndCount(runColor, runX, runHistory) * PENALTY_N3;
    }
    for (let x = 0; x < this.size; x++) {
      let runColor = false;
      let runY = 0;
      const runHistory = [0, 0, 0, 0, 0, 0, 0];
      for (let y = 0; y < this.size; y++) {
        if (this.modules[y][x] === runColor) {
          runY++;
          if (runY === 5)
            result += PENALTY_N1;
          else if (runY > 5)
            result++;
        } else {
          this.finderPenaltyAddHistory(runY, runHistory);
          if (!runColor)
            result += this.finderPenaltyCountPatterns(runHistory) * PENALTY_N3;
          runColor = this.modules[y][x];
          runY = 1;
        }
      }
      result += this.finderPenaltyTerminateAndCount(runColor, runY, runHistory) * PENALTY_N3;
    }
    for (let y = 0; y < this.size - 1; y++) {
      for (let x = 0; x < this.size - 1; x++) {
        const color = this.modules[y][x];
        if (color === this.modules[y][x + 1] && color === this.modules[y + 1][x] && color === this.modules[y + 1][x + 1])
          result += PENALTY_N2;
      }
    }
    let dark = 0;
    for (const row of this.modules)
      dark = row.reduce((sum, color) => sum + (color ? 1 : 0), dark);
    const total = this.size * this.size;
    const k = Math.ceil(Math.abs(dark * 20 - total * 10) / total) - 1;
    result += k * PENALTY_N4;
    return result;
  }
  /* -- Private helper functions -- */
  // Returns an ascending list of positions of alignment patterns for this version number.
  // Each position is in the range [0,177), and are used on both the x and y axes.
  // This could be implemented as lookup table of 40 variable-length lists of integers.
  getAlignmentPatternPositions() {
    if (this.version === 1) {
      return [];
    } else {
      const numAlign = Math.floor(this.version / 7) + 2;
      const step = this.version === 32 ? 26 : Math.ceil((this.version * 4 + 4) / (numAlign * 2 - 2)) * 2;
      const result = [6];
      for (let pos = this.size - 7; result.length < numAlign; pos -= step)
        result.splice(1, 0, pos);
      return result;
    }
  }
  // Can only be called immediately after a light run is added, and
  // returns either 0, 1, or 2. A helper function for getPenaltyScore().
  finderPenaltyCountPatterns(runHistory) {
    const n = runHistory[1];
    const core = n > 0 && runHistory[2] === n && runHistory[3] === n * 3 && runHistory[4] === n && runHistory[5] === n;
    return (core && runHistory[0] >= n * 4 && runHistory[6] >= n ? 1 : 0) + (core && runHistory[6] >= n * 4 && runHistory[0] >= n ? 1 : 0);
  }
  // Must be called at the end of a line (row or column) of modules. A helper function for getPenaltyScore().
  finderPenaltyTerminateAndCount(currentRunColor, currentRunLength, runHistory) {
    if (currentRunColor) {
      this.finderPenaltyAddHistory(currentRunLength, runHistory);
      currentRunLength = 0;
    }
    currentRunLength += this.size;
    this.finderPenaltyAddHistory(currentRunLength, runHistory);
    return this.finderPenaltyCountPatterns(runHistory);
  }
  // Pushes the given value to the front and drops the last value. A helper function for getPenaltyScore().
  finderPenaltyAddHistory(currentRunLength, runHistory) {
    if (runHistory[0] === 0)
      currentRunLength += this.size;
    runHistory.pop();
    runHistory.unshift(currentRunLength);
  }
};
function appendBits(val, len, bb) {
  if (len < 0 || len > 31 || val >>> len !== 0)
    throw new RangeError("Value out of range");
  for (let i = len - 1; i >= 0; i--)
    bb.push(val >>> i & 1);
}
function getBit(x, i) {
  return (x >>> i & 1) !== 0;
}
var QrSegment = class {
  // Creates a new QR Code segment with the given attributes and data.
  // The character count (numChars) must agree with the mode and the bit buffer length,
  // but the constraint isn't checked. The given bit buffer is cloned and stored.
  constructor(mode, numChars, bitData) {
    this.mode = mode;
    this.numChars = numChars;
    this.bitData = bitData;
    if (numChars < 0)
      throw new RangeError("Invalid argument");
    this.bitData = bitData.slice();
  }
  /* -- Methods -- */
  // Returns a new copy of the data bits of this segment.
  getData() {
    return this.bitData.slice();
  }
};
var MODE_NUMERIC = [1, 10, 12, 14];
var MODE_ALPHANUMERIC = [2, 9, 11, 13];
var MODE_BYTE = [4, 8, 16, 16];
function numCharCountBits(mode, ver) {
  return mode[Math.floor((ver + 7) / 17) + 1];
}
function makeBytes(data) {
  const bb = [];
  for (const b of data)
    appendBits(b, 8, bb);
  return new QrSegment(MODE_BYTE, data.length, bb);
}
function makeNumeric(digits) {
  if (!isNumeric(digits))
    throw new RangeError("String contains non-numeric characters");
  const bb = [];
  for (let i = 0; i < digits.length; ) {
    const n = Math.min(digits.length - i, 3);
    appendBits(Number.parseInt(digits.substring(i, i + n), 10), n * 3 + 1, bb);
    i += n;
  }
  return new QrSegment(MODE_NUMERIC, digits.length, bb);
}
function makeAlphanumeric(text) {
  if (!isAlphanumeric(text))
    throw new RangeError("String contains unencodable characters in alphanumeric mode");
  const bb = [];
  let i;
  for (i = 0; i + 2 <= text.length; i += 2) {
    let temp = ALPHANUMERIC_CHARSET.indexOf(text.charAt(i)) * 45;
    temp += ALPHANUMERIC_CHARSET.indexOf(text.charAt(i + 1));
    appendBits(temp, 11, bb);
  }
  if (i < text.length)
    appendBits(ALPHANUMERIC_CHARSET.indexOf(text.charAt(i)), 6, bb);
  return new QrSegment(MODE_ALPHANUMERIC, text.length, bb);
}
function makeSegments(text) {
  if (text === "")
    return [];
  else if (isNumeric(text))
    return [makeNumeric(text)];
  else if (isAlphanumeric(text))
    return [makeAlphanumeric(text)];
  else
    return [makeBytes(toUtf8ByteArray(text))];
}
function isNumeric(text) {
  return NUMERIC_REGEX.test(text);
}
function isAlphanumeric(text) {
  return ALPHANUMERIC_REGEX.test(text);
}
function getTotalBits(segs, version) {
  let result = 0;
  for (const seg of segs) {
    const ccbits = numCharCountBits(seg.mode, version);
    if (seg.numChars >= 1 << ccbits)
      return Number.POSITIVE_INFINITY;
    result += 4 + ccbits + seg.bitData.length;
  }
  return result;
}
function toUtf8ByteArray(str) {
  str = encodeURI(str);
  const result = [];
  for (let i = 0; i < str.length; i++) {
    if (str.charAt(i) !== "%") {
      result.push(str.charCodeAt(i));
    } else {
      result.push(Number.parseInt(str.substring(i + 1, i + 3), 16));
      i += 2;
    }
  }
  return result;
}
function getNumRawDataModules(ver) {
  if (ver < MIN_VERSION || ver > MAX_VERSION)
    throw new RangeError("Version number out of range");
  let result = (16 * ver + 128) * ver + 64;
  if (ver >= 2) {
    const numAlign = Math.floor(ver / 7) + 2;
    result -= (25 * numAlign - 10) * numAlign - 55;
    if (ver >= 7)
      result -= 36;
  }
  return result;
}
function getNumDataCodewords(ver, ecl) {
  return Math.floor(getNumRawDataModules(ver) / 8) - ECC_CODEWORDS_PER_BLOCK[ecl[0]][ver] * NUM_ERROR_CORRECTION_BLOCKS[ecl[0]][ver];
}
function reedSolomonComputeDivisor(degree) {
  if (degree < 1 || degree > 255)
    throw new RangeError("Degree out of range");
  const result = [];
  for (let i = 0; i < degree - 1; i++)
    result.push(0);
  result.push(1);
  let root = 1;
  for (let i = 0; i < degree; i++) {
    for (let j = 0; j < result.length; j++) {
      result[j] = reedSolomonMultiply(result[j], root);
      if (j + 1 < result.length)
        result[j] ^= result[j + 1];
    }
    root = reedSolomonMultiply(root, 2);
  }
  return result;
}
function reedSolomonComputeRemainder(data, divisor) {
  const result = divisor.map((_) => 0);
  for (const b of data) {
    const factor = b ^ result.shift();
    result.push(0);
    divisor.forEach((coef, i) => result[i] ^= reedSolomonMultiply(coef, factor));
  }
  return result;
}
function reedSolomonMultiply(x, y) {
  if (x >>> 8 !== 0 || y >>> 8 !== 0)
    throw new RangeError("Byte out of range");
  let z = 0;
  for (let i = 7; i >= 0; i--) {
    z = z << 1 ^ (z >>> 7) * 285;
    z ^= (y >>> i & 1) * x;
  }
  return z;
}
function encodeSegments(segs, ecl, minVersion = 1, maxVersion = 40, mask = -1, boostEcl = true) {
  if (!(MIN_VERSION <= minVersion && minVersion <= maxVersion && maxVersion <= MAX_VERSION) || mask < -1 || mask > 7)
    throw new RangeError("Invalid value");
  let version;
  let dataUsedBits;
  for (version = minVersion; ; version++) {
    const dataCapacityBits2 = getNumDataCodewords(version, ecl) * 8;
    const usedBits = getTotalBits(segs, version);
    if (usedBits <= dataCapacityBits2) {
      dataUsedBits = usedBits;
      break;
    }
    if (version >= maxVersion)
      throw new RangeError("Data too long");
  }
  for (const newEcl of [MEDIUM, QUARTILE, HIGH]) {
    if (boostEcl && dataUsedBits <= getNumDataCodewords(version, newEcl) * 8)
      ecl = newEcl;
  }
  const bb = [];
  for (const seg of segs) {
    appendBits(seg.mode[0], 4, bb);
    appendBits(seg.numChars, numCharCountBits(seg.mode, version), bb);
    for (const b of seg.getData())
      bb.push(b);
  }
  const dataCapacityBits = getNumDataCodewords(version, ecl) * 8;
  appendBits(0, Math.min(4, dataCapacityBits - bb.length), bb);
  appendBits(0, (8 - bb.length % 8) % 8, bb);
  for (let padByte = 236; bb.length < dataCapacityBits; padByte ^= 236 ^ 17)
    appendBits(padByte, 8, bb);
  const dataCodewords = Array.from({ length: Math.ceil(bb.length / 8) }, () => 0);
  bb.forEach((b, i) => dataCodewords[i >>> 3] |= b << 7 - (i & 7));
  return new QrCode(version, ecl, dataCodewords, mask);
}
function encode(data, options) {
  var _a8;
  const {
    ecc = "L",
    boostEcc = false,
    minVersion = 1,
    maxVersion = 40,
    maskPattern = -1,
    border = 1
  } = options || {};
  const segment = typeof data === "string" ? makeSegments(data) : Array.isArray(data) ? [makeBytes(data)] : void 0;
  if (!segment)
    throw new Error(`uqr only supports encoding string and binary data, but got: ${typeof data}`);
  const qr = encodeSegments(
    segment,
    EccMap[ecc],
    minVersion,
    maxVersion,
    maskPattern,
    boostEcc
  );
  const result = addBorder({
    version: qr.version,
    maskPattern: qr.mask,
    size: qr.size,
    data: qr.modules,
    types: qr.types
  }, border);
  if (options == null ? void 0 : options.invert)
    result.data = result.data.map((row) => row.map((mod2) => !mod2));
  (_a8 = options == null ? void 0 : options.onEncoded) == null ? void 0 : _a8.call(options, result);
  return result;
}
function addBorder(input, border = 1) {
  if (!border)
    return input;
  const { size: size3 } = input;
  const newSize = size3 + border * 2;
  input.size = newSize;
  input.data.forEach((row) => {
    for (let i = 0; i < border; i++) {
      row.unshift(false);
      row.push(false);
    }
  });
  for (let i = 0; i < border; i++) {
    input.data.unshift(Array.from({ length: newSize }, (_) => false));
    input.data.push(Array.from({ length: newSize }, (_) => false));
  }
  const b = QrCodeDataType.Border;
  input.types.forEach((row) => {
    for (let i = 0; i < border; i++) {
      row.unshift(b);
      row.push(b);
    }
  });
  for (let i = 0; i < border; i++) {
    input.types.unshift(Array.from({ length: newSize }, (_) => b));
    input.types.push(Array.from({ length: newSize }, (_) => b));
  }
  return input;
}

// node_modules/@zag-js/qr-code/dist/index.mjs
var anatomy21 = createAnatomy("qr-code").parts("root", "frame", "pattern", "overlay", "downloadTrigger");
var parts23 = anatomy21.build();
var dom21 = createScope({
  getRootId: (ctx) => {
    var _a8;
    return ((_a8 = ctx.ids) == null ? void 0 : _a8.root) ?? `qrcode:${ctx.id}:root`;
  },
  getFrameId: (ctx) => {
    var _a8;
    return ((_a8 = ctx.ids) == null ? void 0 : _a8.frame) ?? `qrcode:${ctx.id}:frame`;
  },
  getFrameEl: (ctx) => dom21.getById(ctx, dom21.getFrameId(ctx))
});
function connect22(state2, send, normalize2) {
  const encoded = state2.context.encoded;
  const pixelSize = state2.context.pixelSize;
  const height = encoded.size * pixelSize;
  const width = encoded.size * pixelSize;
  const paths = [];
  for (let row = 0; row < encoded.size; row++) {
    for (let col = 0; col < encoded.size; col++) {
      const x = col * pixelSize;
      const y = row * pixelSize;
      if (encoded.data[row][col]) {
        paths.push(`M${x},${y}h${pixelSize}v${pixelSize}h-${pixelSize}z`);
      }
    }
  }
  return {
    value: state2.context.value,
    setValue(value) {
      send({ type: "VALUE.SET", value });
    },
    getDataUrl(type, quality) {
      const svgEl = dom21.getFrameEl(state2.context);
      return getDataUrl(svgEl, { type, quality });
    },
    getRootProps() {
      return normalize2.element({
        id: dom21.getRootId(state2.context),
        ...parts23.root.attrs,
        style: {
          "--qrcode-pixel-size": `${pixelSize}px`,
          "--qrcode-width": `${width}px`,
          "--qrcode-height": `${height}px`,
          position: "relative"
        }
      });
    },
    getFrameProps() {
      return normalize2.svg({
        id: dom21.getFrameId(state2.context),
        ...parts23.frame.attrs,
        xmlns: "http://www.w3.org/2000/svg",
        viewBox: `0 0 ${width} ${height}`
      });
    },
    getPatternProps() {
      return normalize2.path({
        d: paths.join(""),
        ...parts23.pattern.attrs
      });
    },
    getOverlayProps() {
      return normalize2.element({
        ...parts23.overlay.attrs,
        style: {
          position: "absolute",
          top: "50%",
          left: "50%",
          translate: "-50% -50%"
        }
      });
    },
    getDownloadTriggerProps(props22) {
      return normalize2.button({
        type: "button",
        ...parts23.downloadTrigger.attrs,
        onClick(event) {
          if (event.defaultPrevented) return;
          send({ type: "DOWNLOAD_TRIGGER.CLICK", ...props22 });
        }
      });
    }
  };
}
function machine22(userContext) {
  const ctx = compact2(userContext);
  return createMachine(
    {
      id: "qr-code",
      initial: "idle",
      context: {
        value: "",
        ...ctx,
        pixelSize: 10
      },
      computed: {
        encoded: memoize((ctx2) => encode(ctx2.value, ctx2.encoding))
      },
      on: {
        "VALUE.SET": {
          actions: ["setValue"]
        },
        "DOWNLOAD_TRIGGER.CLICK": {
          actions: ["downloadQrCode"]
        }
      }
    },
    {
      actions: {
        setValue(ctx2, evt) {
          set18.value(ctx2, evt.value);
        },
        downloadQrCode(ctx2, evt) {
          const { mimeType, quality, fileName } = evt;
          const svgEl = dom21.getFrameEl(ctx2);
          const doc = dom21.getDoc(ctx2);
          getDataUrl(svgEl, { type: mimeType, quality }).then((dataUri) => {
            const a = doc.createElement("a");
            a.href = dataUri;
            a.rel = "noopener";
            a.download = fileName;
            a.click();
            setTimeout(() => {
              a.remove();
            }, 0);
          });
        }
      }
    }
  );
}
var set18 = {
  value(ctx, value) {
    var _a8;
    if (isEqual(ctx.value, value)) return;
    ctx.value = value;
    (_a8 = ctx.onValueChange) == null ? void 0 : _a8.call(ctx, { value });
  }
};
var props19 = createProps2()([
  "ids",
  "value",
  "id",
  "encoding",
  "dir",
  "getRootNode",
  "onValueChange"
]);
var splitProps20 = createSplitProps(props19);

// node_modules/@ark-ui/react/dist/components/qr-code/use-qr-code.js
var import_react466 = __toESM(require_react(), 1);
var useQrCode = (props21 = {}) => {
  const { getRootNode } = useEnvironmentContext();
  const { dir } = useLocaleContext();
  const initialContext = {
    id: (0, import_react466.useId)(),
    dir,
    value: props21.defaultValue,
    getRootNode,
    onValueChange: useEvent(props21.onValueChange, { sync: true }),
    ...props21
  };
  const context = {
    ...initialContext,
    value: props21.value,
    onValueChange: useEvent(props21.onValueChange, { sync: true })
  };
  const [state2, send] = useMachine(machine22(initialContext), { context });
  return connect22(state2, send, normalizeProps);
};

// node_modules/@ark-ui/react/dist/components/qr-code/qr-code-root.js
var QrCodeRoot = (0, import_react468.forwardRef)((props21, ref2) => {
  const [qrcodeProps, localProps] = createSplitProps2()(props21, [
    "defaultValue",
    "encoding",
    "id",
    "ids",
    "onValueChange",
    "value"
  ]);
  const qrCode = useQrCode(qrcodeProps);
  const mergedProps = mergeProps(qrCode.getRootProps(), localProps);
  return (0, import_jsx_runtime214.jsx)(QrCodeProvider, { value: qrCode, children: (0, import_jsx_runtime214.jsx)(ark.div, { ...mergedProps, ref: ref2 }) });
});
QrCodeRoot.displayName = "QrcodeRoot";

// node_modules/@ark-ui/react/dist/components/qr-code/qr-code-root-provider.js
var import_jsx_runtime215 = __toESM(require_jsx_runtime(), 1);
var import_react470 = __toESM(require_react(), 1);
var QrCodeRootProvider = (0, import_react470.forwardRef)(
  (props21, ref2) => {
    const [{ value: qrCode }, localProps] = createSplitProps2()(props21, ["value"]);
    const mergedProps = mergeProps(qrCode.getRootProps(), localProps);
    return (0, import_jsx_runtime215.jsx)(QrCodeProvider, { value: qrCode, children: (0, import_jsx_runtime215.jsx)(ark.div, { ...mergedProps, ref: ref2 }) });
  }
);
QrCodeRootProvider.displayName = "QrCodeRootProvider";

// node_modules/@ark-ui/react/dist/components/qr-code/qr-code.js
var qr_code_exports = {};
__export(qr_code_exports, {
  Context: () => QrCodeContext,
  DownloadTrigger: () => QrCodeDownloadTrigger,
  Frame: () => QrCodeFrame,
  Overlay: () => QrCodeOverlay,
  Pattern: () => QrCodePattern,
  Root: () => QrCodeRoot,
  RootProvider: () => QrCodeRootProvider
});

// node_modules/@ark-ui/react/dist/components/segment-group/use-segment-group-context.js
var [SegmentGroupProvider, useSegmentGroupContext] = createContext(
  {
    name: "SegmentGroupContext",
    hookName: "useSegmentGroupContext",
    providerName: "<SegmentGroupProvider />"
  }
);

// node_modules/@ark-ui/react/dist/components/segment-group/segment-group-context.js
var SegmentGroupContext = (props21) => props21.children(useSegmentGroupContext());

// node_modules/@ark-ui/react/dist/components/segment-group/segment-group-indicator.js
var import_jsx_runtime216 = __toESM(require_jsx_runtime(), 1);
var import_react472 = __toESM(require_react(), 1);

// node_modules/@ark-ui/react/dist/components/segment-group/segment-group.anatomy.js
var segmentGroupAnatomy = anatomy10.rename("segment-group");
var parts24 = segmentGroupAnatomy.build();

// node_modules/@ark-ui/react/dist/components/segment-group/segment-group-indicator.js
var SegmentGroupIndicator = (0, import_react472.forwardRef)(
  (props21, ref2) => {
    const segmentGroup = useSegmentGroupContext();
    const mergedProps = mergeProps(
      segmentGroup.getIndicatorProps(),
      parts24.indicator.attrs,
      props21
    );
    return (0, import_jsx_runtime216.jsx)(ark.div, { ...mergedProps, ref: ref2 });
  }
);
SegmentGroupIndicator.displayName = "SegmentGroupIndicator";

// node_modules/@ark-ui/react/dist/components/segment-group/segment-group-item.js
var import_jsx_runtime217 = __toESM(require_jsx_runtime(), 1);
var import_react474 = __toESM(require_react(), 1);

// node_modules/@ark-ui/react/dist/components/segment-group/use-segment-group-item-context.js
var [SegmentGroupItemProvider, useSegmentGroupItemContext] = createContext({
  name: "SegmentGroupItemContext",
  hookName: "useSegmentGroupItemContext",
  providerName: "<SegmentGroupItemProvider />"
});

// node_modules/@ark-ui/react/dist/components/segment-group/use-segment-group-item-props-context.js
var [SegmentGroupItemPropsProvider, useSegmentGroupItemPropsContext] = createContext({
  name: "SegmentGroupItemPropsContext",
  hookName: "useSegmentGroupItemPropsContext",
  providerName: "<SegmentGroupItemPropsProvider />"
});

// node_modules/@ark-ui/react/dist/components/segment-group/segment-group-item.js
var SegmentGroupItem = (0, import_react474.forwardRef)(
  (props21, ref2) => {
    const [itemProps7, localProps] = createSplitProps2()(props21, [
      "value",
      "disabled",
      "invalid"
    ]);
    const segmentGroup = useSegmentGroupContext();
    const mergedProps = mergeProps(
      segmentGroup.getItemProps(itemProps7),
      parts24.item.attrs,
      localProps
    );
    const itemState = segmentGroup.getItemState(itemProps7);
    return (0, import_jsx_runtime217.jsx)(SegmentGroupItemPropsProvider, { value: itemProps7, children: (0, import_jsx_runtime217.jsx)(SegmentGroupItemProvider, { value: itemState, children: (0, import_jsx_runtime217.jsx)(ark.label, { ...mergedProps, ref: ref2 }) }) });
  }
);
SegmentGroupItem.displayName = "SegmentGroupItem";

// node_modules/@ark-ui/react/dist/components/segment-group/segment-group-item-context.js
var SegmentGroupItemContext = (props21) => props21.children(useSegmentGroupItemContext());

// node_modules/@ark-ui/react/dist/components/segment-group/segment-group-item-control.js
var import_jsx_runtime218 = __toESM(require_jsx_runtime(), 1);
var import_react476 = __toESM(require_react(), 1);
var SegmentGroupItemControl = (0, import_react476.forwardRef)(
  (props21, ref2) => {
    const segmentGroup = useSegmentGroupContext();
    const itemProps7 = useSegmentGroupItemPropsContext();
    const mergedProps = mergeProps(
      segmentGroup.getItemControlProps(itemProps7),
      parts24.itemControl.attrs,
      props21
    );
    return (0, import_jsx_runtime218.jsx)(ark.div, { ...mergedProps, ref: ref2 });
  }
);
SegmentGroupItemControl.displayName = "SegmentGroupItemControl";

// node_modules/@ark-ui/react/dist/components/segment-group/segment-group-item-hidden-input.js
var import_jsx_runtime219 = __toESM(require_jsx_runtime(), 1);
var import_react478 = __toESM(require_react(), 1);
var SegmentGroupItemHiddenInput = (0, import_react478.forwardRef)((props21, ref2) => {
  const segmentGroup = useSegmentGroupContext();
  const itemProps7 = useSegmentGroupItemPropsContext();
  const mergedProps = mergeProps(segmentGroup.getItemHiddenInputProps(itemProps7), props21);
  return (0, import_jsx_runtime219.jsx)(ark.input, { ...mergedProps, ref: ref2 });
});
SegmentGroupItemHiddenInput.displayName = "SegmentGroupItemHiddenInput";

// node_modules/@ark-ui/react/dist/components/segment-group/segment-group-item-text.js
var import_jsx_runtime220 = __toESM(require_jsx_runtime(), 1);
var import_react480 = __toESM(require_react(), 1);
var SegmentGroupItemText = (0, import_react480.forwardRef)(
  (props21, ref2) => {
    const segmentGroup = useSegmentGroupContext();
    const itemProps7 = useSegmentGroupItemPropsContext();
    const mergedProps = mergeProps(
      segmentGroup.getItemTextProps(itemProps7),
      parts24.itemText.attrs,
      props21
    );
    return (0, import_jsx_runtime220.jsx)(ark.span, { ...mergedProps, ref: ref2 });
  }
);
SegmentGroupItemText.displayName = "SegmentGroupItemText";

// node_modules/@ark-ui/react/dist/components/segment-group/segment-group-label.js
var import_jsx_runtime221 = __toESM(require_jsx_runtime(), 1);
var import_react482 = __toESM(require_react(), 1);
var SegmentGroupLabel = (0, import_react482.forwardRef)(
  (props21, ref2) => {
    const segmentGroup = useSegmentGroupContext();
    const mergedProps = mergeProps(
      segmentGroup.getLabelProps(),
      parts24.label.attrs,
      props21
    );
    return (0, import_jsx_runtime221.jsx)(ark.label, { ...mergedProps, ref: ref2 });
  }
);
SegmentGroupLabel.displayName = "SegmentGroupLabel";

// node_modules/@ark-ui/react/dist/components/segment-group/segment-group-root.js
var import_jsx_runtime222 = __toESM(require_jsx_runtime(), 1);
var import_react486 = __toESM(require_react(), 1);

// node_modules/@ark-ui/react/dist/components/segment-group/use-segment-group.js
var import_react484 = __toESM(require_react(), 1);
var useSegmentGroup = (props21 = {}) => {
  const { getRootNode } = useEnvironmentContext();
  const { dir } = useLocaleContext();
  const initialContext = {
    id: (0, import_react484.useId)(),
    dir,
    getRootNode,
    value: props21.defaultValue,
    ...props21
  };
  const context = {
    ...initialContext,
    value: props21.value,
    onValueChange: useEvent(props21.onValueChange, { sync: true })
  };
  const [state2, send] = useMachine(machine11(initialContext), {
    context
  });
  return connect11(state2, send, normalizeProps);
};

// node_modules/@ark-ui/react/dist/components/segment-group/segment-group-root.js
var SegmentGroupRoot = (0, import_react486.forwardRef)((props21, ref2) => {
  const [useSegmentGroupProps, localProps] = createSplitProps2()(props21, [
    "defaultValue",
    "disabled",
    "form",
    "id",
    "ids",
    "name",
    "onValueChange",
    "orientation",
    "readOnly",
    "value"
  ]);
  const segmentGroup = useSegmentGroup(useSegmentGroupProps);
  const mergedProps = mergeProps(
    segmentGroup.getRootProps(),
    parts24.root.attrs,
    localProps
  );
  return (0, import_jsx_runtime222.jsx)(SegmentGroupProvider, { value: segmentGroup, children: (0, import_jsx_runtime222.jsx)(ark.div, { ...mergedProps, ref: ref2 }) });
});
SegmentGroupRoot.displayName = "SegmentGroupRoot";

// node_modules/@ark-ui/react/dist/components/segment-group/segment-group-root-provider.js
var import_jsx_runtime223 = __toESM(require_jsx_runtime(), 1);
var import_react488 = __toESM(require_react(), 1);
var SegmentGroupRootProvider = (0, import_react488.forwardRef)(
  (props21, ref2) => {
    const [{ value: segmentGroup }, localProps] = createSplitProps2()(props21, [
      "value"
    ]);
    const mergedProps = mergeProps(
      segmentGroup.getRootProps(),
      parts24.root.attrs,
      localProps
    );
    return (0, import_jsx_runtime223.jsx)(SegmentGroupProvider, { value: segmentGroup, children: (0, import_jsx_runtime223.jsx)(ark.div, { ...mergedProps, ref: ref2 }) });
  }
);
SegmentGroupRootProvider.displayName = "SegmentGroupRootProvider";

// node_modules/@ark-ui/react/dist/components/segment-group/segment-group.js
var segment_group_exports = {};
__export(segment_group_exports, {
  Context: () => SegmentGroupContext,
  Indicator: () => SegmentGroupIndicator,
  Item: () => SegmentGroupItem,
  ItemContext: () => SegmentGroupItemContext,
  ItemControl: () => SegmentGroupItemControl,
  ItemHiddenInput: () => SegmentGroupItemHiddenInput,
  ItemText: () => SegmentGroupItemText,
  Label: () => SegmentGroupLabel,
  Root: () => SegmentGroupRoot,
  RootProvider: () => SegmentGroupRootProvider
});

// node_modules/@ark-ui/react/dist/components/tooltip/tooltip-arrow.js
var import_jsx_runtime224 = __toESM(require_jsx_runtime(), 1);
var import_react490 = __toESM(require_react(), 1);

// node_modules/@ark-ui/react/dist/components/tooltip/use-tooltip-context.js
var [TooltipProvider, useTooltipContext] = createContext({
  name: "TooltipContext",
  hookName: "useTooltipContext",
  providerName: "<TooltipProvider />"
});

// node_modules/@ark-ui/react/dist/components/tooltip/tooltip-arrow.js
var TooltipArrow = (0, import_react490.forwardRef)((props21, ref2) => {
  const tooltip = useTooltipContext();
  const mergedProps = mergeProps(tooltip.getArrowProps(), props21);
  return (0, import_jsx_runtime224.jsx)(ark.div, { ...mergedProps, ref: ref2 });
});
TooltipArrow.displayName = "TooltipArrow";

// node_modules/@ark-ui/react/dist/components/tooltip/tooltip-arrow-tip.js
var import_jsx_runtime225 = __toESM(require_jsx_runtime(), 1);
var import_react492 = __toESM(require_react(), 1);
var TooltipArrowTip = (0, import_react492.forwardRef)((props21, ref2) => {
  const tooltip = useTooltipContext();
  const mergedProps = mergeProps(tooltip.getArrowTipProps(), props21);
  return (0, import_jsx_runtime225.jsx)(ark.div, { ...mergedProps, ref: ref2 });
});
TooltipArrowTip.displayName = "TooltipArrowTip";

// node_modules/@ark-ui/react/dist/components/tooltip/tooltip-content.js
var import_jsx_runtime226 = __toESM(require_jsx_runtime(), 1);
var import_react494 = __toESM(require_react(), 1);
var TooltipContent = (0, import_react494.forwardRef)((props21, ref2) => {
  const tooltip = useTooltipContext();
  const presence = usePresenceContext();
  const mergedProps = mergeProps(tooltip.getContentProps(), presence.getPresenceProps(), props21);
  if (presence.unmounted) {
    return null;
  }
  return (0, import_jsx_runtime226.jsx)(ark.div, { ...mergedProps, ref: composeRefs(presence.ref, ref2) });
});
TooltipContent.displayName = "TooltipContent";

// node_modules/@ark-ui/react/dist/components/tooltip/tooltip-context.js
var TooltipContext = (props21) => props21.children(useTooltipContext());

// node_modules/@ark-ui/react/dist/components/tooltip/tooltip-positioner.js
var import_jsx_runtime227 = __toESM(require_jsx_runtime(), 1);
var import_react496 = __toESM(require_react(), 1);
var TooltipPositioner = (0, import_react496.forwardRef)(
  (props21, ref2) => {
    const tooltip = useTooltipContext();
    const mergedProps = mergeProps(tooltip.getPositionerProps(), props21);
    const presence = usePresenceContext();
    if (presence.unmounted) {
      return null;
    }
    return (0, import_jsx_runtime227.jsx)(ark.div, { ...mergedProps, ref: ref2 });
  }
);
TooltipPositioner.displayName = "TooltipPositioner";

// node_modules/@ark-ui/react/dist/components/tooltip/tooltip-root.js
var import_jsx_runtime228 = __toESM(require_jsx_runtime(), 1);

// node_modules/@zag-js/tooltip/dist/index.mjs
var anatomy22 = createAnatomy("tooltip").parts("trigger", "arrow", "arrowTip", "positioner", "content");
var parts25 = anatomy22.build();
var dom22 = createScope({
  getTriggerId: (ctx) => {
    var _a8;
    return ((_a8 = ctx.ids) == null ? void 0 : _a8.trigger) ?? `tooltip:${ctx.id}:trigger`;
  },
  getContentId: (ctx) => {
    var _a8;
    return ((_a8 = ctx.ids) == null ? void 0 : _a8.content) ?? `tooltip:${ctx.id}:content`;
  },
  getArrowId: (ctx) => {
    var _a8;
    return ((_a8 = ctx.ids) == null ? void 0 : _a8.arrow) ?? `tooltip:${ctx.id}:arrow`;
  },
  getPositionerId: (ctx) => {
    var _a8;
    return ((_a8 = ctx.ids) == null ? void 0 : _a8.positioner) ?? `tooltip:${ctx.id}:popper`;
  },
  getTriggerEl: (ctx) => dom22.getById(ctx, dom22.getTriggerId(ctx)),
  getContentEl: (ctx) => dom22.getById(ctx, dom22.getContentId(ctx)),
  getPositionerEl: (ctx) => dom22.getById(ctx, dom22.getPositionerId(ctx)),
  getArrowEl: (ctx) => dom22.getById(ctx, dom22.getArrowId(ctx))
});
var store = proxy({
  id: null,
  prevId: null,
  setId(val) {
    this.prevId = this.id;
    this.id = val;
  }
});
function connect23(state2, send, normalize2) {
  const id = state2.context.id;
  const hasAriaLabel = state2.context.hasAriaLabel;
  const open = state2.hasTag("open");
  const triggerId = dom22.getTriggerId(state2.context);
  const contentId = dom22.getContentId(state2.context);
  const disabled = state2.context.disabled;
  const popperStyles = getPlacementStyles({
    ...state2.context.positioning,
    placement: state2.context.currentPlacement
  });
  return {
    open,
    setOpen(nextOpen) {
      if (nextOpen === open) return;
      send(nextOpen ? "OPEN" : "CLOSE");
    },
    reposition(options = {}) {
      send({ type: "POSITIONING.SET", options });
    },
    getTriggerProps() {
      return normalize2.button({
        ...parts25.trigger.attrs,
        id: triggerId,
        dir: state2.context.dir,
        "data-expanded": dataAttr(open),
        "data-state": open ? "open" : "closed",
        "aria-describedby": open ? contentId : void 0,
        onClick(event) {
          if (event.defaultPrevented) return;
          if (disabled) return;
          if (!state2.context.closeOnClick) return;
          send({ type: "CLOSE", src: "trigger.click" });
        },
        onFocus(event) {
          if (event.defaultPrevented) return;
          if (disabled) return;
          if (state2.event.src === "trigger.pointerdown") return;
          if (!isFocusVisible()) return;
          send({ type: "OPEN", src: "trigger.focus" });
        },
        onBlur(event) {
          if (event.defaultPrevented) return;
          if (disabled) return;
          if (id === store.id) {
            send({ type: "CLOSE", src: "trigger.blur" });
          }
        },
        onPointerDown(event) {
          if (event.defaultPrevented) return;
          if (disabled) return;
          if (!state2.context.closeOnPointerDown) return;
          if (id === store.id) {
            send({ type: "CLOSE", src: "trigger.pointerdown" });
          }
        },
        onPointerMove(event) {
          if (event.defaultPrevented) return;
          if (disabled) return;
          if (event.pointerType === "touch") return;
          send("POINTER_MOVE");
        },
        onPointerLeave() {
          if (disabled) return;
          send("POINTER_LEAVE");
        },
        onPointerCancel() {
          if (disabled) return;
          send("POINTER_LEAVE");
        }
      });
    },
    getArrowProps() {
      return normalize2.element({
        id: dom22.getArrowId(state2.context),
        ...parts25.arrow.attrs,
        dir: state2.context.dir,
        style: popperStyles.arrow
      });
    },
    getArrowTipProps() {
      return normalize2.element({
        ...parts25.arrowTip.attrs,
        dir: state2.context.dir,
        style: popperStyles.arrowTip
      });
    },
    getPositionerProps() {
      return normalize2.element({
        id: dom22.getPositionerId(state2.context),
        ...parts25.positioner.attrs,
        dir: state2.context.dir,
        style: popperStyles.floating
      });
    },
    getContentProps() {
      return normalize2.element({
        ...parts25.content.attrs,
        dir: state2.context.dir,
        hidden: !open,
        "data-state": open ? "open" : "closed",
        role: hasAriaLabel ? void 0 : "tooltip",
        id: hasAriaLabel ? void 0 : contentId,
        "data-placement": state2.context.currentPlacement,
        onPointerEnter() {
          send("CONTENT.POINTER_MOVE");
        },
        onPointerLeave() {
          send("CONTENT.POINTER_LEAVE");
        },
        style: {
          pointerEvents: state2.context.interactive ? "auto" : "none"
        }
      });
    }
  };
}
var { and: and9, not: not10 } = guards;
function machine23(userContext) {
  const ctx = compact2(userContext);
  return createMachine(
    {
      id: "tooltip",
      initial: ctx.open ? "open" : "closed",
      activities: ["trackFocusVisible"],
      context: {
        openDelay: 1e3,
        closeDelay: 500,
        closeOnPointerDown: true,
        closeOnEscape: true,
        interactive: false,
        closeOnScroll: true,
        closeOnClick: true,
        disabled: false,
        ...ctx,
        currentPlacement: void 0,
        hasPointerMoveOpened: false,
        positioning: {
          placement: "bottom",
          ...ctx.positioning
        }
      },
      computed: {
        hasAriaLabel: (ctx2) => !!ctx2["aria-label"]
      },
      watch: {
        disabled: ["closeIfDisabled"],
        open: ["toggleVisibility"]
      },
      states: {
        closed: {
          tags: ["closed"],
          entry: ["clearGlobalId"],
          on: {
            "CONTROLLED.OPEN": "open",
            OPEN: [
              {
                guard: "isOpenControlled",
                actions: ["invokeOnOpen"]
              },
              {
                target: "open",
                actions: ["invokeOnOpen"]
              }
            ],
            POINTER_LEAVE: {
              actions: ["clearPointerMoveOpened"]
            },
            POINTER_MOVE: [
              {
                guard: and9("noVisibleTooltip", not10("hasPointerMoveOpened")),
                target: "opening"
              },
              {
                guard: not10("hasPointerMoveOpened"),
                target: "open",
                actions: ["setPointerMoveOpened", "invokeOnOpen"]
              }
            ]
          }
        },
        opening: {
          tags: ["closed"],
          activities: ["trackScroll", "trackPointerlockChange"],
          after: {
            OPEN_DELAY: [
              {
                guard: "isOpenControlled",
                actions: ["setPointerMoveOpened", "invokeOnOpen"]
              },
              {
                target: "open",
                actions: ["setPointerMoveOpened", "invokeOnOpen"]
              }
            ]
          },
          on: {
            "CONTROLLED.OPEN": "open",
            "CONTROLLED.CLOSE": "closed",
            OPEN: [
              {
                guard: "isOpenControlled",
                actions: ["invokeOnOpen"]
              },
              {
                target: "open",
                actions: ["invokeOnOpen"]
              }
            ],
            POINTER_LEAVE: [
              {
                guard: "isOpenControlled",
                // We trigger toggleVisibility manually since the `ctx.open` has not changed yet (at this point)
                actions: ["clearPointerMoveOpened", "invokeOnClose", "toggleVisibility"]
              },
              {
                target: "closed",
                actions: ["clearPointerMoveOpened", "invokeOnClose"]
              }
            ],
            CLOSE: [
              {
                guard: "isOpenControlled",
                // We trigger toggleVisibility manually since the `ctx.open` has not changed yet (at this point)
                actions: ["invokeOnClose", "toggleVisibility"]
              },
              {
                target: "closed",
                actions: ["invokeOnClose"]
              }
            ]
          }
        },
        open: {
          tags: ["open"],
          activities: ["trackEscapeKey", "trackScroll", "trackPointerlockChange", "trackPositioning"],
          entry: ["setGlobalId"],
          on: {
            "CONTROLLED.CLOSE": "closed",
            CLOSE: [
              {
                guard: "isOpenControlled",
                actions: ["invokeOnClose"]
              },
              {
                target: "closed",
                actions: ["invokeOnClose"]
              }
            ],
            POINTER_LEAVE: [
              {
                guard: "isVisible",
                target: "closing",
                actions: ["clearPointerMoveOpened"]
              },
              // == group ==
              {
                guard: "isOpenControlled",
                actions: ["clearPointerMoveOpened", "invokeOnClose"]
              },
              {
                target: "closed",
                actions: ["clearPointerMoveOpened", "invokeOnClose"]
              }
            ],
            "CONTENT.POINTER_LEAVE": {
              guard: "isInteractive",
              target: "closing"
            },
            "POSITIONING.SET": {
              actions: "reposition"
            }
          }
        },
        closing: {
          tags: ["open"],
          activities: ["trackStore", "trackPositioning"],
          after: {
            CLOSE_DELAY: [
              {
                guard: "isOpenControlled",
                actions: ["invokeOnClose"]
              },
              {
                target: "closed",
                actions: ["invokeOnClose"]
              }
            ]
          },
          on: {
            "CONTROLLED.CLOSE": "closed",
            "CONTROLLED.OPEN": "open",
            CLOSE: [
              {
                guard: "isOpenControlled",
                actions: ["invokeOnClose"]
              },
              {
                target: "closed",
                actions: ["invokeOnClose"]
              }
            ],
            POINTER_MOVE: [
              {
                guard: "isOpenControlled",
                // We trigger toggleVisibility manually since the `ctx.open` has not changed yet (at this point)
                actions: ["setPointerMoveOpened", "invokeOnOpen", "toggleVisibility"]
              },
              {
                target: "open",
                actions: ["setPointerMoveOpened", "invokeOnOpen"]
              }
            ],
            "CONTENT.POINTER_MOVE": {
              guard: "isInteractive",
              target: "open"
            },
            "POSITIONING.SET": {
              actions: "reposition"
            }
          }
        }
      }
    },
    {
      activities: {
        trackFocusVisible(ctx2) {
          return trackFocusVisible({ root: dom22.getRootNode(ctx2) });
        },
        trackPositioning(ctx2) {
          ctx2.currentPlacement || (ctx2.currentPlacement = ctx2.positioning.placement);
          const getPositionerEl = () => dom22.getPositionerEl(ctx2);
          return getPlacement(dom22.getTriggerEl(ctx2), getPositionerEl, {
            ...ctx2.positioning,
            defer: true,
            onComplete(data) {
              ctx2.currentPlacement = data.placement;
            }
          });
        },
        trackPointerlockChange(ctx2, _evt, { send }) {
          const onChange = () => send({ type: "CLOSE", src: "pointerlock:change" });
          return addDomEvent(dom22.getDoc(ctx2), "pointerlockchange", onChange, false);
        },
        trackScroll(ctx2, _evt, { send }) {
          if (!ctx2.closeOnScroll) return;
          const triggerEl = dom22.getTriggerEl(ctx2);
          if (!triggerEl) return;
          const overflowParents = getOverflowAncestors(triggerEl);
          const cleanups2 = overflowParents.map((overflowParent) => {
            const onScroll = () => {
              send({ type: "CLOSE", src: "scroll" });
            };
            return addDomEvent(overflowParent, "scroll", onScroll, { passive: true, capture: true });
          });
          return () => {
            cleanups2.forEach((fn) => fn == null ? void 0 : fn());
          };
        },
        trackStore(ctx2, _evt, { send }) {
          return subscribe(store, () => {
            if (store.id !== ctx2.id) {
              send({ type: "CLOSE", src: "id.change" });
            }
          });
        },
        trackEscapeKey(ctx2, _evt, { send }) {
          if (!ctx2.closeOnEscape) return;
          const onKeyDown = (event) => {
            if (isComposingEvent(event)) return;
            if (event.key !== "Escape") return;
            event.stopPropagation();
            send({ type: "CLOSE", src: "keydown.escape" });
          };
          return addDomEvent(dom22.getDoc(ctx2), "keydown", onKeyDown, true);
        }
      },
      actions: {
        setGlobalId(ctx2) {
          store.setId(ctx2.id);
        },
        clearGlobalId(ctx2) {
          if (ctx2.id === store.id) {
            store.setId(null);
          }
        },
        invokeOnOpen(ctx2) {
          var _a8;
          (_a8 = ctx2.onOpenChange) == null ? void 0 : _a8.call(ctx2, { open: true });
        },
        invokeOnClose(ctx2) {
          var _a8;
          (_a8 = ctx2.onOpenChange) == null ? void 0 : _a8.call(ctx2, { open: false });
        },
        closeIfDisabled(ctx2, _evt, { send }) {
          if (!ctx2.disabled) return;
          send({ type: "CLOSE", src: "disabled.change" });
        },
        reposition(ctx2, evt) {
          const getPositionerEl = () => dom22.getPositionerEl(ctx2);
          getPlacement(dom22.getTriggerEl(ctx2), getPositionerEl, {
            ...ctx2.positioning,
            ...evt.options,
            defer: true,
            listeners: false,
            onComplete(data) {
              ctx2.currentPlacement = data.placement;
            }
          });
        },
        toggleVisibility(ctx2, evt, { send }) {
          queueMicrotask(() => {
            send({ type: ctx2.open ? "CONTROLLED.OPEN" : "CONTROLLED.CLOSE", previousEvent: evt });
          });
        },
        setPointerMoveOpened(ctx2) {
          ctx2.hasPointerMoveOpened = true;
        },
        clearPointerMoveOpened(ctx2) {
          ctx2.hasPointerMoveOpened = false;
        }
      },
      guards: {
        noVisibleTooltip: () => store.id === null,
        isVisible: (ctx2) => ctx2.id === store.id,
        isInteractive: (ctx2) => ctx2.interactive,
        hasPointerMoveOpened: (ctx2) => !!ctx2.hasPointerMoveOpened,
        isOpenControlled: (ctx2) => !!ctx2["open.controlled"]
      },
      delays: {
        OPEN_DELAY: (ctx2) => ctx2.openDelay,
        CLOSE_DELAY: (ctx2) => ctx2.closeDelay
      }
    }
  );
}
var props20 = createProps2()([
  "aria-label",
  "closeDelay",
  "closeOnEscape",
  "closeOnPointerDown",
  "closeOnScroll",
  "closeOnClick",
  "dir",
  "disabled",
  "getRootNode",
  "id",
  "ids",
  "interactive",
  "onOpenChange",
  "open.controlled",
  "open",
  "openDelay",
  "positioning"
]);
var splitProps21 = createSplitProps(props20);

// node_modules/@ark-ui/react/dist/components/tooltip/use-tooltip.js
var import_react498 = __toESM(require_react(), 1);
var useTooltip = (props21 = {}) => {
  const { getRootNode } = useEnvironmentContext();
  const { dir } = useLocaleContext();
  const initialContext = {
    id: (0, import_react498.useId)(),
    dir,
    getRootNode,
    open: props21.defaultOpen,
    "open.controlled": props21.open !== void 0,
    ...props21
  };
  const context = {
    ...initialContext,
    onOpenChange: useEvent(props21.onOpenChange, { sync: true })
  };
  const [state2, send] = useMachine(machine23(initialContext), { context });
  return connect23(state2, send, normalizeProps);
};

// node_modules/@ark-ui/react/dist/components/tooltip/tooltip-root.js
var TooltipRoot = (props21) => {
  const [presenceProps, { children, ...localProps }] = splitPresenceProps(props21);
  const tooltip = useTooltip(localProps);
  const presence = usePresence(mergeProps({ present: tooltip.open }, presenceProps));
  return (0, import_jsx_runtime228.jsx)(TooltipProvider, { value: tooltip, children: (0, import_jsx_runtime228.jsx)(PresenceProvider, { value: presence, children }) });
};

// node_modules/@ark-ui/react/dist/components/tooltip/tooltip-root-provider.js
var import_jsx_runtime229 = __toESM(require_jsx_runtime(), 1);
var TooltipRootProvider = (props21) => {
  const [presenceProps, { value: tooltip, children }] = splitPresenceProps(props21);
  const presence = usePresence(mergeProps({ present: tooltip.open }, presenceProps));
  return (0, import_jsx_runtime229.jsx)(TooltipProvider, { value: tooltip, children: (0, import_jsx_runtime229.jsx)(PresenceProvider, { value: presence, children }) });
};

// node_modules/@ark-ui/react/dist/components/tooltip/tooltip-trigger.js
var import_jsx_runtime230 = __toESM(require_jsx_runtime(), 1);
var import_react502 = __toESM(require_react(), 1);
var TooltipTrigger = (0, import_react502.forwardRef)((props21, ref2) => {
  const tooltip = useTooltipContext();
  const mergedProps = mergeProps(tooltip.getTriggerProps(), props21);
  return (0, import_jsx_runtime230.jsx)(ark.button, { ...mergedProps, ref: ref2 });
});
TooltipTrigger.displayName = "TooltipTrigger";

// node_modules/@ark-ui/react/dist/components/tooltip/tooltip.js
var tooltip_exports = {};
__export(tooltip_exports, {
  Arrow: () => TooltipArrow,
  ArrowTip: () => TooltipArrowTip,
  Content: () => TooltipContent,
  Context: () => TooltipContext,
  Positioner: () => TooltipPositioner,
  Root: () => TooltipRoot,
  RootProvider: () => TooltipRootProvider,
  Trigger: () => TooltipTrigger
});

// node_modules/@chakra-ui/react/dist/esm/anatomy.js
var accordionAnatomy = anatomy.extendWith("itemBody");
var actionBarAnatomy = createAnatomy("action-bar").parts(
  "positioner",
  "content",
  "separator",
  "selectionTrigger",
  "closeTrigger"
);
var alertAnatomy = createAnatomy("alert").parts(
  "title",
  "description",
  "root",
  "indicator",
  "content"
);
var breadcrumbAnatomy = createAnatomy("breadcrumb").parts(
  "link",
  "currentLink",
  "item",
  "list",
  "root",
  "ellipsis",
  "separator"
);
var blockquoteAnatomy = createAnatomy("blockquote").parts(
  "root",
  "icon",
  "content",
  "caption"
);
var cardAnatomy = createAnatomy("card").parts(
  "root",
  "header",
  "body",
  "footer",
  "title",
  "description"
);
var checkboxCardAnatomy = createAnatomy("checkbox-card", [
  "root",
  "control",
  "label",
  "description",
  "addon",
  "indicator",
  "content"
]);
var dataListAnatomy = createAnatomy("data-list").parts(
  "root",
  "item",
  "itemLabel",
  "itemValue"
);
var dialogAnatomy = anatomy5.extendWith(
  "header",
  "body",
  "footer",
  "backdrop"
);
var drawerAnatomy = anatomy5.extendWith(
  "header",
  "body",
  "footer",
  "backdrop"
);
var editableAnatomy = anatomy6.extendWith("textarea");
var emptyStateAnatomy = createAnatomy("empty-state", [
  "root",
  "content",
  "indicator",
  "title",
  "description"
]);
var fieldAnatomy2 = fieldAnatomy.extendWith("requiredIndicator");
var fieldsetAnatomy2 = fieldsetAnatomy.extendWith("content");
var fileUploadAnatomy = anatomy7.extendWith(
  "itemContent",
  "dropzoneContent"
);
var listAnatomy = createAnatomy("list").parts(
  "root",
  "item",
  "indicator"
);
var menuAnatomy = anatomy8.extendWith("itemCommand");
var nativeSelectAnatomy = createAnatomy("select").parts(
  "root",
  "field",
  "indicator"
);
var popoverAnatomy = anatomy9.extendWith(
  "header",
  "body",
  "footer"
);
var radioGroupAnatomy = anatomy10.extendWith(
  "itemAddon",
  "itemIndicator"
);
var radioCardAnatomy = radioGroupAnatomy.extendWith(
  "itemContent",
  "itemDescription"
);
var ratingGroupAnatomy = anatomy11.extendWith("itemIndicator");
var selectAnatomy = anatomy12.extendWith("indicatorGroup");
var sliderAnatomy = anatomy13.extendWith("markerIndicator");
var statAnatomy = createAnatomy("stat").parts(
  "root",
  "label",
  "helpText",
  "valueText",
  "valueUnit",
  "indicator"
);
var statusAnatomy = createAnatomy("status").parts("root", "indicator");
var stepsAnatomy = createAnatomy("steps", [
  "root",
  "list",
  "item",
  "trigger",
  "indicator",
  "separator",
  "content",
  "title",
  "description",
  "nextTrigger",
  "prevTrigger",
  "progress"
]);
var switchAnatomy = anatomy14.extendWith("indicator");
var tableAnatomy = createAnatomy("table").parts(
  "root",
  "header",
  "body",
  "row",
  "columnHeader",
  "cell",
  "footer",
  "caption"
);
var toastAnatomy = createAnatomy("toast").parts(
  "root",
  "title",
  "description",
  "indicator",
  "closeTrigger",
  "actionTrigger"
);
var tabsAnatomy = createAnatomy("tabs").parts(
  "root",
  "trigger",
  "list",
  "content",
  "contentGroup",
  "indicator"
);
var tagAnatomy = createAnatomy("tag").parts(
  "root",
  "label",
  "closeTrigger",
  "startElement",
  "endElement"
);
var timelineAnatomy = createAnatomy("timeline").parts(
  "root",
  "item",
  "content",
  "separator",
  "indicator",
  "connector",
  "title",
  "description"
);

// node_modules/@chakra-ui/react/dist/esm/theme/recipes/accordion.js
var accordionSlotRecipe = defineSlotRecipe({
  className: "chakra-accordion",
  slots: accordionAnatomy.keys(),
  base: {
    root: {
      width: "full",
      "--accordion-radius": "radii.l2"
    },
    item: {
      overflowAnchor: "none"
    },
    itemTrigger: {
      display: "flex",
      alignItems: "center",
      width: "full",
      outline: "0",
      gap: "3",
      fontWeight: "medium",
      borderRadius: "var(--accordion-radius)",
      _focusVisible: {
        outline: "2px solid",
        outlineColor: "colorPalette.focusRing"
      },
      _disabled: {
        layerStyle: "disabled"
      }
    },
    itemBody: {
      pt: "var(--accordion-padding-y)",
      pb: "calc(var(--accordion-padding-y) * 2)"
    },
    itemContent: {
      overflow: "hidden",
      borderRadius: "var(--accordion-radius)",
      _open: {
        animationName: "expand-height, fade-in",
        animationDuration: "moderate"
      },
      _closed: {
        animationName: "collapse-height, fade-out",
        animationDuration: "moderate"
      }
    },
    itemIndicator: {
      transition: "rotate 0.2s",
      transformOrigin: "center",
      color: "fg.subtle",
      _open: {
        rotate: "180deg"
      },
      _icon: {
        width: "1.2em",
        height: "1.2em"
      }
    }
  },
  variants: {
    variant: {
      outline: {
        item: {
          borderBottomWidth: "1px"
        }
      },
      subtle: {
        itemTrigger: {
          px: "var(--accordion-padding-x)"
        },
        itemContent: {
          px: "var(--accordion-padding-x)"
        },
        item: {
          borderRadius: "var(--accordion-radius)",
          _open: {
            bg: "colorPalette.subtle"
          }
        }
      },
      enclosed: {
        root: {
          borderWidth: "1px",
          borderRadius: "var(--accordion-radius)",
          divideY: "1px",
          overflow: "hidden"
        },
        itemTrigger: {
          px: "var(--accordion-padding-x)"
        },
        itemContent: {
          px: "var(--accordion-padding-x)"
        },
        item: {
          _open: {
            bg: "bg.subtle"
          }
        }
      },
      plain: {}
    },
    size: {
      sm: {
        root: {
          "--accordion-padding-x": "spacing.3",
          "--accordion-padding-y": "spacing.2"
        },
        itemTrigger: {
          textStyle: "sm",
          py: "var(--accordion-padding-y)"
        }
      },
      md: {
        root: {
          "--accordion-padding-x": "spacing.4",
          "--accordion-padding-y": "spacing.2"
        },
        itemTrigger: {
          textStyle: "md",
          py: "var(--accordion-padding-y)"
        }
      },
      lg: {
        root: {
          "--accordion-padding-x": "spacing.4.5",
          "--accordion-padding-y": "spacing.2.5"
        },
        itemTrigger: {
          textStyle: "lg",
          py: "var(--accordion-padding-y)"
        }
      }
    }
  },
  defaultVariants: {
    size: "md",
    variant: "outline"
  }
});

// node_modules/@chakra-ui/react/dist/esm/theme/recipes/action-bar.js
var actionBarSlotRecipe = defineSlotRecipe({
  className: "chakra-action-bar",
  slots: actionBarAnatomy.keys(),
  base: {
    positioner: {
      position: "fixed",
      display: "flex",
      justifyContent: "center",
      pointerEvents: "none",
      insetInline: "0",
      top: "unset",
      bottom: "calc(env(safe-area-inset-bottom) + 20px)"
    },
    content: {
      bg: "bg.panel",
      shadow: "md",
      display: "flex",
      alignItems: "center",
      gap: "3",
      borderRadius: "l3",
      py: "2.5",
      px: "3",
      pointerEvents: "auto",
      // Stabilize the position of the action bar when the scrollbar is hidden
      // by using the scrollbar width to offset the position.
      translate: "calc(-1 * var(--scrollbar-width) / 2) 0px",
      _open: {
        animationName: "slide-from-bottom, fade-in",
        animationDuration: "moderate"
      },
      _closed: {
        animationName: "slide-to-bottom, fade-out",
        animationDuration: "faster"
      }
    },
    separator: {
      width: "1px",
      height: "5",
      bg: "border"
    },
    selectionTrigger: {
      display: "inline-flex",
      alignItems: "center",
      gap: "2",
      alignSelf: "stretch",
      textStyle: "sm",
      px: "4",
      py: "1",
      borderRadius: "l2",
      borderWidth: "1px",
      borderStyle: "dashed"
    }
  }
});

// node_modules/@chakra-ui/react/dist/esm/theme/recipes/alert.js
var alertSlotRecipe = defineSlotRecipe({
  slots: alertAnatomy.keys(),
  className: "chakra-alert",
  base: {
    root: {
      width: "full",
      display: "flex",
      alignItems: "flex-start",
      position: "relative",
      borderRadius: "l3"
    },
    title: {
      fontWeight: "medium"
    },
    description: {
      display: "inline"
    },
    indicator: {
      display: "inline-flex",
      alignItems: "center",
      justifyContent: "center",
      flexShrink: "0",
      width: "1em",
      height: "1em",
      _icon: { boxSize: "full" }
    },
    content: {
      display: "flex",
      flex: "1",
      gap: "1"
    }
  },
  variants: {
    status: {
      info: {
        root: { colorPalette: "blue" }
      },
      warning: {
        root: { colorPalette: "orange" }
      },
      success: {
        root: { colorPalette: "green" }
      },
      error: {
        root: { colorPalette: "red" }
      },
      neutral: {
        root: { colorPalette: "gray" }
      }
    },
    inline: {
      true: {
        content: {
          display: "inline-flex",
          flexDirection: "row",
          alignItems: "center"
        }
      },
      false: {
        content: {
          display: "flex",
          flexDirection: "column"
        }
      }
    },
    variant: {
      subtle: {
        root: {
          bg: "colorPalette.subtle",
          color: "colorPalette.fg"
        }
      },
      surface: {
        root: {
          bg: "colorPalette.subtle",
          color: "colorPalette.fg",
          shadow: "inset 0 0 0px 1px var(--shadow-color)",
          shadowColor: "colorPalette.muted"
        },
        indicator: {
          color: "colorPalette.fg"
        }
      },
      outline: {
        root: {
          color: "colorPalette.fg",
          shadow: "inset 0 0 0px 1px var(--shadow-color)",
          shadowColor: "colorPalette.muted"
        },
        indicator: {
          color: "colorPalette.fg"
        }
      },
      solid: {
        root: {
          bg: "colorPalette.solid",
          color: "colorPalette.contrast"
        },
        indicator: {
          color: "colorPalette.contrast"
        }
      }
    },
    size: {
      sm: {
        root: {
          gap: "2",
          px: "3",
          py: "3",
          textStyle: "xs"
        },
        indicator: {
          textStyle: "lg"
        }
      },
      md: {
        root: {
          gap: "3",
          px: "4",
          py: "4",
          textStyle: "sm"
        },
        indicator: {
          textStyle: "xl"
        }
      },
      lg: {
        root: {
          gap: "3",
          px: "4",
          py: "4",
          textStyle: "md"
        },
        indicator: {
          textStyle: "2xl"
        }
      }
    }
  },
  defaultVariants: {
    status: "info",
    variant: "subtle",
    size: "md",
    inline: false
  }
});

// node_modules/@chakra-ui/react/dist/esm/theme/recipes/avatar.js
var avatarSlotRecipe = defineSlotRecipe({
  slots: anatomy15.keys(),
  className: "chakra-avatar",
  base: {
    root: {
      display: "inline-flex",
      alignItems: "center",
      justifyContent: "center",
      fontWeight: "medium",
      position: "relative",
      verticalAlign: "top",
      flexShrink: "0",
      userSelect: "none",
      width: "var(--avatar-size)",
      height: "var(--avatar-size)",
      fontSize: "var(--avatar-font-size)",
      borderRadius: "var(--avatar-radius)",
      "&[data-group-item]": {
        borderWidth: "2px",
        borderColor: "bg"
      }
    },
    image: {
      width: "100%",
      height: "100%",
      objectFit: "cover",
      borderRadius: "var(--avatar-radius)"
    },
    fallback: {
      lineHeight: "1",
      textTransform: "uppercase",
      fontWeight: "medium",
      fontSize: "var(--avatar-font-size)",
      borderRadius: "var(--avatar-radius)"
    }
  },
  variants: {
    size: {
      full: {
        root: {
          "--avatar-size": "100%",
          "--avatar-font-size": "100%"
        }
      },
      "2xs": {
        root: {
          "--avatar-font-size": "fontSizes.2xs",
          "--avatar-size": "sizes.6"
        }
      },
      xs: {
        root: {
          "--avatar-font-size": "fontSizes.xs",
          "--avatar-size": "sizes.8"
        }
      },
      sm: {
        root: {
          "--avatar-font-size": "fontSizes.sm",
          "--avatar-size": "sizes.9"
        }
      },
      md: {
        root: {
          "--avatar-font-size": "fontSizes.md",
          "--avatar-size": "sizes.10"
        }
      },
      lg: {
        root: {
          "--avatar-font-size": "fontSizes.md",
          "--avatar-size": "sizes.11"
        }
      },
      xl: {
        root: {
          "--avatar-font-size": "fontSizes.lg",
          "--avatar-size": "sizes.12"
        }
      },
      "2xl": {
        root: {
          "--avatar-font-size": "fontSizes.xl",
          "--avatar-size": "sizes.16"
        }
      }
    },
    variant: {
      solid: {
        root: {
          bg: "colorPalette.solid",
          color: "colorPalette.contrast"
        }
      },
      subtle: {
        root: {
          bg: "colorPalette.muted",
          color: "colorPalette.fg"
        }
      },
      outline: {
        root: {
          color: "colorPalette.fg",
          borderWidth: "1px",
          borderColor: "colorPalette.muted"
        }
      }
    },
    shape: {
      square: {},
      rounded: {
        root: { "--avatar-radius": "radii.l3" }
      },
      full: {
        root: { "--avatar-radius": "radii.full" }
      }
    },
    borderless: {
      true: {
        root: {
          "&[data-group-item]": {
            borderWidth: "0px"
          }
        }
      }
    }
  },
  defaultVariants: {
    size: "md",
    shape: "full",
    variant: "subtle"
  }
});

// node_modules/@chakra-ui/react/dist/esm/theme/recipes/blockquote.js
var blockquoteSlotRecipe = defineSlotRecipe({
  className: "chakra-blockquote",
  slots: blockquoteAnatomy.keys(),
  base: {
    root: {
      position: "relative",
      display: "flex",
      flexDirection: "column",
      gap: "2"
    },
    caption: {
      textStyle: "sm",
      color: "fg.muted"
    },
    icon: {
      boxSize: "5"
    }
  },
  variants: {
    justify: {
      start: {
        root: {
          alignItems: "flex-start",
          textAlign: "start"
        }
      },
      center: {
        root: {
          alignItems: "center",
          textAlign: "center"
        }
      },
      end: {
        root: {
          alignItems: "flex-end",
          textAlign: "end"
        }
      }
    },
    variant: {
      subtle: {
        root: {
          paddingX: "5",
          borderStartWidth: "4px",
          borderStartColor: "colorPalette.muted"
        },
        icon: {
          color: "colorPalette.fg"
        }
      },
      solid: {
        root: {
          paddingX: "5",
          borderStartWidth: "4px",
          borderStartColor: "colorPalette.solid"
        },
        icon: {
          color: "colorPalette.solid"
        }
      },
      plain: {
        root: {
          paddingX: "5"
        },
        icon: {
          color: "colorPalette.solid"
        }
      }
    }
  },
  defaultVariants: {
    variant: "subtle",
    justify: "start"
  }
});

// node_modules/@chakra-ui/react/dist/esm/theme/recipes/breadcrumb.js
var breadcrumbSlotRecipe = defineSlotRecipe({
  className: "chakra-breadcrumb",
  slots: breadcrumbAnatomy.keys(),
  base: {
    list: {
      display: "flex",
      alignItems: "center",
      wordBreak: "break-word",
      color: "fg.muted",
      listStyle: "none"
    },
    link: {
      outline: "0",
      textDecoration: "none",
      borderRadius: "l1",
      focusRing: "outside",
      display: "inline-flex",
      alignItems: "center",
      gap: "2"
    },
    item: {
      display: "inline-flex",
      alignItems: "center"
    },
    separator: {
      color: "fg.muted",
      opacity: "0.8",
      _icon: {
        boxSize: "1em"
      },
      _rtl: {
        rotate: "180deg"
      }
    },
    ellipsis: {
      display: "inline-flex",
      alignItems: "center",
      justifyContent: "center",
      _icon: {
        boxSize: "1em"
      }
    }
  },
  variants: {
    variant: {
      underline: {
        link: {
          color: "colorPalette.fg",
          textDecoration: "underline",
          textUnderlineOffset: "0.2em",
          textDecorationColor: "colorPalette.muted"
        },
        currentLink: {
          color: "colorPalette.fg"
        }
      },
      plain: {
        link: {
          color: "fg.muted",
          _hover: { color: "fg" }
        },
        currentLink: {
          color: "fg"
        }
      }
    },
    size: {
      sm: {
        list: {
          gap: "1",
          textStyle: "xs"
        }
      },
      md: {
        list: {
          gap: "1.5",
          textStyle: "sm"
        }
      },
      lg: {
        list: {
          gap: "2",
          textStyle: "md"
        }
      }
    }
  },
  defaultVariants: {
    variant: "plain",
    size: "md"
  }
});

// node_modules/@chakra-ui/react/dist/esm/theme/recipes/card.js
var cardSlotRecipe = defineSlotRecipe({
  className: "chakra-card",
  slots: cardAnatomy.keys(),
  base: {
    root: {
      display: "flex",
      flexDirection: "column",
      position: "relative",
      minWidth: "0",
      wordWrap: "break-word",
      borderRadius: "l3",
      color: "fg",
      textAlign: "start"
    },
    title: {
      fontWeight: "semibold"
    },
    description: {
      color: "fg.muted",
      fontSize: "sm"
    },
    header: {
      paddingInline: "var(--card-padding)",
      paddingTop: "var(--card-padding)",
      display: "flex",
      flexDirection: "column",
      gap: "1.5"
    },
    body: {
      padding: "var(--card-padding)",
      flex: "1",
      display: "flex",
      flexDirection: "column"
    },
    footer: {
      display: "flex",
      alignItems: "center",
      gap: "2",
      paddingInline: "var(--card-padding)",
      paddingBottom: "var(--card-padding)"
    }
  },
  variants: {
    size: {
      sm: {
        root: {
          "--card-padding": "spacing.4"
        },
        title: {
          textStyle: "md"
        }
      },
      md: {
        root: {
          "--card-padding": "spacing.6"
        },
        title: {
          textStyle: "lg"
        }
      },
      lg: {
        root: {
          "--card-padding": "spacing.7"
        },
        title: {
          textStyle: "xl"
        }
      }
    },
    variant: {
      elevated: {
        root: {
          bg: "bg.panel",
          boxShadow: "md"
        }
      },
      outline: {
        root: {
          bg: "bg.panel",
          borderWidth: "1px",
          borderColor: "border"
        }
      },
      subtle: {
        root: {
          bg: "bg.muted"
        }
      }
    }
  },
  defaultVariants: {
    variant: "outline",
    size: "md"
  }
});

// node_modules/@chakra-ui/react/dist/esm/theme/recipes/checkbox.js
var _a, _b, _c, _d, _e, _f, _g, _h, _i, _j, _k, _l, _m, _n;
var checkboxSlotRecipe = defineSlotRecipe({
  slots: checkboxAnatomy.keys(),
  className: "chakra-checkbox",
  base: {
    root: {
      display: "inline-flex",
      gap: "2",
      alignItems: "center",
      verticalAlign: "top",
      position: "relative"
    },
    control: checkmarkRecipe.base,
    label: {
      fontWeight: "medium",
      userSelect: "none",
      _disabled: {
        opacity: "0.5"
      }
    }
  },
  variants: {
    size: {
      xs: {
        root: { gap: "1.5" },
        label: { textStyle: "xs" },
        control: (_b = (_a = checkmarkRecipe.variants) == null ? void 0 : _a.size) == null ? void 0 : _b.xs
      },
      sm: {
        root: { gap: "2" },
        label: { textStyle: "sm" },
        control: (_d = (_c = checkmarkRecipe.variants) == null ? void 0 : _c.size) == null ? void 0 : _d.sm
      },
      md: {
        root: { gap: "2.5" },
        label: { textStyle: "sm" },
        control: (_f = (_e = checkmarkRecipe.variants) == null ? void 0 : _e.size) == null ? void 0 : _f.md
      },
      lg: {
        root: { gap: "3" },
        label: { textStyle: "md" },
        control: (_h = (_g = checkmarkRecipe.variants) == null ? void 0 : _g.size) == null ? void 0 : _h.lg
      }
    },
    variant: {
      outline: {
        control: (_j = (_i = checkmarkRecipe.variants) == null ? void 0 : _i.variant) == null ? void 0 : _j.outline
      },
      solid: {
        control: (_l = (_k = checkmarkRecipe.variants) == null ? void 0 : _k.variant) == null ? void 0 : _l.solid
      },
      subtle: {
        control: (_n = (_m = checkmarkRecipe.variants) == null ? void 0 : _m.variant) == null ? void 0 : _n.subtle
      }
    }
  },
  defaultVariants: {
    variant: "solid",
    size: "md"
  }
});

// node_modules/@chakra-ui/react/dist/esm/theme/recipes/checkbox-card.js
var _a2, _b2, _c2, _d2, _e2, _f2, _g2;
var checkboxCardSlotRecipe = defineSlotRecipe({
  slots: checkboxCardAnatomy.keys(),
  className: "chakra-checkbox-card",
  base: {
    root: {
      display: "flex",
      flexDirection: "column",
      userSelect: "none",
      position: "relative",
      borderRadius: "l2",
      flex: "1",
      focusVisibleRing: "outside",
      _disabled: {
        opacity: "0.8",
        borderColor: "border.subtle"
      },
      _invalid: {
        outline: "2px solid",
        outlineColor: "border.error"
      }
    },
    control: {
      display: "inline-flex",
      flex: "1",
      position: "relative",
      borderRadius: "inherit",
      justifyContent: "var(--checkbox-card-justify)",
      alignItems: "var(--checkbox-card-align)"
    },
    label: {
      fontWeight: "medium",
      display: "flex",
      alignItems: "center",
      gap: "2",
      _disabled: {
        opacity: "0.5"
      }
    },
    description: {
      opacity: "0.64",
      textStyle: "sm"
    },
    addon: {
      _disabled: {
        opacity: "0.5"
      }
    },
    indicator: checkmarkRecipe.base,
    content: {
      display: "flex",
      flexDirection: "column",
      flex: "1",
      gap: "1",
      justifyContent: "var(--checkbox-card-justify)",
      alignItems: "var(--checkbox-card-align)"
    }
  },
  variants: {
    size: {
      sm: {
        root: {
          textStyle: "sm"
        },
        control: {
          padding: "3",
          gap: "1.5"
        },
        addon: {
          px: "3",
          py: "1.5",
          borderTopWidth: "1px"
        },
        indicator: (_a2 = checkmarkRecipe.variants) == null ? void 0 : _a2.size.sm
      },
      md: {
        root: {
          textStyle: "sm"
        },
        control: {
          padding: "4",
          gap: "2.5"
        },
        addon: {
          px: "4",
          py: "2",
          borderTopWidth: "1px"
        },
        indicator: (_b2 = checkmarkRecipe.variants) == null ? void 0 : _b2.size.md
      },
      lg: {
        root: {
          textStyle: "md"
        },
        control: {
          padding: "4",
          gap: "3.5"
        },
        addon: {
          px: "4",
          py: "2",
          borderTopWidth: "1px"
        },
        indicator: (_c2 = checkmarkRecipe.variants) == null ? void 0 : _c2.size.lg
      }
    },
    variant: {
      surface: {
        root: {
          borderWidth: "1px",
          borderColor: "border",
          _checked: {
            bg: "colorPalette.subtle",
            color: "colorPalette.fg",
            borderColor: "colorPalette.muted"
          },
          _disabled: {
            bg: "bg.muted"
          }
        },
        indicator: (_d2 = checkmarkRecipe.variants) == null ? void 0 : _d2.variant.solid
      },
      subtle: {
        root: {
          bg: "bg.muted"
        },
        control: {
          _checked: {
            bg: "colorPalette.muted",
            color: "colorPalette.fg"
          }
        },
        indicator: (_e2 = checkmarkRecipe.variants) == null ? void 0 : _e2.variant.plain
      },
      outline: {
        root: {
          borderWidth: "1px",
          borderColor: "border",
          _checked: {
            boxShadow: "0 0 0 1px var(--shadow-color)",
            boxShadowColor: "colorPalette.solid",
            borderColor: "colorPalette.solid"
          }
        },
        indicator: (_f2 = checkmarkRecipe.variants) == null ? void 0 : _f2.variant.solid
      },
      solid: {
        root: {
          borderWidth: "1px",
          _checked: {
            bg: "colorPalette.solid",
            color: "colorPalette.contrast",
            borderColor: "colorPalette.solid"
          }
        },
        indicator: (_g2 = checkmarkRecipe.variants) == null ? void 0 : _g2.variant.inverted
      }
    },
    justify: {
      start: {
        root: { "--checkbox-card-justify": "flex-start" }
      },
      end: {
        root: { "--checkbox-card-justify": "flex-end" }
      },
      center: {
        root: { "--checkbox-card-justify": "center" }
      }
    },
    align: {
      start: {
        root: { "--checkbox-card-align": "flex-start" },
        content: { textAlign: "start" }
      },
      end: {
        root: { "--checkbox-card-align": "flex-end" },
        content: { textAlign: "end" }
      },
      center: {
        root: { "--checkbox-card-align": "center" },
        content: { textAlign: "center" }
      }
    },
    orientation: {
      vertical: {
        control: { flexDirection: "column" }
      },
      horizontal: {
        control: { flexDirection: "row" }
      }
    }
  },
  defaultVariants: {
    size: "md",
    variant: "outline",
    align: "start",
    orientation: "horizontal"
  }
});

// node_modules/@chakra-ui/react/dist/esm/theme/recipes/collapsible.js
var collapsibleSlotRecipe = defineSlotRecipe({
  slots: anatomy2.keys(),
  className: "chakra-collapsible",
  base: {
    content: {
      overflow: "hidden",
      _open: {
        animationName: "expand-height, fade-in",
        animationDuration: "moderate"
      },
      _closed: {
        animationName: "collapse-height, fade-out",
        animationDuration: "moderate"
      }
    }
  }
});

// node_modules/@chakra-ui/react/dist/esm/theme/recipes/color-picker.js
var _a3, _b3, _c3, _d3, _e3, _f3, _g3, _h2, _i2, _j2, _k2, _l2, _m2, _n2, _o, _p, _q, _r;
var colorPickerSlotRecipe = defineSlotRecipe({
  className: "colorPicker",
  slots: colorPickerAnatomy.keys(),
  base: {
    root: {
      display: "flex",
      flexDirection: "column",
      gap: "1.5"
    },
    label: {
      color: "fg",
      fontWeight: "medium",
      textStyle: "sm"
    },
    valueText: {
      textAlign: "start"
    },
    control: {
      display: "flex",
      alignItems: "center",
      flexDirection: "row",
      gap: "2",
      position: "relative"
    },
    swatchTrigger: {
      display: "flex",
      alignItems: "center",
      justifyContent: "center"
    },
    trigger: {
      display: "flex",
      alignItems: "center",
      justifyContent: "center",
      flexDirection: "row",
      flexShrink: "0",
      gap: "2",
      textStyle: "sm",
      minH: "var(--input-height)",
      minW: "var(--input-height)",
      px: "1",
      rounded: "l2",
      _disabled: { opacity: "0.5" },
      "--focus-color": "colors.colorPalette.focusRing",
      "&:focus-visible": {
        borderColor: "var(--focus-color)",
        outline: "1px solid var(--focus-color)"
      },
      "&[data-fit-content]": {
        "--input-height": "unset",
        px: "0",
        border: "0"
      }
    },
    content: {
      display: "flex",
      flexDirection: "column",
      bg: "bg.panel",
      borderRadius: "l3",
      boxShadow: "lg",
      width: "64",
      p: "4",
      gap: "3",
      zIndex: "dropdown",
      _open: {
        animationStyle: "slide-fade-in",
        animationDuration: "fast"
      },
      _closed: {
        animationStyle: "slide-fade-out",
        animationDuration: "faster"
      }
    },
    area: {
      height: "180px",
      borderRadius: "l2",
      overflow: "hidden"
    },
    areaThumb: {
      borderRadius: "full",
      height: "var(--thumb-size)",
      width: "var(--thumb-size)",
      borderWidth: "2px",
      borderColor: "white",
      shadow: "sm",
      focusVisibleRing: "mixed",
      focusRingColor: "white"
    },
    areaBackground: {
      height: "full"
    },
    channelSlider: {
      borderRadius: "l2",
      flex: "1"
    },
    channelSliderTrack: {
      height: "var(--slider-height)",
      borderRadius: "inherit",
      boxShadow: "inset 0 0 0 1px rgba(0,0,0,0.1)"
    },
    swatchGroup: {
      display: "flex",
      flexDirection: "row",
      flexWrap: "wrap",
      gap: "2"
    },
    swatch: {
      ...colorSwatchRecipe.base,
      borderRadius: "l1"
    },
    swatchIndicator: {
      color: "white",
      rounded: "full"
    },
    channelSliderThumb: {
      borderRadius: "full",
      height: "var(--thumb-size)",
      width: "var(--thumb-size)",
      borderWidth: "2px",
      borderColor: "white",
      shadow: "sm",
      transform: "translate(-50%, -50%)",
      focusVisibleRing: "outside",
      focusRingOffset: "1px"
    },
    channelInput: {
      ...inputRecipe.base,
      "&::-webkit-inner-spin-button, &::-webkit-outer-spin-button": {
        WebkitAppearance: "none",
        margin: 0
      }
    },
    formatSelect: {
      textStyle: "xs",
      textTransform: "uppercase",
      borderWidth: "1px",
      minH: "6",
      focusRing: "inside",
      rounded: "l2"
    },
    transparencyGrid: {
      borderRadius: "l2"
    },
    view: {
      display: "flex",
      flexDirection: "column",
      gap: "2"
    }
  },
  variants: {
    size: {
      "2xs": {
        channelInput: (_b3 = (_a3 = inputRecipe.variants) == null ? void 0 : _a3.size) == null ? void 0 : _b3["2xs"],
        swatch: { "--swatch-size": "sizes.4.5" },
        trigger: { "--input-height": "sizes.7" },
        area: { "--thumb-size": "sizes.3" },
        channelSlider: {
          "--slider-height": "sizes.3",
          "--thumb-size": "sizes.3"
        }
      },
      xs: {
        channelInput: (_d3 = (_c3 = inputRecipe.variants) == null ? void 0 : _c3.size) == null ? void 0 : _d3.xs,
        swatch: { "--swatch-size": "sizes.5" },
        trigger: { "--input-height": "sizes.8" },
        area: { "--thumb-size": "sizes.3.5" },
        channelSlider: {
          "--slider-height": "sizes.3.5",
          "--thumb-size": "sizes.3.5"
        }
      },
      sm: {
        channelInput: (_f3 = (_e3 = inputRecipe.variants) == null ? void 0 : _e3.size) == null ? void 0 : _f3.sm,
        swatch: { "--swatch-size": "sizes.6" },
        trigger: { "--input-height": "sizes.9" },
        area: { "--thumb-size": "sizes.3.5" },
        channelSlider: {
          "--slider-height": "sizes.3.5",
          "--thumb-size": "sizes.3.5"
        }
      },
      md: {
        channelInput: (_h2 = (_g3 = inputRecipe.variants) == null ? void 0 : _g3.size) == null ? void 0 : _h2.md,
        swatch: { "--swatch-size": "sizes.7" },
        trigger: { "--input-height": "sizes.10" },
        area: { "--thumb-size": "sizes.3.5" },
        channelSlider: {
          "--slider-height": "sizes.3.5",
          "--thumb-size": "sizes.3.5"
        }
      },
      lg: {
        channelInput: (_j2 = (_i2 = inputRecipe.variants) == null ? void 0 : _i2.size) == null ? void 0 : _j2.lg,
        swatch: { "--swatch-size": "sizes.7" },
        trigger: { "--input-height": "sizes.11" },
        area: { "--thumb-size": "sizes.3.5" },
        channelSlider: {
          "--slider-height": "sizes.3.5",
          "--thumb-size": "sizes.3.5"
        }
      },
      xl: {
        channelInput: (_l2 = (_k2 = inputRecipe.variants) == null ? void 0 : _k2.size) == null ? void 0 : _l2.xl,
        swatch: { "--swatch-size": "sizes.8" },
        trigger: { "--input-height": "sizes.12" },
        area: { "--thumb-size": "sizes.3.5" },
        channelSlider: {
          "--slider-height": "sizes.3.5",
          "--thumb-size": "sizes.3.5"
        }
      },
      "2xl": {
        channelInput: (_n2 = (_m2 = inputRecipe.variants) == null ? void 0 : _m2.size) == null ? void 0 : _n2["2xl"],
        swatch: { "--swatch-size": "sizes.10" },
        trigger: { "--input-height": "sizes.16" },
        area: { "--thumb-size": "sizes.3.5" },
        channelSlider: {
          "--slider-height": "sizes.3.5",
          "--thumb-size": "sizes.3.5"
        }
      }
    },
    variant: {
      outline: {
        channelInput: (_p = (_o = inputRecipe.variants) == null ? void 0 : _o.variant) == null ? void 0 : _p.outline,
        trigger: {
          borderWidth: "1px"
        }
      },
      subtle: {
        channelInput: (_r = (_q = inputRecipe.variants) == null ? void 0 : _q.variant) == null ? void 0 : _r.subtle,
        trigger: {
          borderWidth: "1px",
          borderColor: "transparent",
          bg: "bg.muted"
        }
      }
    }
  },
  defaultVariants: {
    size: "md",
    variant: "outline"
  }
});

// node_modules/@chakra-ui/react/dist/esm/theme/recipes/data-list.js
var dataListSlotRecipe = defineSlotRecipe({
  slots: dataListAnatomy.keys(),
  className: "chakra-data-list",
  base: {
    itemLabel: {
      display: "flex",
      alignItems: "center",
      gap: "1"
    },
    itemValue: {
      display: "flex",
      minWidth: "0",
      flex: "1"
    }
  },
  variants: {
    orientation: {
      horizontal: {
        root: {
          display: "flex",
          flexDirection: "column"
        },
        item: {
          display: "inline-flex",
          alignItems: "center",
          gap: "4"
        },
        itemLabel: {
          minWidth: "120px"
        }
      },
      vertical: {
        root: {
          display: "flex",
          flexDirection: "column"
        },
        item: {
          display: "flex",
          flexDirection: "column",
          gap: "1"
        }
      }
    },
    size: {
      sm: {
        root: {
          gap: "3"
        },
        item: {
          textStyle: "xs"
        }
      },
      md: {
        root: {
          gap: "4"
        },
        item: {
          textStyle: "sm"
        }
      },
      lg: {
        root: {
          gap: "5"
        },
        item: {
          textStyle: "md"
        }
      }
    },
    variant: {
      subtle: {
        itemLabel: {
          color: "fg.muted"
        }
      },
      bold: {
        itemLabel: {
          fontWeight: "medium"
        },
        itemValue: {
          color: "fg.muted"
        }
      }
    }
  },
  defaultVariants: {
    size: "md",
    orientation: "vertical",
    variant: "subtle"
  }
});

// node_modules/@chakra-ui/react/dist/esm/theme/recipes/dialog.js
var dialogSlotRecipe = defineSlotRecipe({
  slots: dialogAnatomy.keys(),
  className: "chakra-dialog",
  base: {
    backdrop: {
      bg: "blackAlpha.500",
      pos: "fixed",
      left: 0,
      top: 0,
      w: "100vw",
      h: "100dvh",
      zIndex: "modal",
      _open: {
        animationName: "fade-in",
        animationDuration: "slow"
      },
      _closed: {
        animationName: "fade-out",
        animationDuration: "moderate"
      }
    },
    positioner: {
      display: "flex",
      width: "100vw",
      height: "100dvh",
      position: "fixed",
      left: 0,
      top: 0,
      "--dialog-z-index": "zIndex.modal",
      zIndex: "calc(var(--dialog-z-index) + var(--layer-index, 0))",
      justifyContent: "center",
      overscrollBehaviorY: "none"
    },
    content: {
      display: "flex",
      flexDirection: "column",
      position: "relative",
      width: "100%",
      outline: 0,
      borderRadius: "l3",
      textStyle: "sm",
      my: "var(--dialog-margin, var(--dialog-base-margin))",
      "--dialog-z-index": "zIndex.modal",
      zIndex: "calc(var(--dialog-z-index) + var(--layer-index, 0))",
      bg: "bg.panel",
      boxShadow: "lg",
      _open: {
        animationDuration: "moderate"
      },
      _closed: {
        animationDuration: "faster"
      }
    },
    header: {
      flex: 0,
      px: "6",
      pt: "6",
      pb: "4"
    },
    body: {
      flex: "1",
      px: "6",
      pt: "2",
      pb: "6"
    },
    footer: {
      display: "flex",
      alignItems: "center",
      justifyContent: "flex-end",
      gap: "3",
      px: "6",
      pt: "2",
      pb: "4"
    },
    title: {
      textStyle: "lg",
      fontWeight: "semibold"
    },
    description: {
      color: "fg.muted"
    }
  },
  variants: {
    placement: {
      center: {
        positioner: {
          alignItems: "center"
        },
        content: {
          "--dialog-base-margin": "auto",
          mx: "auto"
        }
      },
      top: {
        positioner: {
          alignItems: "flex-start"
        },
        content: {
          "--dialog-base-margin": "spacing.16",
          mx: "auto"
        }
      },
      bottom: {
        positioner: {
          alignItems: "flex-end"
        },
        content: {
          "--dialog-base-margin": "spacing.16",
          mx: "auto"
        }
      }
    },
    scrollBehavior: {
      inside: {
        positioner: {
          overflow: "hidden"
        },
        content: {
          maxH: "calc(100% - 7.5rem)"
        },
        body: {
          overflow: "auto"
        }
      },
      outside: {
        positioner: {
          overflow: "auto",
          pointerEvents: "auto"
        }
      }
    },
    size: {
      xs: {
        content: {
          maxW: "sm"
        }
      },
      sm: {
        content: {
          maxW: "md"
        }
      },
      md: {
        content: {
          maxW: "lg"
        }
      },
      lg: {
        content: {
          maxW: "2xl"
        }
      },
      xl: {
        content: {
          maxW: "4xl"
        }
      },
      cover: {
        positioner: {
          padding: "10"
        },
        content: {
          width: "100%",
          height: "100%",
          "--dialog-margin": "0"
        }
      },
      full: {
        content: {
          maxW: "100vw",
          minH: "100vh",
          "--dialog-margin": "0",
          borderRadius: "0"
        }
      }
    },
    motionPreset: {
      scale: {
        content: {
          _open: { animationName: "scale-in, fade-in" },
          _closed: { animationName: "scale-out, fade-out" }
        }
      },
      "slide-in-bottom": {
        content: {
          _open: { animationName: "slide-from-bottom, fade-in" },
          _closed: { animationName: "slide-to-bottom, fade-out" }
        }
      },
      "slide-in-top": {
        content: {
          _open: { animationName: "slide-from-top, fade-in" },
          _closed: { animationName: "slide-to-top, fade-out" }
        }
      },
      "slide-in-left": {
        content: {
          _open: { animationName: "slide-from-left, fade-in" },
          _closed: { animationName: "slide-to-left, fade-out" }
        }
      },
      "slide-in-right": {
        content: {
          _open: { animationName: "slide-from-right, fade-in" },
          _closed: { animationName: "slide-to-right, fade-out" }
        }
      },
      none: {}
    }
  },
  defaultVariants: {
    size: "md",
    scrollBehavior: "outside",
    placement: "top",
    motionPreset: "scale"
  }
});

// node_modules/@chakra-ui/react/dist/esm/theme/recipes/drawer.js
var drawerSlotRecipe = defineSlotRecipe({
  slots: drawerAnatomy.keys(),
  className: "chakra-drawer",
  base: {
    backdrop: {
      bg: "blackAlpha.500",
      pos: "fixed",
      insetInlineStart: 0,
      top: 0,
      w: "100vw",
      h: "100dvh",
      zIndex: "modal",
      _open: {
        animationName: "fade-in",
        animationDuration: "slow"
      },
      _closed: {
        animationName: "fade-out",
        animationDuration: "moderate"
      }
    },
    positioner: {
      display: "flex",
      width: "100vw",
      height: "100dvh",
      position: "fixed",
      insetInlineStart: 0,
      top: 0,
      zIndex: "modal",
      overscrollBehaviorY: "none"
    },
    content: {
      display: "flex",
      flexDirection: "column",
      position: "relative",
      width: "100%",
      outline: 0,
      zIndex: "modal",
      textStyle: "sm",
      maxH: "100dvh",
      color: "inherit",
      bg: "bg.panel",
      boxShadow: "lg",
      _open: {
        animationDuration: "slowest",
        animationTimingFunction: "ease-in-smooth"
      },
      _closed: {
        animationDuration: "slower",
        animationTimingFunction: "ease-in-smooth"
      }
    },
    header: {
      flex: 0,
      px: "6",
      pt: "6",
      pb: "4"
    },
    body: {
      px: "6",
      py: "2",
      flex: "1",
      overflow: "auto"
    },
    footer: {
      display: "flex",
      alignItems: "center",
      justifyContent: "flex-end",
      gap: "3",
      px: "6",
      pt: "2",
      pb: "4"
    },
    title: {
      textStyle: "lg",
      fontWeight: "semibold"
    },
    description: {
      color: "fg.muted"
    }
  },
  variants: {
    size: {
      xs: {
        content: {
          maxW: "xs"
        }
      },
      sm: {
        content: {
          maxW: "md"
        }
      },
      md: {
        content: {
          maxW: "lg"
        }
      },
      lg: {
        content: {
          maxW: "2xl"
        }
      },
      xl: {
        content: {
          maxW: "4xl"
        }
      },
      full: {
        content: {
          maxW: "100vw",
          h: "100dvh"
        }
      }
    },
    placement: {
      start: {
        positioner: {
          justifyContent: "flex-start"
        },
        content: {
          _open: {
            animationName: {
              base: "slide-from-left-full, fade-in",
              _rtl: "slide-from-right-full, fade-in"
            }
          },
          _closed: {
            animationName: {
              base: "slide-to-left-full, fade-out",
              _rtl: "slide-to-right-full, fade-out"
            }
          }
        }
      },
      end: {
        positioner: {
          justifyContent: "flex-end"
        },
        content: {
          _open: {
            animationName: {
              base: "slide-from-right-full, fade-in",
              _rtl: "slide-from-left-full, fade-in"
            }
          },
          _closed: {
            animationName: {
              base: "slide-to-right-full, fade-out",
              _rtl: "slide-to-right-full, fade-out"
            }
          }
        }
      },
      top: {
        positioner: {
          alignItems: "flex-start"
        },
        content: {
          maxW: "100%",
          _open: { animationName: "slide-from-top-full, fade-in" },
          _closed: { animationName: "slide-to-top-full, fade-out" }
        }
      },
      bottom: {
        positioner: {
          alignItems: "flex-end"
        },
        content: {
          maxW: "100%",
          _open: { animationName: "slide-from-bottom-full, fade-in" },
          _closed: { animationName: "slide-to-bottom-full, fade-out" }
        }
      }
    },
    contained: {
      true: {
        positioner: {
          padding: "4"
        },
        content: {
          borderRadius: "l3"
        }
      }
    }
  },
  defaultVariants: {
    size: "xs",
    placement: "end"
  }
});

// node_modules/@chakra-ui/react/dist/esm/theme/recipes/editable.js
var sharedStyles = defineStyle({
  fontSize: "inherit",
  fontWeight: "inherit",
  textAlign: "inherit",
  bg: "transparent",
  borderRadius: "l2"
});
var editableSlotRecipe = defineSlotRecipe({
  slots: editableAnatomy.keys(),
  className: "chakra-editable",
  base: {
    root: {
      display: "inline-flex",
      alignItems: "center",
      position: "relative",
      gap: "1.5",
      width: "full"
    },
    preview: {
      ...sharedStyles,
      py: "1",
      px: "1",
      display: "inline-flex",
      alignItems: "center",
      transitionProperty: "common",
      transitionDuration: "normal",
      cursor: "text",
      _hover: {
        bg: "bg.muted"
      },
      _disabled: {
        userSelect: "none"
      }
    },
    input: {
      ...sharedStyles,
      outline: "0",
      py: "1",
      px: "1",
      transitionProperty: "common",
      transitionDuration: "normal",
      width: "full",
      focusVisibleRing: "inside",
      focusRingWidth: "2px",
      _placeholder: { opacity: 0.6 }
    },
    control: {
      display: "inline-flex",
      alignItems: "center",
      gap: "1.5"
    }
  },
  variants: {
    size: {
      sm: {
        root: {
          textStyle: "sm"
        },
        preview: { minH: "8" },
        input: { minH: "8" }
      },
      md: {
        root: {
          textStyle: "sm"
        },
        preview: { minH: "9" },
        input: { minH: "9" }
      },
      lg: {
        root: {
          textStyle: "md"
        },
        preview: { minH: "10" },
        input: { minH: "10" }
      }
    }
  },
  defaultVariants: {
    size: "md"
  }
});

// node_modules/@chakra-ui/react/dist/esm/theme/recipes/empty-state.js
var emptyStateSlotRecipe = defineSlotRecipe({
  slots: emptyStateAnatomy.keys(),
  className: "chakra-empty-state",
  base: {
    root: {
      width: "full"
    },
    content: {
      display: "flex",
      flexDirection: "column",
      alignItems: "center",
      justifyContent: "center"
    },
    indicator: {
      display: "flex",
      alignItems: "center",
      justifyContent: "center",
      color: "fg.subtle",
      _icon: {
        boxSize: "1em"
      }
    },
    title: {
      fontWeight: "semibold"
    },
    description: {
      textStyle: "sm",
      color: "fg.muted"
    }
  },
  variants: {
    size: {
      sm: {
        root: {
          px: "4",
          py: "6"
        },
        title: {
          textStyle: "md"
        },
        content: {
          gap: "4"
        },
        indicator: {
          textStyle: "2xl"
        }
      },
      md: {
        root: {
          px: "8",
          py: "12"
        },
        title: {
          textStyle: "lg"
        },
        content: {
          gap: "6"
        },
        indicator: {
          textStyle: "4xl"
        }
      },
      lg: {
        root: {
          px: "12",
          py: "16"
        },
        title: {
          textStyle: "xl"
        },
        content: {
          gap: "8"
        },
        indicator: {
          textStyle: "6xl"
        }
      }
    }
  },
  defaultVariants: {
    size: "md"
  }
});

// node_modules/@chakra-ui/react/dist/esm/theme/recipes/field.js
var fieldSlotRecipe = defineSlotRecipe({
  className: "chakra-field",
  slots: fieldAnatomy2.keys(),
  base: {
    requiredIndicator: {
      color: "fg.error",
      lineHeight: "1"
    },
    root: {
      display: "flex",
      width: "100%",
      position: "relative",
      gap: "1.5"
    },
    label: {
      display: "flex",
      alignItems: "center",
      textAlign: "start",
      textStyle: "sm",
      fontWeight: "medium",
      gap: "1",
      userSelect: "none",
      _disabled: {
        opacity: "0.5"
      }
    },
    errorText: {
      display: "inline-flex",
      alignItems: "center",
      fontWeight: "medium",
      gap: "1",
      color: "fg.error",
      textStyle: "xs"
    },
    helperText: {
      color: "fg.muted",
      textStyle: "xs"
    }
  },
  variants: {
    orientation: {
      vertical: {
        root: {
          flexDirection: "column",
          alignItems: "flex-start"
        }
      },
      horizontal: {
        root: {
          flexDirection: "row",
          alignItems: "center",
          justifyContent: "space-between"
        },
        label: {
          flex: "0 0 var(--field-label-width, 80px)"
        }
      }
    }
  },
  defaultVariants: {
    orientation: "vertical"
  }
});

// node_modules/@chakra-ui/react/dist/esm/theme/recipes/fieldset.js
var fieldsetSlotRecipe = defineSlotRecipe({
  className: "fieldset",
  slots: fieldsetAnatomy2.keys(),
  base: {
    root: {
      display: "flex",
      flexDirection: "column",
      width: "full"
    },
    content: {
      display: "flex",
      flexDirection: "column",
      width: "full"
    },
    legend: {
      color: "fg",
      fontWeight: "medium",
      _disabled: {
        opacity: "0.5"
      }
    },
    helperText: {
      color: "fg.muted",
      textStyle: "sm"
    },
    errorText: {
      display: "inline-flex",
      alignItems: "center",
      color: "fg.error",
      gap: "2",
      fontWeight: "medium",
      textStyle: "sm"
    }
  },
  variants: {
    size: {
      sm: {
        root: { spaceY: "2" },
        content: { gap: "1.5" },
        legend: { textStyle: "sm" }
      },
      md: {
        root: { spaceY: "4" },
        content: { gap: "4" },
        legend: { textStyle: "sm" }
      },
      lg: {
        root: { spaceY: "6" },
        content: { gap: "4" },
        legend: { textStyle: "md" }
      }
    }
  },
  defaultVariants: {
    size: "md"
  }
});

// node_modules/@chakra-ui/react/dist/esm/theme/recipes/file-upload.js
var fileUploadSlotRecipe = defineSlotRecipe({
  className: "chakra-file-upload",
  slots: fileUploadAnatomy.keys(),
  base: {
    root: {
      display: "flex",
      flexDirection: "column",
      gap: "4",
      width: "100%",
      alignItems: "flex-start"
    },
    label: {
      fontWeight: "medium",
      textStyle: "sm"
    },
    dropzone: {
      background: "bg",
      borderRadius: "l3",
      borderWidth: "2px",
      borderStyle: "dashed",
      display: "flex",
      alignItems: "center",
      flexDirection: "column",
      gap: "4",
      justifyContent: "center",
      minHeight: "2xs",
      px: "3",
      py: "2",
      transition: "backgrounds",
      focusVisibleRing: "outside",
      _hover: {
        bg: "bg.subtle"
      },
      _dragging: {
        bg: "colorPalette.subtle",
        borderStyle: "solid",
        borderColor: "colorPalette.solid"
      }
    },
    dropzoneContent: {
      display: "flex",
      flexDirection: "column",
      alignItems: "center",
      textAlign: "center",
      gap: "1",
      textStyle: "sm"
    },
    item: {
      textStyle: "sm",
      animationName: "fade-in",
      animationDuration: "moderate",
      background: "bg",
      borderRadius: "l2",
      borderWidth: "1px",
      width: "100%",
      display: "flex",
      alignItems: "center",
      gap: "3",
      p: "4"
    },
    itemGroup: {
      width: "100%",
      display: "flex",
      flexDirection: "column",
      gap: "3"
    },
    itemName: {
      color: "fg",
      fontWeight: "medium",
      lineClamp: "1"
    },
    itemContent: {
      display: "flex",
      flexDirection: "column",
      gap: "0.5",
      flex: "1"
    },
    itemSizeText: {
      color: "fg.muted",
      textStyle: "xs"
    },
    itemDeleteTrigger: {
      alignSelf: "flex-start"
    },
    itemPreviewImage: {
      width: "10",
      height: "10",
      objectFit: "scale-down"
    }
  },
  defaultVariants: {}
});

// node_modules/@chakra-ui/react/dist/esm/theme/recipes/hover-card.js
var hoverCardSlotRecipe = defineSlotRecipe({
  className: "chakra-hover-card",
  slots: anatomy17.keys(),
  base: {
    content: {
      position: "relative",
      display: "flex",
      flexDirection: "column",
      textStyle: "sm",
      "--hovercard-bg": "colors.bg.panel",
      bg: "var(--hovercard-bg)",
      boxShadow: "lg",
      maxWidth: "80",
      borderRadius: "l3",
      zIndex: "popover",
      transformOrigin: "var(--transform-origin)",
      outline: "0",
      _open: {
        animationStyle: "slide-fade-in",
        animationDuration: "fast"
      },
      _closed: {
        animationStyle: "slide-fade-out",
        animationDuration: "faster"
      }
    },
    arrow: {
      "--arrow-size": "sizes.3",
      "--arrow-background": "var(--hovercard-bg)"
    },
    arrowTip: {
      borderTopWidth: "0.5px",
      borderInlineStartWidth: "0.5px"
    }
  },
  variants: {
    size: {
      xs: {
        content: {
          padding: "3"
        }
      },
      sm: {
        content: {
          padding: "4"
        }
      },
      md: {
        content: {
          padding: "5"
        }
      },
      lg: {
        content: {
          padding: "6"
        }
      }
    }
  },
  defaultVariants: {
    size: "md"
  }
});

// node_modules/@chakra-ui/react/dist/esm/theme/recipes/list.js
var listSlotRecipe = defineSlotRecipe({
  className: "chakra-list",
  slots: listAnatomy.keys(),
  base: {
    root: {
      display: "flex",
      flexDirection: "column",
      gap: "var(--list-gap)",
      "& :where(ul, ol)": {
        marginTop: "var(--list-gap)"
      }
    },
    item: {
      whiteSpace: "normal",
      display: "list-item"
    },
    indicator: {
      marginEnd: "2",
      minHeight: "1lh",
      flexShrink: 0,
      display: "inline-block",
      verticalAlign: "middle"
    }
  },
  variants: {
    variant: {
      marker: {
        root: {
          listStyle: "revert"
        },
        item: {
          _marker: {
            color: "fg.subtle"
          }
        }
      },
      plain: {
        item: {
          alignItems: "flex-start",
          display: "inline-flex"
        }
      }
    },
    align: {
      center: {
        item: { alignItems: "center" }
      },
      start: {
        item: { alignItems: "flex-start" }
      },
      end: {
        item: { alignItems: "flex-end" }
      }
    }
  },
  defaultVariants: {
    variant: "marker"
  }
});

// node_modules/@chakra-ui/react/dist/esm/theme/recipes/menu.js
var menuSlotRecipe = defineSlotRecipe({
  className: "chakra-menu",
  slots: menuAnatomy.keys(),
  base: {
    content: {
      outline: 0,
      bg: "bg.panel",
      boxShadow: "lg",
      color: "fg",
      maxHeight: "var(--available-height)",
      "--menu-z-index": "zIndex.dropdown",
      zIndex: "calc(var(--menu-z-index) + var(--layer-index, 0))",
      borderRadius: "l2",
      overflow: "hidden",
      overflowY: "auto",
      _open: {
        animationStyle: "slide-fade-in",
        animationDuration: "fast"
      },
      _closed: {
        animationStyle: "slide-fade-out",
        animationDuration: "faster"
      }
    },
    item: {
      textDecoration: "none",
      color: "fg",
      userSelect: "none",
      borderRadius: "l1",
      width: "100%",
      display: "flex",
      cursor: "menuitem",
      alignItems: "center",
      textAlign: "start",
      position: "relative",
      flex: "0 0 auto",
      outline: 0,
      _disabled: {
        layerStyle: "disabled"
      }
    },
    itemText: {
      flex: "1"
    },
    itemGroupLabel: {
      px: "2",
      py: "1.5",
      fontWeight: "semibold",
      textStyle: "sm"
    },
    indicator: {
      display: "inline-flex",
      alignItems: "center",
      justifyContent: "center",
      flexShrink: "0"
    },
    itemCommand: {
      opacity: "0.6",
      textStyle: "xs",
      ms: "auto",
      ps: "4",
      letterSpacing: "widest"
    },
    separator: {
      height: "1px",
      bg: "bg.muted",
      my: "1",
      mx: "-1"
    }
  },
  variants: {
    variant: {
      subtle: {
        item: {
          _highlighted: {
            bg: "bg.emphasized/60"
          }
        }
      },
      solid: {
        item: {
          _highlighted: {
            bg: "colorPalette.solid",
            color: "colorPalette.contrast"
          }
        }
      }
    },
    size: {
      sm: {
        content: {
          minW: "8rem",
          padding: "1"
        },
        item: {
          gap: "1",
          textStyle: "xs",
          py: "1",
          px: "1.5"
        }
      },
      md: {
        content: {
          minW: "8rem",
          padding: "1.5"
        },
        item: {
          gap: "2",
          textStyle: "sm",
          py: "1.5",
          px: "2"
        }
      }
    }
  },
  defaultVariants: {
    size: "md",
    variant: "subtle"
  }
});

// node_modules/@chakra-ui/react/dist/esm/theme/recipes/select.js
var selectSlotRecipe = defineSlotRecipe({
  className: "chakra-select",
  slots: selectAnatomy.keys(),
  base: {
    root: {
      display: "flex",
      flexDirection: "column",
      gap: "1.5",
      width: "full"
    },
    trigger: {
      display: "flex",
      alignItems: "center",
      justifyContent: "space-between",
      width: "full",
      minH: "var(--select-trigger-height)",
      px: "var(--select-trigger-padding-x)",
      borderRadius: "l2",
      userSelect: "none",
      textAlign: "start",
      focusVisibleRing: "inside",
      _placeholderShown: {
        color: "fg.muted/80"
      },
      _disabled: {
        layerStyle: "disabled"
      },
      _invalid: {
        borderColor: "border.error"
      }
    },
    indicatorGroup: {
      display: "flex",
      alignItems: "center",
      gap: "1",
      pos: "absolute",
      right: "0",
      top: "0",
      bottom: "0",
      px: "var(--select-trigger-padding-x)",
      pointerEvents: "none"
    },
    indicator: {
      display: "flex",
      alignItems: "center",
      justifyContent: "center",
      color: { base: "fg.muted", _disabled: "fg.subtle", _invalid: "fg.error" }
    },
    content: {
      background: "bg.panel",
      display: "flex",
      flexDirection: "column",
      zIndex: "dropdown",
      borderRadius: "l2",
      outline: 0,
      maxH: "96",
      overflowY: "auto",
      boxShadow: "md",
      _open: {
        animationStyle: "slide-fade-in",
        animationDuration: "fast"
      },
      _closed: {
        animationStyle: "slide-fade-out",
        animationDuration: "fastest"
      }
    },
    item: {
      position: "relative",
      userSelect: "none",
      display: "flex",
      alignItems: "center",
      gap: "2",
      cursor: "option",
      justifyContent: "space-between",
      flex: "1",
      textAlign: "start",
      borderRadius: "l1",
      _highlighted: {
        bg: "bg.emphasized/60"
      },
      _disabled: {
        pointerEvents: "none",
        opacity: "0.5"
      },
      _icon: {
        width: "4",
        height: "4"
      }
    },
    control: {
      pos: "relative"
    },
    itemText: {
      flex: "1"
    },
    itemGroup: {
      _first: { mt: "0" }
    },
    itemGroupLabel: {
      py: "1",
      fontWeight: "medium"
    },
    label: {
      fontWeight: "medium",
      userSelect: "none",
      textStyle: "sm",
      _disabled: {
        layerStyle: "disabled"
      }
    },
    valueText: {
      lineClamp: "1",
      maxW: "80%"
    }
  },
  variants: {
    variant: {
      outline: {
        trigger: {
          bg: "transparent",
          borderWidth: "1px",
          borderColor: "border",
          _expanded: {
            borderColor: "border.emphasized"
          }
        }
      },
      subtle: {
        trigger: {
          borderWidth: "1px",
          borderColor: "transparent",
          bg: "bg.muted"
        }
      }
    },
    size: {
      xs: {
        root: {
          "--select-trigger-height": "sizes.8",
          "--select-trigger-padding-x": "spacing.2"
        },
        content: {
          p: "1",
          gap: "1",
          textStyle: "xs"
        },
        trigger: {
          textStyle: "xs",
          gap: "1"
        },
        item: {
          py: "1",
          px: "2"
        },
        itemGroupLabel: {
          py: "1",
          px: "2"
        },
        indicator: {
          _icon: {
            width: "3.5",
            height: "3.5"
          }
        }
      },
      sm: {
        root: {
          "--select-trigger-height": "sizes.9",
          "--select-trigger-padding-x": "spacing.2.5"
        },
        content: {
          p: "1",
          textStyle: "sm"
        },
        trigger: {
          textStyle: "sm",
          gap: "1"
        },
        indicator: {
          _icon: {
            width: "4",
            height: "4"
          }
        },
        item: {
          py: "1",
          px: "1.5"
        },
        itemGroup: {
          mt: "1"
        },
        itemGroupLabel: {
          py: "1",
          px: "1.5"
        }
      },
      md: {
        root: {
          "--select-trigger-height": "sizes.10",
          "--select-trigger-padding-x": "spacing.3"
        },
        content: {
          p: "1",
          textStyle: "sm"
        },
        itemGroup: {
          mt: "1.5"
        },
        item: {
          py: "1.5",
          px: "2"
        },
        itemIndicator: {
          display: "flex",
          alignItems: "center",
          justifyContent: "center"
        },
        itemGroupLabel: {
          py: "1.5",
          px: "2"
        },
        trigger: {
          textStyle: "sm",
          gap: "2"
        },
        indicator: {
          _icon: {
            width: "4",
            height: "4"
          }
        }
      },
      lg: {
        root: {
          "--select-trigger-height": "sizes.12",
          "--select-trigger-padding-x": "spacing.4"
        },
        content: {
          p: "1.5",
          textStyle: "md"
        },
        itemGroup: {
          mt: "2"
        },
        item: {
          py: "2",
          px: "3"
        },
        itemGroupLabel: {
          py: "2",
          px: "3"
        },
        trigger: {
          textStyle: "md",
          py: "3",
          gap: "2"
        },
        indicator: {
          _icon: {
            width: "5",
            height: "5"
          }
        }
      }
    }
  },
  defaultVariants: {
    size: "md",
    variant: "outline"
  }
});

// node_modules/@chakra-ui/react/dist/esm/theme/recipes/native-select.js
var _a4, _b4;
var nativeSelectSlotRecipe = defineSlotRecipe({
  className: "chakra-native-select",
  slots: nativeSelectAnatomy.keys(),
  base: {
    root: {
      height: "fit-content",
      display: "flex",
      width: "100%",
      position: "relative"
    },
    field: {
      width: "100%",
      minWidth: "0",
      outline: "0",
      appearance: "none",
      borderRadius: "l2",
      "--error-color": "colors.border.error",
      _disabled: {
        layerStyle: "disabled"
      },
      _invalid: {
        focusRingColor: "var(--error-color)",
        borderColor: "var(--error-color)"
      },
      focusVisibleRing: "inside",
      lineHeight: "normal",
      "& > option, & > optgroup": {
        bg: "bg"
      }
    },
    indicator: {
      position: "absolute",
      display: "inline-flex",
      alignItems: "center",
      justifyContent: "center",
      pointerEvents: "none",
      top: "50%",
      transform: "translateY(-50%)",
      height: "100%",
      color: "fg.muted",
      _disabled: {
        opacity: "0.5"
      },
      _invalid: {
        color: "fg.error"
      },
      _icon: {
        width: "1em",
        height: "1em"
      }
    }
  },
  variants: {
    variant: {
      outline: {
        field: (_a4 = selectSlotRecipe.variants) == null ? void 0 : _a4.variant.outline.trigger
      },
      subtle: {
        field: (_b4 = selectSlotRecipe.variants) == null ? void 0 : _b4.variant.subtle.trigger
      },
      plain: {
        field: {
          bg: "transparent",
          color: "fg",
          focusRingWidth: "2px"
        }
      }
    },
    size: {
      xs: {
        field: {
          textStyle: "xs",
          ps: "2",
          pe: "6",
          height: "6"
        },
        indicator: {
          textStyle: "sm",
          insetEnd: "1.5"
        }
      },
      sm: {
        field: {
          textStyle: "sm",
          ps: "2.5",
          pe: "8",
          height: "8"
        },
        indicator: {
          textStyle: "md",
          insetEnd: "2"
        }
      },
      md: {
        field: {
          textStyle: "sm",
          ps: "3",
          pe: "8",
          height: "10"
        },
        indicator: {
          textStyle: "lg",
          insetEnd: "2"
        }
      },
      lg: {
        field: {
          textStyle: "md",
          ps: "4",
          pe: "8",
          height: "11"
        },
        indicator: {
          textStyle: "xl",
          insetEnd: "3"
        }
      },
      xl: {
        field: {
          textStyle: "md",
          ps: "4.5",
          pe: "10",
          height: "12"
        },
        indicator: {
          textStyle: "xl",
          insetEnd: "3"
        }
      }
    }
  },
  defaultVariants: selectSlotRecipe.defaultVariants
});

// node_modules/@chakra-ui/react/dist/esm/utils/entries.js
function mapEntries2(obj, f) {
  const result = {};
  for (const key in obj) {
    const kv = f(key, obj[key]);
    result[kv[0]] = kv[1];
  }
  return result;
}

// node_modules/@chakra-ui/react/dist/esm/theme/recipes/number-input.js
var triggerStyle = defineStyle({
  display: "flex",
  justifyContent: "center",
  alignItems: "center",
  flex: "1",
  userSelect: "none",
  cursor: "button",
  lineHeight: "1",
  color: "fg.muted",
  "--stepper-base-radius": "radii.l1",
  "--stepper-radius": "calc(var(--stepper-base-radius) + 1px)",
  _icon: {
    boxSize: "1em"
  },
  _disabled: {
    opacity: "0.5"
  },
  _hover: {
    bg: "bg.muted"
  },
  _active: {
    bg: "bg.emphasized"
  }
});
var numberInputSlotRecipe = defineSlotRecipe({
  className: "chakra-number-input",
  slots: anatomy18.keys(),
  base: {
    root: {
      position: "relative",
      zIndex: "0",
      isolation: "isolate"
    },
    input: {
      ...inputRecipe.base,
      verticalAlign: "top",
      pe: "calc(var(--stepper-width) + 0.5rem)"
    },
    control: {
      display: "flex",
      flexDirection: "column",
      position: "absolute",
      top: "0",
      insetEnd: "0px",
      margin: "1px",
      width: "var(--stepper-width)",
      height: "calc(100% - 2px)",
      zIndex: "1",
      borderStartWidth: "1px",
      divideY: "1px"
    },
    incrementTrigger: {
      ...triggerStyle,
      borderTopEndRadius: "var(--stepper-radius)"
    },
    decrementTrigger: {
      ...triggerStyle,
      borderBottomEndRadius: "var(--stepper-radius)"
    },
    valueText: {
      fontWeight: "medium",
      fontFeatureSettings: "pnum",
      fontVariantNumeric: "proportional-nums"
    }
  },
  variants: {
    size: {
      xs: {
        input: inputRecipe.variants.size.xs,
        control: {
          fontSize: "2xs",
          "--stepper-width": "sizes.4"
        }
      },
      sm: {
        input: inputRecipe.variants.size.sm,
        control: {
          fontSize: "xs",
          "--stepper-width": "sizes.5"
        }
      },
      md: {
        input: inputRecipe.variants.size.md,
        control: {
          fontSize: "sm",
          "--stepper-width": "sizes.6"
        }
      },
      lg: {
        input: inputRecipe.variants.size.lg,
        control: {
          fontSize: "sm",
          "--stepper-width": "sizes.6"
        }
      }
    },
    variant: mapEntries2(inputRecipe.variants.variant, (key, variantStyles) => [
      key,
      { input: variantStyles }
    ])
  },
  defaultVariants: {
    size: "md",
    variant: "outline"
  }
});

// node_modules/@chakra-ui/react/dist/esm/theme/recipes/pin-input.js
var { variants: variants2, defaultVariants: defaultVariants2 } = inputRecipe;
var pinInputSlotRecipe = defineSlotRecipe({
  className: "chakra-pin-input",
  slots: anatomy19.keys(),
  base: {
    input: {
      ...inputRecipe.base,
      textAlign: "center",
      width: "var(--input-height)"
    }
  },
  variants: {
    size: mapEntries2(variants2.size, (key, value) => [key, { input: value }]),
    variant: mapEntries2(variants2.variant, (key, value) => [
      key,
      { input: value }
    ])
  },
  defaultVariants: defaultVariants2
});

// node_modules/@chakra-ui/react/dist/esm/theme/recipes/popover.js
var popoverSlotRecipe = defineSlotRecipe({
  className: "chakra-popover",
  slots: popoverAnatomy.keys(),
  base: {
    content: {
      position: "relative",
      display: "flex",
      flexDirection: "column",
      textStyle: "sm",
      "--popover-bg": "colors.bg.panel",
      bg: "var(--popover-bg)",
      boxShadow: "lg",
      "--popover-size": "sizes.xs",
      "--popover-mobile-size": "calc(100dvw - 1rem)",
      width: {
        base: "min(var(--popover-mobile-size), var(--popover-size))",
        sm: "var(--popover-size)"
      },
      borderRadius: "l3",
      "--popover-z-index": "zIndex.popover",
      zIndex: "calc(var(--popover-z-index) + var(--layer-index, 0))",
      outline: "0",
      transformOrigin: "var(--transform-origin)",
      maxHeight: "var(--available-height)",
      _open: {
        animationStyle: "scale-fade-in",
        animationDuration: "fast"
      },
      _closed: {
        animationStyle: "scale-fade-out",
        animationDuration: "faster"
      }
    },
    header: {
      paddingInline: "var(--popover-padding)",
      paddingTop: "var(--popover-padding)"
    },
    body: {
      padding: "var(--popover-padding)",
      flex: "1"
    },
    footer: {
      display: "flex",
      alignItems: "center",
      paddingInline: "var(--popover-padding)",
      paddingBottom: "var(--popover-padding)"
    },
    arrow: {
      "--arrow-size": "sizes.3",
      "--arrow-background": "var(--popover-bg)"
    },
    arrowTip: {
      borderTopWidth: "1px",
      borderInlineStartWidth: "1px"
    }
  },
  variants: {
    size: {
      xs: {
        content: {
          "--popover-padding": "spacing.3"
        }
      },
      sm: {
        content: {
          "--popover-padding": "spacing.4"
        }
      },
      md: {
        content: {
          "--popover-padding": "spacing.5"
        }
      },
      lg: {
        content: {
          "--popover-padding": "spacing.6"
        }
      }
    }
  },
  defaultVariants: {
    size: "md"
  }
});

// node_modules/@chakra-ui/react/dist/esm/theme/recipes/progress.js
var progressSlotRecipe = defineSlotRecipe({
  slots: anatomy20.keys(),
  className: "chakra-progress",
  base: {
    root: {
      textStyle: "sm",
      position: "relative"
    },
    track: {
      overflow: "hidden",
      position: "relative"
    },
    range: {
      display: "flex",
      alignItems: "center",
      justifyContent: "center",
      transitionProperty: "width, height",
      transitionDuration: "slow",
      height: "100%",
      bgColor: "var(--track-color)",
      _indeterminate: {
        "--animate-from-x": "-40%",
        "--animate-to-x": "100%",
        position: "absolute",
        willChange: "left",
        minWidth: "50%",
        animation: "position 1s ease infinite normal none running",
        backgroundImage: `linear-gradient(to right, transparent 0%, var(--track-color) 50%, transparent 100%)`
      }
    },
    label: {
      display: "inline-flex",
      fontWeight: "medium",
      alignItems: "center",
      gap: "1"
    },
    valueText: {
      textStyle: "xs",
      lineHeight: "1",
      fontWeight: "medium"
    }
  },
  variants: {
    variant: {
      outline: {
        track: {
          shadow: "inset",
          bgColor: "bg.muted"
        },
        range: {
          bgColor: "colorPalette.solid"
        }
      },
      subtle: {
        track: {
          bgColor: "colorPalette.muted"
        },
        range: {
          bgColor: "colorPalette.solid/72"
        }
      }
    },
    shape: {
      square: {},
      rounded: {
        track: {
          borderRadius: "l1"
        }
      },
      full: {
        track: {
          borderRadius: "full"
        }
      }
    },
    striped: {
      true: {
        range: {
          backgroundImage: `linear-gradient(45deg, var(--stripe-color) 25%, transparent 25%, transparent 50%, var(--stripe-color) 50%, var(--stripe-color) 75%, transparent 75%, transparent)`,
          backgroundSize: `var(--stripe-size) var(--stripe-size)`,
          "--stripe-size": "1rem",
          "--stripe-color": {
            _light: "rgba(255, 255, 255, 0.3)",
            _dark: "rgba(0, 0, 0, 0.3)"
          }
        }
      }
    },
    animated: {
      true: {
        range: {
          "--animate-from": "var(--stripe-size)",
          animation: "bg-position 1s linear infinite"
        }
      }
    },
    size: {
      xs: {
        track: { h: "1.5" }
      },
      sm: {
        track: { h: "2" }
      },
      md: {
        track: { h: "2.5" }
      },
      lg: {
        track: { h: "3" }
      },
      xl: {
        track: { h: "4" }
      }
    }
  },
  defaultVariants: {
    variant: "outline",
    size: "md",
    shape: "rounded"
  }
});

// node_modules/@chakra-ui/react/dist/esm/theme/recipes/progress-circle.js
var progressCircleSlotRecipe = defineSlotRecipe({
  className: "chakra-progress-circle",
  slots: anatomy20.keys(),
  base: {
    root: {
      display: "inline-flex",
      textStyle: "sm",
      position: "relative"
    },
    circle: {
      _indeterminate: {
        animation: "spin 2s linear infinite"
      }
    },
    circleTrack: {
      "--track-color": "colors.colorPalette.muted",
      stroke: "var(--track-color)"
    },
    circleRange: {
      stroke: "colorPalette.solid",
      transitionProperty: "stroke-dasharray",
      transitionDuration: "0.6s",
      _indeterminate: {
        animation: "circular-progress 1.5s linear infinite"
      }
    },
    label: {
      display: "inline-flex"
    },
    valueText: {
      lineHeight: "1",
      fontWeight: "medium",
      letterSpacing: "tight",
      fontVariantNumeric: "tabular-nums"
    }
  },
  variants: {
    size: {
      xs: {
        circle: {
          "--size": "24px",
          "--thickness": "4px"
        },
        valueText: {
          textStyle: "2xs"
        }
      },
      sm: {
        circle: {
          "--size": "32px",
          "--thickness": "5px"
        },
        valueText: {
          textStyle: "2xs"
        }
      },
      md: {
        circle: {
          "--size": "40px",
          "--thickness": "6px"
        },
        valueText: {
          textStyle: "xs"
        }
      },
      lg: {
        circle: {
          "--size": "48px",
          "--thickness": "7px"
        },
        valueText: {
          textStyle: "sm"
        }
      },
      xl: {
        circle: {
          "--size": "64px",
          "--thickness": "8px"
        },
        valueText: {
          textStyle: "sm"
        }
      }
    }
  },
  defaultVariants: {
    size: "md"
  }
});

// node_modules/@chakra-ui/react/dist/esm/theme/recipes/qr-code.js
var qrCodeSlotRecipe = defineSlotRecipe({
  slots: anatomy21.keys(),
  className: "chakra-qr-code",
  base: {
    root: {
      position: "relative",
      width: "fit-content",
      "--qr-code-overlay-size": "calc(var(--qr-code-size) / 3)"
    },
    frame: {
      width: "var(--qr-code-size)",
      height: "var(--qr-code-size)",
      fill: "currentColor"
    },
    overlay: {
      display: "flex",
      alignItems: "center",
      justifyContent: "center",
      width: "var(--qr-code-overlay-size)",
      height: "var(--qr-code-overlay-size)",
      padding: "1",
      bg: "bg",
      rounded: "l1"
    }
  },
  variants: {
    size: {
      "2xs": {
        root: { "--qr-code-size": "40px" }
      },
      xs: {
        root: { "--qr-code-size": "64px" }
      },
      sm: {
        root: { "--qr-code-size": "80px" }
      },
      md: {
        root: { "--qr-code-size": "120px" }
      },
      lg: {
        root: { "--qr-code-size": "160px" }
      },
      xl: {
        root: { "--qr-code-size": "200px" }
      },
      "2xl": {
        root: { "--qr-code-size": "240px" }
      },
      full: {
        root: { "--qr-code-size": "100%" }
      }
    }
  },
  defaultVariants: {
    size: "md"
  }
});

// node_modules/@chakra-ui/react/dist/esm/theme/recipes/radio-card.js
var _a5, _b5, _c4, _d4, _e4, _f4, _g4;
var radioCardSlotRecipe = defineSlotRecipe({
  className: "chakra-radio-card",
  slots: radioCardAnatomy.keys(),
  base: {
    root: {
      display: "flex",
      flexDirection: "column",
      gap: "1.5",
      isolation: "isolate"
    },
    item: {
      flex: "1",
      display: "flex",
      flexDirection: "column",
      userSelect: "none",
      position: "relative",
      borderRadius: "l2",
      _focus: {
        bg: "colorPalette.muted/20"
      },
      _disabled: {
        opacity: "0.8",
        borderColor: "border.disabled"
      },
      _checked: {
        zIndex: "1"
      }
    },
    label: {
      display: "inline-flex",
      fontWeight: "medium",
      textStyle: "sm",
      _disabled: {
        opacity: "0.5"
      }
    },
    itemText: {
      fontWeight: "medium"
    },
    itemDescription: {
      opacity: "0.64",
      textStyle: "sm"
    },
    itemControl: {
      display: "inline-flex",
      flex: "1",
      pos: "relative",
      rounded: "inherit",
      justifyContent: "var(--radio-card-justify)",
      alignItems: "var(--radio-card-align)",
      _disabled: {
        bg: "bg.muted"
      }
    },
    itemIndicator: radiomarkRecipe.base,
    itemAddon: {
      roundedBottom: "inherit",
      _disabled: {
        color: "fg.muted"
      }
    },
    itemContent: {
      display: "flex",
      flexDirection: "column",
      flex: "1",
      gap: "1",
      justifyContent: "var(--radio-card-justify)",
      alignItems: "var(--radio-card-align)"
    }
  },
  variants: {
    size: {
      sm: {
        item: {
          textStyle: "sm"
        },
        itemControl: {
          padding: "3",
          gap: "1.5"
        },
        itemAddon: {
          px: "3",
          py: "1.5",
          borderTopWidth: "1px"
        },
        itemIndicator: (_a5 = radiomarkRecipe.variants) == null ? void 0 : _a5.size.sm
      },
      md: {
        item: {
          textStyle: "sm"
        },
        itemControl: {
          padding: "4",
          gap: "2.5"
        },
        itemAddon: {
          px: "4",
          py: "2",
          borderTopWidth: "1px"
        },
        itemIndicator: (_b5 = radiomarkRecipe.variants) == null ? void 0 : _b5.size.md
      },
      lg: {
        item: {
          textStyle: "md"
        },
        itemControl: {
          padding: "4",
          gap: "3.5"
        },
        itemAddon: {
          px: "4",
          py: "2",
          borderTopWidth: "1px"
        },
        itemIndicator: (_c4 = radiomarkRecipe.variants) == null ? void 0 : _c4.size.lg
      }
    },
    variant: {
      surface: {
        item: {
          borderWidth: "1px",
          _checked: {
            bg: "colorPalette.subtle",
            color: "colorPalette.fg",
            borderColor: "colorPalette.muted"
          }
        },
        itemIndicator: (_d4 = radiomarkRecipe.variants) == null ? void 0 : _d4.variant.solid
      },
      subtle: {
        item: {
          bg: "bg.muted"
        },
        itemControl: {
          _checked: {
            bg: "colorPalette.muted",
            color: "colorPalette.fg"
          }
        },
        itemIndicator: (_e4 = radiomarkRecipe.variants) == null ? void 0 : _e4.variant.outline
      },
      outline: {
        item: {
          borderWidth: "1px",
          _checked: {
            boxShadow: "0 0 0 1px var(--shadow-color)",
            boxShadowColor: "colorPalette.solid",
            borderColor: "colorPalette.solid"
          }
        },
        itemIndicator: (_f4 = radiomarkRecipe.variants) == null ? void 0 : _f4.variant.solid
      },
      solid: {
        item: {
          borderWidth: "1px",
          _checked: {
            bg: "colorPalette.solid",
            color: "colorPalette.contrast",
            borderColor: "colorPalette.solid"
          }
        },
        itemIndicator: (_g4 = radiomarkRecipe.variants) == null ? void 0 : _g4.variant.inverted
      }
    },
    justify: {
      start: {
        item: { "--radio-card-justify": "flex-start" }
      },
      end: {
        item: { "--radio-card-justify": "flex-end" }
      },
      center: {
        item: { "--radio-card-justify": "center" }
      }
    },
    align: {
      start: {
        item: { "--radio-card-align": "flex-start" },
        itemControl: { textAlign: "start" }
      },
      end: {
        item: { "--radio-card-align": "flex-end" },
        itemControl: { textAlign: "end" }
      },
      center: {
        item: { "--radio-card-align": "center" },
        itemControl: { textAlign: "center" }
      }
    },
    orientation: {
      vertical: {
        itemControl: { flexDirection: "column" }
      },
      horizontal: {
        itemControl: { flexDirection: "row" }
      }
    }
  },
  defaultVariants: {
    size: "md",
    variant: "outline",
    align: "start",
    orientation: "horizontal"
  }
});

// node_modules/@chakra-ui/react/dist/esm/theme/recipes/radio-group.js
var _a6, _b6, _c5, _d5, _e5, _f5, _g5, _h3, _i3, _j3, _k3, _l3, _m3, _n3;
var radioGroupSlotRecipe = defineSlotRecipe({
  className: "chakra-radio-group",
  slots: radioGroupAnatomy.keys(),
  base: {
    item: {
      display: "inline-flex",
      alignItems: "center",
      position: "relative",
      fontWeight: "medium",
      _disabled: {
        cursor: "disabled"
      }
    },
    itemControl: radiomarkRecipe.base,
    label: {
      userSelect: "none",
      textStyle: "sm",
      _disabled: {
        opacity: "0.5"
      }
    }
  },
  variants: {
    variant: {
      outline: {
        itemControl: (_b6 = (_a6 = radiomarkRecipe.variants) == null ? void 0 : _a6.variant) == null ? void 0 : _b6.outline
      },
      subtle: {
        itemControl: (_d5 = (_c5 = radiomarkRecipe.variants) == null ? void 0 : _c5.variant) == null ? void 0 : _d5.subtle
      },
      solid: {
        itemControl: (_f5 = (_e5 = radiomarkRecipe.variants) == null ? void 0 : _e5.variant) == null ? void 0 : _f5.solid
      }
    },
    size: {
      xs: {
        item: { textStyle: "xs", gap: "1.5" },
        itemControl: (_h3 = (_g5 = radiomarkRecipe.variants) == null ? void 0 : _g5.size) == null ? void 0 : _h3.xs
      },
      sm: {
        item: { textStyle: "sm", gap: "2" },
        itemControl: (_j3 = (_i3 = radiomarkRecipe.variants) == null ? void 0 : _i3.size) == null ? void 0 : _j3.sm
      },
      md: {
        item: { textStyle: "sm", gap: "2.5" },
        itemControl: (_l3 = (_k3 = radiomarkRecipe.variants) == null ? void 0 : _k3.size) == null ? void 0 : _l3.md
      },
      lg: {
        item: { textStyle: "md", gap: "3" },
        itemControl: (_n3 = (_m3 = radiomarkRecipe.variants) == null ? void 0 : _m3.size) == null ? void 0 : _n3.lg
      }
    }
  },
  defaultVariants: {
    size: "md",
    variant: "solid"
  }
});

// node_modules/@chakra-ui/react/dist/esm/theme/recipes/rating-group.js
var ratingGroupSlotRecipe = defineSlotRecipe({
  className: "chakra-rating-group",
  slots: ratingGroupAnatomy.keys(),
  base: {
    root: {
      display: "inline-flex"
    },
    control: {
      display: "inline-flex",
      alignItems: "center"
    },
    item: {
      display: "inline-flex",
      alignItems: "center",
      justifyContent: "center",
      userSelect: "none"
    },
    itemIndicator: {
      display: "inline-flex",
      alignItems: "center",
      justifyContent: "center",
      width: "1em",
      height: "1em",
      position: "relative",
      _icon: {
        stroke: "currentColor",
        width: "100%",
        height: "100%",
        display: "inline-block",
        flexShrink: 0,
        position: "absolute",
        left: 0,
        top: 0
      },
      "& [data-bg]": {
        color: "bg.emphasized"
      },
      "& [data-fg]": {
        color: "transparent"
      },
      "&[data-highlighted]:not([data-half])": {
        "& [data-fg]": {
          color: "colorPalette.solid"
        }
      },
      "&[data-half]": {
        "& [data-fg]": {
          color: "colorPalette.solid",
          clipPath: "inset(0 50% 0 0)"
        }
      }
    }
  },
  variants: {
    size: {
      xs: {
        item: {
          textStyle: "sm"
        }
      },
      sm: {
        item: {
          textStyle: "md"
        }
      },
      md: {
        item: {
          textStyle: "xl"
        }
      },
      lg: {
        item: {
          textStyle: "2xl"
        }
      }
    }
  },
  defaultVariants: {
    size: "md"
  }
});

// node_modules/@chakra-ui/react/dist/esm/theme/recipes/segment-group.js
var segmentGroupSlotRecipe = defineSlotRecipe({
  className: "chakra-segment-group",
  slots: segmentGroupAnatomy.keys(),
  base: {
    root: {
      "--segment-radius": "radii.l2",
      borderRadius: "l2",
      display: "inline-flex",
      boxShadow: "inset",
      minW: "max-content",
      textAlign: "center",
      position: "relative",
      isolation: "isolate",
      bg: "bg.muted"
    },
    item: {
      display: "flex",
      alignItems: "center",
      userSelect: "none",
      fontSize: "sm",
      position: "relative",
      color: "fg",
      borderRadius: "var(--segment-radius)",
      _disabled: {
        opacity: "0.5"
      },
      "&:has(input:focus-visible)": {
        focusRing: "outside"
      },
      _before: {
        content: '""',
        position: "absolute",
        insetInlineStart: 0,
        insetBlock: "1.5",
        bg: "border",
        width: "1px",
        transition: "opacity 0.2s"
      },
      "& + &[data-state=checked], &[data-state=checked] + &, &:first-of-type": {
        _before: {
          opacity: "0"
        }
      },
      "&[data-state=checked][data-ssr]": {
        shadow: "sm",
        bg: "bg",
        borderRadius: "var(--segment-radius)"
      }
    },
    indicator: {
      shadow: "sm",
      pos: "absolute",
      bg: { _light: "bg", _dark: "bg.emphasized" },
      width: "var(--width)",
      height: "var(--height)",
      top: "var(--top)",
      left: "var(--left)",
      zIndex: -1,
      borderRadius: "var(--segment-radius)"
    }
  },
  variants: {
    size: {
      xs: {
        root: {
          height: "6"
        },
        item: {
          textStyle: "xs",
          px: "3",
          gap: "1"
        }
      },
      sm: {
        root: {
          height: "8"
        },
        item: {
          textStyle: "sm",
          px: "4",
          gap: "2"
        }
      },
      md: {
        root: {
          height: "10"
        },
        item: {
          textStyle: "sm",
          px: "4",
          gap: "2"
        }
      },
      lg: {
        root: {
          height: "10"
        },
        item: {
          textStyle: "md",
          px: "5",
          gap: "3"
        }
      }
    }
  },
  defaultVariants: {
    size: "md"
  }
});

// node_modules/@chakra-ui/react/dist/esm/theme/recipes/slider.js
var sliderSlotRecipe = defineSlotRecipe({
  className: "chakra-slider",
  slots: sliderAnatomy.keys(),
  base: {
    root: {
      display: "flex",
      flexDirection: "column",
      gap: "1",
      textStyle: "sm",
      position: "relative",
      isolation: "isolate",
      touchAction: "none"
    },
    label: {
      fontWeight: "medium",
      textStyle: "sm"
    },
    control: {
      display: "inline-flex",
      alignItems: "center",
      position: "relative"
    },
    track: {
      overflow: "hidden",
      borderRadius: "full",
      flex: "1"
    },
    range: {
      width: "inherit",
      height: "inherit",
      _disabled: { bg: "border.emphasized!" }
    },
    markerGroup: {
      position: "absolute!",
      zIndex: "1"
    },
    marker: {
      "--marker-bg": { base: "white", _underValue: "colors.bg" },
      display: "flex",
      alignItems: "center",
      gap: "calc(var(--slider-thumb-size) / 2)",
      color: "fg.muted",
      textStyle: "xs"
    },
    markerIndicator: {
      width: "var(--slider-marker-size)",
      height: "var(--slider-marker-size)",
      borderRadius: "full",
      bg: "var(--marker-bg)"
    },
    thumb: {
      width: "var(--slider-thumb-size)",
      height: "var(--slider-thumb-size)",
      display: "flex",
      alignItems: "center",
      justifyContent: "center",
      outline: 0,
      zIndex: "2",
      borderRadius: "full",
      _focusVisible: {
        ring: "2px",
        ringColor: "colorPalette.focusRing",
        ringOffset: "2px",
        ringOffsetColor: "bg"
      }
    }
  },
  variants: {
    size: {
      sm: {
        root: {
          "--slider-thumb-size": "sizes.4",
          "--slider-track-size": "sizes.1.5",
          "--slider-marker-center": "6px",
          "--slider-marker-size": "sizes.1",
          "--slider-marker-inset": "3px"
        }
      },
      md: {
        root: {
          "--slider-thumb-size": "sizes.5",
          "--slider-track-size": "sizes.2",
          "--slider-marker-center": "8px",
          "--slider-marker-size": "sizes.1",
          "--slider-marker-inset": "4px"
        }
      },
      lg: {
        root: {
          "--slider-thumb-size": "sizes.6",
          "--slider-track-size": "sizes.2.5",
          "--slider-marker-center": "9px",
          "--slider-marker-size": "sizes.1.5",
          "--slider-marker-inset": "5px"
        }
      }
    },
    variant: {
      outline: {
        track: {
          shadow: "inset",
          bg: "bg.emphasized/72"
        },
        range: {
          bg: "colorPalette.solid"
        },
        thumb: {
          borderWidth: "2px",
          borderColor: "colorPalette.solid",
          bg: "bg",
          _disabled: {
            bg: "border.emphasized",
            borderColor: "border.emphasized"
          }
        }
      },
      solid: {
        track: {
          bg: "colorPalette.subtle",
          _disabled: {
            bg: "bg.muted"
          }
        },
        range: {
          bg: "colorPalette.solid"
        },
        thumb: {
          bg: "colorPalette.solid",
          _disabled: {
            bg: "border.emphasized"
          }
        }
      }
    },
    orientation: {
      vertical: {
        root: {
          display: "inline-flex"
        },
        control: {
          flexDirection: "column",
          height: "100%",
          minWidth: "var(--slider-thumb-size)",
          "&[data-has-mark-label]": {
            marginEnd: "4"
          }
        },
        track: {
          width: "var(--slider-track-size)"
        },
        thumb: {
          left: "50%",
          translate: "-50% 0"
        },
        markerGroup: {
          insetStart: "var(--slider-marker-center)",
          insetBlock: "var(--slider-marker-inset)"
        },
        marker: {
          flexDirection: "row"
        }
      },
      horizontal: {
        control: {
          flexDirection: "row",
          width: "100%",
          minHeight: "var(--slider-thumb-size)",
          "&[data-has-mark-label]": {
            marginBottom: "4"
          }
        },
        track: {
          height: "var(--slider-track-size)"
        },
        thumb: {
          top: "50%",
          translate: "0 -50%"
        },
        markerGroup: {
          top: "var(--slider-marker-center)",
          insetInline: "var(--slider-marker-inset)"
        },
        marker: {
          flexDirection: "column"
        }
      }
    }
  },
  defaultVariants: {
    size: "md",
    variant: "outline",
    orientation: "horizontal"
  }
});

// node_modules/@chakra-ui/react/dist/esm/theme/recipes/stat.js
var statSlotRecipe = defineSlotRecipe({
  className: "chakra-stat",
  slots: statAnatomy.keys(),
  base: {
    root: {
      display: "flex",
      flexDirection: "column",
      gap: "1",
      position: "relative",
      flex: "1"
    },
    label: {
      display: "inline-flex",
      gap: "1.5",
      alignItems: "center",
      color: "fg.muted",
      textStyle: "sm"
    },
    helpText: {
      color: "fg.muted",
      textStyle: "xs"
    },
    valueUnit: {
      color: "fg.muted",
      textStyle: "xs",
      fontWeight: "initial",
      letterSpacing: "initial"
    },
    valueText: {
      verticalAlign: "baseline",
      fontWeight: "semibold",
      letterSpacing: "tight",
      fontFeatureSettings: "pnum",
      fontVariantNumeric: "proportional-nums",
      display: "inline-flex",
      gap: "1"
    },
    indicator: {
      display: "inline-flex",
      alignItems: "center",
      justifyContent: "center",
      marginEnd: 1,
      "& :where(svg)": {
        w: "1em",
        h: "1em"
      },
      "&[data-type=up]": {
        color: "fg.success"
      },
      "&[data-type=down]": {
        color: "fg.error"
      }
    }
  },
  variants: {
    size: {
      sm: {
        valueText: {
          textStyle: "xl"
        }
      },
      md: {
        valueText: {
          textStyle: "2xl"
        }
      },
      lg: {
        valueText: {
          textStyle: "3xl"
        }
      }
    }
  },
  defaultVariants: {
    size: "md"
  }
});

// node_modules/@chakra-ui/react/dist/esm/theme/recipes/status.js
var statusSlotRecipe = defineSlotRecipe({
  className: "chakra-status",
  slots: statusAnatomy.keys(),
  base: {
    root: {
      display: "inline-flex",
      alignItems: "center",
      gap: "2"
    },
    indicator: {
      width: "0.64em",
      height: "0.64em",
      flexShrink: 0,
      borderRadius: "full",
      forcedColorAdjust: "none",
      bg: "colorPalette.solid"
    }
  },
  variants: {
    size: {
      sm: {
        root: {
          textStyle: "xs"
        }
      },
      md: {
        root: {
          textStyle: "sm"
        }
      },
      lg: {
        root: {
          textStyle: "md"
        }
      }
    }
  },
  defaultVariants: {
    size: "md"
  }
});

// node_modules/@chakra-ui/react/dist/esm/theme/recipes/steps.js
var stepsSlotRecipe = defineSlotRecipe({
  className: "chakra-steps",
  slots: stepsAnatomy.keys(),
  base: {
    root: {
      display: "flex",
      width: "full"
    },
    list: {
      display: "flex",
      justifyContent: "space-between",
      "--steps-gutter": "spacing.3",
      "--steps-thickness": "2px"
    },
    title: {
      fontWeight: "medium",
      color: "fg"
    },
    description: {
      color: "fg.muted"
    },
    separator: {
      bg: "border",
      flex: "1"
    },
    indicator: {
      display: "flex",
      justifyContent: "center",
      alignItems: "center",
      flexShrink: "0",
      borderRadius: "full",
      fontWeight: "medium",
      width: "var(--steps-size)",
      height: "var(--steps-size)",
      _icon: {
        flexShrink: "0",
        width: "var(--steps-icon-size)",
        height: "var(--steps-icon-size)"
      }
    },
    item: {
      position: "relative",
      display: "flex",
      flex: "1 0 0",
      "&:last-of-type": {
        flex: "initial",
        "& [data-part=separator]": {
          display: "none"
        }
      }
    },
    trigger: {
      display: "flex",
      alignItems: "center",
      gap: "3",
      textAlign: "start",
      focusVisibleRing: "outside",
      borderRadius: "l2"
    },
    content: {
      focusVisibleRing: "outside"
    }
  },
  variants: {
    orientation: {
      vertical: {
        root: {
          flexDirection: "row",
          height: "100%"
        },
        list: {
          flexDirection: "column",
          alignItems: "flex-start"
        },
        separator: {
          position: "absolute",
          width: "var(--steps-thickness)",
          height: "100%",
          maxHeight: "calc(100% - var(--steps-size) - var(--steps-gutter) * 2)",
          top: "calc(var(--steps-size) + var(--steps-gutter))",
          insetStart: "calc(var(--steps-size) / 2 - 1px)"
        },
        item: {
          alignItems: "flex-start"
        }
      },
      horizontal: {
        root: {
          flexDirection: "column",
          width: "100%"
        },
        list: {
          flexDirection: "row",
          alignItems: "center"
        },
        separator: {
          width: "100%",
          height: "var(--steps-thickness)",
          marginX: "var(--steps-gutter)"
        },
        item: {
          alignItems: "center"
        }
      }
    },
    variant: {
      solid: {
        indicator: {
          _incomplete: {
            borderWidth: "var(--steps-thickness)"
          },
          _current: {
            bg: "colorPalette.muted",
            borderWidth: "var(--steps-thickness)",
            borderColor: "colorPalette.solid",
            color: "colorPalette.fg"
          },
          _complete: {
            bg: "colorPalette.solid",
            borderColor: "colorPalette.solid",
            color: "colorPalette.contrast"
          }
        },
        separator: {
          _complete: {
            bg: "colorPalette.solid"
          }
        }
      },
      subtle: {
        indicator: {
          _incomplete: {
            bg: "bg.muted"
          },
          _current: {
            bg: "colorPalette.muted",
            color: "colorPalette.fg"
          },
          _complete: {
            bg: "colorPalette.emphasized",
            color: "colorPalette.fg"
          }
        },
        separator: {
          _complete: {
            bg: "colorPalette.emphasized"
          }
        }
      }
    },
    size: {
      xs: {
        root: {
          gap: "2.5"
        },
        list: {
          "--steps-size": "sizes.6",
          "--steps-icon-size": "sizes.3.5",
          textStyle: "xs"
        },
        title: {
          textStyle: "sm"
        }
      },
      sm: {
        root: {
          gap: "3"
        },
        list: {
          "--steps-size": "sizes.8",
          "--steps-icon-size": "sizes.4",
          textStyle: "xs"
        },
        title: {
          textStyle: "sm"
        }
      },
      md: {
        root: {
          gap: "4"
        },
        list: {
          "--steps-size": "sizes.10",
          "--steps-icon-size": "sizes.4",
          textStyle: "sm"
        },
        title: {
          textStyle: "sm"
        }
      },
      lg: {
        root: {
          gap: "6"
        },
        list: {
          "--steps-size": "sizes.11",
          "--steps-icon-size": "sizes.5",
          textStyle: "md"
        },
        title: {
          textStyle: "md"
        }
      }
    }
  },
  defaultVariants: {
    size: "md",
    variant: "solid",
    orientation: "horizontal"
  }
});

// node_modules/@chakra-ui/react/dist/esm/theme/recipes/switch.js
var switchSlotRecipe = defineSlotRecipe({
  slots: switchAnatomy.keys(),
  className: "chakra-switch",
  base: {
    root: {
      display: "inline-flex",
      gap: "2.5",
      alignItems: "center",
      position: "relative",
      verticalAlign: "middle",
      "--switch-diff": "calc(var(--switch-width) - var(--switch-height))",
      "--switch-x": {
        base: "var(--switch-diff)",
        _rtl: "calc(var(--switch-diff) * -1)"
      }
    },
    label: {
      lineHeight: "1",
      userSelect: "none",
      fontSize: "sm",
      fontWeight: "medium",
      _disabled: {
        opacity: "0.5"
      }
    },
    indicator: {
      position: "absolute",
      height: "var(--switch-height)",
      width: "var(--switch-height)",
      fontSize: "var(--switch-indicator-font-size)",
      fontWeight: "medium",
      flexShrink: 0,
      userSelect: "none",
      display: "grid",
      placeContent: "center",
      transition: "inset-inline-start 0.12s ease",
      insetInlineStart: "calc(var(--switch-x) - 2px)",
      _checked: {
        insetInlineStart: "2px"
      }
    },
    control: {
      display: "inline-flex",
      gap: "0.5rem",
      flexShrink: 0,
      justifyContent: "flex-start",
      cursor: "switch",
      borderRadius: "full",
      position: "relative",
      width: "var(--switch-width)",
      height: "var(--switch-height)",
      _disabled: {
        opacity: "0.5",
        cursor: "not-allowed"
      },
      _invalid: {
        outline: "2px solid",
        outlineColor: "border.error",
        outlineOffset: "2px"
      }
    },
    thumb: {
      display: "flex",
      alignItems: "center",
      justifyContent: "center",
      flexShrink: 0,
      transitionProperty: "translate",
      transitionDuration: "fast",
      borderRadius: "inherit",
      _checked: {
        translate: "var(--switch-x) 0"
      }
    }
  },
  variants: {
    variant: {
      solid: {
        control: {
          borderRadius: "full",
          bg: "bg.emphasized",
          focusVisibleRing: "outside",
          _checked: {
            bg: "colorPalette.solid"
          }
        },
        thumb: {
          bg: "white",
          width: "var(--switch-height)",
          height: "var(--switch-height)",
          scale: "0.8",
          boxShadow: "sm",
          _checked: {
            bg: "colorPalette.contrast"
          }
        }
      },
      raised: {
        control: {
          borderRadius: "full",
          height: "calc(var(--switch-height) / 2)",
          bg: "bg.muted",
          boxShadow: "inset",
          _checked: {
            bg: "colorPalette.solid/60"
          }
        },
        thumb: {
          width: "var(--switch-height)",
          height: "var(--switch-height)",
          position: "relative",
          top: "calc(var(--switch-height) * -0.25)",
          bg: "white",
          boxShadow: "xs",
          focusVisibleRing: "outside",
          _checked: {
            bg: "colorPalette.solid"
          }
        }
      }
    },
    size: {
      xs: {
        root: {
          "--switch-width": "sizes.6",
          "--switch-height": "sizes.3",
          "--switch-indicator-font-size": "fontSizes.xs"
        }
      },
      sm: {
        root: {
          "--switch-width": "sizes.8",
          "--switch-height": "sizes.4",
          "--switch-indicator-font-size": "fontSizes.xs"
        }
      },
      md: {
        root: {
          "--switch-width": "sizes.10",
          "--switch-height": "sizes.5",
          "--switch-indicator-font-size": "fontSizes.sm"
        }
      },
      lg: {
        root: {
          "--switch-width": "sizes.12",
          "--switch-height": "sizes.6",
          "--switch-indicator-font-size": "fontSizes.md"
        }
      }
    }
  },
  defaultVariants: {
    variant: "solid",
    size: "md"
  }
});

// node_modules/@chakra-ui/react/dist/esm/theme/recipes/table.js
var tableSlotRecipe = defineSlotRecipe({
  className: "chakra-table",
  slots: tableAnatomy.keys(),
  base: {
    root: {
      fontVariantNumeric: "lining-nums tabular-nums",
      borderCollapse: "collapse",
      width: "full",
      textAlign: "start",
      verticalAlign: "top"
    },
    row: {
      _selected: {
        bg: "colorPalette.subtle"
      }
    },
    cell: {
      textAlign: "start",
      alignItems: "center"
    },
    columnHeader: {
      fontWeight: "medium",
      textAlign: "start",
      color: "fg"
    },
    caption: {
      fontWeight: "medium",
      textStyle: "xs"
    },
    footer: {
      fontWeight: "medium"
    }
  },
  variants: {
    interactive: {
      true: {
        body: {
          "& tr": {
            _hover: {
              bg: "colorPalette.subtle"
            }
          }
        }
      }
    },
    stickyHeader: {
      true: {
        header: {
          "& :where(tr)": {
            top: "var(--table-sticky-offset, 0)",
            position: "sticky",
            zIndex: 1
          }
        }
      }
    },
    striped: {
      true: {
        row: {
          "&:nth-of-type(odd) td": {
            bg: "bg.muted"
          }
        }
      }
    },
    showColumnBorder: {
      true: {
        columnHeader: {
          "&:not(:last-of-type)": {
            borderInlineEndWidth: "1px"
          }
        },
        cell: {
          "&:not(:last-of-type)": {
            borderInlineEndWidth: "1px"
          }
        }
      }
    },
    variant: {
      line: {
        columnHeader: {
          borderBottomWidth: "1px"
        },
        cell: {
          borderBottomWidth: "1px"
        },
        row: {
          bg: "bg"
        }
      },
      outline: {
        root: {
          boxShadow: "0 0 0 1px {colors.border}",
          overflow: "hidden"
        },
        columnHeader: {
          borderBottomWidth: "1px"
        },
        header: {
          bg: "bg.muted"
        },
        row: {
          "&:not(:last-of-type)": {
            borderBottomWidth: "1px"
          }
        },
        footer: {
          borderTopWidth: "1px"
        }
      }
    },
    size: {
      sm: {
        root: {
          textStyle: "sm"
        },
        columnHeader: {
          px: "2",
          py: "2"
        },
        cell: {
          px: "2",
          py: "2"
        }
      },
      md: {
        root: {
          textStyle: "sm"
        },
        columnHeader: {
          px: "3",
          py: "3"
        },
        cell: {
          px: "3",
          py: "3"
        }
      },
      lg: {
        root: {
          textStyle: "md"
        },
        columnHeader: {
          px: "4",
          py: "3"
        },
        cell: {
          px: "4",
          py: "3"
        }
      }
    }
  },
  defaultVariants: {
    variant: "line",
    size: "md"
  }
});

// node_modules/@chakra-ui/react/dist/esm/theme/recipes/tabs.js
var tabsSlotRecipe = defineSlotRecipe({
  slots: tabsAnatomy.keys(),
  className: "chakra-tabs",
  base: {
    root: {
      "--tabs-trigger-radius": "radii.l2",
      position: "relative",
      _horizontal: {
        display: "block"
      },
      _vertical: {
        display: "flex"
      }
    },
    list: {
      display: "inline-flex",
      position: "relative",
      isolation: "isolate",
      "--tabs-indicator-shadow": "shadows.xs",
      "--tabs-indicator-bg": "colors.bg",
      minH: "var(--tabs-height)",
      _horizontal: {
        flexDirection: "row"
      },
      _vertical: {
        flexDirection: "column"
      }
    },
    trigger: {
      outline: "0",
      minW: "var(--tabs-height)",
      height: "var(--tabs-height)",
      display: "flex",
      alignItems: "center",
      fontWeight: "medium",
      position: "relative",
      cursor: "button",
      gap: "2",
      _focusVisible: {
        zIndex: 1,
        outline: "2px solid",
        outlineColor: "colorPalette.focusRing"
      },
      _disabled: {
        cursor: "not-allowed",
        opacity: 0.5
      }
    },
    content: {
      focusVisibleRing: "inside",
      _horizontal: {
        width: "100%",
        pt: "var(--tabs-content-padding)"
      },
      _vertical: {
        height: "100%",
        ps: "var(--tabs-content-padding)"
      }
    },
    indicator: {
      width: "var(--width)",
      height: "var(--height)",
      borderRadius: "var(--tabs-indicator-radius)",
      bg: "var(--tabs-indicator-bg)",
      shadow: "var(--tabs-indicator-shadow)",
      zIndex: -1
    }
  },
  variants: {
    fitted: {
      true: {
        list: {
          display: "flex"
        },
        trigger: {
          flex: 1,
          textAlign: "center",
          justifyContent: "center"
        }
      }
    },
    justify: {
      start: {
        list: {
          justifyContent: "flex-start"
        }
      },
      center: {
        list: {
          justifyContent: "center"
        }
      },
      end: {
        list: {
          justifyContent: "flex-end"
        }
      }
    },
    size: {
      sm: {
        root: {
          "--tabs-height": "sizes.9",
          "--tabs-content-padding": "spacing.3"
        },
        trigger: {
          py: "1",
          px: "3",
          textStyle: "sm"
        }
      },
      md: {
        root: {
          "--tabs-height": "sizes.10",
          "--tabs-content-padding": "spacing.4"
        },
        trigger: {
          py: "2",
          px: "4",
          textStyle: "sm"
        }
      },
      lg: {
        root: {
          "--tabs-height": "sizes.11",
          "--tabs-content-padding": "spacing.4.5"
        },
        trigger: {
          py: "2",
          px: "4.5",
          textStyle: "md"
        }
      }
    },
    variant: {
      line: {
        list: {
          display: "flex",
          borderColor: "border",
          _horizontal: {
            borderBottomWidth: "1px"
          },
          _vertical: {
            borderEndWidth: "1px"
          }
        },
        trigger: {
          color: "fg.muted",
          _disabled: {
            _active: { bg: "initial" }
          },
          _selected: {
            color: "fg",
            _horizontal: {
              layerStyle: "indicator.bottom",
              "--indicator-offset-y": "-1px",
              "--indicator-color": "colors.colorPalette.solid"
            },
            _vertical: {
              layerStyle: "indicator.end",
              "--indicator-offset-x": "-1px"
            }
          }
        }
      },
      subtle: {
        trigger: {
          borderRadius: "var(--tabs-trigger-radius)",
          color: "fg.muted",
          _selected: {
            bg: "colorPalette.subtle",
            color: "colorPalette.fg"
          }
        }
      },
      enclosed: {
        list: {
          bg: "bg.muted",
          padding: "1",
          borderRadius: "l3",
          minH: "calc(var(--tabs-height) - 4px)"
        },
        trigger: {
          justifyContent: "center",
          color: "fg.muted",
          borderRadius: "var(--tabs-trigger-radius)",
          _selected: {
            bg: "bg",
            color: "colorPalette.fg",
            shadow: "xs"
          }
        }
      },
      outline: {
        list: {
          "--line-thickness": "1px",
          "--line-offset": "calc(var(--line-thickness) * -1)",
          borderColor: "border",
          display: "flex",
          _horizontal: {
            _before: {
              content: '""',
              position: "absolute",
              bottom: "0px",
              width: "100%",
              borderBottomWidth: "var(--line-thickness)",
              borderBottomColor: "border"
            }
          },
          _vertical: {
            _before: {
              content: '""',
              position: "absolute",
              insetInline: "var(--line-offset)",
              height: "calc(100% - calc(var(--line-thickness) * 2))",
              borderEndWidth: "var(--line-thickness)",
              borderEndColor: "border"
            }
          }
        },
        trigger: {
          color: "fg.muted",
          borderWidth: "1px",
          borderColor: "transparent",
          _selected: {
            bg: "currentBg",
            color: "colorPalette.fg"
          },
          _horizontal: {
            borderTopRadius: "var(--tabs-trigger-radius)",
            marginBottom: "var(--line-offset)",
            marginEnd: { _notLast: "var(--line-offset)" },
            _selected: {
              borderColor: "border",
              borderBottomColor: "transparent"
            }
          },
          _vertical: {
            borderStartRadius: "var(--tabs-trigger-radius)",
            marginEnd: "var(--line-offset)",
            marginBottom: { _notLast: "var(--line-offset)" },
            _selected: {
              borderColor: "border",
              borderEndColor: "transparent"
            }
          }
        }
      },
      plain: {
        trigger: {
          color: "fg.muted",
          _selected: {
            color: "colorPalette.fg"
          },
          borderRadius: "var(--tabs-trigger-radius)",
          "&[data-selected][data-ssr]": {
            bg: "var(--tabs-indicator-bg)",
            shadow: "var(--tabs-indicator-shadow)",
            borderRadius: "var(--tabs-indicator-radius)"
          }
        }
      }
    }
  },
  defaultVariants: {
    size: "md",
    variant: "line"
  }
});

// node_modules/@chakra-ui/react/dist/esm/theme/recipes/tag.js
var _a7;
var badgeVariant = (_a7 = badgeRecipe.variants) == null ? void 0 : _a7.variant;
var tagSlotRecipe = defineSlotRecipe({
  slots: tagAnatomy.keys(),
  className: "chakra-tag",
  base: {
    root: {
      display: "inline-flex",
      alignItems: "center",
      verticalAlign: "top",
      maxWidth: "100%",
      userSelect: "none",
      borderRadius: "l2",
      focusVisibleRing: "outside"
    },
    label: {
      lineClamp: "1"
    },
    closeTrigger: {
      display: "flex",
      alignItems: "center",
      justifyContent: "center",
      outline: "0",
      borderRadius: "l1",
      color: "currentColor",
      focusVisibleRing: "inside",
      focusRingWidth: "2px"
    },
    startElement: {
      flexShrink: 0,
      boxSize: "var(--tag-element-size)",
      ms: "var(--tag-element-offset)",
      "&:has([data-scope=avatar])": {
        boxSize: "var(--tag-avatar-size)",
        ms: "calc(var(--tag-element-offset) * 1.5)"
      },
      _icon: { boxSize: "100%" }
    },
    endElement: {
      flexShrink: 0,
      boxSize: "var(--tag-element-size)",
      me: "var(--tag-element-offset)",
      _icon: { boxSize: "100%" },
      "&:has(button)": {
        ms: "calc(var(--tag-element-offset) * -1)"
      }
    }
  },
  variants: {
    size: {
      sm: {
        root: {
          px: "1.5",
          minH: "4.5",
          gap: "1",
          "--tag-avatar-size": "spacing.3",
          "--tag-element-size": "spacing.3",
          "--tag-element-offset": "-2px"
        },
        label: {
          textStyle: "xs"
        }
      },
      md: {
        root: {
          px: "1.5",
          minH: "5",
          gap: "1",
          "--tag-avatar-size": "spacing.3.5",
          "--tag-element-size": "spacing.3.5",
          "--tag-element-offset": "-2px"
        },
        label: {
          textStyle: "xs"
        }
      },
      lg: {
        root: {
          px: "2",
          minH: "6",
          gap: "1.5",
          "--tag-avatar-size": "spacing.4.5",
          "--tag-element-size": "spacing.4",
          "--tag-element-offset": "-3px"
        },
        label: {
          textStyle: "sm"
        }
      },
      xl: {
        root: {
          px: "2.5",
          minH: "8",
          gap: "1.5",
          "--tag-avatar-size": "spacing.6",
          "--tag-element-size": "spacing.4.5",
          "--tag-element-offset": "-4px"
        },
        label: {
          textStyle: "sm"
        }
      }
    },
    variant: {
      subtle: {
        root: badgeVariant == null ? void 0 : badgeVariant.subtle
      },
      solid: {
        root: badgeVariant == null ? void 0 : badgeVariant.solid
      },
      outline: {
        root: badgeVariant == null ? void 0 : badgeVariant.outline
      },
      surface: {
        root: badgeVariant == null ? void 0 : badgeVariant.surface
      }
    }
  },
  defaultVariants: {
    size: "md",
    variant: "surface"
  }
});

// node_modules/@chakra-ui/react/dist/esm/theme/recipes/timeline.js
var timelineSlotRecipe = defineSlotRecipe({
  slots: timelineAnatomy.keys(),
  className: "chakra-timeline",
  base: {
    root: {
      display: "flex",
      flexDirection: "column",
      width: "full",
      "--timeline-thickness": "1px",
      "--timeline-gutter": "4px"
    },
    item: {
      display: "flex",
      position: "relative",
      alignItems: "flex-start",
      flexShrink: 0,
      gap: "4",
      _last: {
        "& :where(.chakra-timeline__separator)": { display: "none" }
      }
    },
    separator: {
      position: "absolute",
      borderStartWidth: "var(--timeline-thickness)",
      ms: "calc(-1 * var(--timeline-thickness) / 2)",
      insetInlineStart: "calc(var(--timeline-indicator-size) / 2)",
      insetBlock: "0",
      borderColor: "border"
    },
    indicator: {
      outline: "2px solid {colors.bg}",
      position: "relative",
      flexShrink: "0",
      boxSize: "var(--timeline-indicator-size)",
      fontSize: "var(--timeline-font-size)",
      display: "flex",
      alignItems: "center",
      justifyContent: "center",
      borderRadius: "full",
      fontWeight: "medium"
    },
    connector: {
      alignSelf: "stretch",
      position: "relative"
    },
    content: {
      pb: "6",
      display: "flex",
      flexDirection: "column",
      width: "full",
      gap: "2"
    },
    title: {
      display: "flex",
      fontWeight: "medium",
      flexWrap: "wrap",
      gap: "1.5",
      alignItems: "center",
      mt: "var(--timeline-margin)"
    },
    description: {
      color: "fg.muted",
      textStyle: "xs"
    }
  },
  variants: {
    variant: {
      subtle: {
        indicator: {
          bg: "colorPalette.muted"
        }
      },
      solid: {
        indicator: {
          bg: "colorPalette.solid",
          color: "colorPalette.contrast"
        }
      },
      outline: {
        indicator: {
          bg: "currentBg",
          borderWidth: "1px",
          borderColor: "colorPalette.muted"
        }
      },
      plain: {}
    },
    size: {
      sm: {
        root: {
          "--timeline-indicator-size": "sizes.4",
          "--timeline-font-size": "fontSizes.2xs"
        },
        title: {
          textStyle: "xs"
        }
      },
      md: {
        root: {
          "--timeline-indicator-size": "sizes.5",
          "--timeline-font-size": "fontSizes.xs"
        },
        title: {
          textStyle: "sm"
        }
      },
      lg: {
        root: {
          "--timeline-indicator-size": "sizes.6",
          "--timeline-font-size": "fontSizes.xs"
        },
        title: {
          mt: "0.5",
          textStyle: "sm"
        }
      },
      xl: {
        root: {
          "--timeline-indicator-size": "sizes.8",
          "--timeline-font-size": "fontSizes.sm"
        },
        title: {
          mt: "1.5",
          textStyle: "sm"
        }
      }
    }
  },
  defaultVariants: {
    size: "md",
    variant: "solid"
  }
});

// node_modules/@chakra-ui/react/dist/esm/theme/recipes/toast.js
var toastSlotRecipe = defineSlotRecipe({
  slots: toastAnatomy.keys(),
  className: "chakra-toast",
  base: {
    root: {
      width: "full",
      display: "flex",
      alignItems: "flex-start",
      position: "relative",
      gap: "3",
      py: "4",
      ps: "4",
      pe: "6",
      borderRadius: "l2",
      translate: "var(--x) var(--y)",
      scale: "var(--scale)",
      zIndex: "var(--z-index)",
      height: "var(--height)",
      opacity: "var(--opacity)",
      willChange: "translate, opacity, scale",
      transition: "translate 400ms, scale 400ms, opacity 400ms, height 400ms, box-shadow 200ms",
      transitionTimingFunction: "cubic-bezier(0.21, 1.02, 0.73, 1)",
      _closed: {
        transition: "translate 400ms, scale 400ms, opacity 200ms",
        transitionTimingFunction: "cubic-bezier(0.06, 0.71, 0.55, 1)"
      },
      bg: "bg.panel",
      color: "fg",
      boxShadow: "xl",
      "--toast-trigger-bg": "colors.bg.muted",
      "&[data-type=warning]": {
        bg: "orange.solid",
        color: "orange.contrast",
        "--toast-trigger-bg": "{white/10}",
        "--toast-border-color": "{white/40}"
      },
      "&[data-type=success]": {
        bg: "green.solid",
        color: "green.contrast",
        "--toast-trigger-bg": "{white/10}",
        "--toast-border-color": "{white/40}"
      },
      "&[data-type=error]": {
        bg: "red.solid",
        color: "red.contrast",
        "--toast-trigger-bg": "{white/10}",
        "--toast-border-color": "{white/40}"
      }
    },
    title: {
      fontWeight: "medium",
      textStyle: "sm",
      marginEnd: "2"
    },
    description: {
      display: "inline",
      textStyle: "sm",
      opacity: "0.8"
    },
    indicator: {
      flexShrink: "0",
      boxSize: "5"
    },
    actionTrigger: {
      textStyle: "sm",
      fontWeight: "medium",
      height: "8",
      px: "3",
      borderRadius: "l2",
      alignSelf: "center",
      borderWidth: "1px",
      borderColor: "var(--toast-border-color, inherit)",
      transition: "background 200ms",
      _hover: {
        bg: "var(--toast-trigger-bg)"
      }
    },
    closeTrigger: {
      position: "absolute",
      top: "1",
      insetEnd: "1",
      padding: "1",
      display: "inline-flex",
      alignItems: "center",
      justifyContent: "center",
      color: "{currentColor/60}",
      borderRadius: "l2",
      textStyle: "md",
      transition: "background 200ms",
      _icon: {
        boxSize: "1em"
      }
    }
  }
});

// node_modules/@chakra-ui/react/dist/esm/theme/recipes/tooltip.js
var tooltipSlotRecipe = defineSlotRecipe({
  slots: anatomy22.keys(),
  className: "chakra-tooltip",
  base: {
    content: {
      "--tooltip-bg": "colors.bg.inverted",
      bg: "var(--tooltip-bg)",
      color: "fg.inverted",
      px: "2.5",
      py: "1",
      borderRadius: "l2",
      fontWeight: "medium",
      textStyle: "xs",
      boxShadow: "md",
      maxW: "xs",
      zIndex: "tooltip",
      transformOrigin: "var(--transform-origin)",
      _open: {
        animationStyle: "scale-fade-in",
        animationDuration: "fast"
      },
      _closed: {
        animationStyle: "scale-fade-out",
        animationDuration: "fast"
      }
    },
    arrow: {
      "--arrow-size": "sizes.2",
      "--arrow-background": "var(--tooltip-bg)"
    },
    arrowTip: {
      borderTopWidth: "1px",
      borderInlineStartWidth: "1px",
      borderColor: "var(--tooltip-bg)"
    }
  }
});

// node_modules/@chakra-ui/react/dist/esm/theme/slot-recipes.js
var slotRecipes = {
  accordion: accordionSlotRecipe,
  actionBar: actionBarSlotRecipe,
  alert: alertSlotRecipe,
  avatar: avatarSlotRecipe,
  blockquote: blockquoteSlotRecipe,
  breadcrumb: breadcrumbSlotRecipe,
  card: cardSlotRecipe,
  checkbox: checkboxSlotRecipe,
  checkboxCard: checkboxCardSlotRecipe,
  collapsible: collapsibleSlotRecipe,
  dataList: dataListSlotRecipe,
  dialog: dialogSlotRecipe,
  drawer: drawerSlotRecipe,
  editable: editableSlotRecipe,
  emptyState: emptyStateSlotRecipe,
  field: fieldSlotRecipe,
  fieldset: fieldsetSlotRecipe,
  fileUpload: fileUploadSlotRecipe,
  hoverCard: hoverCardSlotRecipe,
  list: listSlotRecipe,
  menu: menuSlotRecipe,
  nativeSelect: nativeSelectSlotRecipe,
  numberInput: numberInputSlotRecipe,
  pinInput: pinInputSlotRecipe,
  popover: popoverSlotRecipe,
  progress: progressSlotRecipe,
  progressCircle: progressCircleSlotRecipe,
  radioCard: radioCardSlotRecipe,
  radioGroup: radioGroupSlotRecipe,
  ratingGroup: ratingGroupSlotRecipe,
  segmentGroup: segmentGroupSlotRecipe,
  select: selectSlotRecipe,
  slider: sliderSlotRecipe,
  stat: statSlotRecipe,
  steps: stepsSlotRecipe,
  switch: switchSlotRecipe,
  table: tableSlotRecipe,
  tabs: tabsSlotRecipe,
  tag: tagSlotRecipe,
  toast: toastSlotRecipe,
  tooltip: tooltipSlotRecipe,
  status: statusSlotRecipe,
  timeline: timelineSlotRecipe,
  colorPicker: colorPickerSlotRecipe,
  qrCode: qrCodeSlotRecipe
};

// node_modules/@chakra-ui/react/dist/esm/theme/text-styles.js
var textStyles = defineTextStyles({
  "2xs": { value: { fontSize: "2xs", lineHeight: "0.75rem" } },
  xs: { value: { fontSize: "xs", lineHeight: "1rem" } },
  sm: { value: { fontSize: "sm", lineHeight: "1.25rem" } },
  md: { value: { fontSize: "md", lineHeight: "1.5rem" } },
  lg: { value: { fontSize: "lg", lineHeight: "1.75rem" } },
  xl: { value: { fontSize: "xl", lineHeight: "1.875rem" } },
  "2xl": { value: { fontSize: "2xl", lineHeight: "2rem" } },
  "3xl": { value: { fontSize: "3xl", lineHeight: "2.375rem" } },
  "4xl": {
    value: {
      fontSize: "4xl",
      lineHeight: "2.75rem",
      letterSpacing: "-0.025em"
    }
  },
  "5xl": {
    value: {
      fontSize: "5xl",
      lineHeight: "3.75rem",
      letterSpacing: "-0.025em"
    }
  },
  "6xl": {
    value: { fontSize: "6xl", lineHeight: "4.5rem", letterSpacing: "-0.025em" }
  },
  "7xl": {
    value: {
      fontSize: "7xl",
      lineHeight: "5.75rem",
      letterSpacing: "-0.025em"
    }
  },
  none: {
    value: {}
  }
});

// node_modules/@chakra-ui/react/dist/esm/theme/tokens/animations.js
var animations = defineTokens.animations({
  spin: { value: "spin 1s linear infinite" },
  ping: { value: "ping 1s cubic-bezier(0, 0, 0.2, 1) infinite" },
  pulse: { value: "pulse 2s cubic-bezier(0.4, 0, 0.6, 1) infinite" },
  bounce: { value: "bounce 1s infinite" }
});

// node_modules/@chakra-ui/react/dist/esm/theme/tokens/aspect-ratios.js
var aspectRatios = defineTokens.aspectRatios({
  square: { value: "1 / 1" },
  landscape: { value: "4 / 3" },
  portrait: { value: "3 / 4" },
  wide: { value: "16 / 9" },
  ultrawide: { value: "18 / 5" },
  golden: { value: "1.618 / 1" }
});

// node_modules/@chakra-ui/react/dist/esm/theme/tokens/blurs.js
var blurs = defineTokens.blurs({
  none: { value: " " },
  sm: { value: "4px" },
  md: { value: "8px" },
  lg: { value: "12px" },
  xl: { value: "16px" },
  "2xl": { value: "24px" },
  "3xl": { value: "40px" },
  "4xl": { value: "64px" }
});

// node_modules/@chakra-ui/react/dist/esm/theme/tokens/borders.js
var borders = defineTokens.borders({
  xs: { value: "0.5px solid" },
  sm: { value: "1px solid" },
  md: { value: "2px solid" },
  lg: { value: "4px solid" },
  xl: { value: "8px solid" }
});

// node_modules/@chakra-ui/react/dist/esm/theme/tokens/colors.js
var colors = defineTokens.colors({
  transparent: { value: "transparent" },
  current: { value: "currentColor" },
  black: { value: "#09090B" },
  white: { value: "#FFFFFF" },
  whiteAlpha: {
    50: { value: "rgba(255, 255, 255, 0.04)" },
    100: { value: "rgba(255, 255, 255, 0.06)" },
    200: { value: "rgba(255, 255, 255, 0.08)" },
    300: { value: "rgba(255, 255, 255, 0.16)" },
    400: { value: "rgba(255, 255, 255, 0.24)" },
    500: { value: "rgba(255, 255, 255, 0.36)" },
    600: { value: "rgba(255, 255, 255, 0.48)" },
    700: { value: "rgba(255, 255, 255, 0.64)" },
    800: { value: "rgba(255, 255, 255, 0.80)" },
    900: { value: "rgba(255, 255, 255, 0.92)" },
    950: { value: "rgba(255, 255, 255, 0.95)" }
  },
  blackAlpha: {
    50: { value: "rgba(0, 0, 0, 0.04)" },
    100: { value: "rgba(0, 0, 0, 0.06)" },
    200: { value: "rgba(0, 0, 0, 0.08)" },
    300: { value: "rgba(0, 0, 0, 0.16)" },
    400: { value: "rgba(0, 0, 0, 0.24)" },
    500: { value: "rgba(0, 0, 0, 0.36)" },
    600: { value: "rgba(0, 0, 0, 0.48)" },
    700: { value: "rgba(0, 0, 0, 0.64)" },
    800: { value: "rgba(0, 0, 0, 0.80)" },
    900: { value: "rgba(0, 0, 0, 0.92)" },
    950: { value: "rgba(0, 0, 0, 0.95)" }
  },
  gray: {
    50: { value: "#fafafa" },
    100: { value: "#f4f4f5" },
    200: { value: "#e4e4e7" },
    300: { value: "#d4d4d8" },
    400: { value: "#a1a1aa" },
    500: { value: "#71717a" },
    600: { value: "#52525b" },
    700: { value: "#3f3f46" },
    800: { value: "#27272a" },
    900: { value: "#18181b" },
    950: { value: "#111111" }
  },
  red: {
    50: { value: "#fef2f2" },
    100: { value: "#fee2e2" },
    200: { value: "#fecaca" },
    300: { value: "#fca5a5" },
    400: { value: "#f87171" },
    500: { value: "#ef4444" },
    600: { value: "#dc2626" },
    700: { value: "#991919" },
    800: { value: "#511111" },
    900: { value: "#300c0c" },
    950: { value: "#1f0808" }
  },
  orange: {
    50: { value: "#fff7ed" },
    100: { value: "#ffedd5" },
    200: { value: "#fed7aa" },
    300: { value: "#fdba74" },
    400: { value: "#fb923c" },
    500: { value: "#f97316" },
    600: { value: "#ea580c" },
    700: { value: "#92310a" },
    800: { value: "#6c2710" },
    900: { value: "#3b1106" },
    950: { value: "#220a04" }
  },
  yellow: {
    50: { value: "#fefce8" },
    100: { value: "#fef9c3" },
    200: { value: "#fef08a" },
    300: { value: "#fde047" },
    400: { value: "#facc15" },
    500: { value: "#eab308" },
    600: { value: "#ca8a04" },
    700: { value: "#845209" },
    800: { value: "#713f12" },
    900: { value: "#422006" },
    950: { value: "#281304" }
  },
  green: {
    50: { value: "#f0fdf4" },
    100: { value: "#dcfce7" },
    200: { value: "#bbf7d0" },
    300: { value: "#86efac" },
    400: { value: "#4ade80" },
    500: { value: "#22c55e" },
    600: { value: "#16a34a" },
    700: { value: "#116932" },
    800: { value: "#124a28" },
    900: { value: "#042713" },
    950: { value: "#03190c" }
  },
  teal: {
    50: { value: "#f0fdfa" },
    100: { value: "#ccfbf1" },
    200: { value: "#99f6e4" },
    300: { value: "#5eead4" },
    400: { value: "#2dd4bf" },
    500: { value: "#14b8a6" },
    600: { value: "#0d9488" },
    700: { value: "#0c5d56" },
    800: { value: "#114240" },
    900: { value: "#032726" },
    950: { value: "#021716" }
  },
  blue: {
    50: { value: "#eff6ff" },
    100: { value: "#dbeafe" },
    200: { value: "#bfdbfe" },
    300: { value: "#a3cfff" },
    400: { value: "#60a5fa" },
    500: { value: "#3b82f6" },
    600: { value: "#2563eb" },
    700: { value: "#173da6" },
    800: { value: "#1a3478" },
    900: { value: "#14204a" },
    950: { value: "#0c142e" }
  },
  cyan: {
    50: { value: "#ecfeff" },
    100: { value: "#cffafe" },
    200: { value: "#a5f3fc" },
    300: { value: "#67e8f9" },
    400: { value: "#22d3ee" },
    500: { value: "#06b6d4" },
    600: { value: "#0891b2" },
    700: { value: "#0c5c72" },
    800: { value: "#134152" },
    900: { value: "#072a38" },
    950: { value: "#051b24" }
  },
  purple: {
    50: { value: "#faf5ff" },
    100: { value: "#f3e8ff" },
    200: { value: "#e9d5ff" },
    300: { value: "#d8b4fe" },
    400: { value: "#c084fc" },
    500: { value: "#a855f7" },
    600: { value: "#9333ea" },
    700: { value: "#641ba3" },
    800: { value: "#4a1772" },
    900: { value: "#2f0553" },
    950: { value: "#1a032e" }
  },
  pink: {
    50: { value: "#fdf2f8" },
    100: { value: "#fce7f3" },
    200: { value: "#fbcfe8" },
    300: { value: "#f9a8d4" },
    400: { value: "#f472b6" },
    500: { value: "#ec4899" },
    600: { value: "#db2777" },
    700: { value: "#a41752" },
    800: { value: "#6d0e34" },
    900: { value: "#45061f" },
    950: { value: "#2c0514" }
  }
});

// node_modules/@chakra-ui/react/dist/esm/theme/tokens/cursor.js
var cursor = defineTokens.cursor({
  button: { value: "pointer" },
  checkbox: { value: "default" },
  disabled: { value: "not-allowed" },
  menuitem: { value: "default" },
  option: { value: "default" },
  radio: { value: "default" },
  slider: { value: "default" },
  switch: { value: "pointer" }
});

// node_modules/@chakra-ui/react/dist/esm/theme/tokens/durations.js
var durations = defineTokens.durations({
  fastest: { value: "50ms" },
  faster: { value: "100ms" },
  fast: { value: "150ms" },
  moderate: { value: "200ms" },
  slow: { value: "300ms" },
  slower: { value: "400ms" },
  slowest: { value: "500ms" }
});

// node_modules/@chakra-ui/react/dist/esm/theme/tokens/easings.js
var easings = defineTokens.easings({
  "ease-in": { value: "cubic-bezier(0.42, 0, 1, 1)" },
  "ease-out": { value: "cubic-bezier(0, 0, 0.58, 1)" },
  "ease-in-out": { value: "cubic-bezier(0.42, 0, 0.58, 1)" },
  "ease-in-smooth": { value: "cubic-bezier(0.32, 0.72, 0, 1)" }
});

// node_modules/@chakra-ui/react/dist/esm/theme/tokens/font-sizes.js
var fontSizes = defineTokens.fontSizes({
  "2xs": { value: "0.625rem" },
  xs: { value: "0.75rem" },
  sm: { value: "0.875rem" },
  md: { value: "1rem" },
  lg: { value: "1.125rem" },
  xl: { value: "1.25rem" },
  "2xl": { value: "1.5rem" },
  "3xl": { value: "1.875rem" },
  "4xl": { value: "2.25rem" },
  "5xl": { value: "3rem" },
  "6xl": { value: "3.75rem" },
  "7xl": { value: "4.5rem" },
  "8xl": { value: "6rem" },
  "9xl": { value: "8rem" }
});

// node_modules/@chakra-ui/react/dist/esm/theme/tokens/font-weights.js
var fontWeights = defineTokens.fontWeights({
  thin: { value: "100" },
  extralight: { value: "200" },
  light: { value: "300" },
  normal: { value: "400" },
  medium: { value: "500" },
  semibold: { value: "600" },
  bold: { value: "700" },
  extrabold: { value: "800" },
  black: { value: "900" }
});

// node_modules/@chakra-ui/react/dist/esm/theme/tokens/fonts.js
var fallback3 = `-apple-system, BlinkMacSystemFont, "Segoe UI", Helvetica, Arial, sans-serif, "Apple Color Emoji", "Segoe UI Emoji", "Segoe UI Symbol"`;
var fonts = defineTokens.fonts({
  heading: {
    value: `Inter, ${fallback3}`
  },
  body: {
    value: `Inter, ${fallback3}`
  },
  mono: {
    value: `SFMono-Regular,Menlo,Monaco,Consolas,"Liberation Mono","Courier New",monospace`
  }
});

// node_modules/@chakra-ui/react/dist/esm/theme/tokens/keyframes.js
var keyframes = defineKeyframes({
  spin: {
    "0%": { transform: "rotate(0deg)" },
    "100%": { transform: "rotate(360deg)" }
  },
  pulse: {
    "50%": { opacity: "0.5" }
  },
  ping: {
    "75%, 100%": {
      transform: "scale(2)",
      opacity: "0"
    }
  },
  bounce: {
    "0%, 100%": {
      transform: "translateY(-25%)",
      animationTimingFunction: "cubic-bezier(0.8,0,1,1)"
    },
    "50%": {
      transform: "none",
      animationTimingFunction: "cubic-bezier(0,0,0.2,1)"
    }
  },
  "bg-position": {
    from: { backgroundPosition: "var(--animate-from, 1rem) 0" },
    to: { backgroundPosition: "var(--animate-to, 0) 0" }
  },
  position: {
    from: {
      insetInlineStart: "var(--animate-from-x)",
      insetBlockStart: "var(--animate-from-y)"
    },
    to: {
      insetInlineStart: "var(--animate-to-x)",
      insetBlockStart: "var(--animate-to-y)"
    }
  },
  "circular-progress": {
    "0%": {
      strokeDasharray: "1, 400",
      strokeDashoffset: "0"
    },
    "50%": {
      strokeDasharray: "400, 400",
      strokeDashoffset: "-100%"
    },
    "100%": {
      strokeDasharray: "400, 400",
      strokeDashoffset: "-260%"
    }
  },
  // collapse
  "expand-height": {
    from: { height: "0" },
    to: { height: "var(--height)" }
  },
  "collapse-height": {
    from: { height: "var(--height)" },
    to: { height: "0" }
  },
  "expand-width": {
    from: { width: "0" },
    to: { width: "var(--width)" }
  },
  "collapse-width": {
    from: { height: "var(--width)" },
    to: { height: "0" }
  },
  // fade
  "fade-in": {
    from: { opacity: 0 },
    to: { opacity: 1 }
  },
  "fade-out": {
    from: { opacity: 1 },
    to: { opacity: 0 }
  },
  // slide from (full)
  "slide-from-left-full": {
    from: { translate: "-100% 0" },
    to: { translate: "0 0" }
  },
  "slide-from-right-full": {
    from: { translate: "100% 0" },
    to: { translate: "0 0" }
  },
  "slide-from-top-full": {
    from: { translate: "0 -100%" },
    to: { translate: "0 0" }
  },
  "slide-from-bottom-full": {
    from: { translate: "0 100%" },
    to: { translate: "0 0" }
  },
  // slide to (full)
  "slide-to-left-full": {
    from: { translate: "0 0" },
    to: { translate: "-100% 0" }
  },
  "slide-to-right-full": {
    from: { translate: "0 0" },
    to: { translate: "100% 0" }
  },
  "slide-to-top-full": {
    from: { translate: "0 0" },
    to: { translate: "0 -100%" }
  },
  "slide-to-bottom-full": {
    from: { translate: "0 0" },
    to: { translate: "0 100%" }
  },
  // slide from
  "slide-from-top": {
    "0%": { translate: "0 -0.5rem" },
    to: { translate: "0" }
  },
  "slide-from-bottom": {
    "0%": { translate: "0 0.5rem" },
    to: { translate: "0" }
  },
  "slide-from-left": {
    "0%": { translate: "-0.5rem 0" },
    to: { translate: "0" }
  },
  "slide-from-right": {
    "0%": { translate: "0.5rem 0" },
    to: { translate: "0" }
  },
  // slide to
  "slide-to-top": {
    "0%": { translate: "0" },
    to: { translate: "0 -0.5rem" }
  },
  "slide-to-bottom": {
    "0%": { translate: "0" },
    to: { translate: "0 0.5rem" }
  },
  "slide-to-left": {
    "0%": { translate: "0" },
    to: { translate: "-0.5rem 0" }
  },
  "slide-to-right": {
    "0%": { translate: "0" },
    to: { translate: "0.5rem 0" }
  },
  // scale
  "scale-in": {
    from: { scale: "0.95" },
    to: { scale: "1" }
  },
  "scale-out": {
    from: { scale: "1" },
    to: { scale: "0.95" }
  }
});

// node_modules/@chakra-ui/react/dist/esm/theme/tokens/letter-spacing.js
var letterSpacings = defineTokens.letterSpacings({
  tighter: { value: "-0.05em" },
  tight: { value: "-0.025em" },
  wide: { value: "0.025em" },
  wider: { value: "0.05em" },
  widest: { value: "0.1em" }
});

// node_modules/@chakra-ui/react/dist/esm/theme/tokens/line-heights.js
var lineHeights = defineTokens.lineHeights({
  shorter: { value: 1.25 },
  short: { value: 1.375 },
  moderate: { value: 1.5 },
  tall: { value: 1.625 },
  taller: { value: 2 }
});

// node_modules/@chakra-ui/react/dist/esm/theme/tokens/radius.js
var radii = defineTokens.radii({
  none: { value: "0" },
  "2xs": { value: "0.0625rem" },
  xs: { value: "0.125rem" },
  sm: { value: "0.25rem" },
  md: { value: "0.375rem" },
  lg: { value: "0.5rem" },
  xl: { value: "0.75rem" },
  "2xl": { value: "1rem" },
  "3xl": { value: "1.5rem" },
  "4xl": { value: "2rem" },
  full: { value: "9999px" }
});

// node_modules/@chakra-ui/react/dist/esm/theme/tokens/spacing.js
var spacing = defineTokens.spacing({
  0.5: { value: "0.125rem" },
  1: { value: "0.25rem" },
  1.5: { value: "0.375rem" },
  2: { value: "0.5rem" },
  2.5: { value: "0.625rem" },
  3: { value: "0.75rem" },
  3.5: { value: "0.875rem" },
  4: { value: "1rem" },
  4.5: { value: "1.125rem" },
  5: { value: "1.25rem" },
  6: { value: "1.5rem" },
  7: { value: "1.75rem" },
  8: { value: "2rem" },
  9: { value: "2.25rem" },
  10: { value: "2.5rem" },
  11: { value: "2.75rem" },
  12: { value: "3rem" },
  14: { value: "3.5rem" },
  16: { value: "4rem" },
  20: { value: "5rem" },
  24: { value: "6rem" },
  28: { value: "7rem" },
  32: { value: "8rem" },
  36: { value: "9rem" },
  40: { value: "10rem" },
  44: { value: "11rem" },
  48: { value: "12rem" },
  52: { value: "13rem" },
  56: { value: "14rem" },
  60: { value: "15rem" },
  64: { value: "16rem" },
  72: { value: "18rem" },
  80: { value: "20rem" },
  96: { value: "24rem" }
});

// node_modules/@chakra-ui/react/dist/esm/theme/tokens/sizes.js
var largeSizes = defineTokens.sizes({
  "3xs": { value: "14rem" },
  "2xs": { value: "16rem" },
  xs: { value: "20rem" },
  sm: { value: "24rem" },
  md: { value: "28rem" },
  lg: { value: "32rem" },
  xl: { value: "36rem" },
  "2xl": { value: "42rem" },
  "3xl": { value: "48rem" },
  "4xl": { value: "56rem" },
  "5xl": { value: "64rem" },
  "6xl": { value: "72rem" },
  "7xl": { value: "80rem" },
  "8xl": { value: "90rem" }
});
var namedSizes = defineTokens.sizes({
  max: { value: "max-content" },
  min: { value: "min-content" },
  fit: { value: "fit-content" },
  prose: { value: "60ch" },
  full: { value: "100%" },
  dvh: { value: "100dvh" },
  svh: { value: "100svh" },
  lvh: { value: "100lvh" },
  dvw: { value: "100dvw" },
  svw: { value: "100svw" },
  lvw: { value: "100lvw" },
  vw: { value: "100vw" },
  vh: { value: "100vh" }
});
var fractionalSizes = defineTokens.sizes({
  "1/2": { value: "50%" },
  "1/3": { value: "33.333333%" },
  "2/3": { value: "66.666667%" },
  "1/4": { value: "25%" },
  "3/4": { value: "75%" },
  "1/5": { value: "20%" },
  "2/5": { value: "40%" },
  "3/5": { value: "60%" },
  "4/5": { value: "80%" },
  "1/6": { value: "16.666667%" },
  "2/6": { value: "33.333333%" },
  "3/6": { value: "50%" },
  "4/6": { value: "66.666667%" },
  "5/6": { value: "83.333333%" },
  "1/12": { value: "8.333333%" },
  "2/12": { value: "16.666667%" },
  "3/12": { value: "25%" },
  "4/12": { value: "33.333333%" },
  "5/12": { value: "41.666667%" },
  "6/12": { value: "50%" },
  "7/12": { value: "58.333333%" },
  "8/12": { value: "66.666667%" },
  "9/12": { value: "75%" },
  "10/12": { value: "83.333333%" },
  "11/12": { value: "91.666667%" }
});
var sizes = defineTokens.sizes({
  ...largeSizes,
  ...spacing,
  ...fractionalSizes,
  ...namedSizes
});

// node_modules/@chakra-ui/react/dist/esm/theme/tokens/z-indices.js
var zIndices = defineTokens.zIndex({
  hide: { value: -1 },
  base: { value: 0 },
  docked: { value: 10 },
  dropdown: { value: 1e3 },
  sticky: { value: 1100 },
  banner: { value: 1200 },
  overlay: { value: 1300 },
  modal: { value: 1400 },
  popover: { value: 1500 },
  skipNav: { value: 1600 },
  toast: { value: 1700 },
  tooltip: { value: 1800 },
  max: { value: 2147483647 }
});

// node_modules/@chakra-ui/react/dist/esm/theme/index.js
var defaultThemeConfig = defineConfig({
  preflight: true,
  cssVarsPrefix: "chakra",
  cssVarsRoot: ":where(html, .chakra-theme)",
  globalCss,
  theme: {
    breakpoints,
    keyframes,
    tokens: {
      aspectRatios,
      animations,
      blurs,
      borders,
      colors,
      durations,
      easings,
      fonts,
      fontSizes,
      fontWeights,
      letterSpacings,
      lineHeights,
      radii,
      spacing,
      sizes,
      zIndex: zIndices,
      cursor
    },
    semanticTokens: {
      colors: semanticColors,
      shadows: semanticShadows,
      radii: semanticRadii
    },
    recipes,
    slotRecipes,
    textStyles,
    layerStyles,
    animationStyles
  }
});

// node_modules/@chakra-ui/react/dist/esm/preset.js
var defaultConfig = mergeConfigs(defaultBaseConfig, defaultThemeConfig);
var defaultSystem = createSystem(defaultConfig);

export {
  isCssVar,
  isString,
  defineConditions,
  defineRecipe,
  defineSlotRecipe,
  defineKeyframes,
  defineGlobalStyles,
  defineStyle,
  defineTextStyles,
  defineAnimationStyles,
  defineLayerStyles,
  defineTokens,
  defineSemanticTokens,
  defineConfig,
  mergeConfigs,
  defaultBaseConfig,
  compact,
  mapObject,
  splitProps,
  cx,
  omit,
  createSystem,
  isValidSystem,
  createContext,
  useAccordionContext,
  createAnatomy,
  MAX_Z_INDEX,
  dataAttr,
  ariaAttr,
  isShadowRoot,
  isAnchorElement,
  isEditableElement,
  contains,
  getDocument,
  getWindow,
  getComputedStyle,
  getDataUrl,
  isSafari,
  getEventTarget,
  isSelfTarget,
  isOpeningInNewTab,
  isDownloadingEvent,
  isComposingEvent,
  isLeftClick,
  isContextMenuEvent,
  isModifierKey,
  getEventKey,
  getNativeEvent,
  getEventStep,
  addDomEvent,
  dispatchInputValueEvent,
  trackFormControl,
  getFocusables,
  isFocusable,
  getTabbables,
  nextTick,
  raf,
  observeAttributes,
  observeChildren,
  clickIfLink,
  scrollIntoView,
  getRelativePoint,
  trackPointerMove,
  queryAll,
  query,
  itemById,
  indexOfId,
  nextById,
  prevById,
  createScope,
  getByTypeahead,
  fromLength,
  first,
  last,
  add2 as add,
  remove,
  removeAt,
  uniq2 as uniq,
  addOrRemove,
  nextIndex,
  next,
  prevIndex,
  prev,
  isEqual,
  runIfFn,
  uuid,
  match2 as match,
  isArray,
  isBoolean,
  isObject3 as isObject,
  isValueWithinRange,
  compact2,
  createSplitProps,
  warn,
  subscribe,
  ref,
  guards,
  createMachine,
  isMachine,
  mergeProps,
  createProps2 as createProps,
  normalizeProps,
  useActor,
  useMachine,
  useAccordionItemContext,
  composeRefs,
  ark,
  createSplitProps2,
  EnvironmentContextProvider,
  useEnvironmentContext,
  LocaleContextProvider,
  useLocaleContext,
  useEvent,
  useCollapsible,
  useCollapsibleContext,
  CollapsibleRoot,
  getPlacement,
  getPlacementStyles,
  trackInteractOutside,
  trackDismissableElement,
  trackDismissableBranch,
  parse,
  $35ea8db9cb2ccb90$export$680ea196effce5f,
  createLiveRegion,
  anatomy4 as anatomy,
  connect4 as connect,
  machine4 as machine,
  RenderStrategyPropsProvider,
  useRenderStrategyPropsContext,
  splitRenderStrategyProps,
  CollapsibleContent,
  useAccordion,
  accordion_exports,
  usePresence,
  useDialogContext,
  PresenceProvider,
  usePresenceContext,
  splitPresenceProps,
  ariaHidden,
  trapFocus,
  useDialog,
  dialog_exports,
  useEditableContext,
  useFieldContext,
  useEditable,
  editable_exports,
  useSafeLayoutEffect2 as useSafeLayoutEffect,
  useFieldsetContext,
  autoResizeInput,
  field_exports,
  fieldset_exports,
  useFileUploadContext,
  formatNumber,
  formatBytes,
  isRTL2 as isRTL,
  useFileUpload,
  file_upload_exports,
  useMenuContext,
  useMenuItemContext,
  useMenu,
  menu_exports,
  usePopoverContext,
  usePopover,
  popover_exports,
  useRadioGroupContext,
  useRadioGroupItemContext,
  trackElementRect,
  useRadioGroup,
  radio_group_exports,
  useRatingGroupContext,
  useRatingGroupItemContext,
  useRatingGroup,
  rating_group_exports,
  ListCollection,
  TreeCollection,
  createListCollection,
  useSelectContext,
  useSelectItemContext,
  useSelect,
  select_exports,
  useSliderContext,
  useSlider,
  slider_exports,
  useSwitchContext,
  useSwitch,
  switch_exports,
  useAvatarContext,
  useAvatar,
  avatar_exports,
  useCheckboxContext,
  useControllableState,
  useCheckboxGroup,
  useCheckboxGroupContext,
  useCheckbox,
  checkbox_exports,
  collapsible_exports,
  useColorPickerContext,
  useColorPicker,
  color_picker_exports,
  useHoverCardContext,
  useHoverCard,
  hover_card_exports,
  useNumberInputContext,
  useNumberInput,
  number_input_exports,
  usePinInputContext,
  usePinInput,
  pin_input_exports,
  useProgressContext,
  useProgress,
  progress_exports,
  useQrCodeContext,
  QrCodeContext,
  useQrCode,
  qr_code_exports,
  useSegmentGroupContext,
  useSegmentGroupItemContext,
  useSegmentGroup,
  segment_group_exports,
  useTooltipContext,
  useTooltip,
  tooltip_exports,
  defaultConfig,
  defaultSystem
};
//# sourceMappingURL=chunk-64QIEMAJ.js.map
